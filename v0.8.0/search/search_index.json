{
    "docs": [
        {
            "location": "/", 
            "text": "PhyloNetworks.jl\n\n\nPhyloNetworks\n is a \nJulia\n package for the manipulation, visualization, inference of phylogenetic networks, and their use for trait evolution.\n\n\n\n\nHow to get help\n\n\n\n\nthe package \nwiki\n has a step-by-step tutorial, done for the 2018 MBL workshop, with background on networks and explanations.\n\n\nthe \ngoogle group\n has answers to common questions.\n\n\nthe Manual below has a quick tutorial (navigation on the left).\n\n\nthe \nIndex\n further below has the full list of documented functions.\n\n\n\n\n\n\nManual Outline\n\n\n\n\nInstallation\n\n\nInstallation of Julia\n\n\nInstallation of the package PhyloNetworks\n\n\nTest example\n\n\nJulia types\n\n\n\n\n\n\nInput for SNaQ\n\n\nTutorial data: gene trees\n\n\nTutorial data: quartet CFs\n\n\nTutorial data: starting tree\n\n\n\n\n\n\nTICR pipeline\n\n\nTo run MrBayes: we already have alignments\n\n\nno-scheduler pipeline\n\n\nslurm pipeline\n\n\n\n\n\n\nTo run mbsum on the output of MrBayes for each gene\n\n\nTo run bucky on all 4-taxon sets: we already have the mbsum output\n\n\nno-scheduler pipeline\n\n\nslurm pipeline\n\n\n\n\n\n\n\n\n\n\nGetting a Network\n\n\nNetwork Estimation\n\n\nparallel computations\n\n\nchoosing the number of hybridizations\n\n\nNetwork Visualization\n\n\nRe-rooting networks\n\n\nCandidate Network Evaluation\n\n\nSNaQ error reporting\n\n\n\n\n\n\nComparing and manipulating networks\n\n\nComparing networks / trees\n\n\nRe-rooting trees and networks\n\n\nWhat if the root conflicts with the direction of a reticulation?\n\n\nExtracting the major tree\n\n\nDisplayed trees and subnetworks\n\n\n\n\n\n\nCandidate Networks\n\n\nOptimizing parameters for a given network\n\n\nNetwork Score with no optimization\n\n\nCandidate networks compatible with a known outgroup\n\n\n\n\n\n\nExtract Expected CFs\n\n\nBootstrap\n\n\nRunning a bootstrap analysis\n\n\nsupport for tree edges\n\n\nsupport for hybrid edges and hybrid nodes\n\n\nWho are the hybrids in bootstrap networks?\n\n\nWhere is the origin of gene flow?\n\n\n\n\n\n\n\n\n\n\nMultiple alleles per species\n\n\nContinuous Trait Evolution\n\n\nModel and Variance Matrix\n\n\nTrait simulation\n\n\nPhylogenetic regression\n\n\nAncestral State Reconstruction\n\n\nFrom known parameters\n\n\nFrom estimated parameters\n\n\nData imputation\n\n\nWith known predictors\n\n\n\n\n\n\nPhylogenetic ANOVA\n\n\nPagel's Lambda\n\n\nShifts and transgressive evolution\n\n\nSimulation of a Shifted BM\n\n\nFit of a Shifted BM\n\n\n\n\n\n\n\n\n\n\nParsimony on networks\n\n\nParsimony score of a given network\n\n\nFinding the most parsimonious network\n\n\n\n\n\n\n\n\n\n\nLibrary Outline\n\n\n\n\nPublic Documentation\n\n\nIndex\n\n\ntypes\n\n\nutilities\n\n\ndata and topology read/write\n\n\nnetwork inference\n\n\nnetwork Comparisons\n\n\ncontinuous trait evolution\n\n\ndiscrete trait evolution\n\n\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\ntypes\n\n\nfunctions\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nFunctions\n\n\n\n\nBase.getindex\n\n\nPhyloNetworks.P\n\n\nPhyloNetworks.Q\n\n\nPhyloNetworks.ancestralStateReconstruction\n\n\nPhyloNetworks.biconnectedComponents\n\n\nPhyloNetworks.blobDecomposition\n\n\nPhyloNetworks.bootsnaq\n\n\nPhyloNetworks.calibrateFromPairwiseDistances!\n\n\nPhyloNetworks.cladewiseorder!\n\n\nPhyloNetworks.deleteHybridThreshold!\n\n\nPhyloNetworks.deleteleaf!\n\n\nPhyloNetworks.descendenceMatrix\n\n\nPhyloNetworks.directEdges!\n\n\nPhyloNetworks.displayedNetworkAt!\n\n\nPhyloNetworks.displayedTrees\n\n\nPhyloNetworks.expectations\n\n\nPhyloNetworks.expectationsPlot\n\n\nPhyloNetworks.fitDiscrete\n\n\nPhyloNetworks.fittedQuartetCF\n\n\nPhyloNetworks.getNodeAges\n\n\nPhyloNetworks.getShiftEdgeNumber\n\n\nPhyloNetworks.getShiftValue\n\n\nPhyloNetworks.hardwiredCluster\n\n\nPhyloNetworks.hardwiredClusterDistance\n\n\nPhyloNetworks.hardwiredClusters\n\n\nPhyloNetworks.hybridBootstrapSupport\n\n\nPhyloNetworks.hybridatnode!\n\n\nPhyloNetworks.lambda_estim\n\n\nPhyloNetworks.majorTree\n\n\nPhyloNetworks.mapAllelesCFtable\n\n\nPhyloNetworks.maxParsimonyNet\n\n\nPhyloNetworks.minorTreeAt\n\n\nPhyloNetworks.mu_estim\n\n\nPhyloNetworks.nStates\n\n\nPhyloNetworks.pairwiseTaxonDistanceMatrix\n\n\nPhyloNetworks.parsimonyGF\n\n\nPhyloNetworks.parsimonySoftwired\n\n\nPhyloNetworks.phyloNetworklm\n\n\nPhyloNetworks.predint\n\n\nPhyloNetworks.predintPlot\n\n\nPhyloNetworks.preorder!\n\n\nPhyloNetworks.printEdges\n\n\nPhyloNetworks.printNodes\n\n\nPhyloNetworks.randomTrait\n\n\nPhyloNetworks.readBootstrapTrees\n\n\nPhyloNetworks.readInputTrees\n\n\nPhyloNetworks.readMultiTopology\n\n\nPhyloNetworks.readSnaqNetwork\n\n\nPhyloNetworks.readTableCF\n\n\nPhyloNetworks.readTableCF!\n\n\nPhyloNetworks.readTopology\n\n\nPhyloNetworks.readTopologyLevel1\n\n\nPhyloNetworks.readTrees2CF\n\n\nPhyloNetworks.regressorHybrid\n\n\nPhyloNetworks.regressorShift\n\n\nPhyloNetworks.rootatnode!\n\n\nPhyloNetworks.rootonedge!\n\n\nPhyloNetworks.rotate!\n\n\nPhyloNetworks.setGamma!\n\n\nPhyloNetworks.setLength!\n\n\nPhyloNetworks.sharedPathMatrix\n\n\nPhyloNetworks.shiftHybrid\n\n\nPhyloNetworks.sigma2_estim\n\n\nPhyloNetworks.simulate\n\n\nPhyloNetworks.snaq!\n\n\nPhyloNetworks.snaqDebug\n\n\nPhyloNetworks.sorttaxa!\n\n\nPhyloNetworks.summarizeDataCF\n\n\nPhyloNetworks.ticr\n\n\nPhyloNetworks.ticr!\n\n\nPhyloNetworks.tipLabels\n\n\nPhyloNetworks.topologyMaxQPseudolik!\n\n\nPhyloNetworks.topologyQPseudolik!\n\n\nPhyloNetworks.treeEdgesBootstrap\n\n\nPhyloNetworks.vcv\n\n\nPhyloNetworks.writeMultiTopology\n\n\nPhyloNetworks.writeSubTree!\n\n\nPhyloNetworks.writeTopology\n\n\nBase.getindex\n\n\nBase.getindex\n\n\nPhyloNetworks.addAlternativeHybridizations!\n\n\nPhyloNetworks.afterOptBL!\n\n\nPhyloNetworks.afterOptBLAll!\n\n\nPhyloNetworks.afterOptBLRepeat!\n\n\nPhyloNetworks.anova\n\n\nPhyloNetworks.assignhybridnames!\n\n\nPhyloNetworks.blobInfo\n\n\nPhyloNetworks.breakedge!\n\n\nPhyloNetworks.calculateObsCFAll!\n\n\nPhyloNetworks.checkNumHybEdges!\n\n\nPhyloNetworks.check_matchtaxonnames!\n\n\nPhyloNetworks.deleteEdge!\n\n\nPhyloNetworks.deleteHybridEdge!\n\n\nPhyloNetworks.deleteLeaf!\n\n\nPhyloNetworks.deleteNode!\n\n\nPhyloNetworks.descendants\n\n\nPhyloNetworks.discrete_backwardlikelihood_tree!\n\n\nPhyloNetworks.discrete_corelikelihood!\n\n\nPhyloNetworks.discrete_corelikelihood_tree!\n\n\nPhyloNetworks.displayedNetworks!\n\n\nPhyloNetworks.fuseedgesat!\n\n\nPhyloNetworks.gammaZero!\n\n\nPhyloNetworks.getChild\n\n\nPhyloNetworks.getChildren\n\n\nPhyloNetworks.getDataValue!\n\n\nPhyloNetworks.getGammas\n\n\nPhyloNetworks.getHeights\n\n\nPhyloNetworks.getMajorParent\n\n\nPhyloNetworks.getMajorParentEdge\n\n\nPhyloNetworks.getMinorParent\n\n\nPhyloNetworks.getMinorParentEdge\n\n\nPhyloNetworks.getParent\n\n\nPhyloNetworks.getParents\n\n\nPhyloNetworks.getPartner\n\n\nPhyloNetworks.getTipSubmatrix\n\n\nPhyloNetworks.hybridEdges\n\n\nPhyloNetworks.hybridEdges\n\n\nPhyloNetworks.inheritanceWeight\n\n\nPhyloNetworks.initializeWeightsFromLeaves!\n\n\nPhyloNetworks.initializeWeightsFromLeavesSoftwired!\n\n\nPhyloNetworks.majoredgelength\n\n\nPhyloNetworks.majoredgematrix\n\n\nPhyloNetworks.makemissing!\n\n\nPhyloNetworks.mapAllelesCFtable!\n\n\nPhyloNetworks.maxParsimonyNetRun1\n\n\nPhyloNetworks.maxParsimonyNetRun1!\n\n\nPhyloNetworks.minorreticulationgamma\n\n\nPhyloNetworks.minorreticulationlength\n\n\nPhyloNetworks.minorreticulationmatrix\n\n\nPhyloNetworks.moveHybrid!\n\n\nPhyloNetworks.nparams\n\n\nPhyloNetworks.optBL!\n\n\nPhyloNetworks.optTopLevel!\n\n\nPhyloNetworks.optTopRun1!\n\n\nPhyloNetworks.optTopRuns!\n\n\nPhyloNetworks.pairwiseTaxonDistanceGrad\n\n\nPhyloNetworks.parseEdgeData!\n\n\nPhyloNetworks.parseHybridNode!\n\n\nPhyloNetworks.parseRemainingSubtree!\n\n\nPhyloNetworks.parseTreeNode!\n\n\nPhyloNetworks.parsimonyBottomUpFitch!\n\n\nPhyloNetworks.parsimonyBottomUpGF!\n\n\nPhyloNetworks.parsimonyBottomUpSoftwired!\n\n\nPhyloNetworks.parsimonyDiscreteFitch\n\n\nPhyloNetworks.parsimonySummaryFitch\n\n\nPhyloNetworks.parsimonyTopDownFitch!\n\n\nPhyloNetworks.proposedTop!\n\n\nPhyloNetworks.readCSVtoArray\n\n\nPhyloNetworks.readStartTop\n\n\nPhyloNetworks.readSubtree!\n\n\nPhyloNetworks.recursionPostOrder\n\n\nPhyloNetworks.recursionPreOrder\n\n\nPhyloNetworks.recursionPreOrder!\n\n\nPhyloNetworks.removeHybrid!\n\n\nPhyloNetworks.resetEdgeNumbers!\n\n\nPhyloNetworks.resetNodeNumbers!\n\n\nPhyloNetworks.sameTaxa\n\n\nPhyloNetworks.sampleBootstrapTrees\n\n\nPhyloNetworks.sampleCFfromCI\n\n\nPhyloNetworks.setBLGammaParsimony!\n\n\nPhyloNetworks.setBranchLength!\n\n\nPhyloNetworks.setGammaBLfromGammaz!\n\n\nPhyloNetworks.setGammas!\n\n\nPhyloNetworks.setNonIdBL!\n\n\nPhyloNetworks.showQ\n\n\nPhyloNetworks.sortUnionTaxa!\n\n\nPhyloNetworks.symmetricNet\n\n\nPhyloNetworks.symmetricNet\n\n\nPhyloNetworks.symmetricTree\n\n\nPhyloNetworks.synchronizePartnersData!\n\n\nPhyloNetworks.taxadiff\n\n\nPhyloNetworks.ticr_optimalpha\n\n\nPhyloNetworks.traitlabels2indices\n\n\nPhyloNetworks.traverseContainRoot!\n\n\nPhyloNetworks.updatePostOrder!\n\n\nPhyloNetworks.updatePreOrder!\n\n\nPhyloNetworks.writeTopologyLevel1\n\n\nStatsBase.fit\n\n\n\n\n\n\nTypes\n\n\n\n\nPhyloNetworks.BinaryTraitSubstitutionModel\n\n\nPhyloNetworks.DataCF\n\n\nPhyloNetworks.EqualRatesSubstitutionModel\n\n\nPhyloNetworks.HybridNetwork\n\n\nPhyloNetworks.ParamsBM\n\n\nPhyloNetworks.PhyloNetworkLinearModel\n\n\nPhyloNetworks.Quartet\n\n\nPhyloNetworks.ReconstructedStates\n\n\nPhyloNetworks.ShiftNet\n\n\nPhyloNetworks.TraitSimulation\n\n\nPhyloNetworks.TraitSubstitutionModel\n\n\nPhyloNetworks.TwoBinaryTraitSubstitutionModel\n\n\nPhyloNetworks.ANode\n\n\nPhyloNetworks.MatrixTopologicalOrder\n\n\nPhyloNetworks.StatisticalSubstitutionModel", 
            "title": "Home"
        }, 
        {
            "location": "/#phylonetworksjl", 
            "text": "PhyloNetworks  is a  Julia  package for the manipulation, visualization, inference of phylogenetic networks, and their use for trait evolution.", 
            "title": "PhyloNetworks.jl"
        }, 
        {
            "location": "/#how-to-get-help", 
            "text": "the package  wiki  has a step-by-step tutorial, done for the 2018 MBL workshop, with background on networks and explanations.  the  google group  has answers to common questions.  the Manual below has a quick tutorial (navigation on the left).  the  Index  further below has the full list of documented functions.", 
            "title": "How to get help"
        }, 
        {
            "location": "/#manual-outline", 
            "text": "Installation  Installation of Julia  Installation of the package PhyloNetworks  Test example  Julia types    Input for SNaQ  Tutorial data: gene trees  Tutorial data: quartet CFs  Tutorial data: starting tree    TICR pipeline  To run MrBayes: we already have alignments  no-scheduler pipeline  slurm pipeline    To run mbsum on the output of MrBayes for each gene  To run bucky on all 4-taxon sets: we already have the mbsum output  no-scheduler pipeline  slurm pipeline      Getting a Network  Network Estimation  parallel computations  choosing the number of hybridizations  Network Visualization  Re-rooting networks  Candidate Network Evaluation  SNaQ error reporting    Comparing and manipulating networks  Comparing networks / trees  Re-rooting trees and networks  What if the root conflicts with the direction of a reticulation?  Extracting the major tree  Displayed trees and subnetworks    Candidate Networks  Optimizing parameters for a given network  Network Score with no optimization  Candidate networks compatible with a known outgroup    Extract Expected CFs  Bootstrap  Running a bootstrap analysis  support for tree edges  support for hybrid edges and hybrid nodes  Who are the hybrids in bootstrap networks?  Where is the origin of gene flow?      Multiple alleles per species  Continuous Trait Evolution  Model and Variance Matrix  Trait simulation  Phylogenetic regression  Ancestral State Reconstruction  From known parameters  From estimated parameters  Data imputation  With known predictors    Phylogenetic ANOVA  Pagel's Lambda  Shifts and transgressive evolution  Simulation of a Shifted BM  Fit of a Shifted BM      Parsimony on networks  Parsimony score of a given network  Finding the most parsimonious network", 
            "title": "Manual Outline"
        }, 
        {
            "location": "/#library-outline", 
            "text": "Public Documentation  Index  types  utilities  data and topology read/write  network inference  network Comparisons  continuous trait evolution  discrete trait evolution    Internal Documentation  Contents  Index  types  functions", 
            "title": "Library Outline"
        }, 
        {
            "location": "/#index", 
            "text": "", 
            "title": "Index"
        }, 
        {
            "location": "/#functions", 
            "text": "Base.getindex  PhyloNetworks.P  PhyloNetworks.Q  PhyloNetworks.ancestralStateReconstruction  PhyloNetworks.biconnectedComponents  PhyloNetworks.blobDecomposition  PhyloNetworks.bootsnaq  PhyloNetworks.calibrateFromPairwiseDistances!  PhyloNetworks.cladewiseorder!  PhyloNetworks.deleteHybridThreshold!  PhyloNetworks.deleteleaf!  PhyloNetworks.descendenceMatrix  PhyloNetworks.directEdges!  PhyloNetworks.displayedNetworkAt!  PhyloNetworks.displayedTrees  PhyloNetworks.expectations  PhyloNetworks.expectationsPlot  PhyloNetworks.fitDiscrete  PhyloNetworks.fittedQuartetCF  PhyloNetworks.getNodeAges  PhyloNetworks.getShiftEdgeNumber  PhyloNetworks.getShiftValue  PhyloNetworks.hardwiredCluster  PhyloNetworks.hardwiredClusterDistance  PhyloNetworks.hardwiredClusters  PhyloNetworks.hybridBootstrapSupport  PhyloNetworks.hybridatnode!  PhyloNetworks.lambda_estim  PhyloNetworks.majorTree  PhyloNetworks.mapAllelesCFtable  PhyloNetworks.maxParsimonyNet  PhyloNetworks.minorTreeAt  PhyloNetworks.mu_estim  PhyloNetworks.nStates  PhyloNetworks.pairwiseTaxonDistanceMatrix  PhyloNetworks.parsimonyGF  PhyloNetworks.parsimonySoftwired  PhyloNetworks.phyloNetworklm  PhyloNetworks.predint  PhyloNetworks.predintPlot  PhyloNetworks.preorder!  PhyloNetworks.printEdges  PhyloNetworks.printNodes  PhyloNetworks.randomTrait  PhyloNetworks.readBootstrapTrees  PhyloNetworks.readInputTrees  PhyloNetworks.readMultiTopology  PhyloNetworks.readSnaqNetwork  PhyloNetworks.readTableCF  PhyloNetworks.readTableCF!  PhyloNetworks.readTopology  PhyloNetworks.readTopologyLevel1  PhyloNetworks.readTrees2CF  PhyloNetworks.regressorHybrid  PhyloNetworks.regressorShift  PhyloNetworks.rootatnode!  PhyloNetworks.rootonedge!  PhyloNetworks.rotate!  PhyloNetworks.setGamma!  PhyloNetworks.setLength!  PhyloNetworks.sharedPathMatrix  PhyloNetworks.shiftHybrid  PhyloNetworks.sigma2_estim  PhyloNetworks.simulate  PhyloNetworks.snaq!  PhyloNetworks.snaqDebug  PhyloNetworks.sorttaxa!  PhyloNetworks.summarizeDataCF  PhyloNetworks.ticr  PhyloNetworks.ticr!  PhyloNetworks.tipLabels  PhyloNetworks.topologyMaxQPseudolik!  PhyloNetworks.topologyQPseudolik!  PhyloNetworks.treeEdgesBootstrap  PhyloNetworks.vcv  PhyloNetworks.writeMultiTopology  PhyloNetworks.writeSubTree!  PhyloNetworks.writeTopology  Base.getindex  Base.getindex  PhyloNetworks.addAlternativeHybridizations!  PhyloNetworks.afterOptBL!  PhyloNetworks.afterOptBLAll!  PhyloNetworks.afterOptBLRepeat!  PhyloNetworks.anova  PhyloNetworks.assignhybridnames!  PhyloNetworks.blobInfo  PhyloNetworks.breakedge!  PhyloNetworks.calculateObsCFAll!  PhyloNetworks.checkNumHybEdges!  PhyloNetworks.check_matchtaxonnames!  PhyloNetworks.deleteEdge!  PhyloNetworks.deleteHybridEdge!  PhyloNetworks.deleteLeaf!  PhyloNetworks.deleteNode!  PhyloNetworks.descendants  PhyloNetworks.discrete_backwardlikelihood_tree!  PhyloNetworks.discrete_corelikelihood!  PhyloNetworks.discrete_corelikelihood_tree!  PhyloNetworks.displayedNetworks!  PhyloNetworks.fuseedgesat!  PhyloNetworks.gammaZero!  PhyloNetworks.getChild  PhyloNetworks.getChildren  PhyloNetworks.getDataValue!  PhyloNetworks.getGammas  PhyloNetworks.getHeights  PhyloNetworks.getMajorParent  PhyloNetworks.getMajorParentEdge  PhyloNetworks.getMinorParent  PhyloNetworks.getMinorParentEdge  PhyloNetworks.getParent  PhyloNetworks.getParents  PhyloNetworks.getPartner  PhyloNetworks.getTipSubmatrix  PhyloNetworks.hybridEdges  PhyloNetworks.hybridEdges  PhyloNetworks.inheritanceWeight  PhyloNetworks.initializeWeightsFromLeaves!  PhyloNetworks.initializeWeightsFromLeavesSoftwired!  PhyloNetworks.majoredgelength  PhyloNetworks.majoredgematrix  PhyloNetworks.makemissing!  PhyloNetworks.mapAllelesCFtable!  PhyloNetworks.maxParsimonyNetRun1  PhyloNetworks.maxParsimonyNetRun1!  PhyloNetworks.minorreticulationgamma  PhyloNetworks.minorreticulationlength  PhyloNetworks.minorreticulationmatrix  PhyloNetworks.moveHybrid!  PhyloNetworks.nparams  PhyloNetworks.optBL!  PhyloNetworks.optTopLevel!  PhyloNetworks.optTopRun1!  PhyloNetworks.optTopRuns!  PhyloNetworks.pairwiseTaxonDistanceGrad  PhyloNetworks.parseEdgeData!  PhyloNetworks.parseHybridNode!  PhyloNetworks.parseRemainingSubtree!  PhyloNetworks.parseTreeNode!  PhyloNetworks.parsimonyBottomUpFitch!  PhyloNetworks.parsimonyBottomUpGF!  PhyloNetworks.parsimonyBottomUpSoftwired!  PhyloNetworks.parsimonyDiscreteFitch  PhyloNetworks.parsimonySummaryFitch  PhyloNetworks.parsimonyTopDownFitch!  PhyloNetworks.proposedTop!  PhyloNetworks.readCSVtoArray  PhyloNetworks.readStartTop  PhyloNetworks.readSubtree!  PhyloNetworks.recursionPostOrder  PhyloNetworks.recursionPreOrder  PhyloNetworks.recursionPreOrder!  PhyloNetworks.removeHybrid!  PhyloNetworks.resetEdgeNumbers!  PhyloNetworks.resetNodeNumbers!  PhyloNetworks.sameTaxa  PhyloNetworks.sampleBootstrapTrees  PhyloNetworks.sampleCFfromCI  PhyloNetworks.setBLGammaParsimony!  PhyloNetworks.setBranchLength!  PhyloNetworks.setGammaBLfromGammaz!  PhyloNetworks.setGammas!  PhyloNetworks.setNonIdBL!  PhyloNetworks.showQ  PhyloNetworks.sortUnionTaxa!  PhyloNetworks.symmetricNet  PhyloNetworks.symmetricNet  PhyloNetworks.symmetricTree  PhyloNetworks.synchronizePartnersData!  PhyloNetworks.taxadiff  PhyloNetworks.ticr_optimalpha  PhyloNetworks.traitlabels2indices  PhyloNetworks.traverseContainRoot!  PhyloNetworks.updatePostOrder!  PhyloNetworks.updatePreOrder!  PhyloNetworks.writeTopologyLevel1  StatsBase.fit", 
            "title": "Functions"
        }, 
        {
            "location": "/#types", 
            "text": "PhyloNetworks.BinaryTraitSubstitutionModel  PhyloNetworks.DataCF  PhyloNetworks.EqualRatesSubstitutionModel  PhyloNetworks.HybridNetwork  PhyloNetworks.ParamsBM  PhyloNetworks.PhyloNetworkLinearModel  PhyloNetworks.Quartet  PhyloNetworks.ReconstructedStates  PhyloNetworks.ShiftNet  PhyloNetworks.TraitSimulation  PhyloNetworks.TraitSubstitutionModel  PhyloNetworks.TwoBinaryTraitSubstitutionModel  PhyloNetworks.ANode  PhyloNetworks.MatrixTopologicalOrder  PhyloNetworks.StatisticalSubstitutionModel", 
            "title": "Types"
        }, 
        {
            "location": "/man/installation/", 
            "text": "Installation\n\n\n\n\nInstallation of Julia\n\n\nJulia is a high-level and interactive programming language (like R or Matlab), but it is also high-performance (like C). To install Julia, follow instructions \nhere\n. For a quick \n basic tutorial on Julia, see \nlearn x in y minutes\n.\n\n\nEditors:\n\n\n\n\nVisual Studio Code\n provides an editor and an integrated development environment (IDE) for Julia: highly recommended!\n\n\nJuno\n provides an IDE for Julia, based on the \nAtom\n editor.\n\n\nyou can also run Julia within a \nJupyter\n notebook (formerly IPython notebook).\n\n\n\n\nIMPORTANT: Julia code is just-in-time compiled. This means that the first time you run a function, it will be compiled at that moment. So, please be patient! Future calls to the function will be much much faster. Trying out toy examples for the first calls is a good idea.\n\n\n\n\nInstallation of the package PhyloNetworks\n\n\nTo install the package, type inside Julia:\n\n\nPkg\n.\nadd\n(\nPhyloNetworks\n)\n\n\n\n\n\n\nThe first step can take a few minutes, be patient. If you already installed the package and want the latest registered version, just do this (which will update all of your packages):\n\n\nPkg\n.\nupdate\n()\n\n\n\n\n\n\nWARNING: It is important to update the package regularly as it is undergoing constant development. Join the google group for updates \nhere\n.\n\n\nPkg.update()\n will install the latest registered version, but there could be other improvements in the \nmaster\n branch of the repository. If you want to update to the latest unregistered version of the package, you can do \nPkg.checkout(\"PhyloNetworks\")\n just beware that the latest changes could be not as robust. If you want to go back to the registered package, you can do \nPkg.free(\"PhyloNetworks\")\n.\n\n\nSimilarly, you can pin a version of the package \nPkg.pin(\"PhyloNetworks\")\n so that \nPkg.update()\n will not modify it. You can always free a pinned package with \nPkg.free(\"PhyloNetworks\")\n. More on checked and pinned packages \nhere\n.\n\n\nThe PhyloNetworks package has dependencies like \nNLopt\n and \nDataFrames\n (see the REQUIRE file for the full list), but everything is installed automatically.\n\n\nThe companion package \nPhyloPlots\n has utilities to visualize networks, and for interoperability, such as to export networks to R (which can then be plotted via R). To install:\n\n\nPkg\n.\nadd\n(\nPhyloPlots\n)\n\n\n\n\n\n\nPhyloPlots depends on PhyloNetworks, and has further dependencies like \nGadfly\n and \nRCall\n\n\n\n\nTest example\n\n\nTo check that your installation worked, type this in Julia to load the package. This is something to type every time you start a Julia session:\n\n\nusing\n \nPhyloNetworks\n;\n\n\n\n\n\n\nThis step can also take a while, if Julia needs to pre-compile the code (after a package update for instance). Here is a very small test for the installation of PhyloNetworks.\n\n\njulia\n net = readTopology(\n(A,(B,(C,D)));\n);\n\njulia\n tipLabels(net)\n4-element Array{String,1}:\n \nA\n\n \nB\n\n \nC\n\n \nD\n\n\n\n\n\n\nYou can see a list of all the functions with\n\n\nwhos\n(\nPhyloNetworks\n)\n\n\n\n\n\n\nand press \n?\n inside Julia to switch to help mode, followed by the name of a function (or type) to get more details about it.\n\n\n\n\nJulia types\n\n\nEach object in Julia has a \ntype\n. We show here small examples on how to get more info on an object, what's its type, and how to manipulate objects. For example, let's take an object \nraxmlCF\n created from reading in some data (see \nInput for SNaQ\n):\n\n\njulia\n raxmltrees = joinpath(Pkg.dir(\nPhyloNetworks\n),\nexamples\n,\nraxmltrees.tre\n);\n\njulia\n raxmlCF = readTrees2CF(raxmltrees);\nwill use all quartets on 6 taxa\ncalculating obsCF from 30 gene trees and for 15 quartets\nReading in quartets...\n0+---------------+100%  \n  ***************  \ntable of obsCF printed to file tableCF.txt\ndescriptive stat of input data printed to file summaryTreesQuartets.txt\n\n\n\n\n\nTyping \nwhos()\n will provide a list of objects and packages in memory, including \nraxmlCF\n that we just created. If we want to know the type of a particular object, we do:\n\n\njulia\n typeof(raxmlCF)\nPhyloNetworks.DataCF\n\n\n\n\n\nwhich shows us that \nraxmlCF\n is of type \nDataCF\n. If we want to know about the attributes the object has, we can type \n?\n in Julia, followed by \nDataCF\n for a description. We can also ask for a list of all its attributes with\n\n\njulia\n fieldnames(raxmlCF)\n5-element Array{Symbol,1}:\n :quartet\n :numQuartets\n :tree\n :numTrees\n :repSpecies\n\n\n\n\n\nFor example, we see that one attribute is \nnumQuartets\n: its the number of 4-taxon subsets in the data. To see what this number is:\n\n\njulia\n raxmlCF.numQuartets\n15\n\n\n\n\n\nWe also noticed an attribute \nquartet\n. It is a vector of Quartet objects inside \nraxmlCF\n, so\n\n\njulia\n raxmlCF.quartet[2].taxon\n4-element Array{String,1}:\n \nA\n\n \nB\n\n \nC\n\n \nE\n\n\n\n\n\n\nwill provide the list of taxon names for the second 4-taxon subset in the data. To see the observed CF, we can type\n\n\njulia\n raxmlCF.quartet[2].obsCF\n3-element Array{Float64,1}:\n 0.833333\n 0.0333333\n 0.133333\n\n\n\n\n\nWe can verify the type with\n\n\njulia\n typeof(raxmlCF.quartet[2])\nPhyloNetworks.Quartet\n\n\n\n\n\nWe can also read a simple network in Julia and print the list of edges\n\n\njulia\n str = \n(A,((B,#H1),(C,(D)#H1)));\n;\n\njulia\n net = readTopology(str);\n\njulia\n printEdges(net)\nedge parent child  length  hybrid isMajor gamma   containRoot inCycle istIdentitiable\n1    -2     1              false  true    1       true        -1      false\n2    -4     2              false  true    1       true        -1      false\n3    -4     3              true   false           false       -1      false\n4    -3     -4             false  true    1       true        -1      true \n5    -5     4              false  true    1       true        -1      false\n6    3      5              false  true    1       true        -1      false\n7    -5     3              true   true            false       -1      true \n8    -3     -5             false  true    1       true        -1      true \n9    -2     -3             false  true    1       true        -1      true\n\n\n\n\n\nWe see that the edges do not have branch lengths, and the hybrid edges do not have gamma values. We can set them with\n\n\njulia\n setLength!(net.edge[1],1.9)\n\njulia\n setGamma!(net.edge[3],0.8)\n\njulia\n printEdges(net)\nedge parent child  length  hybrid isMajor gamma   containRoot inCycle istIdentitiable\n1    -2     1      1.900   false  true    1       true        -1      false\n2    -4     2              false  true    1       true        -1      false\n3    -4     3              true   true    0.8     false       -1      false\n4    -3     -4             false  true    1       true        -1      true \n5    -5     4              false  true    1       true        -1      false\n6    3      5              false  true    1       true        -1      false\n7    -5     3              true   false   0.2     false       -1      true \n8    -3     -5             false  true    1       true        -1      true \n9    -2     -3             false  true    1       true        -1      true\n\n\n\n\n\nwhere 1 and 3 correspond to the position of the given edge to modify in the list of edges. We can only change the gamma value of hybrid edges (not tree edges). Such an attempt below will cause an error with a message to explain that the edge was a tree edge:\n\n\nsetGamma!\n(\nnet\n.\nedge\n[\n4\n],\n0.7\n)\n\n\n# should return this:\n\n\n# ERROR: cannot change gamma in a tree edge", 
            "title": "Installation"
        }, 
        {
            "location": "/man/installation/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/man/installation/#installation-of-julia", 
            "text": "Julia is a high-level and interactive programming language (like R or Matlab), but it is also high-performance (like C). To install Julia, follow instructions  here . For a quick   basic tutorial on Julia, see  learn x in y minutes .  Editors:   Visual Studio Code  provides an editor and an integrated development environment (IDE) for Julia: highly recommended!  Juno  provides an IDE for Julia, based on the  Atom  editor.  you can also run Julia within a  Jupyter  notebook (formerly IPython notebook).   IMPORTANT: Julia code is just-in-time compiled. This means that the first time you run a function, it will be compiled at that moment. So, please be patient! Future calls to the function will be much much faster. Trying out toy examples for the first calls is a good idea.", 
            "title": "Installation of Julia"
        }, 
        {
            "location": "/man/installation/#installation-of-the-package-phylonetworks", 
            "text": "To install the package, type inside Julia:  Pkg . add ( PhyloNetworks )   The first step can take a few minutes, be patient. If you already installed the package and want the latest registered version, just do this (which will update all of your packages):  Pkg . update ()   WARNING: It is important to update the package regularly as it is undergoing constant development. Join the google group for updates  here .  Pkg.update()  will install the latest registered version, but there could be other improvements in the  master  branch of the repository. If you want to update to the latest unregistered version of the package, you can do  Pkg.checkout(\"PhyloNetworks\")  just beware that the latest changes could be not as robust. If you want to go back to the registered package, you can do  Pkg.free(\"PhyloNetworks\") .  Similarly, you can pin a version of the package  Pkg.pin(\"PhyloNetworks\")  so that  Pkg.update()  will not modify it. You can always free a pinned package with  Pkg.free(\"PhyloNetworks\") . More on checked and pinned packages  here .  The PhyloNetworks package has dependencies like  NLopt  and  DataFrames  (see the REQUIRE file for the full list), but everything is installed automatically.  The companion package  PhyloPlots  has utilities to visualize networks, and for interoperability, such as to export networks to R (which can then be plotted via R). To install:  Pkg . add ( PhyloPlots )   PhyloPlots depends on PhyloNetworks, and has further dependencies like  Gadfly  and  RCall", 
            "title": "Installation of the package PhyloNetworks"
        }, 
        {
            "location": "/man/installation/#test-example", 
            "text": "To check that your installation worked, type this in Julia to load the package. This is something to type every time you start a Julia session:  using   PhyloNetworks ;   This step can also take a while, if Julia needs to pre-compile the code (after a package update for instance). Here is a very small test for the installation of PhyloNetworks.  julia  net = readTopology( (A,(B,(C,D))); );\n\njulia  tipLabels(net)\n4-element Array{String,1}:\n  A \n  B \n  C \n  D   You can see a list of all the functions with  whos ( PhyloNetworks )   and press  ?  inside Julia to switch to help mode, followed by the name of a function (or type) to get more details about it.", 
            "title": "Test example"
        }, 
        {
            "location": "/man/installation/#julia-types", 
            "text": "Each object in Julia has a  type . We show here small examples on how to get more info on an object, what's its type, and how to manipulate objects. For example, let's take an object  raxmlCF  created from reading in some data (see  Input for SNaQ ):  julia  raxmltrees = joinpath(Pkg.dir( PhyloNetworks ), examples , raxmltrees.tre );\n\njulia  raxmlCF = readTrees2CF(raxmltrees);\nwill use all quartets on 6 taxa\ncalculating obsCF from 30 gene trees and for 15 quartets\nReading in quartets...\n0+---------------+100%  \n  ***************  \ntable of obsCF printed to file tableCF.txt\ndescriptive stat of input data printed to file summaryTreesQuartets.txt  Typing  whos()  will provide a list of objects and packages in memory, including  raxmlCF  that we just created. If we want to know the type of a particular object, we do:  julia  typeof(raxmlCF)\nPhyloNetworks.DataCF  which shows us that  raxmlCF  is of type  DataCF . If we want to know about the attributes the object has, we can type  ?  in Julia, followed by  DataCF  for a description. We can also ask for a list of all its attributes with  julia  fieldnames(raxmlCF)\n5-element Array{Symbol,1}:\n :quartet\n :numQuartets\n :tree\n :numTrees\n :repSpecies  For example, we see that one attribute is  numQuartets : its the number of 4-taxon subsets in the data. To see what this number is:  julia  raxmlCF.numQuartets\n15  We also noticed an attribute  quartet . It is a vector of Quartet objects inside  raxmlCF , so  julia  raxmlCF.quartet[2].taxon\n4-element Array{String,1}:\n  A \n  B \n  C \n  E   will provide the list of taxon names for the second 4-taxon subset in the data. To see the observed CF, we can type  julia  raxmlCF.quartet[2].obsCF\n3-element Array{Float64,1}:\n 0.833333\n 0.0333333\n 0.133333  We can verify the type with  julia  typeof(raxmlCF.quartet[2])\nPhyloNetworks.Quartet  We can also read a simple network in Julia and print the list of edges  julia  str =  (A,((B,#H1),(C,(D)#H1))); ;\n\njulia  net = readTopology(str);\n\njulia  printEdges(net)\nedge parent child  length  hybrid isMajor gamma   containRoot inCycle istIdentitiable\n1    -2     1              false  true    1       true        -1      false\n2    -4     2              false  true    1       true        -1      false\n3    -4     3              true   false           false       -1      false\n4    -3     -4             false  true    1       true        -1      true \n5    -5     4              false  true    1       true        -1      false\n6    3      5              false  true    1       true        -1      false\n7    -5     3              true   true            false       -1      true \n8    -3     -5             false  true    1       true        -1      true \n9    -2     -3             false  true    1       true        -1      true  We see that the edges do not have branch lengths, and the hybrid edges do not have gamma values. We can set them with  julia  setLength!(net.edge[1],1.9)\n\njulia  setGamma!(net.edge[3],0.8)\n\njulia  printEdges(net)\nedge parent child  length  hybrid isMajor gamma   containRoot inCycle istIdentitiable\n1    -2     1      1.900   false  true    1       true        -1      false\n2    -4     2              false  true    1       true        -1      false\n3    -4     3              true   true    0.8     false       -1      false\n4    -3     -4             false  true    1       true        -1      true \n5    -5     4              false  true    1       true        -1      false\n6    3      5              false  true    1       true        -1      false\n7    -5     3              true   false   0.2     false       -1      true \n8    -3     -5             false  true    1       true        -1      true \n9    -2     -3             false  true    1       true        -1      true  where 1 and 3 correspond to the position of the given edge to modify in the list of edges. We can only change the gamma value of hybrid edges (not tree edges). Such an attempt below will cause an error with a message to explain that the edge was a tree edge:  setGamma! ( net . edge [ 4 ], 0.7 )  # should return this:  # ERROR: cannot change gamma in a tree edge", 
            "title": "Julia types"
        }, 
        {
            "location": "/man/inputdata/", 
            "text": "Input for SNaQ\n\n\nSNaQ is a method implemented in the package to estimate a phylogenetic network from multiple molecular sequence alignments. There are two alternatives for the input data:\n\n\n\n\nA list of estimated gene trees for each locus, which can be obtained using \nMrBayes\n or \nRAxML\n. Or:\n\n\nA table of concordance factors (CF), i.e. gene tree frequencies, for each 4-taxon subset. This table can be obtained from \nBUCKy\n, to account for gene tree uncertainty\n\n\n\n\nThis \npipeline\n can be used to obtain the table of quartet CF needed as input for SNaQ (see also the \nwiki\n.) It starts from the sequence alignments, runs MrBayes and then BUCKy (both parallelized), producing the table of estimated CFs and their credibility intervals. Additional details on this \nTICR pipeline\n describe how to insert data at various stages (e.g. after running MrBayes on each locus).\n\n\n\n\nTutorial data: gene trees\n\n\nWe suggest that you create a special directory for running these examples, where input files can be downloaded and where output files will be created (with estimated networks for instance). Enter this directory and run Julia from there.\n\n\nSuppose you have a file with a list of gene trees in parenthetical format called \nraxmltrees.tre\n. You can access the example file of input trees \nhere\n or \nhere\n for easier download.\n\n\nDo not copy-paste into a \"smart\" text-editor. Instead, save the file directly into your working directory using \"save link as\" or \"download linked file as\". This file contains 30 gene trees, each in parenthetical format on 6 taxa like this (with rounded branch lengths):\n\n\n(E:0.038,((A:0.014,B:0.010):0.010,(C:0.008,D:0.002):0.010):0.025,O:0.078);\n\n\nIf \nraxmltrees.tre\n is in your working directory, you can view its content within Julia:\n\n\nless\n(\nraxmltrees.tre\n)\n\n\n\n\n\n\nor like this, to view the version downloaded with the package:\n\n\nraxmltrees\n \n=\n \njoinpath\n(\nPkg\n.\ndir\n(\nPhyloNetworks\n),\nexamples\n,\nraxmltrees.tre\n)\n\n\nless\n(\nraxmltrees\n)\n\n\n\n\n\n\nJust type \nq\n to quit viewing this file. You could read in these 30 trees and visualize the third one (say) like this:\n\n\nusing\n \nPhyloNetworks\n\n\nraxmltrees\n \n=\n \njoinpath\n(\nPkg\n.\ndir\n(\nPhyloNetworks\n),\nexamples\n,\nraxmltrees.tre\n);\n\n\n\n\n\n\njulia\n \ngenetrees\n \n=\n \nreadMultiTopology\n(\nraxmltrees\n);\n\n\n\njulia\n \ngenetrees\n[\n3\n]\n\n\nPhyloNetworks\n.\nHybridNetwork\n,\n \nRooted\n \nNetwork\n\n\n9\n \nedges\n\n\n10\n \nnodes\n:\n \n6\n \ntips\n,\n \n0\n \nhybrid\n \nnodes\n,\n \n4\n \ninternal\n \ntree\n \nnodes\n.\n\n\ntip\n \nlabels\n:\n \nE\n,\n \nA\n,\n \nB\n,\n \nC\n,\n \n...\n\n\n((\nE\n:\n0\n.\n015\n,(\nA\n:\n0\n.\n006\n,\nB\n:\n0\n.\n006\n)\n:\n0\n.\n003\n)\n:\n0\n.\n041\n,(\nC\n:\n0\n.\n006\n,\nD\n:\n0\n.\n0\n)\n:\n0\n.\n041\n,\nO\n:\n0\n.\n052\n);\n\n\n\n\n\n\nTo visualize any of these input trees, use the \nPhyloPlots\n package:\n\n\nusing\n \nPhyloPlots\n\n\nplot\n(\ngenetrees\n[\n3\n],\n \n:\nR\n);\n \n# tree for 3rd gene\n\n\n\n\n\n\n\n\nTo read in all gene trees and directly summarize them by a list of quartet CFs (proportion of input trees with a given quartet):\n\n\njulia\n raxmlCF = readTrees2CF(raxmltrees, CFfile=\ntableCF.txt\n);\nwill use all quartets on 6 taxa\ncalculating obsCF from 30 gene trees and for 15 quartets\nReading in quartets...\n0+---------------+100%  \n  ***************  \ntable of obsCF printed to file tableCF.txt\ndescriptive stat of input data printed to file summaryTreesQuartets.txt\n\njulia\n PhyloNetworks.writeObsCF(raxmlCF) # observed CFs: gene frequencies\n15\u00d78 DataFrames.DataFrame\n\u2502 Row \u2502 t1 \u2502 t2 \u2502 t3 \u2502 t4 \u2502 CF12_34  \u2502 CF13_24   \u2502 CF14_23   \u2502 ngenes \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 A  \u2502 B  \u2502 C  \u2502 D  \u2502 1.0      \u2502 0.0       \u2502 0.0       \u2502 30     \u2502\n\u2502 2   \u2502 A  \u2502 B  \u2502 C  \u2502 E  \u2502 0.833333 \u2502 0.0333333 \u2502 0.133333  \u2502 30     \u2502\n\u2502 3   \u2502 A  \u2502 B  \u2502 C  \u2502 O  \u2502 0.866667 \u2502 0.0       \u2502 0.133333  \u2502 30     \u2502\n\u2502 4   \u2502 A  \u2502 B  \u2502 D  \u2502 E  \u2502 0.833333 \u2502 0.0333333 \u2502 0.133333  \u2502 30     \u2502\n\u2502 5   \u2502 A  \u2502 B  \u2502 D  \u2502 O  \u2502 0.866667 \u2502 0.0       \u2502 0.133333  \u2502 30     \u2502\n\u2502 6   \u2502 A  \u2502 B  \u2502 E  \u2502 O  \u2502 0.833333 \u2502 0.0666667 \u2502 0.1       \u2502 30     \u2502\n\u2502 7   \u2502 A  \u2502 C  \u2502 D  \u2502 E  \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 30     \u2502\n\u2502 8   \u2502 A  \u2502 C  \u2502 D  \u2502 O  \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 30     \u2502\n\u2502 9   \u2502 A  \u2502 C  \u2502 E  \u2502 O  \u2502 0.533333 \u2502 0.333333  \u2502 0.133333  \u2502 30     \u2502\n\u2502 10  \u2502 A  \u2502 D  \u2502 E  \u2502 O  \u2502 0.533333 \u2502 0.333333  \u2502 0.133333  \u2502 30     \u2502\n\u2502 11  \u2502 B  \u2502 C  \u2502 D  \u2502 E  \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 30     \u2502\n\u2502 12  \u2502 B  \u2502 C  \u2502 D  \u2502 O  \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 30     \u2502\n\u2502 13  \u2502 B  \u2502 C  \u2502 E  \u2502 O  \u2502 0.666667 \u2502 0.266667  \u2502 0.0666667 \u2502 30     \u2502\n\u2502 14  \u2502 B  \u2502 D  \u2502 E  \u2502 O  \u2502 0.666667 \u2502 0.266667  \u2502 0.0666667 \u2502 30     \u2502\n\u2502 15  \u2502 C  \u2502 D  \u2502 E  \u2502 O  \u2502 1.0      \u2502 0.0       \u2502 0.0       \u2502 30     \u2502\n\n\n\n\n\nless(\"tableCF.txt\")\n lets you see the content of the newly created file \"tableCF.txt\", within Julia. Again, type \nq\n to quit viewing this file.\n\n\nIn this table, each 4-taxon set is listed in one row. The 3 \"CF\" columns gives the proportion of genes that has each of the 3 possible trees on these 4 taxa.\n\n\nFor more help on any function, type \n?\n to enter the help mode, then type the name of the function. For example: type \n?\n then \nreadTrees2CF\n for information on the various options of that function.\n\n\nWhen there are many more taxa, the number of quartets might be very large and we might want to use a subset to speed things up. Here, if we wanted to use a random sample of 10 quartets instead of all quartets, we could do:\n\n\nreadTrees2CF(raxmltrees, whichQ=\"rand\", numQ=10, CFfile=\"tableCF10.txt\")\n\n\nBe careful to use a numQ value smaller than the total number of possible 4-taxon subsets, which is \nn choose 4\n on \nn\n taxa (e.g. 15 on 6 taxa). To get a predictable random sample, you may set the seed with \nsrand(12321)\n (for instance) prior to sampling the quartets as above.\n\n\n\n\nTutorial data: quartet CFs\n\n\nIf we already have a table of quartet concordance factor (CF) values in a file \nbuckyCF.csv\n in this format\n\n\n\n\n\n\n\n\nTaxon1\n\n\nTaxon2\n\n\nTaxon3\n\n\nTaxon4\n\n\nCF12_34\n\n\nCF13_24\n\n\nCF14_23\n\n\n\n\n\n\n\n\n\n\nD\n\n\nA\n\n\nE\n\n\nO\n\n\n0.565\n\n\n0.0903\n\n\n0.3447\n\n\n\n\n\n\n...\n\n\n\n\n\n\n\n\n\n\n\n\n...\n\n\n\n\n\n\n\n\nwe would read it in one step like this: \nreadTableCF(\"buckyCF.csv\")\n. An example file comes with the package, available \nhere\n or \nhere\n.\n\n\njulia\n buckyCFfile = joinpath(Pkg.dir(\nPhyloNetworks\n),\nexamples\n,\nbuckyCF.csv\n);\n\njulia\n buckyCF = readTableCF(buckyCFfile)\n30 gene trees per 4-taxon set\nObject DataCF\nnumber of quartets: 15\n\n\n\n\n\nThe same thing could be done in 2 steps: first to read the file and convert it to a 'DataFrame' object, and then to convert this DataFrame into a DataCF object.\n\n\njulia\n using CSV, DataFrames\n\njulia\n dat = CSV.read(buckyCFfile);\n\njulia\n head(dat) # head shows the first 6 rows only\n6\u00d714 DataFrames.DataFrame. Omitted printing of 8 columns\n\u2502 Row \u2502 taxon1 \u2502 taxon2 \u2502 taxon3 \u2502 taxon4 \u2502 CF12.34    \u2502 CF12.34_lo \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 D      \u2502 A      \u2502 E      \u2502 O      \u2502 0.565033   \u2502 0.5        \u2502\n\u2502 2   \u2502 D      \u2502 A      \u2502 E      \u2502 B      \u2502 0.0005     \u2502 0.0        \u2502\n\u2502 3   \u2502 C      \u2502 A      \u2502 E      \u2502 B      \u2502 0.0005     \u2502 0.0        \u2502\n\u2502 4   \u2502 C      \u2502 A      \u2502 E      \u2502 O      \u2502 0.565033   \u2502 0.5        \u2502\n\u2502 5   \u2502 D      \u2502 A      \u2502 O      \u2502 B      \u2502 3.33333e-5 \u2502 0.0        \u2502\n\u2502 6   \u2502 C      \u2502 D      \u2502 E      \u2502 O      \u2502 0.999867   \u2502 1.0        \u2502\n\njulia\n buckyCF = readTableCF(dat)\n30 gene trees per 4-taxon set\nObject DataCF\nnumber of quartets: 15\n\njulia\n PhyloNetworks.writeObsCF(buckyCF)\n15\u00d78 DataFrames.DataFrame\n\u2502 Row \u2502 t1 \u2502 t2 \u2502 t3 \u2502 t4 \u2502 CF12_34    \u2502 CF13_24    \u2502 CF14_23    \u2502 ngenes \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 D  \u2502 A  \u2502 E  \u2502 O  \u2502 0.565033   \u2502 0.0903     \u2502 0.344667   \u2502 30     \u2502\n\u2502 2   \u2502 D  \u2502 A  \u2502 E  \u2502 B  \u2502 0.0005     \u2502 0.8599     \u2502 0.139567   \u2502 30     \u2502\n\u2502 3   \u2502 C  \u2502 A  \u2502 E  \u2502 B  \u2502 0.0005     \u2502 0.8599     \u2502 0.139567   \u2502 30     \u2502\n\u2502 4   \u2502 C  \u2502 A  \u2502 E  \u2502 O  \u2502 0.565033   \u2502 0.0903     \u2502 0.344667   \u2502 30     \u2502\n\u2502 5   \u2502 D  \u2502 A  \u2502 O  \u2502 B  \u2502 3.33333e-5 \u2502 0.8885     \u2502 0.111467   \u2502 30     \u2502\n\u2502 6   \u2502 C  \u2502 D  \u2502 E  \u2502 O  \u2502 0.999867   \u2502 6.66667e-5 \u2502 6.66667e-5 \u2502 30     \u2502\n\u2502 7   \u2502 C  \u2502 E  \u2502 O  \u2502 B  \u2502 0.0401667  \u2502 0.263067   \u2502 0.696767   \u2502 30     \u2502\n\u2502 8   \u2502 C  \u2502 D  \u2502 A  \u2502 E  \u2502 1.0        \u2502 0.0        \u2502 0.0        \u2502 30     \u2502\n\u2502 9   \u2502 C  \u2502 D  \u2502 O  \u2502 B  \u2502 0.999867   \u2502 6.66667e-5 \u2502 6.66667e-5 \u2502 30     \u2502\n\u2502 10  \u2502 C  \u2502 D  \u2502 E  \u2502 B  \u2502 1.0        \u2502 0.0        \u2502 0.0        \u2502 30     \u2502\n\u2502 11  \u2502 D  \u2502 E  \u2502 O  \u2502 B  \u2502 0.0401667  \u2502 0.263067   \u2502 0.696767   \u2502 30     \u2502\n\u2502 12  \u2502 C  \u2502 D  \u2502 A  \u2502 O  \u2502 0.999867   \u2502 6.66667e-5 \u2502 6.66667e-5 \u2502 30     \u2502\n\u2502 13  \u2502 C  \u2502 D  \u2502 A  \u2502 B  \u2502 1.0        \u2502 0.0        \u2502 0.0        \u2502 30     \u2502\n\u2502 14  \u2502 A  \u2502 E  \u2502 O  \u2502 B  \u2502 0.0731667  \u2502 0.0424667  \u2502 0.884367   \u2502 30     \u2502\n\u2502 15  \u2502 C  \u2502 A  \u2502 O  \u2502 B  \u2502 3.33333e-5 \u2502 0.8885     \u2502 0.111467   \u2502 30     \u2502\n\n\n\n\n\nIn the input file, columns need to be in the right order: with the first 4 columns giving the names of the taxa in each 4-taxon set. The CF values are assumed to be in columns named \"CF12_34\", etc., or else in columns 5,6,7. If available, a column named \"ngenes\" will be taken to have the the number of genes for each 4-taxon subset.\n\n\n\n\nTutorial data: starting tree\n\n\nIf we have a tree for the data set at hand, it can be used as a starting point for the optimization. From our gene trees, we estimated a species tree with \nASTRAL\n. This tree comes with the package in file \nastral.tre\n \nhere\n. This file has 102 trees: 100 bootstrap species trees, followed by their greedy consensus, followed by the best tree on the original data. It's this last tree that we are most interested in. We can read it with\n\n\nastralfile\n \n=\n \njoinpath\n(\nPkg\n.\ndir\n(\nPhyloNetworks\n),\nexamples\n,\nastral.tre\n);\n\n\nastraltree\n \n=\n \nreadMultiTopology\n(\nastralfile\n)[\n102\n]\n \n# 102th tree: last tree here\n\n\nplot\n(\nastraltree\n,\n \n:\nR\n,\n \nshowEdgeLength\n=\ntrue\n);\n\n\n\n\n\n\n\n\nTo start its search, SNaQ will need a network of \"level 1\". All trees and all networks with 1 hybridization are of level 1. To make sure that a network with 2 or more hybridizations is of level 1, we can read it in with \nreadTopologyLevel1\n (which also unroots the tree, resolves polytomies, replaces missing branch lengths by 1 for starting values etc.):\n\n\nT\n=\nreadTopologyLevel1\n(\nstartNetwork.txt\n)\n\n\n\n\n\n\n(here \nstartNetwork.txt\n is a hypothetical file: replace this by the name of a file that contains your network of interest.)\n\n\nNext: \nGetting a Network", 
            "title": "Input Data for SNaQ"
        }, 
        {
            "location": "/man/inputdata/#input-for-snaq", 
            "text": "SNaQ is a method implemented in the package to estimate a phylogenetic network from multiple molecular sequence alignments. There are two alternatives for the input data:   A list of estimated gene trees for each locus, which can be obtained using  MrBayes  or  RAxML . Or:  A table of concordance factors (CF), i.e. gene tree frequencies, for each 4-taxon subset. This table can be obtained from  BUCKy , to account for gene tree uncertainty   This  pipeline  can be used to obtain the table of quartet CF needed as input for SNaQ (see also the  wiki .) It starts from the sequence alignments, runs MrBayes and then BUCKy (both parallelized), producing the table of estimated CFs and their credibility intervals. Additional details on this  TICR pipeline  describe how to insert data at various stages (e.g. after running MrBayes on each locus).", 
            "title": "Input for SNaQ"
        }, 
        {
            "location": "/man/inputdata/#tutorial-data-gene-trees", 
            "text": "We suggest that you create a special directory for running these examples, where input files can be downloaded and where output files will be created (with estimated networks for instance). Enter this directory and run Julia from there.  Suppose you have a file with a list of gene trees in parenthetical format called  raxmltrees.tre . You can access the example file of input trees  here  or  here  for easier download.  Do not copy-paste into a \"smart\" text-editor. Instead, save the file directly into your working directory using \"save link as\" or \"download linked file as\". This file contains 30 gene trees, each in parenthetical format on 6 taxa like this (with rounded branch lengths):  (E:0.038,((A:0.014,B:0.010):0.010,(C:0.008,D:0.002):0.010):0.025,O:0.078);  If  raxmltrees.tre  is in your working directory, you can view its content within Julia:  less ( raxmltrees.tre )   or like this, to view the version downloaded with the package:  raxmltrees   =   joinpath ( Pkg . dir ( PhyloNetworks ), examples , raxmltrees.tre )  less ( raxmltrees )   Just type  q  to quit viewing this file. You could read in these 30 trees and visualize the third one (say) like this:  using   PhyloNetworks  raxmltrees   =   joinpath ( Pkg . dir ( PhyloNetworks ), examples , raxmltrees.tre );   julia   genetrees   =   readMultiTopology ( raxmltrees );  julia   genetrees [ 3 ]  PhyloNetworks . HybridNetwork ,   Rooted   Network  9   edges  10   nodes :   6   tips ,   0   hybrid   nodes ,   4   internal   tree   nodes .  tip   labels :   E ,   A ,   B ,   C ,   ...  (( E : 0 . 015 ,( A : 0 . 006 , B : 0 . 006 ) : 0 . 003 ) : 0 . 041 ,( C : 0 . 006 , D : 0 . 0 ) : 0 . 041 , O : 0 . 052 );   To visualize any of these input trees, use the  PhyloPlots  package:  using   PhyloPlots  plot ( genetrees [ 3 ],   : R );   # tree for 3rd gene    To read in all gene trees and directly summarize them by a list of quartet CFs (proportion of input trees with a given quartet):  julia  raxmlCF = readTrees2CF(raxmltrees, CFfile= tableCF.txt );\nwill use all quartets on 6 taxa\ncalculating obsCF from 30 gene trees and for 15 quartets\nReading in quartets...\n0+---------------+100%  \n  ***************  \ntable of obsCF printed to file tableCF.txt\ndescriptive stat of input data printed to file summaryTreesQuartets.txt\n\njulia  PhyloNetworks.writeObsCF(raxmlCF) # observed CFs: gene frequencies\n15\u00d78 DataFrames.DataFrame\n\u2502 Row \u2502 t1 \u2502 t2 \u2502 t3 \u2502 t4 \u2502 CF12_34  \u2502 CF13_24   \u2502 CF14_23   \u2502 ngenes \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 A  \u2502 B  \u2502 C  \u2502 D  \u2502 1.0      \u2502 0.0       \u2502 0.0       \u2502 30     \u2502\n\u2502 2   \u2502 A  \u2502 B  \u2502 C  \u2502 E  \u2502 0.833333 \u2502 0.0333333 \u2502 0.133333  \u2502 30     \u2502\n\u2502 3   \u2502 A  \u2502 B  \u2502 C  \u2502 O  \u2502 0.866667 \u2502 0.0       \u2502 0.133333  \u2502 30     \u2502\n\u2502 4   \u2502 A  \u2502 B  \u2502 D  \u2502 E  \u2502 0.833333 \u2502 0.0333333 \u2502 0.133333  \u2502 30     \u2502\n\u2502 5   \u2502 A  \u2502 B  \u2502 D  \u2502 O  \u2502 0.866667 \u2502 0.0       \u2502 0.133333  \u2502 30     \u2502\n\u2502 6   \u2502 A  \u2502 B  \u2502 E  \u2502 O  \u2502 0.833333 \u2502 0.0666667 \u2502 0.1       \u2502 30     \u2502\n\u2502 7   \u2502 A  \u2502 C  \u2502 D  \u2502 E  \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 30     \u2502\n\u2502 8   \u2502 A  \u2502 C  \u2502 D  \u2502 O  \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 30     \u2502\n\u2502 9   \u2502 A  \u2502 C  \u2502 E  \u2502 O  \u2502 0.533333 \u2502 0.333333  \u2502 0.133333  \u2502 30     \u2502\n\u2502 10  \u2502 A  \u2502 D  \u2502 E  \u2502 O  \u2502 0.533333 \u2502 0.333333  \u2502 0.133333  \u2502 30     \u2502\n\u2502 11  \u2502 B  \u2502 C  \u2502 D  \u2502 E  \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 30     \u2502\n\u2502 12  \u2502 B  \u2502 C  \u2502 D  \u2502 O  \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 30     \u2502\n\u2502 13  \u2502 B  \u2502 C  \u2502 E  \u2502 O  \u2502 0.666667 \u2502 0.266667  \u2502 0.0666667 \u2502 30     \u2502\n\u2502 14  \u2502 B  \u2502 D  \u2502 E  \u2502 O  \u2502 0.666667 \u2502 0.266667  \u2502 0.0666667 \u2502 30     \u2502\n\u2502 15  \u2502 C  \u2502 D  \u2502 E  \u2502 O  \u2502 1.0      \u2502 0.0       \u2502 0.0       \u2502 30     \u2502  less(\"tableCF.txt\")  lets you see the content of the newly created file \"tableCF.txt\", within Julia. Again, type  q  to quit viewing this file.  In this table, each 4-taxon set is listed in one row. The 3 \"CF\" columns gives the proportion of genes that has each of the 3 possible trees on these 4 taxa.  For more help on any function, type  ?  to enter the help mode, then type the name of the function. For example: type  ?  then  readTrees2CF  for information on the various options of that function.  When there are many more taxa, the number of quartets might be very large and we might want to use a subset to speed things up. Here, if we wanted to use a random sample of 10 quartets instead of all quartets, we could do:  readTrees2CF(raxmltrees, whichQ=\"rand\", numQ=10, CFfile=\"tableCF10.txt\")  Be careful to use a numQ value smaller than the total number of possible 4-taxon subsets, which is  n choose 4  on  n  taxa (e.g. 15 on 6 taxa). To get a predictable random sample, you may set the seed with  srand(12321)  (for instance) prior to sampling the quartets as above.", 
            "title": "Tutorial data: gene trees"
        }, 
        {
            "location": "/man/inputdata/#tutorial-data-quartet-cfs", 
            "text": "If we already have a table of quartet concordance factor (CF) values in a file  buckyCF.csv  in this format     Taxon1  Taxon2  Taxon3  Taxon4  CF12_34  CF13_24  CF14_23      D  A  E  O  0.565  0.0903  0.3447    ...       ...     we would read it in one step like this:  readTableCF(\"buckyCF.csv\") . An example file comes with the package, available  here  or  here .  julia  buckyCFfile = joinpath(Pkg.dir( PhyloNetworks ), examples , buckyCF.csv );\n\njulia  buckyCF = readTableCF(buckyCFfile)\n30 gene trees per 4-taxon set\nObject DataCF\nnumber of quartets: 15  The same thing could be done in 2 steps: first to read the file and convert it to a 'DataFrame' object, and then to convert this DataFrame into a DataCF object.  julia  using CSV, DataFrames\n\njulia  dat = CSV.read(buckyCFfile);\n\njulia  head(dat) # head shows the first 6 rows only\n6\u00d714 DataFrames.DataFrame. Omitted printing of 8 columns\n\u2502 Row \u2502 taxon1 \u2502 taxon2 \u2502 taxon3 \u2502 taxon4 \u2502 CF12.34    \u2502 CF12.34_lo \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 D      \u2502 A      \u2502 E      \u2502 O      \u2502 0.565033   \u2502 0.5        \u2502\n\u2502 2   \u2502 D      \u2502 A      \u2502 E      \u2502 B      \u2502 0.0005     \u2502 0.0        \u2502\n\u2502 3   \u2502 C      \u2502 A      \u2502 E      \u2502 B      \u2502 0.0005     \u2502 0.0        \u2502\n\u2502 4   \u2502 C      \u2502 A      \u2502 E      \u2502 O      \u2502 0.565033   \u2502 0.5        \u2502\n\u2502 5   \u2502 D      \u2502 A      \u2502 O      \u2502 B      \u2502 3.33333e-5 \u2502 0.0        \u2502\n\u2502 6   \u2502 C      \u2502 D      \u2502 E      \u2502 O      \u2502 0.999867   \u2502 1.0        \u2502\n\njulia  buckyCF = readTableCF(dat)\n30 gene trees per 4-taxon set\nObject DataCF\nnumber of quartets: 15\n\njulia  PhyloNetworks.writeObsCF(buckyCF)\n15\u00d78 DataFrames.DataFrame\n\u2502 Row \u2502 t1 \u2502 t2 \u2502 t3 \u2502 t4 \u2502 CF12_34    \u2502 CF13_24    \u2502 CF14_23    \u2502 ngenes \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 D  \u2502 A  \u2502 E  \u2502 O  \u2502 0.565033   \u2502 0.0903     \u2502 0.344667   \u2502 30     \u2502\n\u2502 2   \u2502 D  \u2502 A  \u2502 E  \u2502 B  \u2502 0.0005     \u2502 0.8599     \u2502 0.139567   \u2502 30     \u2502\n\u2502 3   \u2502 C  \u2502 A  \u2502 E  \u2502 B  \u2502 0.0005     \u2502 0.8599     \u2502 0.139567   \u2502 30     \u2502\n\u2502 4   \u2502 C  \u2502 A  \u2502 E  \u2502 O  \u2502 0.565033   \u2502 0.0903     \u2502 0.344667   \u2502 30     \u2502\n\u2502 5   \u2502 D  \u2502 A  \u2502 O  \u2502 B  \u2502 3.33333e-5 \u2502 0.8885     \u2502 0.111467   \u2502 30     \u2502\n\u2502 6   \u2502 C  \u2502 D  \u2502 E  \u2502 O  \u2502 0.999867   \u2502 6.66667e-5 \u2502 6.66667e-5 \u2502 30     \u2502\n\u2502 7   \u2502 C  \u2502 E  \u2502 O  \u2502 B  \u2502 0.0401667  \u2502 0.263067   \u2502 0.696767   \u2502 30     \u2502\n\u2502 8   \u2502 C  \u2502 D  \u2502 A  \u2502 E  \u2502 1.0        \u2502 0.0        \u2502 0.0        \u2502 30     \u2502\n\u2502 9   \u2502 C  \u2502 D  \u2502 O  \u2502 B  \u2502 0.999867   \u2502 6.66667e-5 \u2502 6.66667e-5 \u2502 30     \u2502\n\u2502 10  \u2502 C  \u2502 D  \u2502 E  \u2502 B  \u2502 1.0        \u2502 0.0        \u2502 0.0        \u2502 30     \u2502\n\u2502 11  \u2502 D  \u2502 E  \u2502 O  \u2502 B  \u2502 0.0401667  \u2502 0.263067   \u2502 0.696767   \u2502 30     \u2502\n\u2502 12  \u2502 C  \u2502 D  \u2502 A  \u2502 O  \u2502 0.999867   \u2502 6.66667e-5 \u2502 6.66667e-5 \u2502 30     \u2502\n\u2502 13  \u2502 C  \u2502 D  \u2502 A  \u2502 B  \u2502 1.0        \u2502 0.0        \u2502 0.0        \u2502 30     \u2502\n\u2502 14  \u2502 A  \u2502 E  \u2502 O  \u2502 B  \u2502 0.0731667  \u2502 0.0424667  \u2502 0.884367   \u2502 30     \u2502\n\u2502 15  \u2502 C  \u2502 A  \u2502 O  \u2502 B  \u2502 3.33333e-5 \u2502 0.8885     \u2502 0.111467   \u2502 30     \u2502  In the input file, columns need to be in the right order: with the first 4 columns giving the names of the taxa in each 4-taxon set. The CF values are assumed to be in columns named \"CF12_34\", etc., or else in columns 5,6,7. If available, a column named \"ngenes\" will be taken to have the the number of genes for each 4-taxon subset.", 
            "title": "Tutorial data: quartet CFs"
        }, 
        {
            "location": "/man/inputdata/#tutorial-data-starting-tree", 
            "text": "If we have a tree for the data set at hand, it can be used as a starting point for the optimization. From our gene trees, we estimated a species tree with  ASTRAL . This tree comes with the package in file  astral.tre   here . This file has 102 trees: 100 bootstrap species trees, followed by their greedy consensus, followed by the best tree on the original data. It's this last tree that we are most interested in. We can read it with  astralfile   =   joinpath ( Pkg . dir ( PhyloNetworks ), examples , astral.tre );  astraltree   =   readMultiTopology ( astralfile )[ 102 ]   # 102th tree: last tree here  plot ( astraltree ,   : R ,   showEdgeLength = true );    To start its search, SNaQ will need a network of \"level 1\". All trees and all networks with 1 hybridization are of level 1. To make sure that a network with 2 or more hybridizations is of level 1, we can read it in with  readTopologyLevel1  (which also unroots the tree, resolves polytomies, replaces missing branch lengths by 1 for starting values etc.):  T = readTopologyLevel1 ( startNetwork.txt )   (here  startNetwork.txt  is a hypothetical file: replace this by the name of a file that contains your network of interest.)  Next:  Getting a Network", 
            "title": "Tutorial data: starting tree"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/", 
            "text": "TICR pipeline\n\n\nPhyloNetworks' \nwiki\n has a step-by-step tutorial, to go from multiple sequence alignments to a table of quartet gene frequencies (concordance factors: CFs), through BUCKy (to integrate out gene tree uncertainty) or through RAxML. To get the \nraxml.pl\n perl script to run RAxML on each gene, download the content of that wiki with\n\n\ngit clone https://github.com/crsl4/PhyloNetworks.jl.wiki.git\n\n\nthen go to the \nscript/\n folder.   Full information and code is \nhere\n. Below is more detail to insert data into the pipeline at various stages, using one of \ntwo pipelines\n, depending on your machine configuration:\n\n\n\n\n\"no-scheduler\" pipeline: original set of Perl scripts from the TICR pipeline, well suited for a machine or a cluster of machines without a job scheduler. The scripts automatically parallelize the work across the available cores.\n\n\n\"slurm\" pipeline: well suited for a cluster where users submit jobs via a job scheduler like \nSLURM\n or \nSGE\n. The job scheduler does the work of parallelizing the work across available cores. The scripts, in this second pipeline, were created to take full advantage of job scheduler capabilities. They were developed for a cluster running SLURM. Adjustments to the submit scripts will be needed, to adapt to your own SLURM configuration or to the syntax that your job scheduler wants.\n\n\n\n\n\n\nTo run MrBayes: we already have alignments\n\n\n\n\nno-scheduler pipeline\n\n\nWe don't need to run \nmdl.pl\n if we already have aligned gene sequences from separate loci. To run MrBayes on each locus, we can simply create a tarball of the Nexus files we wish to use (fasta won't work at this stage). The command below assumes that we want to use all the files ending with \".nex\" in the current directory, one file per locus:\n\n\ntar czf my-genes.tar.gz *.nex\n\n\n\n\n\nOnce the tarball has been successfully generated, we can then specify this file as input for \nmb.pl\n assuming we have a valid MrBayes block located in the file \"bayes.txt\":\n\n\nmb.pl my-genes.tar.gz -m bayes.txt -o my-genes-mb\n\n\n\n\n\nIf we get an error message like \nmb.pl: Command not found\n, it might be because \nmb.pl\n has no execute permission, or the current directory is not in our \"path\". An easy fix is to run this command instead:\n\n\nperl mb.pl my-genes.tar.gz -m bayes.txt -o my-genes-mb\n\n\n\n\n\nThe resulting output tarball would now be located in \nmy-genes-mb/my-genes.mb.tar\n, and can be used normally with \nbucky.pl\n, that is, like this:\n\n\nbucky.pl my-genes-mb/my-genes.mb.tar -o mygenes-bucky\n\n\n\n\n\nThe output, with the table of concordance factors for all sets of 4 taxa, will be in a file named \nmy-genes.CFs.csv\n inside a directory named \nmygenes-bucky\n. That's the file containing the quartet concordance factors to give to SNaQ as input. There is \nno\n need to do any of the steps below: they are already done by \nbucky.pl\n.\n\n\n\n\nslurm pipeline\n\n\nSLURM will parallelize the MrBayes runs across genes.\n\n\n\n\n\n\nNavigate in some \"working\" directory where you place:\n\n\n\n\na folder containing all nexus files, which we will call \"nexusfolder\" below\n\n\na text file named \nmb-block.txt\n with the MrBayes block to be used\n\n\n\n\nfor all the genes (containing the options for MrBayes: model of sequence evolution, number of generations etc.). If we want a different MrBayes block for different genes, step 2 should be skipped, and we should instead find some other way to put the specific MrBayes block at the end of each nexus file.\n2. In the \"working\" directory above, run the julia script \npaste-mb-block.jl\n with \"nexusfolder\" as argument, to tell the script where to find all the nexus files:\n\n\nbash\njulia path/to/paste-mb-block.jl nexusfolder\n\n\nThis script will read all the nexus files in the directory \nnexusfolder\n, will create a new directory \nnexusfolder-block\n, and will create new nexus files (containing the MrBayes block found in file \nmb-block.txt\n) as \n1.nex, 2.nex, ...\n in the new directory. A \ntranslate.txt\n file will also be created to map the original gene file names to the new (numbered) file names. If we named our MrBayes block file differently: we can edit the script and modify it to replace \nmb-block.txt\n by our actual file name for the MrBayes block.\n3. Modify the submit script \nmb-slurm-submit.sh\n, which will parallelize all the individual-gene MrBayes runs with SLURM:\n\n\n\n\nchange \n--array\n to the correct number of genes\n\n\nchange \n--mail-user\n to the user's email (if this is an option for your job scheduler)\n\n\nreplace the \n/workspace/software/bin\n in \nPATH=\"/workspace/software/bin:$PATH\"\n to the path where the \nmb\n executable is located or put the whole path in the command: \n/s/mrbayes-3.2.6-1/bin/mb\n\n\n\n\nIn slurm, we can then submit the MrBayes array job with:\n\n\n\n\n\n\nsbatch mb-slurm-submit.sh\n\n\n\n\n\nWith this slurm pipeline, the steps below are needed: keep reading.\n\n\n\n\nTo run mbsum on the output of MrBayes for each gene\n\n\nIf we have the output of MrBayes and want to run BUCKy, we must first run \nmbsum\n on the output from MrBayes, separately for each gene.\n\n\nFor a gene with output tree files named \ngene1.run1.t\n, \ngene1.run2.t\n and \ngene1.run3.t\n, and a desired burnin of 1000 trees per tree file, we do this:\n\n\nmbsum -n \n1000\n -o gene1.in gene1.run1.t gene1.run2.t gene1.run3.t\n\n\n\n\n\nThis \nmbsum\n command will need to be executed for each gene. Then we can continue to the next section to run bucky.\n\n\nAlternatively, we can use the julia script \nmbsum-t-files.jl\n, and give it as argument the directory that has the output tree files from MrBayes, to run mbsum for \nall\n the genes. \nmbsum\n is fast, so there is no attempt to parallelize the various mbsum commands.\n\n\njulia mbsum-t-files.jl mbfolder\n\n\n\n\n\nWarning:\n a burnin of 2500 generations is hard coded in this script. This can easily be changed: edit this short script near the top of the file, to change the value of \nburnin\n.\n\n\n\n\nTo run bucky on all 4-taxon sets: we already have the mbsum output\n\n\n\n\nno-scheduler pipeline\n\n\nIf we already ran \nmbsum\n on the output from MrBayes, for each individual gene, we can simply create a tarball containing all the mbsum output files. So if we had mbsum output in files named \ngene1.in\n, \ngene2.in\n, ... , \ngene100.in\n, we would want to run something similar to the following command to create the tarball:\n\n\ntar czf my-genes-mbsum.tar.gz gene*.in\n\n\n\n\n\nWe can now use this tarball along with the \n-s\n option in \nbucky.pl\n like this:\n\n\nbucky.pl my-genes-mbsum.tar.gz -s -o mygenes-bucky\n\n\n\n\n\nAgain, if we get an error like \nbucky.pl: Command not found\n, we could run instead\n\n\nperl bucky.pl my-genes-mbsum.tar.gz -s -o mygenes-bucky\n\n\n\n\n\nThe output, with the table of concordance factors for all sets of 4 taxa, will be in a file named \nmy-genes.CFs.csv\n inside directory \nmygenes-bucky\n. That's the file containing the quartet concordance factors to give to SNaQ as input.\n\n\n\n\nslurm pipeline\n\n\nWe want to run \nbucky\n on every 4-taxon set. SLURM will parallelize these jobs with the submit script \nbucky-slurm-submit.sh\n, which calls the perl script \nbucky-slurm.pl\n.\n\n\nThe perl script \nbucky-slurm.pl\n runs \nbucky\n on a single 4-taxon set. It takes the following arguments, which must be modified in the submit script \nbucky-slurm-submit.sh\n:\n\n\n\n\nname of the folder containing the \nmbsum\n output files (one per locus) from previous step. This folder is named \nmbsum\n in the submit script: adapt if needed.\n\n\noutput name: \n-o\n or \n--out-dir\n name of the directory to store output files in. This option is not used in the default submit script\n\n\nbucky arguments: \n-a\n or \n--alpha\n for the prior alpha value, and \n-n\n or \n--ngen\n number of generations. These options are not used either, in the script: the defaults are used then (\u03b1=1, 1 million generations)\n\n\ninteger for the given quartet, via option \n-q\n. The quartet ID is specified by SLURM with its own array ID: \n$SLURM_ARRAY_TASK_ID\n.\n\n\n\n\nIn the submit script that gives instructions to the job scheduler:\n\n\n\n\nadapt the name of the \n$SLURM_ARRAY_TASK_ID\n variable, which captures the task number in the array of tasks, to your scheduler syntax\n\n\nchange \n--array\n to the correct number of 4-taxon sets. For example, if there are 15 taxa in the dataset, there are \n1365\n 4-taxon sets. To get this number, if you are unsure, use \nchoose(15,4)\n in R or \nbinomial(15,4)\n in Julia, but replace 15 by your actual number of individuals.\n\n\nchange \n--mail-user\n to the user's email (if this is an option for your job scheduler)\n\n\nreplace the \n/workspace/software/bin\n in \nPATH=\"/workspace/software/bin:$PATH\"\n by the path where the \nbucky\n executable is located. Also, replace \n/workspace/claudia/software/TICR/scripts/\n by the full path where the \nbucky-slurm.pl\n script is located.\n\n\n\n\nIn slurm, we would submit the BUCKy array job with:\n\n\nsbatch bucky-slurm-submit.sh\n\n\n\n\n\nAt the end, the array job will produce\n\n\n\n\na \n.concordance\n file for every 4-taxon set\n\n\na \n.cf\n file with the parsed output for that same 4-taxon set, in the format needed for the final CF table.\n\n\n\n\nThe \n.cf\n files can be concatenated to produce the file containing the quartet concordance factors across all 4-taxon sets, to give to SNaQ as input:\n\n\ncat *.cf \n CFtable.csv\n\n\n\n\n\nAlternatively, if the list of \n.cf\n files is not easily captured by \n*.cf\n (because the list is too long for a shell command), the following julia script can do the concatenation. Just copy-paste the commands below within a Julia session, started from the directory that contains the \n.cf\n files:\n\n\nfiles\n \n=\n \nString\n[]\n \n# empty vector of strings: will contain the .cf file names later\n\n\nfor\n \nf\n \nin\n \nfilter\n(\nx\n \n-\n \nendswith\n(\nx\n,\n \n.cf\n),\n \nreaddir\n())\n\n    \npush!\n(\nfiles\n,\nf\n)\n\n\nend\n\n\nprintln\n(\nfound \n$\n(\nlength\n(\nfiles\n))\n cf files\n)\n \n# to check how many .cf output files were found\n\n\nopen\n(\nCFtable.csv\n,\nw\n)\n \ndo\n \nf_out\n\n  \nfor\n \nfile\n \nin\n \nfiles\n\n    \n@show\n \nfile\n \n# to see the .cf file name: comment this out if that\ns too much screen output\n\n    \nopen\n(\nfile\n)\n \ndo\n \nf_in\n\n        \nline\n \n=\n \nreadstring\n(\nf_in\n)\n\n        \nwrite\n(\nf_out\n,\n \nstring\n(\nline\n,\n\\n\n))\n\n    \nend\n \n# closes \nfile\n safely\n\n  \nend\n\n\nend\n \n# closes \nCFtable.csv\n safely\n\n\n\n\n\n\nWhen this is done, we will have a file \nCFtable.csv\n containing the quartet concordance factors, to give to SNaQ as input :smiley:", 
            "title": "TICR pipeline"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#ticr-pipeline", 
            "text": "PhyloNetworks'  wiki  has a step-by-step tutorial, to go from multiple sequence alignments to a table of quartet gene frequencies (concordance factors: CFs), through BUCKy (to integrate out gene tree uncertainty) or through RAxML. To get the  raxml.pl  perl script to run RAxML on each gene, download the content of that wiki with  git clone https://github.com/crsl4/PhyloNetworks.jl.wiki.git  then go to the  script/  folder.   Full information and code is  here . Below is more detail to insert data into the pipeline at various stages, using one of  two pipelines , depending on your machine configuration:   \"no-scheduler\" pipeline: original set of Perl scripts from the TICR pipeline, well suited for a machine or a cluster of machines without a job scheduler. The scripts automatically parallelize the work across the available cores.  \"slurm\" pipeline: well suited for a cluster where users submit jobs via a job scheduler like  SLURM  or  SGE . The job scheduler does the work of parallelizing the work across available cores. The scripts, in this second pipeline, were created to take full advantage of job scheduler capabilities. They were developed for a cluster running SLURM. Adjustments to the submit scripts will be needed, to adapt to your own SLURM configuration or to the syntax that your job scheduler wants.", 
            "title": "TICR pipeline"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#to-run-mrbayes-we-already-have-alignments", 
            "text": "", 
            "title": "To run MrBayes: we already have alignments"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#no-scheduler-pipeline", 
            "text": "We don't need to run  mdl.pl  if we already have aligned gene sequences from separate loci. To run MrBayes on each locus, we can simply create a tarball of the Nexus files we wish to use (fasta won't work at this stage). The command below assumes that we want to use all the files ending with \".nex\" in the current directory, one file per locus:  tar czf my-genes.tar.gz *.nex  Once the tarball has been successfully generated, we can then specify this file as input for  mb.pl  assuming we have a valid MrBayes block located in the file \"bayes.txt\":  mb.pl my-genes.tar.gz -m bayes.txt -o my-genes-mb  If we get an error message like  mb.pl: Command not found , it might be because  mb.pl  has no execute permission, or the current directory is not in our \"path\". An easy fix is to run this command instead:  perl mb.pl my-genes.tar.gz -m bayes.txt -o my-genes-mb  The resulting output tarball would now be located in  my-genes-mb/my-genes.mb.tar , and can be used normally with  bucky.pl , that is, like this:  bucky.pl my-genes-mb/my-genes.mb.tar -o mygenes-bucky  The output, with the table of concordance factors for all sets of 4 taxa, will be in a file named  my-genes.CFs.csv  inside a directory named  mygenes-bucky . That's the file containing the quartet concordance factors to give to SNaQ as input. There is  no  need to do any of the steps below: they are already done by  bucky.pl .", 
            "title": "no-scheduler pipeline"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#slurm-pipeline", 
            "text": "SLURM will parallelize the MrBayes runs across genes.    Navigate in some \"working\" directory where you place:   a folder containing all nexus files, which we will call \"nexusfolder\" below  a text file named  mb-block.txt  with the MrBayes block to be used   for all the genes (containing the options for MrBayes: model of sequence evolution, number of generations etc.). If we want a different MrBayes block for different genes, step 2 should be skipped, and we should instead find some other way to put the specific MrBayes block at the end of each nexus file.\n2. In the \"working\" directory above, run the julia script  paste-mb-block.jl  with \"nexusfolder\" as argument, to tell the script where to find all the nexus files:  bash\njulia path/to/paste-mb-block.jl nexusfolder  This script will read all the nexus files in the directory  nexusfolder , will create a new directory  nexusfolder-block , and will create new nexus files (containing the MrBayes block found in file  mb-block.txt ) as  1.nex, 2.nex, ...  in the new directory. A  translate.txt  file will also be created to map the original gene file names to the new (numbered) file names. If we named our MrBayes block file differently: we can edit the script and modify it to replace  mb-block.txt  by our actual file name for the MrBayes block.\n3. Modify the submit script  mb-slurm-submit.sh , which will parallelize all the individual-gene MrBayes runs with SLURM:   change  --array  to the correct number of genes  change  --mail-user  to the user's email (if this is an option for your job scheduler)  replace the  /workspace/software/bin  in  PATH=\"/workspace/software/bin:$PATH\"  to the path where the  mb  executable is located or put the whole path in the command:  /s/mrbayes-3.2.6-1/bin/mb   In slurm, we can then submit the MrBayes array job with:    sbatch mb-slurm-submit.sh  With this slurm pipeline, the steps below are needed: keep reading.", 
            "title": "slurm pipeline"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#to-run-mbsum-on-the-output-of-mrbayes-for-each-gene", 
            "text": "If we have the output of MrBayes and want to run BUCKy, we must first run  mbsum  on the output from MrBayes, separately for each gene.  For a gene with output tree files named  gene1.run1.t ,  gene1.run2.t  and  gene1.run3.t , and a desired burnin of 1000 trees per tree file, we do this:  mbsum -n  1000  -o gene1.in gene1.run1.t gene1.run2.t gene1.run3.t  This  mbsum  command will need to be executed for each gene. Then we can continue to the next section to run bucky.  Alternatively, we can use the julia script  mbsum-t-files.jl , and give it as argument the directory that has the output tree files from MrBayes, to run mbsum for  all  the genes.  mbsum  is fast, so there is no attempt to parallelize the various mbsum commands.  julia mbsum-t-files.jl mbfolder  Warning:  a burnin of 2500 generations is hard coded in this script. This can easily be changed: edit this short script near the top of the file, to change the value of  burnin .", 
            "title": "To run mbsum on the output of MrBayes for each gene"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#to-run-bucky-on-all-4-taxon-sets-we-already-have-the-mbsum-output", 
            "text": "", 
            "title": "To run bucky on all 4-taxon sets: we already have the mbsum output"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#no-scheduler-pipeline_1", 
            "text": "If we already ran  mbsum  on the output from MrBayes, for each individual gene, we can simply create a tarball containing all the mbsum output files. So if we had mbsum output in files named  gene1.in ,  gene2.in , ... ,  gene100.in , we would want to run something similar to the following command to create the tarball:  tar czf my-genes-mbsum.tar.gz gene*.in  We can now use this tarball along with the  -s  option in  bucky.pl  like this:  bucky.pl my-genes-mbsum.tar.gz -s -o mygenes-bucky  Again, if we get an error like  bucky.pl: Command not found , we could run instead  perl bucky.pl my-genes-mbsum.tar.gz -s -o mygenes-bucky  The output, with the table of concordance factors for all sets of 4 taxa, will be in a file named  my-genes.CFs.csv  inside directory  mygenes-bucky . That's the file containing the quartet concordance factors to give to SNaQ as input.", 
            "title": "no-scheduler pipeline"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#slurm-pipeline_1", 
            "text": "We want to run  bucky  on every 4-taxon set. SLURM will parallelize these jobs with the submit script  bucky-slurm-submit.sh , which calls the perl script  bucky-slurm.pl .  The perl script  bucky-slurm.pl  runs  bucky  on a single 4-taxon set. It takes the following arguments, which must be modified in the submit script  bucky-slurm-submit.sh :   name of the folder containing the  mbsum  output files (one per locus) from previous step. This folder is named  mbsum  in the submit script: adapt if needed.  output name:  -o  or  --out-dir  name of the directory to store output files in. This option is not used in the default submit script  bucky arguments:  -a  or  --alpha  for the prior alpha value, and  -n  or  --ngen  number of generations. These options are not used either, in the script: the defaults are used then (\u03b1=1, 1 million generations)  integer for the given quartet, via option  -q . The quartet ID is specified by SLURM with its own array ID:  $SLURM_ARRAY_TASK_ID .   In the submit script that gives instructions to the job scheduler:   adapt the name of the  $SLURM_ARRAY_TASK_ID  variable, which captures the task number in the array of tasks, to your scheduler syntax  change  --array  to the correct number of 4-taxon sets. For example, if there are 15 taxa in the dataset, there are  1365  4-taxon sets. To get this number, if you are unsure, use  choose(15,4)  in R or  binomial(15,4)  in Julia, but replace 15 by your actual number of individuals.  change  --mail-user  to the user's email (if this is an option for your job scheduler)  replace the  /workspace/software/bin  in  PATH=\"/workspace/software/bin:$PATH\"  by the path where the  bucky  executable is located. Also, replace  /workspace/claudia/software/TICR/scripts/  by the full path where the  bucky-slurm.pl  script is located.   In slurm, we would submit the BUCKy array job with:  sbatch bucky-slurm-submit.sh  At the end, the array job will produce   a  .concordance  file for every 4-taxon set  a  .cf  file with the parsed output for that same 4-taxon set, in the format needed for the final CF table.   The  .cf  files can be concatenated to produce the file containing the quartet concordance factors across all 4-taxon sets, to give to SNaQ as input:  cat *.cf   CFtable.csv  Alternatively, if the list of  .cf  files is not easily captured by  *.cf  (because the list is too long for a shell command), the following julia script can do the concatenation. Just copy-paste the commands below within a Julia session, started from the directory that contains the  .cf  files:  files   =   String []   # empty vector of strings: will contain the .cf file names later  for   f   in   filter ( x   -   endswith ( x ,   .cf ),   readdir ()) \n     push! ( files , f )  end  println ( found  $ ( length ( files ))  cf files )   # to check how many .cf output files were found  open ( CFtable.csv , w )   do   f_out \n   for   file   in   files \n     @show   file   # to see the .cf file name: comment this out if that s too much screen output \n     open ( file )   do   f_in \n         line   =   readstring ( f_in ) \n         write ( f_out ,   string ( line , \\n )) \n     end   # closes  file  safely \n   end  end   # closes  CFtable.csv  safely   When this is done, we will have a file  CFtable.csv  containing the quartet concordance factors, to give to SNaQ as input :smiley:", 
            "title": "slurm pipeline"
        }, 
        {
            "location": "/man/snaq_plot/", 
            "text": "Getting a Network\n\n\n\n\nNetwork Estimation\n\n\nSNaQ implements the statistical inference method in \nSol\ns-Lemus and An\n 2016\n. The procedure involves a numerical optimization of branch lengths and inheritance probabilities and a heuristic search in the space of phylogenetic networks.\n\n\nAfter \nInput for SNaQ\n, we can estimate the network using the input data \nraxmlCF\n and starting from tree (or network) \nastraltree\n. We first impose the constraint of at most 0 hybrid node, that is, we ask for a tree.\n\n\nnet0\n \n=\n \nsnaq!\n(\nastraltree\n,\nraxmlCF\n,\n \nhmax\n=\n0\n,\n \nfilename\n=\nnet0\n,\n \nseed\n=\n1234\n)\n\n\n\n\n\n\nPart of the screen output shows this:\n\n\nMaxNet is (C,D,((B,A):1.395762055180493,(O,E):0.48453400554506426):10.0);\nwith -loglik 53.53150526187732\n\n\n\n\n\nThis parenthetical (extended Newick) description is not very human-friendly, so we plot the tree (more about plotting networks below: \nNetwork Visualization\n ).\n\n\nusing\n \nPhyloPlots\n\n\nplot\n(\nnet0\n,\n \n:\nR\n);\n\n\n\n\n\n\n\n\nWe can use this tree as a starting point to search for the best network allowing for at most \nhmax=1\n hybrid node (which is the default).\n\n\nnet1\n \n=\n \nsnaq!\n(\nnet0\n,\n \nraxmlCF\n,\n \nhmax\n=\n1\n,\n \nfilename\n=\nnet1\n,\n \nseed\n=\n2345\n)\n\n\n\n\n\n\npart of screen output:\n\n\nbest\n \nnetwork\n \nand\n \nnetworks\n \nwith\n \ndifferent\n \nhybrid\n/\ngene\n \nflow\n \ndirections\n \nprinted\n \nto\n \n.\nnetworks\n \nfile\n\n\nMaxNet\n \nis\n \n(\nC\n,\nD\n,((\nO\n,(\nE\n,\n#\nH7\n:\n::\n0\n.\n19558838614943078\n)\n:\n0\n.\n31352437658618976\n)\n:\n0\n.\n6640664399202987\n,(\nB\n,(\nA\n)\n#\nH7\n:\n::\n0\n.\n8044116138505693\n)\n:\n10\n.\n0\n)\n:\n10\n.\n0\n);\n\n\nwith\n \n-loglik\n \n28\n.\n31506721890958\n\n\n\n\n\n\nWe can visualize the estimated network and its inheritance values \u03b3, which measure the proportion of genes inherited via each parent at a reticulation event (e.g. proportion of genes inherited via gene flow).\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n);\n\n\n\n\n\n\n\n\nThis network has A as a hybrid, 80.4% sister to B, and 19.6% sister to E (which is otherwise sister to O). C \n D are sister to each other. We can also check the output files created by \nsnaq!\n:\n\n\nless\n(\nnet1.err\n)\n \n# would provide info about errors, if any\n\n\nless\n(\nnet1.out\n)\n \n# main output file with the estimated network from each run\n\n\nless\n(\nnet1.networks\n)\n \n# extra info\n\n\n\n\n\n\nwhen viewing these result files with \nless\n within Julia, use arrows to scroll down and type \nq\n to quit viewing the files. The file \nnet1.networks\n contains a list of networks that are slight modifications of the best (estimated) network \nnet1\n. The modifications changed the direction of one reticulation at a time, by moving the placement of one hybrid node to another node inside the same cycle. For each modified network, the pseudolikelihood score was calculated.\n\n\nThe function name \nsnaq!\n ends with ! because it modifies the argument \nraxmlCF\n by including the expected CF. Type \n?\n then \nsnaq!\n to get help on that function.\n\n\nThe main output file, here \nnet1.out\n (or \nsnaq.out\n by default) has the estimated network in parenthetical format, but we can also print it directly to the screen:\n\n\njulia\n \nnet1\n\n\nPhyloNetworks\n.\nHybridNetwork\n,\n \nRooted\n \nNetwork\n\n\n12\n \nedges\n\n\n12\n \nnodes\n:\n \n6\n \ntips\n,\n \n1\n \nhybrid\n \nnodes\n,\n \n5\n \ninternal\n \ntree\n \nnodes\n.\n\n\ntip\n \nlabels\n:\n \nC\n,\n \nD\n,\n \nO\n,\n \nE\n,\n \n...\n\n\n(\nC\n,\nD\n,((\nO\n,(\nE\n,\n#\nH7\n:\n::\n0\n.\n196\n)\n:\n0\n.\n314\n)\n:\n0\n.\n664\n,(\nB\n,(\nA\n)\n#\nH7\n:\n::\n0\n.\n804\n)\n:\n10\n.\n0\n)\n:\n10\n.\n0\n);\n\n\n\njulia\n \nwriteTopology\n(\nnet1\n)\n  \n#\n \nwrites\n \nto\n \nscreen\n,\n \nfull\n \nprecision\n \nfor\n \nbranch\n \nlengths\n \nand\n \n\u03b3\n\n\n(C,D,((O,(E,#H7:::0.19558838614943078):0.31352437658618976):0.6640664399202987,(B,(A)#H7:::0.8044116138505693):10.0):10.0);\n\n\n\njulia\n \nwriteTopology\n(\nnet1\n,\n \nround\n=\ntrue\n,\n \ndigits\n=\n2\n)\n\n\n(C,D,((O,(E,#H7:::0.2):0.31):0.66,(B,(A)#H7:::0.8):10.0):10.0);\n\n\n\njulia\n \nwriteTopology\n(\nnet1\n,\ndi\n=\ntrue\n)\n \n#\n \n\u03b3\n \nomitted\n:\n \nfor\n \ndendroscope\n\n\n(C,D,((O,(E,#H7):0.31352437658618976):0.6640664399202987,(B,(A)#H7):10.0):10.0);\n\n\n\njulia\n \nwriteTopology\n(\nnet1\n,\n \nbestnet_h1.tre\n)\n \n#\n \nwrites\n \nto\n \nfile\n:\n \ncreates\n \nor\n \noverwrites\n \nfile\n\n\n\n\n\n\nThe option \ndi=true\n is for the parenthetical format used by \nDendroscope\n (without reticulation heritabilities). Copy this parenthetical description and paste it into Dendroscope, or use the plotting function described below.\n\n\nWe can go on and let the network have up to 2 or 3 hybrid nodes:\n\n\nnet2\n \n=\n \nsnaq!\n(\nnet1\n,\nraxmlCF\n,\n \nhmax\n=\n2\n,\n \nfilename\n=\nnet2\n,\n \nseed\n=\n3456\n)\n\n\nnet3\n \n=\n \nsnaq!\n(\nnet0\n,\nraxmlCF\n,\n \nhmax\n=\n3\n,\n \nfilename\n=\nnet3\n,\n \nseed\n=\n4567\n)\n\n\n\n\n\n\nand plot them (they are identical and they both have a single reticulation):\n\n\nusing\n \nRCall\n                  \n# to be able to tweak our plot within R\n\n\nR\nlayout(matrix(1:2, 1, 2))\n \n# to get 2 plots into a single figure: 1 row, 2 columns\n\n\nR\npar(mar = c(0,0,1,0))\n     \n# for smaller margins\n\n\nplot\n(\nnet2\n,\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n);\n\n\nR\nmtext(\nhmax=2\n)\n           \n# add text annotation: title here\n\n\nplot\n(\nnet3\n,\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n);\n\n\nR\nmtext(\nhmax=3\n)\n\n\n\n\n\n\n\n\nwith this screen output for net2 (only 1 hybrid node found):\n\n\nMaxNet\n \nis\n \n(\nC\n,\nD\n,((\nB\n,(\nA\n)\n#\nH7\n:\n::\n0\n.\n804411606649347\n)\n:\n10\n.\n0\n,(\nO\n,(\n#\nH7\n:\n::\n0\n.\n19558839335065303\n,\nE\n)\n:\n0\n.\n3135243143217013\n)\n:\n0\n.\n664066456871298\n)\n:\n10\n.\n0\n);\n\n\nwith\n \n-loglik\n \n28\n.\n31506721890957\n\n\n\n\n\n\nand this output for net3 (again, only 1 hybrid found):\n\n\nMaxNet\n \nis\n \n(\nD\n,\nC\n,((\nO\n,(\nE\n,\n#\nH7\n:\n::\n0\n.\n19558839257941849\n)\n:\n0\n.\n3135243301652981\n)\n:\n0\n.\n6640664138384673\n,(\nB\n,(\nA\n)\n#\nH7\n:\n::\n0\n.\n8044116074205815\n)\n:\n10\n.\n0\n)\n:\n10\n.\n0\n);\n\n\nwith\n \n-loglik\n \n28\n.\n315067218909626\n\n\n\n\n\n\n\n\nparallel computations\n\n\nFor network estimation, multiple runs can done in parallel. For example, if your machine has 4 or more processors (or cores), you can tell julia to use 4 processors by starting julia with \njulia -p 4\n, or by starting julia the usual way (\njulia\n) and then adding processors with:\n\n\naddprocs\n(\n4\n)\n\n\n\n\n\n\nIf we load a package (\nusing PhyloNetworks\n) before adding processors, then we need to re-load it again so that all processors have access to it:\n\n\n@everywhere\n \nusing\n \nPhyloNetworks\n\n\n\n\n\n\nAfter that, running any of the \nsnaq!(...)\n command will use different cores for different runs, as processors become available. Fewer details are printed to the log file when multiple cores are used in parallel.\n\n\nWhen running \nbootsnaq\n, the analysis of each bootstrap replicate will use multiple cores to parallelize separate runs of that particular bootstrap replicate. You may parallelize things further by running \nbootsnaq\n multiple times (on separate machines for instance), each time for a small subset of bootstrap replicates, and with a different seed each time.\n\n\nWe may tell julia to add more processors than our machine has, but we will not receive any performance benefits. At any time during the julia session, \nnworkers()\n tells us how many worker processors julia has access to.\n\n\nBelow is an example of how to use a cluster, to run many independent \nsnaq!\n searches in parallel on a cluster running the \nslurm\n job manager (other managers would require a different, but similar submit file). This example uses 2 files:\n\n\n\n\na julia script file, to do many runs of \nsnaq!\n in parallel, asking for many cores (default: 10 runs, asking for 10 cores). This julia script can take arguments: the maximum allowed number of hybridizations \nhmax\n, and the number of runs (to run 50 runs instead of 10, say).\n\n\na submit file, to launch the julia script.\n\n\n\n\nFirst\n: the example julia script, below, is assumed (by the submit file) to be called \nrunSNaQ.jl\n. It uses a starting tree that is assumed to be available in a file named \nastraltree.tre\n, but that could be modified (to use a network with h=1 to start the search with hmax=2 for instance). It also assumes that the quartet concordance factor data are in file \ntableCF_speciesNames.csv\n. Again, this file name should be adjusted. To run this julia script for 50 runs and hmax=3, do \njulia runSNaQ.jl 3 50\n.\n\n\n#!/usr/bin/env julia\n\n\n\n# file \nrunSNaQ.jl\n. run in the shell like this in general:\n\n\n# julia runSNaQ.jl hvalue nruns\n\n\n# example for h=2 and default 10 runs:\n\n\n# julia runSNaQ.jl 2\n\n\n# or example for h=3 and 50 runs:\n\n\n# julia runSNaQ.jl 3 50\n\n\n\nlength\n(\nARGS\n)\n \n \n0\n \n||\n\n    \nerror\n(\nneed 1 or 2 arguments: # reticulations (h) and # runs (optional, 10 by default)\n)\n\n\nh\n \n=\n \nparse\n(\nInt\n,\n \nARGS\n[\n1\n])\n\n\nnruns\n \n=\n \n10\n\n\nif\n \nlength\n(\nARGS\n)\n \n \n1\n\n    \nnruns\n \n=\n \nparse\n(\nInt\n,\n \nARGS\n[\n2\n])\n\n\nend\n\n\noutputfile\n \n=\n \nstring\n(\nnet\n,\n \nh\n,\n \n_\n,\n \nnruns\n,\n \nruns\n)\n \n# example: \nnet2_10runs\n\n\nseed\n \n=\n \n1234\n \n+\n \nh\n \n# change as desired! Best to have it different for different h\n\n\ninfo\n(\nwill run SNaQ with h=\n,\nh\n,\n\n    \n, # of runs=\n,\nnruns\n,\n\n    \n, seed=\n,\nseed\n,\n\n    \n, output will go to: \n,\n \noutputfile\n)\n\n\n\naddprocs\n(\nnruns\n)\n\n\n@everywhere\n \nusing\n \nPhyloNetworks\n\n\nnet0\n \n=\n \nreadTopology\n(\nastraltree.tre\n);\n\n\nusing\n \nCSV\n\n\ndf_sp\n \n=\n \nCSV\n.\nread\n(\ntableCF_speciesNames.csv\n,\n \ncategorical\n=\nfalse\n);\n\n\nd_sp\n \n=\n \nreadTableCF!\n(\ndf_sp\n);\n\n\nnet\n \n=\n \nsnaq!\n(\nnet0\n,\n \nd_sp\n,\n \nhmax\n=\nh\n,\n \nfilename\n=\noutputfile\n,\n \nseed\n=\nseed\n,\n \nruns\n=\nnruns\n)\n\n\n\n\n\n\nWhen julia is called on a script, whatever comes after \"julia scriptname\" is given to julia in an array of values. This array is called \nARGS\n. So if we call a script like this: \njulia runSNaQ.jl 2\n then the script will know the arguments through \nARGS\n, which would contain a single element, \n\"2\"\n. This first element is just a string, at this stage. We want to use it as a number, so we ask julia to parse the string into an integer.\n\n\nSecond\n: we need a \"submit\" file to ask a job scheduler like \nslurm\n to submit our julia script to a cluster. In the submit file below, the first 5 lines set things up for slurm. They are most likely to be specific to your cluster. The main idea here is to use a slurm \"array\" from 0 to 3, to run our julia script multiple times, 4 times actually: from hmax=0 to hmax=3. Each would do 30 runs. Then log out of the cluster and go for coffee.\n\n\n#!/bin/bash\n\n\n#SBATCH -o path/to/slurm/log/file/runsnaq_slurm%a.log\n\n\n#SBATCH -J runsnaq\n\n\n#SBATCH --array=0-3\n\n\n#SBATCH -n 120\n\n\n## --array: to run multiple instances of this script,\n\n\n##          one for each value in the array\n\n\n## -J job name\n\n\n## -n number of cores\n\n\n\necho\n \nslurm task ID = \n$SLURM_ARRAY_TASK_ID\n used as hmax\n\n\necho\n \nstart of SNaQ parallel runs on \n$(\nhostname\n)\n\n\n# finally: launch the julia script, using Julia executable appropriate for slurm, with full paths:\n\n/workspace/software/bin/julia --history-file\n=\nno -- runSNaQ.jl \n$SLURM_ARRAY_TASK_ID\n \n30\n \n net\n$SLURM_ARRAY_TASK_ID_30runs\n.screenlog \n2\n1\n\n\necho\n \nend of SNaQ run ...\n\n\n\n\n\n\n\n\nchoosing the number of hybridizations\n\n\nEach network has a \nloglik\n attribute, which is its pseudo deviance: twice the negative log-likelihood up to a constant (the constant is such that the score is 0 if the network fits the data perfectly). The lower the better. We can plot these scores across hybrid values:\n\n\nscores\n \n=\n \n[\nnet0\n.\nloglik\n,\n \nnet1\n.\nloglik\n,\n \nnet2\n.\nloglik\n,\n \nnet3\n.\nloglik\n]\n\n\nR\nplot(\n$scores\n, type=\nb\n, ylab=\nnetwork score\n, xlab=\nhmax\n, col=\nblue\n)\n\n\n\n\n\n\n\n\nHere the slope heuristic suggests a single hybrid node: the score does not get much better beyond h=1.\n\n\nWe made the plot via R above. A more Julian way would use a Julia plotting package such as \nGadfly\n or \nPlots\n, like this for instance:\n\n\nusing\n \nGadfly\n\n\nplot\n(\nx\n=\ncollect\n(\n0\n:\n3\n),\n \ny\n=\nscores\n,\n \nGeom\n.\npoint\n,\n \nGeom\n.\nline\n)\n\n\n\n\n\n\n\n\n\n\n\nNetwork Visualization\n\n\nTo visualize the estimated network, we can use the companion package \nPhyloPlots\n. In the example below, julia creates and sends the plot to R via \nRCall\n, so we can tweak the plot in various ways via commands sent to R. To save the plot in a file: we first tell R to create an image file, then we send the plot of the network, then we tell R to wrap up and save its image file.\n\n\nusing\n \nPhyloPlots\n \n# to visualize networks\n\n\nusing\n \nRCall\n      \n# to send additional commands to R like this: R\n...\n\n\nR\nname = function(x) file.path(\n..\n, \nassets\n, \nfigures\n, x)\n \n# function to create file name in appropriate folder\n\n\nR\nsvg(name(\nsnaqplot_net1_2.svg\n), width=4, height=3)\n \n# starts image file\n\n\nR\npar(mar = c(0,0,0,0))\n \n# to reduce margins (no margins at all here)\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n,\n \nshowEdgeNumber\n=\ntrue\n);\n \n# network is plotted \n sent to file\n\n\nR\ndev.off()\n;\n \n# wrap up and save image file\n\n\n\n\n\n\n\n\n\n\n\nThe plot function has many options, to annotate nodes and edges. In the example above, hybrid edges were annotated with their \u03b3 inheritance values (in blue: light blue for the minor edge with \u03b3\n0.5, and dark blue for the major edge with \u03b3\n0.5), and edges were annotated with their internal numbers.\n\n\nType \n?\n to switch to the help mode of Julia, then type the name of the function, here \nplot\n. Edge colors can be modified, for instance.\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nshowEdgeLength\n=\ntrue\n,\n \nminorHybridEdgeColor\n=\ntan\n)\n\n\n\n\n\n\n\n\n\n\n\nEdge lengths are shown, too. They were estimated in coalescent units: number of generations / effective population size. Some edge lengths are not identifiable, hence not shown.\n\n\nBelow is another example, where space was added between the network and the taxon names via the \ntipOffset\n option. Also, edge colors were changed, and the nodes numbers are shown (used internally)\n\n\nplot\n(\nnet1\n,\n:\nR\n,\n \ntipOffset\n=\n0.5\n,\n \nshowNodeNumber\n=\ntrue\n,\n \nedgeColor\n=\ntomato4\n,\n\n     \nminorHybridEdgeColor\n=\nskyblue\n,\n \nmajorHybridEdgeColor\n=\ntan\n);\n\n\n\n\n\n\n\n\n\n\nRe-rooting networks\n\n\nSNaQ infers an unrooted semi-directed network. The direction of hybrid edges can be inferred, but the direction of tree edges cannot be inferred. To obtain a representative visualization, it is best to root the network first, using one or more outgroup. Go to \nRe-rooting trees and networks\n for this. If your outgroup conflicts with the direction of reticulations in the estimated network, see section \nCandidate networks compatible with a known outgroup\n.\n\n\n\n\nCandidate Network Evaluation\n\n\nFrom a set of candidate networks, one might simply need to score of each network to pick the best. Here, the score is the negative log pseudo-likelihood, and the lower the better. See the section to get the score of \nCandidate Networks\n.\n\n\n\n\nSNaQ error reporting\n\n\nPlease report any bugs and errors by opening an \nissue\n. The easiest way to provide information on the error is by checking the \n.err\n file, which will show the number of runs that failed and the corresponding seed to replicate the run. In case of an error, the \n.err\n file might look like: \nTotal errors: 1 in seeds [4545]\n. To replicate the bug (necessary to fix it!), you can run the following function with the same settings that caused the error:\n\n\nsnaqDebug\n(\nstartnetwork\n,\n \nraxmlCF\n,\n \nhmax\n=\n2\n,\n \nseed\n=\n4545\n)\n\n\n\n\n\n\nThis will create two files: \nsnaqDebug.log\n and \ndebug.log\n, with information on steps to retrace the bug. You can attach them to your issue (or send them offline), to help us fix the bug.", 
            "title": "Network estimation and display"
        }, 
        {
            "location": "/man/snaq_plot/#getting-a-network", 
            "text": "", 
            "title": "Getting a Network"
        }, 
        {
            "location": "/man/snaq_plot/#network-estimation", 
            "text": "SNaQ implements the statistical inference method in  Sol s-Lemus and An  2016 . The procedure involves a numerical optimization of branch lengths and inheritance probabilities and a heuristic search in the space of phylogenetic networks.  After  Input for SNaQ , we can estimate the network using the input data  raxmlCF  and starting from tree (or network)  astraltree . We first impose the constraint of at most 0 hybrid node, that is, we ask for a tree.  net0   =   snaq! ( astraltree , raxmlCF ,   hmax = 0 ,   filename = net0 ,   seed = 1234 )   Part of the screen output shows this:  MaxNet is (C,D,((B,A):1.395762055180493,(O,E):0.48453400554506426):10.0);\nwith -loglik 53.53150526187732  This parenthetical (extended Newick) description is not very human-friendly, so we plot the tree (more about plotting networks below:  Network Visualization  ).  using   PhyloPlots  plot ( net0 ,   : R );    We can use this tree as a starting point to search for the best network allowing for at most  hmax=1  hybrid node (which is the default).  net1   =   snaq! ( net0 ,   raxmlCF ,   hmax = 1 ,   filename = net1 ,   seed = 2345 )   part of screen output:  best   network   and   networks   with   different   hybrid / gene   flow   directions   printed   to   . networks   file  MaxNet   is   ( C , D ,(( O ,( E , # H7 : :: 0 . 19558838614943078 ) : 0 . 31352437658618976 ) : 0 . 6640664399202987 ,( B ,( A ) # H7 : :: 0 . 8044116138505693 ) : 10 . 0 ) : 10 . 0 );  with   -loglik   28 . 31506721890958   We can visualize the estimated network and its inheritance values \u03b3, which measure the proportion of genes inherited via each parent at a reticulation event (e.g. proportion of genes inherited via gene flow).  plot ( net1 ,   : R ,   showGamma = true );    This network has A as a hybrid, 80.4% sister to B, and 19.6% sister to E (which is otherwise sister to O). C   D are sister to each other. We can also check the output files created by  snaq! :  less ( net1.err )   # would provide info about errors, if any  less ( net1.out )   # main output file with the estimated network from each run  less ( net1.networks )   # extra info   when viewing these result files with  less  within Julia, use arrows to scroll down and type  q  to quit viewing the files. The file  net1.networks  contains a list of networks that are slight modifications of the best (estimated) network  net1 . The modifications changed the direction of one reticulation at a time, by moving the placement of one hybrid node to another node inside the same cycle. For each modified network, the pseudolikelihood score was calculated.  The function name  snaq!  ends with ! because it modifies the argument  raxmlCF  by including the expected CF. Type  ?  then  snaq!  to get help on that function.  The main output file, here  net1.out  (or  snaq.out  by default) has the estimated network in parenthetical format, but we can also print it directly to the screen:  julia   net1  PhyloNetworks . HybridNetwork ,   Rooted   Network  12   edges  12   nodes :   6   tips ,   1   hybrid   nodes ,   5   internal   tree   nodes .  tip   labels :   C ,   D ,   O ,   E ,   ...  ( C , D ,(( O ,( E , # H7 : :: 0 . 196 ) : 0 . 314 ) : 0 . 664 ,( B ,( A ) # H7 : :: 0 . 804 ) : 10 . 0 ) : 10 . 0 );  julia   writeTopology ( net1 )    #   writes   to   screen ,   full   precision   for   branch   lengths   and   \u03b3  (C,D,((O,(E,#H7:::0.19558838614943078):0.31352437658618976):0.6640664399202987,(B,(A)#H7:::0.8044116138505693):10.0):10.0);  julia   writeTopology ( net1 ,   round = true ,   digits = 2 )  (C,D,((O,(E,#H7:::0.2):0.31):0.66,(B,(A)#H7:::0.8):10.0):10.0);  julia   writeTopology ( net1 , di = true )   #   \u03b3   omitted :   for   dendroscope  (C,D,((O,(E,#H7):0.31352437658618976):0.6640664399202987,(B,(A)#H7):10.0):10.0);  julia   writeTopology ( net1 ,   bestnet_h1.tre )   #   writes   to   file :   creates   or   overwrites   file   The option  di=true  is for the parenthetical format used by  Dendroscope  (without reticulation heritabilities). Copy this parenthetical description and paste it into Dendroscope, or use the plotting function described below.  We can go on and let the network have up to 2 or 3 hybrid nodes:  net2   =   snaq! ( net1 , raxmlCF ,   hmax = 2 ,   filename = net2 ,   seed = 3456 )  net3   =   snaq! ( net0 , raxmlCF ,   hmax = 3 ,   filename = net3 ,   seed = 4567 )   and plot them (they are identical and they both have a single reticulation):  using   RCall                    # to be able to tweak our plot within R  R layout(matrix(1:2, 1, 2))   # to get 2 plots into a single figure: 1 row, 2 columns  R par(mar = c(0,0,1,0))       # for smaller margins  plot ( net2 ,   : R ,   showGamma = true );  R mtext( hmax=2 )             # add text annotation: title here  plot ( net3 ,   : R ,   showGamma = true );  R mtext( hmax=3 )    with this screen output for net2 (only 1 hybrid node found):  MaxNet   is   ( C , D ,(( B ,( A ) # H7 : :: 0 . 804411606649347 ) : 10 . 0 ,( O ,( # H7 : :: 0 . 19558839335065303 , E ) : 0 . 3135243143217013 ) : 0 . 664066456871298 ) : 10 . 0 );  with   -loglik   28 . 31506721890957   and this output for net3 (again, only 1 hybrid found):  MaxNet   is   ( D , C ,(( O ,( E , # H7 : :: 0 . 19558839257941849 ) : 0 . 3135243301652981 ) : 0 . 6640664138384673 ,( B ,( A ) # H7 : :: 0 . 8044116074205815 ) : 10 . 0 ) : 10 . 0 );  with   -loglik   28 . 315067218909626", 
            "title": "Network Estimation"
        }, 
        {
            "location": "/man/snaq_plot/#parallel-computations", 
            "text": "For network estimation, multiple runs can done in parallel. For example, if your machine has 4 or more processors (or cores), you can tell julia to use 4 processors by starting julia with  julia -p 4 , or by starting julia the usual way ( julia ) and then adding processors with:  addprocs ( 4 )   If we load a package ( using PhyloNetworks ) before adding processors, then we need to re-load it again so that all processors have access to it:  @everywhere   using   PhyloNetworks   After that, running any of the  snaq!(...)  command will use different cores for different runs, as processors become available. Fewer details are printed to the log file when multiple cores are used in parallel.  When running  bootsnaq , the analysis of each bootstrap replicate will use multiple cores to parallelize separate runs of that particular bootstrap replicate. You may parallelize things further by running  bootsnaq  multiple times (on separate machines for instance), each time for a small subset of bootstrap replicates, and with a different seed each time.  We may tell julia to add more processors than our machine has, but we will not receive any performance benefits. At any time during the julia session,  nworkers()  tells us how many worker processors julia has access to.  Below is an example of how to use a cluster, to run many independent  snaq!  searches in parallel on a cluster running the  slurm  job manager (other managers would require a different, but similar submit file). This example uses 2 files:   a julia script file, to do many runs of  snaq!  in parallel, asking for many cores (default: 10 runs, asking for 10 cores). This julia script can take arguments: the maximum allowed number of hybridizations  hmax , and the number of runs (to run 50 runs instead of 10, say).  a submit file, to launch the julia script.   First : the example julia script, below, is assumed (by the submit file) to be called  runSNaQ.jl . It uses a starting tree that is assumed to be available in a file named  astraltree.tre , but that could be modified (to use a network with h=1 to start the search with hmax=2 for instance). It also assumes that the quartet concordance factor data are in file  tableCF_speciesNames.csv . Again, this file name should be adjusted. To run this julia script for 50 runs and hmax=3, do  julia runSNaQ.jl 3 50 .  #!/usr/bin/env julia  # file  runSNaQ.jl . run in the shell like this in general:  # julia runSNaQ.jl hvalue nruns  # example for h=2 and default 10 runs:  # julia runSNaQ.jl 2  # or example for h=3 and 50 runs:  # julia runSNaQ.jl 3 50  length ( ARGS )     0   || \n     error ( need 1 or 2 arguments: # reticulations (h) and # runs (optional, 10 by default) )  h   =   parse ( Int ,   ARGS [ 1 ])  nruns   =   10  if   length ( ARGS )     1 \n     nruns   =   parse ( Int ,   ARGS [ 2 ])  end  outputfile   =   string ( net ,   h ,   _ ,   nruns ,   runs )   # example:  net2_10runs  seed   =   1234   +   h   # change as desired! Best to have it different for different h  info ( will run SNaQ with h= , h , \n     , # of runs= , nruns , \n     , seed= , seed , \n     , output will go to:  ,   outputfile )  addprocs ( nruns )  @everywhere   using   PhyloNetworks  net0   =   readTopology ( astraltree.tre );  using   CSV  df_sp   =   CSV . read ( tableCF_speciesNames.csv ,   categorical = false );  d_sp   =   readTableCF! ( df_sp );  net   =   snaq! ( net0 ,   d_sp ,   hmax = h ,   filename = outputfile ,   seed = seed ,   runs = nruns )   When julia is called on a script, whatever comes after \"julia scriptname\" is given to julia in an array of values. This array is called  ARGS . So if we call a script like this:  julia runSNaQ.jl 2  then the script will know the arguments through  ARGS , which would contain a single element,  \"2\" . This first element is just a string, at this stage. We want to use it as a number, so we ask julia to parse the string into an integer.  Second : we need a \"submit\" file to ask a job scheduler like  slurm  to submit our julia script to a cluster. In the submit file below, the first 5 lines set things up for slurm. They are most likely to be specific to your cluster. The main idea here is to use a slurm \"array\" from 0 to 3, to run our julia script multiple times, 4 times actually: from hmax=0 to hmax=3. Each would do 30 runs. Then log out of the cluster and go for coffee.  #!/bin/bash  #SBATCH -o path/to/slurm/log/file/runsnaq_slurm%a.log  #SBATCH -J runsnaq  #SBATCH --array=0-3  #SBATCH -n 120  ## --array: to run multiple instances of this script,  ##          one for each value in the array  ## -J job name  ## -n number of cores  echo   slurm task ID =  $SLURM_ARRAY_TASK_ID  used as hmax  echo   start of SNaQ parallel runs on  $( hostname )  # finally: launch the julia script, using Julia executable appropriate for slurm, with full paths: \n/workspace/software/bin/julia --history-file = no -- runSNaQ.jl  $SLURM_ARRAY_TASK_ID   30    net $SLURM_ARRAY_TASK_ID_30runs .screenlog  2 1  echo   end of SNaQ run ...", 
            "title": "parallel computations"
        }, 
        {
            "location": "/man/snaq_plot/#choosing-the-number-of-hybridizations", 
            "text": "Each network has a  loglik  attribute, which is its pseudo deviance: twice the negative log-likelihood up to a constant (the constant is such that the score is 0 if the network fits the data perfectly). The lower the better. We can plot these scores across hybrid values:  scores   =   [ net0 . loglik ,   net1 . loglik ,   net2 . loglik ,   net3 . loglik ]  R plot( $scores , type= b , ylab= network score , xlab= hmax , col= blue )    Here the slope heuristic suggests a single hybrid node: the score does not get much better beyond h=1.  We made the plot via R above. A more Julian way would use a Julia plotting package such as  Gadfly  or  Plots , like this for instance:  using   Gadfly  plot ( x = collect ( 0 : 3 ),   y = scores ,   Geom . point ,   Geom . line )", 
            "title": "choosing the number of hybridizations"
        }, 
        {
            "location": "/man/snaq_plot/#network-visualization", 
            "text": "To visualize the estimated network, we can use the companion package  PhyloPlots . In the example below, julia creates and sends the plot to R via  RCall , so we can tweak the plot in various ways via commands sent to R. To save the plot in a file: we first tell R to create an image file, then we send the plot of the network, then we tell R to wrap up and save its image file.  using   PhyloPlots   # to visualize networks  using   RCall        # to send additional commands to R like this: R ...  R name = function(x) file.path( .. ,  assets ,  figures , x)   # function to create file name in appropriate folder  R svg(name( snaqplot_net1_2.svg ), width=4, height=3)   # starts image file  R par(mar = c(0,0,0,0))   # to reduce margins (no margins at all here)  plot ( net1 ,   : R ,   showGamma = true ,   showEdgeNumber = true );   # network is plotted   sent to file  R dev.off() ;   # wrap up and save image file     The plot function has many options, to annotate nodes and edges. In the example above, hybrid edges were annotated with their \u03b3 inheritance values (in blue: light blue for the minor edge with \u03b3 0.5, and dark blue for the major edge with \u03b3 0.5), and edges were annotated with their internal numbers.  Type  ?  to switch to the help mode of Julia, then type the name of the function, here  plot . Edge colors can be modified, for instance.  plot ( net1 ,   : R ,   showEdgeLength = true ,   minorHybridEdgeColor = tan )     Edge lengths are shown, too. They were estimated in coalescent units: number of generations / effective population size. Some edge lengths are not identifiable, hence not shown.  Below is another example, where space was added between the network and the taxon names via the  tipOffset  option. Also, edge colors were changed, and the nodes numbers are shown (used internally)  plot ( net1 , : R ,   tipOffset = 0.5 ,   showNodeNumber = true ,   edgeColor = tomato4 , \n      minorHybridEdgeColor = skyblue ,   majorHybridEdgeColor = tan );", 
            "title": "Network Visualization"
        }, 
        {
            "location": "/man/snaq_plot/#re-rooting-networks", 
            "text": "SNaQ infers an unrooted semi-directed network. The direction of hybrid edges can be inferred, but the direction of tree edges cannot be inferred. To obtain a representative visualization, it is best to root the network first, using one or more outgroup. Go to  Re-rooting trees and networks  for this. If your outgroup conflicts with the direction of reticulations in the estimated network, see section  Candidate networks compatible with a known outgroup .", 
            "title": "Re-rooting networks"
        }, 
        {
            "location": "/man/snaq_plot/#candidate-network-evaluation", 
            "text": "From a set of candidate networks, one might simply need to score of each network to pick the best. Here, the score is the negative log pseudo-likelihood, and the lower the better. See the section to get the score of  Candidate Networks .", 
            "title": "Candidate Network Evaluation"
        }, 
        {
            "location": "/man/snaq_plot/#snaq-error-reporting", 
            "text": "Please report any bugs and errors by opening an  issue . The easiest way to provide information on the error is by checking the  .err  file, which will show the number of runs that failed and the corresponding seed to replicate the run. In case of an error, the  .err  file might look like:  Total errors: 1 in seeds [4545] . To replicate the bug (necessary to fix it!), you can run the following function with the same settings that caused the error:  snaqDebug ( startnetwork ,   raxmlCF ,   hmax = 2 ,   seed = 4545 )   This will create two files:  snaqDebug.log  and  debug.log , with information on steps to retrace the bug. You can attach them to your issue (or send them offline), to help us fix the bug.", 
            "title": "SNaQ error reporting"
        }, 
        {
            "location": "/man/dist_reroot/", 
            "text": "Comparing and manipulating networks\n\n\nExamples below follow those in \nGetting a Network\n.\n\n\n\n\nComparing networks / trees\n\n\nIs the SNaQ tree (network with h=0) the same as the ASTRAL tree? We can calculate their Robinson-Foulds distance:\n\n\njulia\n hardwiredClusterDistance(astraltree, net0, false)\n0\n\n\n\n\n\nThe last option \nfalse\n is to consider topologies as unrooted. The RF distance is 0, so the two unrooted topologies are the same. If we had considered them as rooted, with whatever root they currently have in their internal representation, we would find a difference:\n\n\njulia\n hardwiredClusterDistance(astraltree, net0, true)\n5\n\n\n\n\n\n\n\nRe-rooting trees and networks\n\n\nWe can re-root our networks with the outgroup, O, and then re-compare the ASTRAL tree and the SNaQ tree as rooted topologies (and find no difference):\n\n\njulia\n rootatnode!(astraltree, \nO\n)\nPhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: E, O, C, D, ...\n(O,(((C,D):3.029,(B,A):1.324):0.464,E));\n\njulia\n rootatnode!(net0, \nO\n)\nPhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: C, D, B, A, ...\n(O,(E,((B,A):1.396,(C,D):10.0):0.485));\n\njulia\n hardwiredClusterDistance(astraltree, net0, true)\n0\n\n\n\n\n\nusing\n \nPhyloPlots\n,\n \nRCall\n\n\nR\nname \n- function(x) file.path(\n..\n, \nassets\n, \nfigures\n, x)\n\n\nR\nsvg(name(\nnet0_O.svg\n), width=4, height=4)\n\n\nR\npar(mar = c(0, 0, 0, 0))\n\n\nplot\n(\nnet0\n,\n \n:\nR\n);\n\n\nR\ndev.off()\n\n\n\n\n\n\n\n\nNote that, as in previous chapters, we use the possibilities of \nRCall\n to save the plot. We only show this commands once, but they will be run behind the scene each time a plot is called.\n\n\nAfter trees/networks are rooted with a correct outgroup, their visualization is more meaningful.\n\n\nNetworks can be re-rooted at a given node or along a given edge. Get help (type \n?\n) on the functions \nrootatnode!\n and \nrootonedge!\n for more info. There are examples in the \nBootstrap\n section.\n\n\nIf the network is plotted with crossing edges, you may identify ways to rotate the children edges at some nodes to untangle some crossing edges. This can be done using the function \nrotate!\n. See an example in the \nBootstrap\n section, or type \n?\n then \nrotate!\n.\n\n\n\n\nWhat if the root conflicts with the direction of a reticulation?\n\n\nWith 1 hybridization or more, the direction of hybrid edges constrain the position of the root. The root cannot be downstream of hybrid edges. Any hybrid node has to be younger than, or of the same age as both of its parents. So time has to flow \"downwards\" of any hybrid node, and the root cannot be placed \"below\" a hybrid node. An attempt to re-root the network at a position incompatible with hybrid edges will fail, with a \nRootMismatch\n error. To show an example, let's use the network below. We plotted the edge numbers, because we will want to use them later to place the root.\n\n\nnet7taxa\n \n=\n \nreadTopology\n(\n(C,D,((O,(E,#H7:::0.196):0.314):0.664,(B,((A1,A2))#H7:::0.804):10.0):10.0);\n)\n\n\nplot\n(\nnet7taxa\n,\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n,\n \nshowEdgeNumber\n=\ntrue\n,\n \ntipOffset\n=\n0.2\n);\n\n\n\n\n\n\n\n\nLet's imagine that the A1 and A2 are our outgroups, and we estimated the network above. According to this network, time must flow from the hybrid node towards A1 and A2. So any attempt to reroot the network with A1 as outgroup, or with A2 as outgroup, or with the A clade (on edge 11), will fail with a \nRootMismatch\n error:\n\n\nrootatnode!\n(\nnet7taxa\n,\n \nA1\n);\n \n# ERROR: RootMismatch: non-leaf node 5 had 0 children. ...\n\n\nrootatnode!\n(\nnet7taxa\n,\n \nA2\n);\n \n# ERROR: RootMismatch (again)\n\n\nrootonedge!\n(\nnet7taxa\n,\n \n11\n);\n   \n# ERROR: RootMismatch (again)\n\n\n\n\n\n\nIn this case, however, it is possible to root the network on either parent edge of the hybrid node. These edges have numbers 12 and 5, based on the plot above. We get these 2 rooted versions of the network:\n\n\nR\nlayout(matrix(1:2,1,2))\n;\n\n\nrootonedge!\n(\nnet7taxa\n,\n \n12\n);\n\n\nplot\n(\nnet7taxa\n,\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n,\n \ntipOffset\n=\n0.2\n);\n\n\nR\nmtext(\nrooted on hybrid edge 12 (major)\n, line=-1)\n\n\nrootonedge!\n(\nnet7taxa\n,\n \n5\n);\n\n\nplot\n(\nnet7taxa\n,\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n,\n \ntipOffset\n=\n0.2\n);\n\n\nR\nmtext(\nrooted on hybrid edge 5 (minor)\n, line=-1)\n\n\n\n\n\n\n\n\nOn the second plot, the A clade does not \nappear\n to be an outgroup, but this is just because the plot follows the major tree primarily, based the major hybrid edges (those with \u03b3\n0.5). We can display the exact same network differently, by changing the \u03b3 inheritance values to invert the major/minor consideration of the hybrid edges.\n\n\nnet7taxa\n.\nedge\n[\n5\n]\n \n# just to check that it\ns one of the 2 hybrid edges of interest\n\n\nsetGamma!\n(\nnet7taxa\n.\nedge\n[\n5\n],\n \n0.501\n)\n \n# switch major/minor edges\n\n\nplot\n(\nnet7taxa\n,\n \n:\nR\n,\n \ntipOffset\n=\n0.2\n);\n \n# not showing gamma values, because we changed them artificially\n\n\nR\nmtext(\nrooted on hybrid edge 5 (considered major)\n, line=-1)\n\n\n\n\n\n\n\n\nConclusion, in this particular example: it is possible to re-root the network to a place where the A clade is indeed an outgroup. But it did require some care, and we discovered that there are 2 acceptable rooting options. The first is more plausible, if we think that the \nspecies tree\n is the \nmajor tree\n, meaning that any gene flow or introgression event replaced less than 50% of the genes in the recipient population.\n\n\nIn other cases, it may not be possible to re-root the network with a known outgroup. It would be the case if A1 was the only outgroup, and if A2 was an ingroup taxon. In such a case, the outgroup knowledge tells us that our estimated network is wrong. One (or more) reticulation in the network must be incorrect. Its placement might be correct, but then its direction would be incorrect. If the network was estimated via \nsnaq!\n, check tips about \nCandidate networks compatible with a known outgroup\n.\n\n\n\n\nExtracting the major tree\n\n\nWe can also compare the networks estimated with h=0 (net0) and h=1 (net1):\n\n\njulia\n \nrootatnode\n!(\nnet1\n,\n \nO\n);\n \n#\n \nthe\n \n;\n \nsuppresses\n \nscreen\n \noutput\n\n\nPhyloNetworks\n.\nHybridNetwork\n,\n \nRooted\n \nNetwork\n\n\n13\n \nedges\n\n\n13\n \nnodes\n:\n \n6\n \ntips\n,\n \n1\n \nhybrid\n \nnodes\n,\n \n6\n \ninternal\n \ntree\n \nnodes\n.\n\n\ntip\n \nlabels\n:\n \nC\n,\n \nD\n,\n \nO\n,\n \nE\n,\n \n...\n\n\n(\nO\n,((\nE\n,\n#\nH7\n:\n::\n0\n.\n196\n)\n:\n0\n.\n314\n,((\nB\n,(\nA\n)\n#\nH7\n:\n::\n0\n.\n804\n)\n:\n10\n.\n0\n,(\nC\n,\nD\n)\n:\n10\n.\n0\n)\n:\n0\n.\n664\n));\n\n\n\njulia\n \nhardwiredClusterDistance\n(\nnet0\n,\n \nnet1\n,\n \ntrue\n)\n\n\n2\n\n\n\n\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n);\n\n\n\n\n\n\n\n\nThey differ by 2 clusters: that's because A is of hybrid descent in net1, not in net0.\n\n\nTo beyond this hybrid difference, we can extract the major tree from the network with 1 hybridization, that is, delete the hybrid edge supported by less than 50% of genes. Then we can compare this tree with the ASTRAL/SNaQ tree net0.\n\n\njulia\n tree1 = majorTree(net1); # major tree from net1\n\njulia\n hardwiredClusterDistance(net0, tree1, true)\n0\n\n\n\n\n\nThey are identical (at distance 0), so here the species network with 1 hybrid node is a refinement of the estimated species tree (this needs not be the case always).\n\n\nIs the SNaQ network with 1 hybrid node the same as the true network, the one that was initially used to simulate the data?\n\n\n(digression on the data: gene trees were simulated under the coalescent along some \"true\" network, then 500 base-pair alignments were simulated along each gene tree with the HKY model, gene trees were estimated from each alignment with RAxML, and these estimated gene trees served as input to both ASTRAL and SNaQ.)\n\n\nThe true network is shown below, correctly rooted at the outgroup O, and plotted with branch lengths proportional to their values in coalescence units:\n\n\njulia\n \ntruenet\n \n=\n \nreadTopology\n(\n((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\n);\n\n\n\njulia\n \nhardwiredClusterDistance\n(\nnet1\n,\n \ntruenet\n,\n \ntrue\n)\n\n\n4\n\n\n\n\n\n\nplot\n(\ntruenet\n,\n \n:\nR\n,\n \nuseEdgeLength\n=\ntrue\n,\n \nshowGamma\n=\ntrue\n);\n\n\n\n\n\n\n\n\nOur estimated network is not the same as the true network:\n\n\n\n\nthe underlying tree is correctly estimated\n\n\nthe origin of gene flow is correctly estimated: E\n\n\nthe target of gene flow is \nnot\n correctly estimated: it was the lineage ancestral to (A,B), but it is estimated to be A only.\n\n\n\n\nFor networks, the distance here is the hardwired cluster distance: the number of hardwired clusters found in one network and not in the other. The \nhardwired cluster\n associated with an edge is the set of \nall\n tips descendant from that edge, i.e. all tips that inherited at least \nsome\n genetic material from that edge.\n\n\n\n\nDisplayed trees and subnetworks\n\n\nWe can extract all trees displayed in a network. These trees are obtained by picking one parent hybrid edge at each hybrid node, and dropping the other parent hybrid edge. We can choose to pick the \"important\" hybrid edges only, with heritability \u03b3 at or above a threshold. Below we use a \u03b3 threshold of 0, so we get all displayed trees:\n\n\njulia\n t = displayedTrees(net1, 0.0) # list of trees displayed in network\n2-element Array{PhyloNetworks.HybridNetwork,1}:\n PhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: C, D, O, E, ...\n(O,(((B,A):10.0,(C,D):10.0):0.664,E));\n\n PhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: C, D, O, E, ...\n(O,((E,A):0.314,((C,D):10.0,B):0.664));\n\njulia\n writeTopology(t[1], round=true)\n\n(O,(((B,A):10.0,(C,D):10.0):0.664,E));\n\n\njulia\n writeTopology(t[2], round=true)\n\n(O,((E,A):0.314,((C,D):10.0,B):0.664));\n\n\n\n\n\n\nIf we decide to keep edges with \u03b3\n0.2 only, then we are left with a single tree in the list (the major tree). This is because our example has 1 hybrid node with minor \u03b3=0.196.\n\n\njulia\n t = displayedTrees(net1, 0.2)\n1-element Array{PhyloNetworks.HybridNetwork,1}:\n PhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: C, D, O, E, ...\n(O,(((B,A):10.0,(C,D):10.0):0.664,E));\n\n\n\n\n\nWe can also delete all \"non-important\" reticulations, those with a minor heritability \u03b3 below some threshold. The function below changes our network \nnet1\n, as indicated by its name ending with a \n!\n.\n\n\njulia\n \ndeleteHybridThreshold\n!(\nnet1\n,\n \n0\n.\n1\n)\n\n\nPhyloNetworks\n.\nHybridNetwork\n,\n \nRooted\n \nNetwork\n\n\n13\n \nedges\n\n\n13\n \nnodes\n:\n \n6\n \ntips\n,\n \n1\n \nhybrid\n \nnodes\n,\n \n6\n \ninternal\n \ntree\n \nnodes\n.\n\n\ntip\n \nlabels\n:\n \nC\n,\n \nD\n,\n \nO\n,\n \nE\n,\n \n...\n\n\n(\nO\n,((\nE\n,\n#\nH7\n:\n::\n0\n.\n196\n)\n:\n0\n.\n314\n,((\nB\n,(\nA\n)\n#\nH7\n:\n::\n0\n.\n804\n)\n:\n10\n.\n0\n,(\nC\n,\nD\n)\n:\n10\n.\n0\n)\n:\n0\n.\n664\n));\n\n\n\n\n\n\nNothing happened to our network: because its \u03b3 is above 0.1. But if we set the threshold to 0.3, then our reticulation disappears:\n\n\njulia\n deleteHybridThreshold!(net1, 0.3)\nPhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: C, D, O, E, ...\n(O,(((B,A):10.0,(C,D):10.0):0.664,E));\n\n\n\n\n\nSee also function \ndisplayedNetworkAt!\n to get the network with a single reticulation of interest, and eliminate all other reticulations.", 
            "title": "Network comparison and manipulation"
        }, 
        {
            "location": "/man/dist_reroot/#comparing-and-manipulating-networks", 
            "text": "Examples below follow those in  Getting a Network .", 
            "title": "Comparing and manipulating networks"
        }, 
        {
            "location": "/man/dist_reroot/#comparing-networks-trees", 
            "text": "Is the SNaQ tree (network with h=0) the same as the ASTRAL tree? We can calculate their Robinson-Foulds distance:  julia  hardwiredClusterDistance(astraltree, net0, false)\n0  The last option  false  is to consider topologies as unrooted. The RF distance is 0, so the two unrooted topologies are the same. If we had considered them as rooted, with whatever root they currently have in their internal representation, we would find a difference:  julia  hardwiredClusterDistance(astraltree, net0, true)\n5", 
            "title": "Comparing networks / trees"
        }, 
        {
            "location": "/man/dist_reroot/#re-rooting-trees-and-networks", 
            "text": "We can re-root our networks with the outgroup, O, and then re-compare the ASTRAL tree and the SNaQ tree as rooted topologies (and find no difference):  julia  rootatnode!(astraltree,  O )\nPhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: E, O, C, D, ...\n(O,(((C,D):3.029,(B,A):1.324):0.464,E));\n\njulia  rootatnode!(net0,  O )\nPhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: C, D, B, A, ...\n(O,(E,((B,A):1.396,(C,D):10.0):0.485));\n\njulia  hardwiredClusterDistance(astraltree, net0, true)\n0  using   PhyloPlots ,   RCall  R name  - function(x) file.path( .. ,  assets ,  figures , x)  R svg(name( net0_O.svg ), width=4, height=4)  R par(mar = c(0, 0, 0, 0))  plot ( net0 ,   : R );  R dev.off()    Note that, as in previous chapters, we use the possibilities of  RCall  to save the plot. We only show this commands once, but they will be run behind the scene each time a plot is called.  After trees/networks are rooted with a correct outgroup, their visualization is more meaningful.  Networks can be re-rooted at a given node or along a given edge. Get help (type  ? ) on the functions  rootatnode!  and  rootonedge!  for more info. There are examples in the  Bootstrap  section.  If the network is plotted with crossing edges, you may identify ways to rotate the children edges at some nodes to untangle some crossing edges. This can be done using the function  rotate! . See an example in the  Bootstrap  section, or type  ?  then  rotate! .", 
            "title": "Re-rooting trees and networks"
        }, 
        {
            "location": "/man/dist_reroot/#what-if-the-root-conflicts-with-the-direction-of-a-reticulation", 
            "text": "With 1 hybridization or more, the direction of hybrid edges constrain the position of the root. The root cannot be downstream of hybrid edges. Any hybrid node has to be younger than, or of the same age as both of its parents. So time has to flow \"downwards\" of any hybrid node, and the root cannot be placed \"below\" a hybrid node. An attempt to re-root the network at a position incompatible with hybrid edges will fail, with a  RootMismatch  error. To show an example, let's use the network below. We plotted the edge numbers, because we will want to use them later to place the root.  net7taxa   =   readTopology ( (C,D,((O,(E,#H7:::0.196):0.314):0.664,(B,((A1,A2))#H7:::0.804):10.0):10.0); )  plot ( net7taxa ,   : R ,   showGamma = true ,   showEdgeNumber = true ,   tipOffset = 0.2 );    Let's imagine that the A1 and A2 are our outgroups, and we estimated the network above. According to this network, time must flow from the hybrid node towards A1 and A2. So any attempt to reroot the network with A1 as outgroup, or with A2 as outgroup, or with the A clade (on edge 11), will fail with a  RootMismatch  error:  rootatnode! ( net7taxa ,   A1 );   # ERROR: RootMismatch: non-leaf node 5 had 0 children. ...  rootatnode! ( net7taxa ,   A2 );   # ERROR: RootMismatch (again)  rootonedge! ( net7taxa ,   11 );     # ERROR: RootMismatch (again)   In this case, however, it is possible to root the network on either parent edge of the hybrid node. These edges have numbers 12 and 5, based on the plot above. We get these 2 rooted versions of the network:  R layout(matrix(1:2,1,2)) ;  rootonedge! ( net7taxa ,   12 );  plot ( net7taxa ,   : R ,   showGamma = true ,   tipOffset = 0.2 );  R mtext( rooted on hybrid edge 12 (major) , line=-1)  rootonedge! ( net7taxa ,   5 );  plot ( net7taxa ,   : R ,   showGamma = true ,   tipOffset = 0.2 );  R mtext( rooted on hybrid edge 5 (minor) , line=-1)    On the second plot, the A clade does not  appear  to be an outgroup, but this is just because the plot follows the major tree primarily, based the major hybrid edges (those with \u03b3 0.5). We can display the exact same network differently, by changing the \u03b3 inheritance values to invert the major/minor consideration of the hybrid edges.  net7taxa . edge [ 5 ]   # just to check that it s one of the 2 hybrid edges of interest  setGamma! ( net7taxa . edge [ 5 ],   0.501 )   # switch major/minor edges  plot ( net7taxa ,   : R ,   tipOffset = 0.2 );   # not showing gamma values, because we changed them artificially  R mtext( rooted on hybrid edge 5 (considered major) , line=-1)    Conclusion, in this particular example: it is possible to re-root the network to a place where the A clade is indeed an outgroup. But it did require some care, and we discovered that there are 2 acceptable rooting options. The first is more plausible, if we think that the  species tree  is the  major tree , meaning that any gene flow or introgression event replaced less than 50% of the genes in the recipient population.  In other cases, it may not be possible to re-root the network with a known outgroup. It would be the case if A1 was the only outgroup, and if A2 was an ingroup taxon. In such a case, the outgroup knowledge tells us that our estimated network is wrong. One (or more) reticulation in the network must be incorrect. Its placement might be correct, but then its direction would be incorrect. If the network was estimated via  snaq! , check tips about  Candidate networks compatible with a known outgroup .", 
            "title": "What if the root conflicts with the direction of a reticulation?"
        }, 
        {
            "location": "/man/dist_reroot/#extracting-the-major-tree", 
            "text": "We can also compare the networks estimated with h=0 (net0) and h=1 (net1):  julia   rootatnode !( net1 ,   O );   #   the   ;   suppresses   screen   output  PhyloNetworks . HybridNetwork ,   Rooted   Network  13   edges  13   nodes :   6   tips ,   1   hybrid   nodes ,   6   internal   tree   nodes .  tip   labels :   C ,   D ,   O ,   E ,   ...  ( O ,(( E , # H7 : :: 0 . 196 ) : 0 . 314 ,(( B ,( A ) # H7 : :: 0 . 804 ) : 10 . 0 ,( C , D ) : 10 . 0 ) : 0 . 664 ));  julia   hardwiredClusterDistance ( net0 ,   net1 ,   true )  2   plot ( net1 ,   : R ,   showGamma = true );    They differ by 2 clusters: that's because A is of hybrid descent in net1, not in net0.  To beyond this hybrid difference, we can extract the major tree from the network with 1 hybridization, that is, delete the hybrid edge supported by less than 50% of genes. Then we can compare this tree with the ASTRAL/SNaQ tree net0.  julia  tree1 = majorTree(net1); # major tree from net1\n\njulia  hardwiredClusterDistance(net0, tree1, true)\n0  They are identical (at distance 0), so here the species network with 1 hybrid node is a refinement of the estimated species tree (this needs not be the case always).  Is the SNaQ network with 1 hybrid node the same as the true network, the one that was initially used to simulate the data?  (digression on the data: gene trees were simulated under the coalescent along some \"true\" network, then 500 base-pair alignments were simulated along each gene tree with the HKY model, gene trees were estimated from each alignment with RAxML, and these estimated gene trees served as input to both ASTRAL and SNaQ.)  The true network is shown below, correctly rooted at the outgroup O, and plotted with branch lengths proportional to their values in coalescence units:  julia   truenet   =   readTopology ( ((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2); );  julia   hardwiredClusterDistance ( net1 ,   truenet ,   true )  4   plot ( truenet ,   : R ,   useEdgeLength = true ,   showGamma = true );    Our estimated network is not the same as the true network:   the underlying tree is correctly estimated  the origin of gene flow is correctly estimated: E  the target of gene flow is  not  correctly estimated: it was the lineage ancestral to (A,B), but it is estimated to be A only.   For networks, the distance here is the hardwired cluster distance: the number of hardwired clusters found in one network and not in the other. The  hardwired cluster  associated with an edge is the set of  all  tips descendant from that edge, i.e. all tips that inherited at least  some  genetic material from that edge.", 
            "title": "Extracting the major tree"
        }, 
        {
            "location": "/man/dist_reroot/#displayed-trees-and-subnetworks", 
            "text": "We can extract all trees displayed in a network. These trees are obtained by picking one parent hybrid edge at each hybrid node, and dropping the other parent hybrid edge. We can choose to pick the \"important\" hybrid edges only, with heritability \u03b3 at or above a threshold. Below we use a \u03b3 threshold of 0, so we get all displayed trees:  julia  t = displayedTrees(net1, 0.0) # list of trees displayed in network\n2-element Array{PhyloNetworks.HybridNetwork,1}:\n PhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: C, D, O, E, ...\n(O,(((B,A):10.0,(C,D):10.0):0.664,E));\n\n PhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: C, D, O, E, ...\n(O,((E,A):0.314,((C,D):10.0,B):0.664));\n\njulia  writeTopology(t[1], round=true) (O,(((B,A):10.0,(C,D):10.0):0.664,E)); \n\njulia  writeTopology(t[2], round=true) (O,((E,A):0.314,((C,D):10.0,B):0.664));   If we decide to keep edges with \u03b3 0.2 only, then we are left with a single tree in the list (the major tree). This is because our example has 1 hybrid node with minor \u03b3=0.196.  julia  t = displayedTrees(net1, 0.2)\n1-element Array{PhyloNetworks.HybridNetwork,1}:\n PhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: C, D, O, E, ...\n(O,(((B,A):10.0,(C,D):10.0):0.664,E));  We can also delete all \"non-important\" reticulations, those with a minor heritability \u03b3 below some threshold. The function below changes our network  net1 , as indicated by its name ending with a  ! .  julia   deleteHybridThreshold !( net1 ,   0 . 1 )  PhyloNetworks . HybridNetwork ,   Rooted   Network  13   edges  13   nodes :   6   tips ,   1   hybrid   nodes ,   6   internal   tree   nodes .  tip   labels :   C ,   D ,   O ,   E ,   ...  ( O ,(( E , # H7 : :: 0 . 196 ) : 0 . 314 ,(( B ,( A ) # H7 : :: 0 . 804 ) : 10 . 0 ,( C , D ) : 10 . 0 ) : 0 . 664 ));   Nothing happened to our network: because its \u03b3 is above 0.1. But if we set the threshold to 0.3, then our reticulation disappears:  julia  deleteHybridThreshold!(net1, 0.3)\nPhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: C, D, O, E, ...\n(O,(((B,A):10.0,(C,D):10.0):0.664,E));  See also function  displayedNetworkAt!  to get the network with a single reticulation of interest, and eliminate all other reticulations.", 
            "title": "Displayed trees and subnetworks"
        }, 
        {
            "location": "/man/fixednetworkoptim/", 
            "text": "Candidate Networks\n\n\n\n\nOptimizing parameters for a given network\n\n\nFor a given network topology, we can optimize the branch lengths and inheritance probabilities (\u03b3) with the pseudolikelihood. This is useful if we have a few candidate networks to compare. Each network can be optimized individually, and the network with the best pseudolikelihood can be chosen.\n\n\nThe score being optimized is the pseudo-deviance, i.e. the negative log pseudo-likelihood up to an additive constant (the lower the better).\n\n\nFollowing our example in \nGetting a Network\n, we can optimize parameters on the true network (the one originally used to simulate the data):\n\n\njulia\n \ntruenet\n \n=\n \nreadTopology\n(\n((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\n);\n\n\n\njulia\n \nnet1alt\n \n=\n \ntopologyMaxQPseudolik\n!(\ntruenet\n,\n \nraxmlCF\n);\n\n\n\njulia\n \nwriteTopology\n(\nnet1alt\n,\n \nround\n=\ntrue\n)\n\n\n(D,C,(((A,B):0.987)#H1:8.376::0.721,((#H1:0.0::0.279,E):1.287,O):1.181):7.615);\n\n\n\njulia\n \nnet1alt\n.\nloglik\n \n#\n \npseudo\n \ndeviance\n,\n \nactually\n\n\n29\n.\n94130186108919\n\n\n\n\n\n\nusing\n \nPhyloPlots\n,\n \nRCall\n\n\nR\nname \n- function(x) file.path(\n..\n, \nassets\n, \nfigures\n, x)\n\n\nR\nsvg(name(\ntruenet_opt.svg\n), width=4, height=4)\n\n\nR\npar(mar = c(0, 0, 0, 0))\n\n\nplot\n(\nnet1alt\n,\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n);\n\n\nR\ndev.off()\n\n\n\n\n\n\n\n\nWe get a score of 29.941, which is comparable to the score of the SNaQ network (net1: 28.315), especially compared to the score of the best tree (net0: 53.532). This begs the question: is the true network within the \"range\" of uncertainty? We can run a \nBootstrap\n analysis to measure uncertainty in our network inference.\n\n\nFor a more thorough optimization, we may increase the requirements before the search stops (but the optimization will take longer). It makes no difference on this small data set.\n\n\nnet1par\n \n=\n \ntopologyMaxQPseudolik!\n(\ntruenet\n,\n \nraxmlCF\n,\n \nftolRel\n=\n1e-10\n,\n \nxtolAbs\n=\n1e-10\n)\n\n\nnet1par\n.\nloglik\n\n\n\n\n\n\n\n\nNetwork Score with no optimization\n\n\nFor a network with given branch lengths and \u03b3 heritabilies, we can compute the pseudolikelihood with:\n\n\njulia\n topologyQPseudolik!(truenet,raxmlCF);\n\njulia\n truenet.loglik\n153.5310295393005\n\n\n\n\n\nThis function is not maximizing the pseudolikelihood, it is simply computing the pseudolikelihood (or deviance) for the given branch lengths and probabilities of inheritance. At the moment, both of these functions require that the given network is of level 1 (cycles don't overlap).\n\n\n\n\nCandidate networks compatible with a known outgroup\n\n\nIf the network was estimated via \nsnaq!\n, it might turn out to be impossible to root our estimated network with a known outgroup (see section \nWhat if the root conflicts with the direction of a reticulation?\n.) At this time, \nsnaq!\n does not impose any rooting constraint on the network: the search for the lowest score considers all level-1 networks, including those that are incompatible with a known outgroup. (The monophyly of outgroups is not imposed either, like in many other methods.)\n\n\nIf the estimated network cannot be rooted with the known outgroup, we can check the \n.networks\n output file. It has a list of networks that are slight modifications of the best network, where the modifications changed the direction of one reticulation at a time. For each modified network, the score was calculated. So if we find in this list a modified network that has a score close to that of the best network, and that can be re-rooted with our known root position, then this modified network is a better candidate than the network with the best score.\n\n\nBelow is what the \nnet1.networks\n file looks like, after performing the analysis in the section \nNetwork Estimation\n. Scroll to the right to see the scores.\n\n\n(\nC\n,\nD\n,((\nO\n,(\nE\n,\n#\nH7\n:\n::\n0\n.\n19558838614943078\n)\n:\n0\n.\n31352437658618976\n)\n:\n0\n.\n6640664399202987\n,(\nB\n,(\nA\n)\n#\nH7\n:\n::\n0\n.\n8044116138505693\n)\n:\n10\n.\n0\n)\n:\n10\n.\n0\n);,\n \nwith\n \n-loglik\n \n28\n.\n31506721890958\n \n(\nbest\n \nnetwork\n \nfound\n,\n \nremaining\n \nsorted\n \nby\n \nlog-pseudolik\n;\n \nthe\n \nsmaller\n,\n \nthe\n \nbetter\n)\n\n\n(\nC\n,\nD\n,((\nO\n,(\nE\n)\n#\nH7\n:\n::\n0\n.\n8150784689693145\n)\n:\n0\n.\n9336405757682176\n,(\nB\n,(\nA\n,\n#\nH7\n:\n::\n0\n.\n18492153103068557\n)\n:\n0\n.\n25386142779877724\n)\n:\n1\n.\n8758156446611114\n)\n:\n10\n.\n0\n);,\n \nwith\n \n-loglik\n \n31\n.\n535560380783814\n\n\n(\nB\n,\n#\nH7\n:\n9\n.\n90999345612101\n::\n0\n.\n2555404440833535\n,(\nA\n,(\nE\n,(\nO\n,((\nC\n,\nD\n)\n:\n10\n.\n0\n)\n#\nH7\n:\n0\n.\n3419231810962026\n::\n0\n.\n7444595559166465\n)\n:\n0\n.\n19994859441332047\n)\n:\n2\n.\n5014911511063644\n)\n:\n0\n.\n7957621793330066\n);,\n \nwith\n \n-loglik\n \n56\n.\n64548310161462\n\n\n(\nC\n,\nD\n,((\nO\n,(\nE\n,((\nB\n)\n#\nH7\n:\n::\n0\n.\n7957543284159452\n,\nA\n)\n:\n4\n.\n786202415937916\n)\n:\n0\n.\n004527712280136759\n)\n:\n1\n.\n7952610454570868\n,\n#\nH7\n:\n::\n0\n.\n20424567158405482\n)\n:\n10\n.\n0\n);,\n \nwith\n \n-loglik\n \n67\n.\n17775727492258\n\n\n(\nC\n,\nD\n,(\n#\nH7\n:\n::\n0\n.\n32947301811471164\n,(\nB\n,(\nA\n,(\nE\n,(\nO\n)\n#\nH7\n:\n::\n0\n.\n6705269818852884\n)\n:\n1\n.\n371799259141243\n)\n:\n0\n.\n0\n)\n:\n6\n.\n397073999864152\n)\n:\n7\n.\n677245926003807\n);,\n \nwith\n \n-loglik\n \n199\n.\n11401961057143\n\n\n\n\n\n\nWe can read this file and look at its list of networks like this:\n\n\njulia\n \nfile\n \n=\n \nnet1.networks\n;\n\n\n\njulia\n \n#\n \nor\n \nuse\n \nthe\n \nexample\n \nfile\n \navailable\n \nwith\n \nthe\n \npackage\n:\n\n       \nfile\n \n=\n \njoinpath\n(\nPkg\n.\ndir\n(\nPhyloNetworks\n),\nexamples\n,\nnet1.networks\n);\n\n\n\njulia\n \nnetlist\n \n=\n \nreadMultiTopology\n(\nfile\n)\n \n#\n \nread\n \nthe\n \nfull\n \nlist\n \nof\n \nnetworks\n \nin\n \nthat\n \nfile\n\n\n5-element\n \nArray\n{\nPhyloNetworks.HybridNetwork,1\n}\n:\n\n \nPhyloNetworks\n.\nHybridNetwork\n,\n \nRooted\n \nNetwork\n\n\n12\n \nedges\n\n\n12\n \nnodes\n:\n \n6\n \ntips\n,\n \n1\n \nhybrid\n \nnodes\n,\n \n5\n \ninternal\n \ntree\n \nnodes\n.\n\n\ntip\n \nlabels\n:\n \nC\n,\n \nD\n,\n \nO\n,\n \nE\n,\n \n...\n\n\n(\nC\n,\nD\n,((\nO\n,(\nE\n,\n#\nH7\n:\n::\n0\n.\n196\n)\n:\n0\n.\n314\n)\n:\n0\n.\n664\n,(\nB\n,(\nA\n)\n#\nH7\n:\n::\n0\n.\n804\n)\n:\n10\n.\n0\n)\n:\n10\n.\n0\n);\n\n\n \nPhyloNetworks\n.\nHybridNetwork\n,\n \nRooted\n \nNetwork\n\n\n12\n \nedges\n\n\n12\n \nnodes\n:\n \n6\n \ntips\n,\n \n1\n \nhybrid\n \nnodes\n,\n \n5\n \ninternal\n \ntree\n \nnodes\n.\n\n\ntip\n \nlabels\n:\n \nC\n,\n \nD\n,\n \nO\n,\n \nE\n,\n \n...\n\n\n(\nC\n,\nD\n,((\nO\n,(\nE\n)\n#\nH7\n:\n::\n0\n.\n815\n)\n:\n0\n.\n934\n,(\nB\n,(\nA\n,\n#\nH7\n:\n::\n0\n.\n185\n)\n:\n0\n.\n254\n)\n:\n1\n.\n876\n)\n:\n10\n.\n0\n);\n\n\n \nPhyloNetworks\n.\nHybridNetwork\n,\n \nRooted\n \nNetwork\n\n\n12\n \nedges\n\n\n12\n \nnodes\n:\n \n6\n \ntips\n,\n \n1\n \nhybrid\n \nnodes\n,\n \n5\n \ninternal\n \ntree\n \nnodes\n.\n\n\ntip\n \nlabels\n:\n \nB\n,\n \nA\n,\n \nE\n,\n \nO\n,\n \n...\n\n\n(\nB\n,\n#\nH7\n:\n9\n.\n91\n::\n0\n.\n256\n,(\nA\n,(\nE\n,(\nO\n,((\nC\n,\nD\n)\n:\n10\n.\n0\n)\n#\nH7\n:\n0\n.\n342\n::\n0\n.\n744\n)\n:\n0\n.\n2\n)\n:\n2\n.\n501\n)\n:\n0\n.\n796\n);\n\n\n \nPhyloNetworks\n.\nHybridNetwork\n,\n \nRooted\n \nNetwork\n\n\n12\n \nedges\n\n\n12\n \nnodes\n:\n \n6\n \ntips\n,\n \n1\n \nhybrid\n \nnodes\n,\n \n5\n \ninternal\n \ntree\n \nnodes\n.\n\n\ntip\n \nlabels\n:\n \nC\n,\n \nD\n,\n \nO\n,\n \nE\n,\n \n...\n\n\n(\nC\n,\nD\n,((\nO\n,(\nE\n,((\nB\n)\n#\nH7\n:\n::\n0\n.\n796\n,\nA\n)\n:\n4\n.\n786\n)\n:\n0\n.\n005\n)\n:\n1\n.\n795\n,\n#\nH7\n:\n::\n0\n.\n204\n)\n:\n10\n.\n0\n);\n\n\n \nPhyloNetworks\n.\nHybridNetwork\n,\n \nRooted\n \nNetwork\n\n\n12\n \nedges\n\n\n12\n \nnodes\n:\n \n6\n \ntips\n,\n \n1\n \nhybrid\n \nnodes\n,\n \n5\n \ninternal\n \ntree\n \nnodes\n.\n\n\ntip\n \nlabels\n:\n \nC\n,\n \nD\n,\n \nB\n,\n \nA\n,\n \n...\n\n\n(\nC\n,\nD\n,(\n#\nH7\n:\n::\n0\n.\n329\n,(\nB\n,(\nA\n,(\nE\n,(\nO\n)\n#\nH7\n:\n::\n0\n.\n671\n)\n:\n1\n.\n372\n)\n:\n0\n.\n0\n)\n:\n6\n.\n397\n)\n:\n7\n.\n677\n);\n\n\n\n\n\n\nNext, we would like to extract the network scores from the file. Below is a one-liner to do this (we make Julia send a \nsed\n command to the shell \u2013sorry, Mac or Linux for this.)\n\n\njulia\n scoresInString = readstring(`sed -E \ns/.+with -loglik ([0-9]+.[0-9]+).+/\\1/\n $file`)\n\n28.31506721890958\\n31.53556038078381\\n56.6454831016146\\n67.1777572749225\\n199.1140196105714\\n\n\n\njulia\n scores = parse.(Float64, split(scoresInString))\n5-element Array{Float64,1}:\n  28.3151\n  31.5356\n  56.6455\n  67.1778\n 199.114\n\njulia\n # next: update the \nloglik\n of each network with the score read from the file\n       for i in eachindex(netlist)\n          netlist[i].loglik = scores[i]\n          println(\nnet $i in the list: score = \n,scores[i])\n       end\nnet 1 in the list: score = 28.31506721890958\nnet 2 in the list: score = 31.53556038078381\nnet 3 in the list: score = 56.6454831016146\nnet 4 in the list: score = 67.1777572749225\nnet 5 in the list: score = 199.1140196105714\n\n\n\n\n\nThe first network in the list is the best network returned by \nsnaq!\n. We see that the second network has a score that's not too far, but the other networks have worse scores. The best network and its best modification (second network in the list) are shown below. We chose to show edge numbers, to use them later to re-root the networks.\n\n\nplot\n(\nnetlist\n[\n1\n],\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n,\n \nshowEdgeNumber\n=\ntrue\n,\n \ntipOffset\n=\n0.1\n);\n\n\nR\nmtext(\nbest net, score=28.3\n, line=-1)\n\n\nplot\n(\nnetlist\n[\n2\n],\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n,\n \nshowEdgeNumber\n=\ntrue\n,\n \ntipOffset\n=\n0.1\n);\n\n\nR\nmtext(\ndirection modified, score=31.5\n, line=-1)\n;\n\n\n\n\n\n\n\n\nNow imagine that our outgroup is taxon A.\n\n\n\n\nbest network: we would get a \"RootMismatch\" error if we tried to set the root on the external edge 9 to A, with \nrootatnode!(netlist[1], \"A\")\n (see section \nWhat if the root conflicts with the direction of a reticulation?\n). But we could root the best network on the major parent edge to A, edge 10 (rooted network on the left below).\n\n\nFor the second best network in our list, there are 2 ways to root it with A: on the external edge 8 to A (top right), or on its parent edge 10 (bottom right). These 2 options give quite different rooted versions of the network, one of which requires the existence of an unsampled taxon, sister to BOECD, that would have contributed to introgression into an ancestor of E. The second rooted version says that an ancestor of (or sister to) A contributed to the introgression into the ancestor of E. A is an outgroup in both cases, but the second case is more parsimonious, in the sense that it does not require the existence of an unsampled taxon.\n\n\n\n\nrootonedge!\n(\nnetlist\n[\n1\n],\n \n10\n);\n \n# root best net to make A outgroup\n\n\nrotate!\n(\nnetlist\n[\n1\n],\n \n-\n4\n);\n \n# to \nun-cross\n edges\n\n\nrotate!\n(\nnetlist\n[\n1\n],\n \n-\n6\n);\n\n\nplot\n(\nnetlist\n[\n1\n],\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n,\n \ntipOffset\n=\n0.1\n);\n\n\nR\nmtext(\nbest net, score=28.3\n, line=-1)\n;\n\n\nrootatnode!\n(\nnetlist\n[\n2\n],\n \nA\n);\n \n# net with modified direction: first way to make A outgroup\n\n\nplot\n(\nnetlist\n[\n2\n],\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n,\n \ntipOffset\n=\n0.1\n);\n\n\nR\nmtext(\nsecond best in list, score=31.5\n\\n\nrequires unsampled population\n, line=-2)\n;\n\n\nrootonedge!\n(\nnetlist\n[\n2\n],\n \n10\n)\n \n# net with modified direction: second way to make A outgroup\n\n\nplot\n(\nnetlist\n[\n2\n],\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n,\n \ntipOffset\n=\n0.1\n);\n\n\nR\nmtext(\nsecond best in list, score=31.5\n\\n\ndifferent root position\n, line=-2)\n;", 
            "title": "Candidate Networks"
        }, 
        {
            "location": "/man/fixednetworkoptim/#candidate-networks", 
            "text": "", 
            "title": "Candidate Networks"
        }, 
        {
            "location": "/man/fixednetworkoptim/#optimizing-parameters-for-a-given-network", 
            "text": "For a given network topology, we can optimize the branch lengths and inheritance probabilities (\u03b3) with the pseudolikelihood. This is useful if we have a few candidate networks to compare. Each network can be optimized individually, and the network with the best pseudolikelihood can be chosen.  The score being optimized is the pseudo-deviance, i.e. the negative log pseudo-likelihood up to an additive constant (the lower the better).  Following our example in  Getting a Network , we can optimize parameters on the true network (the one originally used to simulate the data):  julia   truenet   =   readTopology ( ((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2); );  julia   net1alt   =   topologyMaxQPseudolik !( truenet ,   raxmlCF );  julia   writeTopology ( net1alt ,   round = true )  (D,C,(((A,B):0.987)#H1:8.376::0.721,((#H1:0.0::0.279,E):1.287,O):1.181):7.615);  julia   net1alt . loglik   #   pseudo   deviance ,   actually  29 . 94130186108919   using   PhyloPlots ,   RCall  R name  - function(x) file.path( .. ,  assets ,  figures , x)  R svg(name( truenet_opt.svg ), width=4, height=4)  R par(mar = c(0, 0, 0, 0))  plot ( net1alt ,   : R ,   showGamma = true );  R dev.off()    We get a score of 29.941, which is comparable to the score of the SNaQ network (net1: 28.315), especially compared to the score of the best tree (net0: 53.532). This begs the question: is the true network within the \"range\" of uncertainty? We can run a  Bootstrap  analysis to measure uncertainty in our network inference.  For a more thorough optimization, we may increase the requirements before the search stops (but the optimization will take longer). It makes no difference on this small data set.  net1par   =   topologyMaxQPseudolik! ( truenet ,   raxmlCF ,   ftolRel = 1e-10 ,   xtolAbs = 1e-10 )  net1par . loglik", 
            "title": "Optimizing parameters for a given network"
        }, 
        {
            "location": "/man/fixednetworkoptim/#network-score-with-no-optimization", 
            "text": "For a network with given branch lengths and \u03b3 heritabilies, we can compute the pseudolikelihood with:  julia  topologyQPseudolik!(truenet,raxmlCF);\n\njulia  truenet.loglik\n153.5310295393005  This function is not maximizing the pseudolikelihood, it is simply computing the pseudolikelihood (or deviance) for the given branch lengths and probabilities of inheritance. At the moment, both of these functions require that the given network is of level 1 (cycles don't overlap).", 
            "title": "Network Score with no optimization"
        }, 
        {
            "location": "/man/fixednetworkoptim/#candidate-networks-compatible-with-a-known-outgroup", 
            "text": "If the network was estimated via  snaq! , it might turn out to be impossible to root our estimated network with a known outgroup (see section  What if the root conflicts with the direction of a reticulation? .) At this time,  snaq!  does not impose any rooting constraint on the network: the search for the lowest score considers all level-1 networks, including those that are incompatible with a known outgroup. (The monophyly of outgroups is not imposed either, like in many other methods.)  If the estimated network cannot be rooted with the known outgroup, we can check the  .networks  output file. It has a list of networks that are slight modifications of the best network, where the modifications changed the direction of one reticulation at a time. For each modified network, the score was calculated. So if we find in this list a modified network that has a score close to that of the best network, and that can be re-rooted with our known root position, then this modified network is a better candidate than the network with the best score.  Below is what the  net1.networks  file looks like, after performing the analysis in the section  Network Estimation . Scroll to the right to see the scores.  ( C , D ,(( O ,( E , # H7 : :: 0 . 19558838614943078 ) : 0 . 31352437658618976 ) : 0 . 6640664399202987 ,( B ,( A ) # H7 : :: 0 . 8044116138505693 ) : 10 . 0 ) : 10 . 0 );,   with   -loglik   28 . 31506721890958   ( best   network   found ,   remaining   sorted   by   log-pseudolik ;   the   smaller ,   the   better )  ( C , D ,(( O ,( E ) # H7 : :: 0 . 8150784689693145 ) : 0 . 9336405757682176 ,( B ,( A , # H7 : :: 0 . 18492153103068557 ) : 0 . 25386142779877724 ) : 1 . 8758156446611114 ) : 10 . 0 );,   with   -loglik   31 . 535560380783814  ( B , # H7 : 9 . 90999345612101 :: 0 . 2555404440833535 ,( A ,( E ,( O ,(( C , D ) : 10 . 0 ) # H7 : 0 . 3419231810962026 :: 0 . 7444595559166465 ) : 0 . 19994859441332047 ) : 2 . 5014911511063644 ) : 0 . 7957621793330066 );,   with   -loglik   56 . 64548310161462  ( C , D ,(( O ,( E ,(( B ) # H7 : :: 0 . 7957543284159452 , A ) : 4 . 786202415937916 ) : 0 . 004527712280136759 ) : 1 . 7952610454570868 , # H7 : :: 0 . 20424567158405482 ) : 10 . 0 );,   with   -loglik   67 . 17775727492258  ( C , D ,( # H7 : :: 0 . 32947301811471164 ,( B ,( A ,( E ,( O ) # H7 : :: 0 . 6705269818852884 ) : 1 . 371799259141243 ) : 0 . 0 ) : 6 . 397073999864152 ) : 7 . 677245926003807 );,   with   -loglik   199 . 11401961057143   We can read this file and look at its list of networks like this:  julia   file   =   net1.networks ;  julia   #   or   use   the   example   file   available   with   the   package : \n        file   =   joinpath ( Pkg . dir ( PhyloNetworks ), examples , net1.networks );  julia   netlist   =   readMultiTopology ( file )   #   read   the   full   list   of   networks   in   that   file  5-element   Array { PhyloNetworks.HybridNetwork,1 } : \n  PhyloNetworks . HybridNetwork ,   Rooted   Network  12   edges  12   nodes :   6   tips ,   1   hybrid   nodes ,   5   internal   tree   nodes .  tip   labels :   C ,   D ,   O ,   E ,   ...  ( C , D ,(( O ,( E , # H7 : :: 0 . 196 ) : 0 . 314 ) : 0 . 664 ,( B ,( A ) # H7 : :: 0 . 804 ) : 10 . 0 ) : 10 . 0 ); \n\n  PhyloNetworks . HybridNetwork ,   Rooted   Network  12   edges  12   nodes :   6   tips ,   1   hybrid   nodes ,   5   internal   tree   nodes .  tip   labels :   C ,   D ,   O ,   E ,   ...  ( C , D ,(( O ,( E ) # H7 : :: 0 . 815 ) : 0 . 934 ,( B ,( A , # H7 : :: 0 . 185 ) : 0 . 254 ) : 1 . 876 ) : 10 . 0 ); \n\n  PhyloNetworks . HybridNetwork ,   Rooted   Network  12   edges  12   nodes :   6   tips ,   1   hybrid   nodes ,   5   internal   tree   nodes .  tip   labels :   B ,   A ,   E ,   O ,   ...  ( B , # H7 : 9 . 91 :: 0 . 256 ,( A ,( E ,( O ,(( C , D ) : 10 . 0 ) # H7 : 0 . 342 :: 0 . 744 ) : 0 . 2 ) : 2 . 501 ) : 0 . 796 ); \n\n  PhyloNetworks . HybridNetwork ,   Rooted   Network  12   edges  12   nodes :   6   tips ,   1   hybrid   nodes ,   5   internal   tree   nodes .  tip   labels :   C ,   D ,   O ,   E ,   ...  ( C , D ,(( O ,( E ,(( B ) # H7 : :: 0 . 796 , A ) : 4 . 786 ) : 0 . 005 ) : 1 . 795 , # H7 : :: 0 . 204 ) : 10 . 0 ); \n\n  PhyloNetworks . HybridNetwork ,   Rooted   Network  12   edges  12   nodes :   6   tips ,   1   hybrid   nodes ,   5   internal   tree   nodes .  tip   labels :   C ,   D ,   B ,   A ,   ...  ( C , D ,( # H7 : :: 0 . 329 ,( B ,( A ,( E ,( O ) # H7 : :: 0 . 671 ) : 1 . 372 ) : 0 . 0 ) : 6 . 397 ) : 7 . 677 );   Next, we would like to extract the network scores from the file. Below is a one-liner to do this (we make Julia send a  sed  command to the shell \u2013sorry, Mac or Linux for this.)  julia  scoresInString = readstring(`sed -E  s/.+with -loglik ([0-9]+.[0-9]+).+/\\1/  $file`) 28.31506721890958\\n31.53556038078381\\n56.6454831016146\\n67.1777572749225\\n199.1140196105714\\n \n\njulia  scores = parse.(Float64, split(scoresInString))\n5-element Array{Float64,1}:\n  28.3151\n  31.5356\n  56.6455\n  67.1778\n 199.114\n\njulia  # next: update the  loglik  of each network with the score read from the file\n       for i in eachindex(netlist)\n          netlist[i].loglik = scores[i]\n          println( net $i in the list: score =  ,scores[i])\n       end\nnet 1 in the list: score = 28.31506721890958\nnet 2 in the list: score = 31.53556038078381\nnet 3 in the list: score = 56.6454831016146\nnet 4 in the list: score = 67.1777572749225\nnet 5 in the list: score = 199.1140196105714  The first network in the list is the best network returned by  snaq! . We see that the second network has a score that's not too far, but the other networks have worse scores. The best network and its best modification (second network in the list) are shown below. We chose to show edge numbers, to use them later to re-root the networks.  plot ( netlist [ 1 ],   : R ,   showGamma = true ,   showEdgeNumber = true ,   tipOffset = 0.1 );  R mtext( best net, score=28.3 , line=-1)  plot ( netlist [ 2 ],   : R ,   showGamma = true ,   showEdgeNumber = true ,   tipOffset = 0.1 );  R mtext( direction modified, score=31.5 , line=-1) ;    Now imagine that our outgroup is taxon A.   best network: we would get a \"RootMismatch\" error if we tried to set the root on the external edge 9 to A, with  rootatnode!(netlist[1], \"A\")  (see section  What if the root conflicts with the direction of a reticulation? ). But we could root the best network on the major parent edge to A, edge 10 (rooted network on the left below).  For the second best network in our list, there are 2 ways to root it with A: on the external edge 8 to A (top right), or on its parent edge 10 (bottom right). These 2 options give quite different rooted versions of the network, one of which requires the existence of an unsampled taxon, sister to BOECD, that would have contributed to introgression into an ancestor of E. The second rooted version says that an ancestor of (or sister to) A contributed to the introgression into the ancestor of E. A is an outgroup in both cases, but the second case is more parsimonious, in the sense that it does not require the existence of an unsampled taxon.   rootonedge! ( netlist [ 1 ],   10 );   # root best net to make A outgroup  rotate! ( netlist [ 1 ],   - 4 );   # to  un-cross  edges  rotate! ( netlist [ 1 ],   - 6 );  plot ( netlist [ 1 ],   : R ,   showGamma = true ,   tipOffset = 0.1 );  R mtext( best net, score=28.3 , line=-1) ;  rootatnode! ( netlist [ 2 ],   A );   # net with modified direction: first way to make A outgroup  plot ( netlist [ 2 ],   : R ,   showGamma = true ,   tipOffset = 0.1 );  R mtext( second best in list, score=31.5 \\n requires unsampled population , line=-2) ;  rootonedge! ( netlist [ 2 ],   10 )   # net with modified direction: second way to make A outgroup  plot ( netlist [ 2 ],   : R ,   showGamma = true ,   tipOffset = 0.1 );  R mtext( second best in list, score=31.5 \\n different root position , line=-2) ;", 
            "title": "Candidate networks compatible with a known outgroup"
        }, 
        {
            "location": "/man/expectedCFs/", 
            "text": "Extract Expected CFs\n\n\nA good way to visualize the \"goodness-of-fit\" of a given estimated network to the data is to plot the observed CF versus the expected CF. If the network is a good fit, then the dots in the plot will be close to the diagonal (x=y line). The following function will create a dataframe with the observed and expected CFs, which are all saved in the DataCF object after running snaq:\n\n\njulia\n topologyMaxQPseudolik!(truenet, raxmlCF);\n\njulia\n df_wide = fittedQuartetCF(raxmlCF) # same as fittedQuartetCF(raxmlCF, :wide)\n15\u00d710 DataFrames.DataFrame. Omitted printing of 2 columns\n\u2502 Row \u2502 tx1 \u2502 tx2 \u2502 tx3 \u2502 tx4 \u2502 obsCF12  \u2502 obsCF13   \u2502 obsCF14   \u2502 expCF12     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 1.0      \u2502 0.0       \u2502 0.0       \u2502 0.999949    \u2502\n\u2502 2   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 0.833333 \u2502 0.0333333 \u2502 0.133333  \u2502 0.835101    \u2502\n\u2502 3   \u2502 A   \u2502 B   \u2502 C   \u2502 O   \u2502 0.866667 \u2502 0.0       \u2502 0.133333  \u2502 0.860271    \u2502\n\u2502 4   \u2502 A   \u2502 B   \u2502 D   \u2502 E   \u2502 0.833333 \u2502 0.0333333 \u2502 0.133333  \u2502 0.835101    \u2502\n\u2502 5   \u2502 A   \u2502 B   \u2502 D   \u2502 O   \u2502 0.866667 \u2502 0.0       \u2502 0.133333  \u2502 0.860271    \u2502\n\u2502 6   \u2502 A   \u2502 B   \u2502 E   \u2502 O   \u2502 0.833333 \u2502 0.0666667 \u2502 0.1       \u2502 0.844588    \u2502\n\u2502 7   \u2502 A   \u2502 C   \u2502 D   \u2502 E   \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 0.000123577 \u2502\n\u2502 8   \u2502 A   \u2502 C   \u2502 D   \u2502 O   \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 0.000133914 \u2502\n\u2502 9   \u2502 A   \u2502 C   \u2502 E   \u2502 O   \u2502 0.533333 \u2502 0.333333  \u2502 0.133333  \u2502 0.598761    \u2502\n\u2502 10  \u2502 A   \u2502 D   \u2502 E   \u2502 O   \u2502 0.533333 \u2502 0.333333  \u2502 0.133333  \u2502 0.598761    \u2502\n\u2502 11  \u2502 B   \u2502 C   \u2502 D   \u2502 E   \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 0.000123577 \u2502\n\u2502 12  \u2502 B   \u2502 C   \u2502 D   \u2502 O   \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 0.000133914 \u2502\n\u2502 13  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 0.666667 \u2502 0.266667  \u2502 0.0666667 \u2502 0.598761    \u2502\n\u2502 14  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 0.666667 \u2502 0.266667  \u2502 0.0666667 \u2502 0.598761    \u2502\n\u2502 15  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 1.0      \u2502 0.0       \u2502 0.0       \u2502 0.999898    \u2502\n\njulia\n df_long = fittedQuartetCF(raxmlCF, :long)\n45\u00d77 DataFrames.DataFrame\n\u2502 Row \u2502 tx1 \u2502 tx2 \u2502 tx3 \u2502 tx4 \u2502 quartet \u2502 obsCF     \u2502 expCF      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 12_34   \u2502 1.0       \u2502 0.999949   \u2502\n\u2502 2   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 13_24   \u2502 0.0       \u2502 2.52737e-5 \u2502\n\u2502 3   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 14_23   \u2502 0.0       \u2502 2.52737e-5 \u2502\n\u2502 4   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 12_34   \u2502 0.833333  \u2502 0.835101   \u2502\n\u2502 5   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 13_24   \u2502 0.0333333 \u2502 0.0824494  \u2502\n\u2502 6   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 14_23   \u2502 0.133333  \u2502 0.0824494  \u2502\n\u2502 7   \u2502 A   \u2502 B   \u2502 C   \u2502 O   \u2502 12_34   \u2502 0.866667  \u2502 0.860271   \u2502\n\u2502 8   \u2502 A   \u2502 B   \u2502 C   \u2502 O   \u2502 13_24   \u2502 0.0       \u2502 0.0698646  \u2502\n\u22ee\n\u2502 37  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 12_34   \u2502 0.666667  \u2502 0.598761   \u2502\n\u2502 38  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.266667  \u2502 0.302023   \u2502\n\u2502 39  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0666667 \u2502 0.099216   \u2502\n\u2502 40  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 12_34   \u2502 0.666667  \u2502 0.598761   \u2502\n\u2502 41  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.266667  \u2502 0.302023   \u2502\n\u2502 42  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0666667 \u2502 0.099216   \u2502\n\u2502 43  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 12_34   \u2502 1.0       \u2502 0.999898   \u2502\n\u2502 44  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.0       \u2502 5.09658e-5 \u2502\n\u2502 45  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0       \u2502 5.09658e-5 \u2502\n\n\n\n\n\nIt is important to have run \nsnaq!\n, \ntopologyQPseudolik!\n or \ntopologyMaxQPseudolik!\n before making these tables, or the result would be meaningless. These functions update the fitted concordance factors (those expected under the network) inside the DataCF object \nraxmlCF\n.\n\n\nHere is one way to plot them, via R again, and using the R package \nggplot2\n.\n\n\nusing\n \nRCall\n\n\n\n\n\n\nTo install ggplot2 if not installed already, do: \nR\"install.packages('ggplot2', dep=TRUE)\"\n\n\n\n\n\n@rlibrary\n \nggplot2\n\n\nggplot\n(\ndf_long\n,\n \naes\n(\nx\n=:\nobsCF\n,\ny\n=:\nexpCF\n))\n \n+\n \ntheme_classic\n()\n \n+\n\n    \ngeom_segment\n(\nx\n=\n0\n,\ny\n=\n0\n,\nxend\n=\n1\n,\nyend\n=\n1\n,\n \ncolor\n=\n#008080\n,\n \nsize\n=\n0.3\n)\n \n+\n \n# diagonal line\n\n    \ngeom_point\n(\nalpha\n=\n0.5\n,\n \ncolor\n=\n#008080\n,\n \nposition\n=\nposition_jitter\n(\nwidth\n=\n0.005\n,\n \nheight\n=\n0.005\n))\n \n+\n\n    \nylab\n(\nquartet CF expected from network\n)\n \n+\n \nxlab\n(\nquartet CF observed in gene trees\n)\n \n+\n \ncoord_equal\n(\nratio\n=\n1\n);\n\n\n\n\n\n\n\n\n\n\n\nMany points are overlapping, so they were \"jittered\" a little to see them all better. There are always many points overlapping on the bottom-left corner: concordance factors of 0.0 for quartet resolutions not observed, and not expected.   To export the table of quartet CFs and explore the fit of the network with other tools:\n\n\nusing\n \nCSV\n\n\nCSV\n.\nwrite\n(\nfittedCF.csv\n,\n \ndf_long\n)\n\n\n\n\n\n\nalternative code to get a similar plot with \nGadfly\n:\n\n\nusing\n \nGadfly\n\n\nplot\n(\nlayer\n(\ndf_long\n,\n \nGeom\n.\npoint\n,\n \nx\n=\nobsCF\n,\n \ny\n=\nexpCF\n),\n\n     \nlayer\n(\nx\n=\n0\n:\n1\n,\ny\n=\n0\n:\n1\n,\n \nGeom\n.\nline\n),\n \n# diagonal line\n\n     \nGuide\n.\nxlabel\n(\nCF observed in gene trees\n),\n \nGuide\n.\nylabel\n(\nCF expected from network\n))\n\n\n\n\n\n\nWe could highlight quartets that include taxon A, say, if we suspect that it is an unrecognized hybrid. Many points are overlapping, like before, so they are again \"jittered\" a bit.\n\n\nusing\n \nDataFrames\n\n\ndf_long\n[\n:\nhas_A\n]\n \n=\n \nno\n \n# add a column to our data, to indicate which 4-taxon sets have A or not\n\n\nfor\n \nr\n \nin\n \neachrow\n(\ndf_long\n)\n\n    \nif\n \nA\n \n\u2208\n \n[\nr\n[\n:\ntx1\n],\n \nr\n[\n:\ntx2\n],\n \nr\n[\n:\ntx3\n],\n \nr\n[\n:\ntx4\n]]\n\n       \nr\n[\n:\nhas_A\n]\n=\nyes\n\n    \nend\n\n\nend\n\n\ndf_long\n\n\n\n\n\n\n45\u00d78 DataFrames.DataFrame\n\u2502 Row \u2502 tx1 \u2502 tx2 \u2502 tx3 \u2502 tx4 \u2502 quartet \u2502 obsCF     \u2502 expCF      \u2502 has_A \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 12_34   \u2502 1.0       \u2502 0.999949   \u2502 yes   \u2502\n\u2502 2   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 13_24   \u2502 0.0       \u2502 2.52737e-5 \u2502 yes   \u2502\n\u2502 3   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 14_23   \u2502 0.0       \u2502 2.52737e-5 \u2502 yes   \u2502\n\u2502 4   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 12_34   \u2502 0.833333  \u2502 0.835101   \u2502 yes   \u2502\n\u2502 5   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 13_24   \u2502 0.0333333 \u2502 0.0824494  \u2502 yes   \u2502\n\u2502 6   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 14_23   \u2502 0.133333  \u2502 0.0824494  \u2502 yes   \u2502\n\u2502 7   \u2502 A   \u2502 B   \u2502 C   \u2502 O   \u2502 12_34   \u2502 0.866667  \u2502 0.860271   \u2502 yes   \u2502\n\u2502 8   \u2502 A   \u2502 B   \u2502 C   \u2502 O   \u2502 13_24   \u2502 0.0       \u2502 0.0698646  \u2502 yes   \u2502\n\u22ee\n\u2502 37  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 12_34   \u2502 0.666667  \u2502 0.598761   \u2502 no    \u2502\n\u2502 38  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.266667  \u2502 0.302023   \u2502 no    \u2502\n\u2502 39  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0666667 \u2502 0.099216   \u2502 no    \u2502\n\u2502 40  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 12_34   \u2502 0.666667  \u2502 0.598761   \u2502 no    \u2502\n\u2502 41  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.266667  \u2502 0.302023   \u2502 no    \u2502\n\u2502 42  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0666667 \u2502 0.099216   \u2502 no    \u2502\n\u2502 43  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 12_34   \u2502 1.0       \u2502 0.999898   \u2502 no    \u2502\n\u2502 44  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.0       \u2502 5.09658e-5 \u2502 no    \u2502\n\u2502 45  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0       \u2502 5.09658e-5 \u2502 no    \u2502\n\n\n\n\n\nggplot\n(\ndf_long\n,\n \naes\n(\nx\n=:\nobsCF\n,\n \ny\n=:\nexpCF\n,\n \ncolor\n=:\nhas_A\n))\n \n+\n \ntheme_classic\n()\n \n+\n\n    \ngeom_segment\n(\nx\n=\n0\n,\ny\n=\n0\n,\nxend\n=\n1\n,\nyend\n=\n1\n,\n \ncolor\n=\nblack\n,\n \nsize\n=\n0.3\n)\n \n+\n \n# diagonal line\n\n    \ngeom_point\n(\nalpha\n=\n0.5\n,\n \nposition\n=\nposition_jitter\n(\nwidth\n=\n0.005\n,\n \nheight\n=\n0.005\n))\n \n+\n\n    \nylab\n(\nquartet CF expected from network\n)\n \n+\n \nxlab\n(\nquartet CF observed in gene trees\n)\n \n+\n \ncoord_equal\n(\nratio\n=\n1\n);", 
            "title": "Extract Expected CFs"
        }, 
        {
            "location": "/man/expectedCFs/#extract-expected-cfs", 
            "text": "A good way to visualize the \"goodness-of-fit\" of a given estimated network to the data is to plot the observed CF versus the expected CF. If the network is a good fit, then the dots in the plot will be close to the diagonal (x=y line). The following function will create a dataframe with the observed and expected CFs, which are all saved in the DataCF object after running snaq:  julia  topologyMaxQPseudolik!(truenet, raxmlCF);\n\njulia  df_wide = fittedQuartetCF(raxmlCF) # same as fittedQuartetCF(raxmlCF, :wide)\n15\u00d710 DataFrames.DataFrame. Omitted printing of 2 columns\n\u2502 Row \u2502 tx1 \u2502 tx2 \u2502 tx3 \u2502 tx4 \u2502 obsCF12  \u2502 obsCF13   \u2502 obsCF14   \u2502 expCF12     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 1.0      \u2502 0.0       \u2502 0.0       \u2502 0.999949    \u2502\n\u2502 2   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 0.833333 \u2502 0.0333333 \u2502 0.133333  \u2502 0.835101    \u2502\n\u2502 3   \u2502 A   \u2502 B   \u2502 C   \u2502 O   \u2502 0.866667 \u2502 0.0       \u2502 0.133333  \u2502 0.860271    \u2502\n\u2502 4   \u2502 A   \u2502 B   \u2502 D   \u2502 E   \u2502 0.833333 \u2502 0.0333333 \u2502 0.133333  \u2502 0.835101    \u2502\n\u2502 5   \u2502 A   \u2502 B   \u2502 D   \u2502 O   \u2502 0.866667 \u2502 0.0       \u2502 0.133333  \u2502 0.860271    \u2502\n\u2502 6   \u2502 A   \u2502 B   \u2502 E   \u2502 O   \u2502 0.833333 \u2502 0.0666667 \u2502 0.1       \u2502 0.844588    \u2502\n\u2502 7   \u2502 A   \u2502 C   \u2502 D   \u2502 E   \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 0.000123577 \u2502\n\u2502 8   \u2502 A   \u2502 C   \u2502 D   \u2502 O   \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 0.000133914 \u2502\n\u2502 9   \u2502 A   \u2502 C   \u2502 E   \u2502 O   \u2502 0.533333 \u2502 0.333333  \u2502 0.133333  \u2502 0.598761    \u2502\n\u2502 10  \u2502 A   \u2502 D   \u2502 E   \u2502 O   \u2502 0.533333 \u2502 0.333333  \u2502 0.133333  \u2502 0.598761    \u2502\n\u2502 11  \u2502 B   \u2502 C   \u2502 D   \u2502 E   \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 0.000123577 \u2502\n\u2502 12  \u2502 B   \u2502 C   \u2502 D   \u2502 O   \u2502 0.0      \u2502 0.0       \u2502 1.0       \u2502 0.000133914 \u2502\n\u2502 13  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 0.666667 \u2502 0.266667  \u2502 0.0666667 \u2502 0.598761    \u2502\n\u2502 14  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 0.666667 \u2502 0.266667  \u2502 0.0666667 \u2502 0.598761    \u2502\n\u2502 15  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 1.0      \u2502 0.0       \u2502 0.0       \u2502 0.999898    \u2502\n\njulia  df_long = fittedQuartetCF(raxmlCF, :long)\n45\u00d77 DataFrames.DataFrame\n\u2502 Row \u2502 tx1 \u2502 tx2 \u2502 tx3 \u2502 tx4 \u2502 quartet \u2502 obsCF     \u2502 expCF      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 12_34   \u2502 1.0       \u2502 0.999949   \u2502\n\u2502 2   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 13_24   \u2502 0.0       \u2502 2.52737e-5 \u2502\n\u2502 3   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 14_23   \u2502 0.0       \u2502 2.52737e-5 \u2502\n\u2502 4   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 12_34   \u2502 0.833333  \u2502 0.835101   \u2502\n\u2502 5   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 13_24   \u2502 0.0333333 \u2502 0.0824494  \u2502\n\u2502 6   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 14_23   \u2502 0.133333  \u2502 0.0824494  \u2502\n\u2502 7   \u2502 A   \u2502 B   \u2502 C   \u2502 O   \u2502 12_34   \u2502 0.866667  \u2502 0.860271   \u2502\n\u2502 8   \u2502 A   \u2502 B   \u2502 C   \u2502 O   \u2502 13_24   \u2502 0.0       \u2502 0.0698646  \u2502\n\u22ee\n\u2502 37  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 12_34   \u2502 0.666667  \u2502 0.598761   \u2502\n\u2502 38  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.266667  \u2502 0.302023   \u2502\n\u2502 39  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0666667 \u2502 0.099216   \u2502\n\u2502 40  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 12_34   \u2502 0.666667  \u2502 0.598761   \u2502\n\u2502 41  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.266667  \u2502 0.302023   \u2502\n\u2502 42  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0666667 \u2502 0.099216   \u2502\n\u2502 43  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 12_34   \u2502 1.0       \u2502 0.999898   \u2502\n\u2502 44  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.0       \u2502 5.09658e-5 \u2502\n\u2502 45  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0       \u2502 5.09658e-5 \u2502  It is important to have run  snaq! ,  topologyQPseudolik!  or  topologyMaxQPseudolik!  before making these tables, or the result would be meaningless. These functions update the fitted concordance factors (those expected under the network) inside the DataCF object  raxmlCF .  Here is one way to plot them, via R again, and using the R package  ggplot2 .  using   RCall   To install ggplot2 if not installed already, do:  R\"install.packages('ggplot2', dep=TRUE)\"   @rlibrary   ggplot2  ggplot ( df_long ,   aes ( x =: obsCF , y =: expCF ))   +   theme_classic ()   + \n     geom_segment ( x = 0 , y = 0 , xend = 1 , yend = 1 ,   color = #008080 ,   size = 0.3 )   +   # diagonal line \n     geom_point ( alpha = 0.5 ,   color = #008080 ,   position = position_jitter ( width = 0.005 ,   height = 0.005 ))   + \n     ylab ( quartet CF expected from network )   +   xlab ( quartet CF observed in gene trees )   +   coord_equal ( ratio = 1 );     Many points are overlapping, so they were \"jittered\" a little to see them all better. There are always many points overlapping on the bottom-left corner: concordance factors of 0.0 for quartet resolutions not observed, and not expected.   To export the table of quartet CFs and explore the fit of the network with other tools:  using   CSV  CSV . write ( fittedCF.csv ,   df_long )   alternative code to get a similar plot with  Gadfly :  using   Gadfly  plot ( layer ( df_long ,   Geom . point ,   x = obsCF ,   y = expCF ), \n      layer ( x = 0 : 1 , y = 0 : 1 ,   Geom . line ),   # diagonal line \n      Guide . xlabel ( CF observed in gene trees ),   Guide . ylabel ( CF expected from network ))   We could highlight quartets that include taxon A, say, if we suspect that it is an unrecognized hybrid. Many points are overlapping, like before, so they are again \"jittered\" a bit.  using   DataFrames  df_long [ : has_A ]   =   no   # add a column to our data, to indicate which 4-taxon sets have A or not  for   r   in   eachrow ( df_long ) \n     if   A   \u2208   [ r [ : tx1 ],   r [ : tx2 ],   r [ : tx3 ],   r [ : tx4 ]] \n        r [ : has_A ] = yes \n     end  end  df_long   45\u00d78 DataFrames.DataFrame\n\u2502 Row \u2502 tx1 \u2502 tx2 \u2502 tx3 \u2502 tx4 \u2502 quartet \u2502 obsCF     \u2502 expCF      \u2502 has_A \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 12_34   \u2502 1.0       \u2502 0.999949   \u2502 yes   \u2502\n\u2502 2   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 13_24   \u2502 0.0       \u2502 2.52737e-5 \u2502 yes   \u2502\n\u2502 3   \u2502 A   \u2502 B   \u2502 C   \u2502 D   \u2502 14_23   \u2502 0.0       \u2502 2.52737e-5 \u2502 yes   \u2502\n\u2502 4   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 12_34   \u2502 0.833333  \u2502 0.835101   \u2502 yes   \u2502\n\u2502 5   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 13_24   \u2502 0.0333333 \u2502 0.0824494  \u2502 yes   \u2502\n\u2502 6   \u2502 A   \u2502 B   \u2502 C   \u2502 E   \u2502 14_23   \u2502 0.133333  \u2502 0.0824494  \u2502 yes   \u2502\n\u2502 7   \u2502 A   \u2502 B   \u2502 C   \u2502 O   \u2502 12_34   \u2502 0.866667  \u2502 0.860271   \u2502 yes   \u2502\n\u2502 8   \u2502 A   \u2502 B   \u2502 C   \u2502 O   \u2502 13_24   \u2502 0.0       \u2502 0.0698646  \u2502 yes   \u2502\n\u22ee\n\u2502 37  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 12_34   \u2502 0.666667  \u2502 0.598761   \u2502 no    \u2502\n\u2502 38  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.266667  \u2502 0.302023   \u2502 no    \u2502\n\u2502 39  \u2502 B   \u2502 C   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0666667 \u2502 0.099216   \u2502 no    \u2502\n\u2502 40  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 12_34   \u2502 0.666667  \u2502 0.598761   \u2502 no    \u2502\n\u2502 41  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.266667  \u2502 0.302023   \u2502 no    \u2502\n\u2502 42  \u2502 B   \u2502 D   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0666667 \u2502 0.099216   \u2502 no    \u2502\n\u2502 43  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 12_34   \u2502 1.0       \u2502 0.999898   \u2502 no    \u2502\n\u2502 44  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 13_24   \u2502 0.0       \u2502 5.09658e-5 \u2502 no    \u2502\n\u2502 45  \u2502 C   \u2502 D   \u2502 E   \u2502 O   \u2502 14_23   \u2502 0.0       \u2502 5.09658e-5 \u2502 no    \u2502  ggplot ( df_long ,   aes ( x =: obsCF ,   y =: expCF ,   color =: has_A ))   +   theme_classic ()   + \n     geom_segment ( x = 0 , y = 0 , xend = 1 , yend = 1 ,   color = black ,   size = 0.3 )   +   # diagonal line \n     geom_point ( alpha = 0.5 ,   position = position_jitter ( width = 0.005 ,   height = 0.005 ))   + \n     ylab ( quartet CF expected from network )   +   xlab ( quartet CF observed in gene trees )   +   coord_equal ( ratio = 1 );", 
            "title": "Extract Expected CFs"
        }, 
        {
            "location": "/man/bootstrap/", 
            "text": "Bootstrap\n\n\n\n\nRunning a bootstrap analysis\n\n\nThere are two ways to do a bootstrap analysis.\n\n\n\n\nFrom quartet CFs with credibility intervals, such as if we used BUCKy. The \nTICR pipeline\n outputs a CF table with extra columns for credibility intervals. We could then read that table and get bootstrap networks like this, and tweak options as needed:\n\n\n\n\nusing\n \nCSV\n\n\ndf\n \n=\n \nCSV\n.\nread\n(\ntableCF_withCI.csv\n)\n\n\nbootnet\n \n=\n \nbootsnaq\n(\nstartnetwork\n,\n \ndf\n,\n \nhmax\n=\n1\n,\n \nfilename\n=\nbootstrap\n)\n\n\n\n\n\n\n\n\nAlternatively, we can use bootstrap gene trees: one file of bootstrap trees per gene. Here, the input is a text file that lists all the bootstrap files (one per gene). We demonstrate this option here.\n\n\n\n\nThe names of all our bootstrap files are listed in \"BSlistfiles\". (ASTRAL can use the same file to do its own bootstrap, see the \nwiki\n for more details). The function \nreadBootstrapTrees\n can read this list of file names, then read each bootstrap file to get the bootstrap sample for each gene. We can use them to sample input gene trees at random, one per gene, and estimate a network from them. We ask the \nbootsnaq\n function to repeat this resampling of bootstrap gene trees several times.\n\n\nbootTrees\n \n=\n \nreadBootstrapTrees\n(\nBSlistfiles\n);\n\n\nbootnet\n \n=\n \nbootsnaq\n(\nnet0\n,\n \nbootTrees\n,\n \nhmax\n=\n1\n,\n \nnrep\n=\n10\n,\n \nruns\n=\n3\n,\n\n                   \nfilename\n=\nbootsnaq\n,\n \nseed\n=\n4321\n)\n\n\n\n\n\n\nThe bootstrap networks are saved in the \nboostrap.out\n file, so they can be read in a new session with \nbootnet = readMultiTopology(\"bootsnap.out\")\n. To save the bootstrap networks to a different file (perhaps after having re-rooted them with an outgroup), we could do this: \nwriteMultiTopology(bootnet, \"bootstrapNets.tre\")\n.\n\n\nThe example above asks for 10 bootstrap replicates, which is definitely too few, to make the example run faster. We might also increase the number of optimization runs (\nruns\n) done for each bootstrap replicate. This bootstrap was run with the default 10 runs per replicate, and 100 bootstrap replicates, and the 100 bootstrap networks come with the package:\n\n\nbootnet\n \n=\n \nreadMultiTopology\n(\nPkg\n.\ndir\n(\nPhyloNetworks\n,\nexamples\n,\nbootsnaq.out\n));\n\n\nlength\n(\nbootnet\n)\n\n\n\n\n\n\n100\n\n\n\n\n\nIf we used a specified list of quartets on the original data, we should use that same list for the bootstrap analysis through the option \nquartetfile\n.\n\n\n\n\nsupport for tree edges\n\n\nNow that we have 100 bootstrap networks, we need to summarize what they have in common (highly supported features) and what they don't (areas of uncertainty).\n\n\nBefore summarizing these bootstrap networks on the best network, it is best to re-read this network to get a reproducible internal numbering of its nodes and edges, used later for mapping bootstrap support to edges.\n\n\nnet1\n \n=\n \nreadTopology\n(\njoinpath\n(\nPkg\n.\ndir\n(\nPhyloNetworks\n),\nexamples\n,\nnet1.out\n))\n\n\n\n\n\n\nPhyloNetworks\n.\nHybridNetwork\n,\n \nRooted\n \nNetwork\n\n\n12\n \nedges\n\n\n12\n \nnodes\n:\n \n6\n \ntips\n,\n \n1\n \nhybrid\n \nnodes\n,\n \n5\n \ninternal\n \ntree\n \nnodes\n.\n\n\ntip\n \nlabels\n:\n \nC\n,\n \nD\n,\n \nO\n,\n \nE\n,\n \n...\n\n\n(\nC\n,\nD\n,((\nO\n,(\nE\n,\n#\nH7\n:\n::\n0\n.\n196\n)\n:\n0\n.\n314\n)\n:\n0\n.\n664\n,(\nB\n,(\nA\n)\n#\nH7\n:\n::\n0\n.\n804\n)\n:\n10\n.\n0\n)\n:\n10\n.\n0\n);\n\n\n\n\n\n\nIt turns out that the direction of gene flow is quite uncertain in this example (see below) with a wrong direction inferred sometimes, so we re-root our best network net1 to the base of O,E, for the figures to be less confusing later.\n\n\nusing\n \nPhyloPlots\n,\n \nRCall\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nshowEdgeNumber\n=\ntrue\n);\n \n# edge 7 leads to O+E\n\n\nrootonedge!\n(\nnet1\n,\n \n7\n)\n \n# makes (O,E) outgroup clade\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nshowNodeNumber\n=\ntrue\n);\n\n\n\n\n\n\n \n\n\nEdges cross: but rotating at node -6 should remove this crossing of edges\n\n\nrotate!\n(\nnet1\n,\n \n-\n6\n)\n\n\n\n\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nshowGamma\n=\ntrue\n);\n\n\n\n\n\n\n\n\nWe can now summarize our bootstrap networks. The functions \ntreeEdgesBootstrap\n and \nhybridBootstrapSupport\n read all bootstrap networks and map the edges / nodes onto a reference network: here net1.\n\n\nBSe_tree\n,\n \ntree1\n \n=\n \ntreeEdgesBootstrap\n(\nbootnet\n,\nnet1\n);\n\n\n\n\n\n\nINFO\n:\n \nedge\n \nnumbers\n \nin\n \nthe\n \ndata\n \nframe\n \ncorrespond\n \nto\n \nthe\n \ncurrent\n \nedge\n \nnumbers\n \nin\n \nthe\n \nnetwork\n.\n\n\nIf\n \nthe\n \nnetwork\n \nis\n \nmodified\n,\n \nthe\n \nedge\n \nnumbers\n \nin\n \nthe\n \n(\nmodified\n)\n \nnetwork\n \nmight\n \nnot\n \ncorrespond\n\n\nto\n \nthose\n \nin\n \nthe\n \nbootstrap\n \ntable\n.\n \nPlot\n \nthe\n \nbootstrap\n \nvalues\n \nonto\n \nthe\n \ncurrent\n \nnetwork\n \nwith\n\n\nplot\n(\nnetwork_name\n,\n \nedgeLabel\n=\nbootstrap_table_name\n)\n\n\n\n\n\n\nThis calculates the major tree \ntree1\n displayed in \nnet1\n, that is, the tree obtained by following the major parent (\u03b3\n0.5) of each hybrid node. This tree can be visualized like this, with edge numbers shown for later use.\n\n\nplot\n(\ntree1\n,\n \n:\nR\n,\n \nshowEdgeNumber\n=\ntrue\n);\n\n\n\n\n\n\n\n\nNext, we can look at bootstrap table \nBSe_tree\n, which has one row for each tree edge in \nnet1\n. One column contains the edge number (same as shown in the plot) and another column contains the edge bootstrap support: the proportion of bootstrap replicates in which this edge was found in the major tree of the inferred network. We can see the full bootstrap table and see which tree edges have bootstrap support lower than 100% (none here) with\n\n\njulia\n showall(BSe_tree)\n3\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 edgeNumber \u2502 proportion \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 13         \u2502 100.0      \u2502\n\u2502 2   \u2502 11         \u2502 100.0      \u2502\n\u2502 3   \u2502 12         \u2502 100.0      \u2502\njulia\n BSe_tree[BSe_tree[:proportion] .\n 100.0, :]\n0\u00d72 DataFrames.DataFrame\n\n\n\n\n\nFinally, we can map the bootstrap proportions onto the network or its main tree by passing the bootstrap table to the \nedgeLabel\n option of \nplot\n:\n\n\nplot\n(\ntree1\n,\n \n:\nR\n,\n \nedgeLabel\n=\nBSe_tree\n);\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nedgeLabel\n=\nBSe_tree\n);\n\n\n\n\n\n\n \n\n\n(Here, it is important that the numbers assigned to edges when building the boostrap table \u2013those in \nnet1\n at the time\u2013 correspond to the current edge numbers in \ntree1\n and \nnet1\n. That was the purpose of reading the network from the output file of \nsnaq!\n earlier, for consistency across different Julia sessions.)\n\n\nIf we wanted to plot only certain bootstrap values, like those below 100% (1.0), we could do this:\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nedgeLabel\n=\nBSe_tree\n[\nBSe_tree\n[\n:\nproportion\n]\n \n.\n \n100.0\n,\n \n:\n]);\n\n\n\n\n\n\n\n\nsupport for hybrid edges and hybrid nodes\n\n\nSummarizing the placement of reticulations is not standard. The function \nhybridBootstrapSupport\n attempts to do so. The descendants of a given hybrid node form the \"recipient\" or \"hybrid\" clade, and is obtained after removing all other reticulations. If reticulation is due to gene flow or introgression, the minor hybrid edge (with \u03b3\n0.5) represents this event. The descendants of the lineage from which gene flow originated is then a second \"sister\" of the hybrid clade. Because of the reticulation event, the hybrid clade has 2 sister clades, not 1: the major sister (through the major hybrid edge with \u03b3\n0.5) and the minor sister (through the minor hybrid edge with \u03b3\n0.5). Note that the network says \nnothing\n about the process: its shows the \nrelationships\n only. We can calculate the frequency that each clade is a hybrid clade, or a major or minor sister for some other hybrid, in the bootstrap networks:\n\n\nBSn\n,\n \nBSe\n,\n \nBSc\n,\n \nBSgam\n,\n \nBSedgenum\n \n=\n \nhybridBootstrapSupport\n(\nbootnet\n,\n \nnet1\n);\n\n\n\n\n\n\nLet's look at the results. We can list all the clades and the percentage of bootstrap networks (bootstrap support) in which each clade is a hybrid or sister to a hybrid:\n\n\njulia\n BSn\n7\u00d79 DataFrames.DataFrame. Omitted printing of 3 columns\n\u2502 Row \u2502 clade    \u2502 node \u2502 hybridnode \u2502 edge \u2502 BS_hybrid \u2502 BS_sister \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 H7       \u2502 7    \u2502 5          \u2502 9    \u2502 33.0      \u2502 51.0      \u2502\n\u2502 2   \u2502 c_minus2 \u2502 -2   \u2502 -2         \u2502 12   \u2502 0.0       \u2502 55.0      \u2502\n\u2502 3   \u2502 E        \u2502 4    \u2502 4          \u2502 4    \u2502 12.0      \u2502 41.0      \u2502\n\u2502 4   \u2502 c_minus4 \u2502 -4   \u2502 -4         \u2502 7    \u2502 44.0      \u2502 0.0       \u2502\n\u2502 5   \u2502 B        \u2502 6    \u2502 6          \u2502 8    \u2502 2.0       \u2502 33.0      \u2502\n\u2502 6   \u2502 c_minus6 \u2502 -6   \u2502 -6         \u2502 11   \u2502 9.0       \u2502 7.0       \u2502\n\u2502 7   \u2502 O        \u2502 3    \u2502 3          \u2502 3    \u2502 0.0       \u2502 13.0      \u2502\n\n\n\n\n\nIf a clade contains a single taxon, it is listed with its taxon name. The clade found in the best network is listed with its tag, starting with H (e.g. \"H7\"). The name of other clades start with \"c_\" followed by their number in the best network, if they do appear in the best network. The node numbers, as used internally in the best network, are listed in a separate column. They can be used later to display the bootstrap support values onto the network. Various columns give the bootstrap support that each clade is a hybrid, or a (major/minor) sister to a hybrid. The last column gives the bootstrap support for the full relationship in the best network: same hybrid with same two sisters. These bootstrap values are associated with nodes (or possibly, their parent edges).\n\n\nTo see what is the clade named \"H7\", for instance:\n\n\njulia\n BSc # this might be too big\n6\u00d78 DataFrames.DataFrame\n\u2502 Row \u2502 taxa \u2502 O     \u2502 E     \u2502 c_minus4 \u2502 B     \u2502 H7    \u2502 c_minus6 \u2502 c_minus2 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 C    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 false \u2502 false    \u2502 true     \u2502\n\u2502 2   \u2502 D    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 false \u2502 false    \u2502 true     \u2502\n\u2502 3   \u2502 O    \u2502 true  \u2502 false \u2502 true     \u2502 false \u2502 false \u2502 false    \u2502 false    \u2502\n\u2502 4   \u2502 E    \u2502 false \u2502 true  \u2502 true     \u2502 false \u2502 false \u2502 false    \u2502 false    \u2502\n\u2502 5   \u2502 B    \u2502 false \u2502 false \u2502 false    \u2502 true  \u2502 false \u2502 true     \u2502 false    \u2502\n\u2502 6   \u2502 A    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 true  \u2502 true     \u2502 false    \u2502\n\njulia\n showall(BSc)\n6\u00d78 DataFrames.DataFrame\n\u2502 Row \u2502 taxa \u2502 O     \u2502 E     \u2502 c_minus4 \u2502 B     \u2502 H7    \u2502 c_minus6 \u2502 c_minus2 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 C    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 false \u2502 false    \u2502 true     \u2502\n\u2502 2   \u2502 D    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 false \u2502 false    \u2502 true     \u2502\n\u2502 3   \u2502 O    \u2502 true  \u2502 false \u2502 true     \u2502 false \u2502 false \u2502 false    \u2502 false    \u2502\n\u2502 4   \u2502 E    \u2502 false \u2502 true  \u2502 true     \u2502 false \u2502 false \u2502 false    \u2502 false    \u2502\n\u2502 5   \u2502 B    \u2502 false \u2502 false \u2502 false    \u2502 true  \u2502 false \u2502 true     \u2502 false    \u2502\n\u2502 6   \u2502 A    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 true  \u2502 true     \u2502 false    \u2502\njulia\n BSc[:taxa][BSc[:H7]]\n1-element Array{String,1}:\n \nA\n\n\n\n\n\n\nWe can also get bootstrap values associated with edges, to describe the support that a given hybrid clade has a given sister clade.\n\n\njulia\n BSe\n12\u00d78 DataFrames.DataFrame. Omitted printing of 3 columns\n\u2502 Row \u2502 edge    \u2502 hybrid_clade \u2502 hybrid \u2502 sister_clade \u2502 sister \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 10      \u2502 H7           \u2502 5      \u2502 B            \u2502 6      \u2502\n\u2502 2   \u2502 5       \u2502 H7           \u2502 5      \u2502 E            \u2502 4      \u2502\n\u2502 3   \u2502 missing \u2502 c_minus4     \u2502 -4     \u2502 c_minus2     \u2502 -2     \u2502\n\u2502 4   \u2502 missing \u2502 c_minus4     \u2502 -4     \u2502 H7           \u2502 7      \u2502\n\u2502 5   \u2502 missing \u2502 E            \u2502 4      \u2502 O            \u2502 3      \u2502\n\u2502 6   \u2502 missing \u2502 c_minus6     \u2502 -6     \u2502 c_minus2     \u2502 -2     \u2502\n\u2502 7   \u2502 missing \u2502 c_minus6     \u2502 -6     \u2502 E            \u2502 4      \u2502\n\u2502 8   \u2502 missing \u2502 E            \u2502 4      \u2502 c_minus6     \u2502 -6     \u2502\n\u2502 9   \u2502 missing \u2502 E            \u2502 4      \u2502 H7           \u2502 7      \u2502\n\u2502 10  \u2502 missing \u2502 B            \u2502 6      \u2502 H7           \u2502 7      \u2502\n\u2502 11  \u2502 missing \u2502 B            \u2502 6      \u2502 c_minus2     \u2502 -2     \u2502\n\u2502 12  \u2502 missing \u2502 H7           \u2502 5      \u2502 O            \u2502 3      \u2502\n\n\n\n\n\nHere, each row describes a pair of 2 clades: one being the hybrid, the other being its sister, connected by a hybrid edge. The first rows corresponds to hybrid edges in the best network. Other rows correspond to edges seen in bootstrap networks but not in the reference network.\n\n\njulia\n BSedgenum\n2-element Array{Int64,1}:\n 10\n  5\n\n\n\n\n\nlists all the hybrid edges in the best network, two for each hybrid node: the major parent edge and then the minor parent edge. In our case, there is only one reticulation, so only 2 hybrid edges.\n\n\nWe can plot the bootstrap values of the 2 hybrid edges in the best network:\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nedgeLabel\n=\nBSe\n[[\n:\nedge\n,\n:\nBS_hybrid_edge\n]]);\n\n\n\n\n\n\n\n\nThis is showing the bootstrap support each hybrid edge: percentage of bootstrap trees with an edge from the same sister clade to the same hybrid clade. Alternatively, we could show the bootstrap support for the full reticulation relationships in the network, one at each hybrid node (support for same hybrid with same sister clades). Here, we find that A received gene flow from E (and is sister to B otherwise) in just 32% of bootstrap networks. In another 1% bootstrap, A received gene flow from another source.\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nnodeLabel\n=\nBSn\n[[\n:\nhybridnode\n,\n:\nBS_hybrid_samesisters\n]]);\n\n\n\n\n\n\n\n\nBelow is example code to place tree edge support and hybrid edge support on the same plot.\n\n\ntmp\n \n=\n \nBSe\n[\n!\nisna\n(\nBSe\n[\n:\nedge\n]),[\n:\nedge\n,\n:\nBS_hybrid_edge\n]]\n\n\nrename!\n(\ntmp\n,\n \n:\nBS_hybrid_edge\n,\n \n:\nproportion\n)\n\n\nrename!\n(\ntmp\n,\n \n:\nedge\n,\n \n:\nedgeNumber\n)\n\n\ntmp\n \n=\n \nvcat\n(\nBSe_tree\n,\n \ntmp\n)\n\n\nplot\n(\nnet1\n,\n \nedgeLabel\n=\ntmp\n,\n \nnodeLabel\n=\nBSn\n[[\n:\nhybridnode\n,\n:\nBS_hybrid_samesisters\n]])\n\n\n\n\n\n\n\n\nWho are the hybrids in bootstrap networks?\n\n\nOn a different plot, we can show the bootstrap support for hybrid clades, first mapped to each node with positive hybrid support, and then mapped on the parent edge of these nodes. A is estimated as a hybrid in only 33% of our bootstrap networks. In another 44%, it is the lineage to (E,O) that is estimated as being of hybrid origin.\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nnodeLabel\n=\nBSn\n[\nBSn\n[\n:\nBS_hybrid\n]\n.\n0\n,\n \n[\n:\nhybridnode\n,\n:\nBS_hybrid\n]]);\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nedgeLabel\n=\nBSn\n[\nBSn\n[\n:\nBS_hybrid\n]\n.\n0\n,\n \n[\n:\nedge\n,\n:\nBS_hybrid\n]]);\n\n\n\n\n\n\n \n\n\n\n\nWhere is the origin of gene flow?\n\n\nWe can plot the support for the various placements of the gene flow origin (minor sister clade), first mapped to each node with positive support for being the origin of gene flow, and then mapped along the parent edge of these nodes. We filtered clades to show those with sister support \n 5%:\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nnodeLabel\n=\nBSn\n[\nBSn\n[\n:\nBS_minor_sister\n]\n.\n5\n,\n \n[\n:\nnode\n,\n:\nBS_minor_sister\n]]);\n\n\nplot\n(\nnet1\n,\n \n:\nR\n,\n \nedgeLabel\n=\nBSn\n[\nBSn\n[\n:\nBS_minor_sister\n]\n.\n5\n,\n \n[\n:\nedge\n,\n:\nBS_minor_sister\n]]);\n\n\n\n\n\n\n \n\n\nIn our best network, the lineage to E is estimated as the origin of gene flow, but this is recovered in only 41% of our bootstrap networks. In another 49%, it is the lineage to A that is estimated as the \norigin\n of gene flow: so gene flow is estimated in the opposite direction. In this example, there is support for gene flow between (A,B) and (E,O), but there is much uncertainty about its exact placement and about its direction.\n\n\nMapping the support for major sister clades might be interesting too:\n\n\nplot\n(\nnet1\n,\n \nnodeLabel\n=\nBSn\n[\nBSn\n[\n:\nBS_major_sister\n]\n.\n5\n,\n \n[\n:\nnode\n,\n:\nBS_major_sister\n]])\n\n\n\n\n\n\nThe estimated heritability \u03b3 on hybrid edges in the reference network, when present in a bootstrap network, was also extracted:\n\n\njulia\n BSgam[1:3,:] # first 3 rows only\n3\u00d72 Array{Float64,2}:\n 0.767833  0.232167\n 0.0       0.0\n 0.804412  0.195588\n\n\n\n\n\n\u03b3=0 values are for bootstrap replicates that did not have the edge in their network. Basic summaries on \u03b3 values for a given edge, say the minor parent, could be obtained like this:\n\n\njulia\n minimum(BSgam[:,2])\n0.0\n\njulia\n maximum(BSgam[:,2])\n0.2321667195572249\n\njulia\n mean(BSgam[:,2])\n0.062201290198789325\n\njulia\n std(BSgam[:,2])\n0.09131993802196252", 
            "title": "Bootstrap"
        }, 
        {
            "location": "/man/bootstrap/#bootstrap", 
            "text": "", 
            "title": "Bootstrap"
        }, 
        {
            "location": "/man/bootstrap/#running-a-bootstrap-analysis", 
            "text": "There are two ways to do a bootstrap analysis.   From quartet CFs with credibility intervals, such as if we used BUCKy. The  TICR pipeline  outputs a CF table with extra columns for credibility intervals. We could then read that table and get bootstrap networks like this, and tweak options as needed:   using   CSV  df   =   CSV . read ( tableCF_withCI.csv )  bootnet   =   bootsnaq ( startnetwork ,   df ,   hmax = 1 ,   filename = bootstrap )    Alternatively, we can use bootstrap gene trees: one file of bootstrap trees per gene. Here, the input is a text file that lists all the bootstrap files (one per gene). We demonstrate this option here.   The names of all our bootstrap files are listed in \"BSlistfiles\". (ASTRAL can use the same file to do its own bootstrap, see the  wiki  for more details). The function  readBootstrapTrees  can read this list of file names, then read each bootstrap file to get the bootstrap sample for each gene. We can use them to sample input gene trees at random, one per gene, and estimate a network from them. We ask the  bootsnaq  function to repeat this resampling of bootstrap gene trees several times.  bootTrees   =   readBootstrapTrees ( BSlistfiles );  bootnet   =   bootsnaq ( net0 ,   bootTrees ,   hmax = 1 ,   nrep = 10 ,   runs = 3 , \n                    filename = bootsnaq ,   seed = 4321 )   The bootstrap networks are saved in the  boostrap.out  file, so they can be read in a new session with  bootnet = readMultiTopology(\"bootsnap.out\") . To save the bootstrap networks to a different file (perhaps after having re-rooted them with an outgroup), we could do this:  writeMultiTopology(bootnet, \"bootstrapNets.tre\") .  The example above asks for 10 bootstrap replicates, which is definitely too few, to make the example run faster. We might also increase the number of optimization runs ( runs ) done for each bootstrap replicate. This bootstrap was run with the default 10 runs per replicate, and 100 bootstrap replicates, and the 100 bootstrap networks come with the package:  bootnet   =   readMultiTopology ( Pkg . dir ( PhyloNetworks , examples , bootsnaq.out ));  length ( bootnet )   100  If we used a specified list of quartets on the original data, we should use that same list for the bootstrap analysis through the option  quartetfile .", 
            "title": "Running a bootstrap analysis"
        }, 
        {
            "location": "/man/bootstrap/#support-for-tree-edges", 
            "text": "Now that we have 100 bootstrap networks, we need to summarize what they have in common (highly supported features) and what they don't (areas of uncertainty).  Before summarizing these bootstrap networks on the best network, it is best to re-read this network to get a reproducible internal numbering of its nodes and edges, used later for mapping bootstrap support to edges.  net1   =   readTopology ( joinpath ( Pkg . dir ( PhyloNetworks ), examples , net1.out ))   PhyloNetworks . HybridNetwork ,   Rooted   Network  12   edges  12   nodes :   6   tips ,   1   hybrid   nodes ,   5   internal   tree   nodes .  tip   labels :   C ,   D ,   O ,   E ,   ...  ( C , D ,(( O ,( E , # H7 : :: 0 . 196 ) : 0 . 314 ) : 0 . 664 ,( B ,( A ) # H7 : :: 0 . 804 ) : 10 . 0 ) : 10 . 0 );   It turns out that the direction of gene flow is quite uncertain in this example (see below) with a wrong direction inferred sometimes, so we re-root our best network net1 to the base of O,E, for the figures to be less confusing later.  using   PhyloPlots ,   RCall  plot ( net1 ,   : R ,   showEdgeNumber = true );   # edge 7 leads to O+E  rootonedge! ( net1 ,   7 )   # makes (O,E) outgroup clade  plot ( net1 ,   : R ,   showNodeNumber = true );      Edges cross: but rotating at node -6 should remove this crossing of edges  rotate! ( net1 ,   - 6 )   plot ( net1 ,   : R ,   showGamma = true );    We can now summarize our bootstrap networks. The functions  treeEdgesBootstrap  and  hybridBootstrapSupport  read all bootstrap networks and map the edges / nodes onto a reference network: here net1.  BSe_tree ,   tree1   =   treeEdgesBootstrap ( bootnet , net1 );   INFO :   edge   numbers   in   the   data   frame   correspond   to   the   current   edge   numbers   in   the   network .  If   the   network   is   modified ,   the   edge   numbers   in   the   ( modified )   network   might   not   correspond  to   those   in   the   bootstrap   table .   Plot   the   bootstrap   values   onto   the   current   network   with  plot ( network_name ,   edgeLabel = bootstrap_table_name )   This calculates the major tree  tree1  displayed in  net1 , that is, the tree obtained by following the major parent (\u03b3 0.5) of each hybrid node. This tree can be visualized like this, with edge numbers shown for later use.  plot ( tree1 ,   : R ,   showEdgeNumber = true );    Next, we can look at bootstrap table  BSe_tree , which has one row for each tree edge in  net1 . One column contains the edge number (same as shown in the plot) and another column contains the edge bootstrap support: the proportion of bootstrap replicates in which this edge was found in the major tree of the inferred network. We can see the full bootstrap table and see which tree edges have bootstrap support lower than 100% (none here) with  julia  showall(BSe_tree)\n3\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 edgeNumber \u2502 proportion \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 13         \u2502 100.0      \u2502\n\u2502 2   \u2502 11         \u2502 100.0      \u2502\n\u2502 3   \u2502 12         \u2502 100.0      \u2502\njulia  BSe_tree[BSe_tree[:proportion] .  100.0, :]\n0\u00d72 DataFrames.DataFrame  Finally, we can map the bootstrap proportions onto the network or its main tree by passing the bootstrap table to the  edgeLabel  option of  plot :  plot ( tree1 ,   : R ,   edgeLabel = BSe_tree );  plot ( net1 ,   : R ,   edgeLabel = BSe_tree );      (Here, it is important that the numbers assigned to edges when building the boostrap table \u2013those in  net1  at the time\u2013 correspond to the current edge numbers in  tree1  and  net1 . That was the purpose of reading the network from the output file of  snaq!  earlier, for consistency across different Julia sessions.)  If we wanted to plot only certain bootstrap values, like those below 100% (1.0), we could do this:  plot ( net1 ,   : R ,   edgeLabel = BSe_tree [ BSe_tree [ : proportion ]   .   100.0 ,   : ]);", 
            "title": "support for tree edges"
        }, 
        {
            "location": "/man/bootstrap/#support-for-hybrid-edges-and-hybrid-nodes", 
            "text": "Summarizing the placement of reticulations is not standard. The function  hybridBootstrapSupport  attempts to do so. The descendants of a given hybrid node form the \"recipient\" or \"hybrid\" clade, and is obtained after removing all other reticulations. If reticulation is due to gene flow or introgression, the minor hybrid edge (with \u03b3 0.5) represents this event. The descendants of the lineage from which gene flow originated is then a second \"sister\" of the hybrid clade. Because of the reticulation event, the hybrid clade has 2 sister clades, not 1: the major sister (through the major hybrid edge with \u03b3 0.5) and the minor sister (through the minor hybrid edge with \u03b3 0.5). Note that the network says  nothing  about the process: its shows the  relationships  only. We can calculate the frequency that each clade is a hybrid clade, or a major or minor sister for some other hybrid, in the bootstrap networks:  BSn ,   BSe ,   BSc ,   BSgam ,   BSedgenum   =   hybridBootstrapSupport ( bootnet ,   net1 );   Let's look at the results. We can list all the clades and the percentage of bootstrap networks (bootstrap support) in which each clade is a hybrid or sister to a hybrid:  julia  BSn\n7\u00d79 DataFrames.DataFrame. Omitted printing of 3 columns\n\u2502 Row \u2502 clade    \u2502 node \u2502 hybridnode \u2502 edge \u2502 BS_hybrid \u2502 BS_sister \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 H7       \u2502 7    \u2502 5          \u2502 9    \u2502 33.0      \u2502 51.0      \u2502\n\u2502 2   \u2502 c_minus2 \u2502 -2   \u2502 -2         \u2502 12   \u2502 0.0       \u2502 55.0      \u2502\n\u2502 3   \u2502 E        \u2502 4    \u2502 4          \u2502 4    \u2502 12.0      \u2502 41.0      \u2502\n\u2502 4   \u2502 c_minus4 \u2502 -4   \u2502 -4         \u2502 7    \u2502 44.0      \u2502 0.0       \u2502\n\u2502 5   \u2502 B        \u2502 6    \u2502 6          \u2502 8    \u2502 2.0       \u2502 33.0      \u2502\n\u2502 6   \u2502 c_minus6 \u2502 -6   \u2502 -6         \u2502 11   \u2502 9.0       \u2502 7.0       \u2502\n\u2502 7   \u2502 O        \u2502 3    \u2502 3          \u2502 3    \u2502 0.0       \u2502 13.0      \u2502  If a clade contains a single taxon, it is listed with its taxon name. The clade found in the best network is listed with its tag, starting with H (e.g. \"H7\"). The name of other clades start with \"c_\" followed by their number in the best network, if they do appear in the best network. The node numbers, as used internally in the best network, are listed in a separate column. They can be used later to display the bootstrap support values onto the network. Various columns give the bootstrap support that each clade is a hybrid, or a (major/minor) sister to a hybrid. The last column gives the bootstrap support for the full relationship in the best network: same hybrid with same two sisters. These bootstrap values are associated with nodes (or possibly, their parent edges).  To see what is the clade named \"H7\", for instance:  julia  BSc # this might be too big\n6\u00d78 DataFrames.DataFrame\n\u2502 Row \u2502 taxa \u2502 O     \u2502 E     \u2502 c_minus4 \u2502 B     \u2502 H7    \u2502 c_minus6 \u2502 c_minus2 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 C    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 false \u2502 false    \u2502 true     \u2502\n\u2502 2   \u2502 D    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 false \u2502 false    \u2502 true     \u2502\n\u2502 3   \u2502 O    \u2502 true  \u2502 false \u2502 true     \u2502 false \u2502 false \u2502 false    \u2502 false    \u2502\n\u2502 4   \u2502 E    \u2502 false \u2502 true  \u2502 true     \u2502 false \u2502 false \u2502 false    \u2502 false    \u2502\n\u2502 5   \u2502 B    \u2502 false \u2502 false \u2502 false    \u2502 true  \u2502 false \u2502 true     \u2502 false    \u2502\n\u2502 6   \u2502 A    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 true  \u2502 true     \u2502 false    \u2502\n\njulia  showall(BSc)\n6\u00d78 DataFrames.DataFrame\n\u2502 Row \u2502 taxa \u2502 O     \u2502 E     \u2502 c_minus4 \u2502 B     \u2502 H7    \u2502 c_minus6 \u2502 c_minus2 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 C    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 false \u2502 false    \u2502 true     \u2502\n\u2502 2   \u2502 D    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 false \u2502 false    \u2502 true     \u2502\n\u2502 3   \u2502 O    \u2502 true  \u2502 false \u2502 true     \u2502 false \u2502 false \u2502 false    \u2502 false    \u2502\n\u2502 4   \u2502 E    \u2502 false \u2502 true  \u2502 true     \u2502 false \u2502 false \u2502 false    \u2502 false    \u2502\n\u2502 5   \u2502 B    \u2502 false \u2502 false \u2502 false    \u2502 true  \u2502 false \u2502 true     \u2502 false    \u2502\n\u2502 6   \u2502 A    \u2502 false \u2502 false \u2502 false    \u2502 false \u2502 true  \u2502 true     \u2502 false    \u2502\njulia  BSc[:taxa][BSc[:H7]]\n1-element Array{String,1}:\n  A   We can also get bootstrap values associated with edges, to describe the support that a given hybrid clade has a given sister clade.  julia  BSe\n12\u00d78 DataFrames.DataFrame. Omitted printing of 3 columns\n\u2502 Row \u2502 edge    \u2502 hybrid_clade \u2502 hybrid \u2502 sister_clade \u2502 sister \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 10      \u2502 H7           \u2502 5      \u2502 B            \u2502 6      \u2502\n\u2502 2   \u2502 5       \u2502 H7           \u2502 5      \u2502 E            \u2502 4      \u2502\n\u2502 3   \u2502 missing \u2502 c_minus4     \u2502 -4     \u2502 c_minus2     \u2502 -2     \u2502\n\u2502 4   \u2502 missing \u2502 c_minus4     \u2502 -4     \u2502 H7           \u2502 7      \u2502\n\u2502 5   \u2502 missing \u2502 E            \u2502 4      \u2502 O            \u2502 3      \u2502\n\u2502 6   \u2502 missing \u2502 c_minus6     \u2502 -6     \u2502 c_minus2     \u2502 -2     \u2502\n\u2502 7   \u2502 missing \u2502 c_minus6     \u2502 -6     \u2502 E            \u2502 4      \u2502\n\u2502 8   \u2502 missing \u2502 E            \u2502 4      \u2502 c_minus6     \u2502 -6     \u2502\n\u2502 9   \u2502 missing \u2502 E            \u2502 4      \u2502 H7           \u2502 7      \u2502\n\u2502 10  \u2502 missing \u2502 B            \u2502 6      \u2502 H7           \u2502 7      \u2502\n\u2502 11  \u2502 missing \u2502 B            \u2502 6      \u2502 c_minus2     \u2502 -2     \u2502\n\u2502 12  \u2502 missing \u2502 H7           \u2502 5      \u2502 O            \u2502 3      \u2502  Here, each row describes a pair of 2 clades: one being the hybrid, the other being its sister, connected by a hybrid edge. The first rows corresponds to hybrid edges in the best network. Other rows correspond to edges seen in bootstrap networks but not in the reference network.  julia  BSedgenum\n2-element Array{Int64,1}:\n 10\n  5  lists all the hybrid edges in the best network, two for each hybrid node: the major parent edge and then the minor parent edge. In our case, there is only one reticulation, so only 2 hybrid edges.  We can plot the bootstrap values of the 2 hybrid edges in the best network:  plot ( net1 ,   : R ,   edgeLabel = BSe [[ : edge , : BS_hybrid_edge ]]);    This is showing the bootstrap support each hybrid edge: percentage of bootstrap trees with an edge from the same sister clade to the same hybrid clade. Alternatively, we could show the bootstrap support for the full reticulation relationships in the network, one at each hybrid node (support for same hybrid with same sister clades). Here, we find that A received gene flow from E (and is sister to B otherwise) in just 32% of bootstrap networks. In another 1% bootstrap, A received gene flow from another source.  plot ( net1 ,   : R ,   nodeLabel = BSn [[ : hybridnode , : BS_hybrid_samesisters ]]);    Below is example code to place tree edge support and hybrid edge support on the same plot.  tmp   =   BSe [ ! isna ( BSe [ : edge ]),[ : edge , : BS_hybrid_edge ]]  rename! ( tmp ,   : BS_hybrid_edge ,   : proportion )  rename! ( tmp ,   : edge ,   : edgeNumber )  tmp   =   vcat ( BSe_tree ,   tmp )  plot ( net1 ,   edgeLabel = tmp ,   nodeLabel = BSn [[ : hybridnode , : BS_hybrid_samesisters ]])", 
            "title": "support for hybrid edges and hybrid nodes"
        }, 
        {
            "location": "/man/bootstrap/#who-are-the-hybrids-in-bootstrap-networks", 
            "text": "On a different plot, we can show the bootstrap support for hybrid clades, first mapped to each node with positive hybrid support, and then mapped on the parent edge of these nodes. A is estimated as a hybrid in only 33% of our bootstrap networks. In another 44%, it is the lineage to (E,O) that is estimated as being of hybrid origin.  plot ( net1 ,   : R ,   nodeLabel = BSn [ BSn [ : BS_hybrid ] . 0 ,   [ : hybridnode , : BS_hybrid ]]);  plot ( net1 ,   : R ,   edgeLabel = BSn [ BSn [ : BS_hybrid ] . 0 ,   [ : edge , : BS_hybrid ]]);", 
            "title": "Who are the hybrids in bootstrap networks?"
        }, 
        {
            "location": "/man/bootstrap/#where-is-the-origin-of-gene-flow", 
            "text": "We can plot the support for the various placements of the gene flow origin (minor sister clade), first mapped to each node with positive support for being the origin of gene flow, and then mapped along the parent edge of these nodes. We filtered clades to show those with sister support   5%:  plot ( net1 ,   : R ,   nodeLabel = BSn [ BSn [ : BS_minor_sister ] . 5 ,   [ : node , : BS_minor_sister ]]);  plot ( net1 ,   : R ,   edgeLabel = BSn [ BSn [ : BS_minor_sister ] . 5 ,   [ : edge , : BS_minor_sister ]]);      In our best network, the lineage to E is estimated as the origin of gene flow, but this is recovered in only 41% of our bootstrap networks. In another 49%, it is the lineage to A that is estimated as the  origin  of gene flow: so gene flow is estimated in the opposite direction. In this example, there is support for gene flow between (A,B) and (E,O), but there is much uncertainty about its exact placement and about its direction.  Mapping the support for major sister clades might be interesting too:  plot ( net1 ,   nodeLabel = BSn [ BSn [ : BS_major_sister ] . 5 ,   [ : node , : BS_major_sister ]])   The estimated heritability \u03b3 on hybrid edges in the reference network, when present in a bootstrap network, was also extracted:  julia  BSgam[1:3,:] # first 3 rows only\n3\u00d72 Array{Float64,2}:\n 0.767833  0.232167\n 0.0       0.0\n 0.804412  0.195588  \u03b3=0 values are for bootstrap replicates that did not have the edge in their network. Basic summaries on \u03b3 values for a given edge, say the minor parent, could be obtained like this:  julia  minimum(BSgam[:,2])\n0.0\n\njulia  maximum(BSgam[:,2])\n0.2321667195572249\n\njulia  mean(BSgam[:,2])\n0.062201290198789325\n\njulia  std(BSgam[:,2])\n0.09131993802196252", 
            "title": "Where is the origin of gene flow?"
        }, 
        {
            "location": "/man/multiplealleles/", 
            "text": "Multiple alleles per species\n\n\nThe default setting for SNaQ considers that each allele in a gene tree corresponds to a taxon (a tip) in the network. If instead each allele/individual can be mapped confidently to a species, and if only the species-level network needs to be estimated, then the following functions should be used:\n\n\ndf_sp\n \n=\n \nmapAllelesCFtable\n(\nmappingFile\n,\n \nCFtable_ind\n);\n\n\nd_sp\n \n=\n \nreadTableCF!\n(\ndf_sp\n);\n\n\n\n\n\n\nwhere the mapping file can be a text (or \ncsv\n) file with two columns named \nallele\n and \nspecies\n, mapping each allele name to a species name. The CF table \nCFtable_ind\n should be a table of concordance factors at the level of individuals. In other words, it should list CFs using one row for each set of 4 alleles/individuals. The first command creates a new data frame \ndf_sp\n of quartet concordance factors at the species level: with the allele names replaced by the appropriate species names.\n\n\nThe second command modifies this data frame \ndf_sp\n by deleting rows that are uninformative about between-species relationships, such as rows corresponding to 4 individuals from the same species. The output \nd_sp\n of this second command is an object of type \nDataCF\n at the species level, which can be used as input for networks estimation with \nsnaq!\n:\n\n\nnet\n \n=\n \nsnaq!\n(\nT_sp\n,\n \nd_sp\n);\n\n\n\n\n\n\nwhere \nT_sp\n should be a starting topology with one tip per species, labelled with the same species names as the names used in the mapping file.\n\n\nWarnings:\n\n\n\n\nThis feature has not been fully tested\n\n\nThis procedure is slow and should be made faster, when working with gene trees as input.\n\n\n\n\nIf input data are gene trees, the CF table at the individual level should be created first, like this:\n\n\njulia\nCFtable_ind = readTrees2CF(gene tree file);\n\n\nbefore applying the two commands above. At this time, however, this procedure requires that all alleles from the same individual are given the same name (the individual's 'name') across all genes for which that individual was sequenced.", 
            "title": "Multiple Alleles"
        }, 
        {
            "location": "/man/multiplealleles/#multiple-alleles-per-species", 
            "text": "The default setting for SNaQ considers that each allele in a gene tree corresponds to a taxon (a tip) in the network. If instead each allele/individual can be mapped confidently to a species, and if only the species-level network needs to be estimated, then the following functions should be used:  df_sp   =   mapAllelesCFtable ( mappingFile ,   CFtable_ind );  d_sp   =   readTableCF! ( df_sp );   where the mapping file can be a text (or  csv ) file with two columns named  allele  and  species , mapping each allele name to a species name. The CF table  CFtable_ind  should be a table of concordance factors at the level of individuals. In other words, it should list CFs using one row for each set of 4 alleles/individuals. The first command creates a new data frame  df_sp  of quartet concordance factors at the species level: with the allele names replaced by the appropriate species names.  The second command modifies this data frame  df_sp  by deleting rows that are uninformative about between-species relationships, such as rows corresponding to 4 individuals from the same species. The output  d_sp  of this second command is an object of type  DataCF  at the species level, which can be used as input for networks estimation with  snaq! :  net   =   snaq! ( T_sp ,   d_sp );   where  T_sp  should be a starting topology with one tip per species, labelled with the same species names as the names used in the mapping file.  Warnings:   This feature has not been fully tested  This procedure is slow and should be made faster, when working with gene trees as input.   If input data are gene trees, the CF table at the individual level should be created first, like this:  julia\nCFtable_ind = readTrees2CF(gene tree file);  before applying the two commands above. At this time, however, this procedure requires that all alleles from the same individual are given the same name (the individual's 'name') across all genes for which that individual was sequenced.", 
            "title": "Multiple alleles per species"
        }, 
        {
            "location": "/man/trait_tree/", 
            "text": "Continuous Trait Evolution\n\n\nOnce the network is inferred, we can take these species relationships into account when studying the distribution of quantitative traits measured for extant species. This is the goal of phylogenetic comparative methods (PCM). More details can be found on the developments below in Bastide et al. 2018\n1\n\n\nWe assume a fixed network, correctly rooted, with branch lengths proportional to calendar time. Here, we consider the true network that was used in the previous sections, and which is ultrametric (all the tips are contemporary).\n\n\ntruenet\n \n=\n \nreadTopology\n(\n((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\n);\n\n\n\n\n\n\nAs previously, we can plot the network thanks to the \nRCall\n package. The \nname\n function is only instrumental here, to ensure that the figure is saved in the correct directory when the documentation is built. We only show the commands to actually save the plot in this first example for the interested reader, but we will hide those in the rest of the chapter, for the sake of clarity.\n\n\nusing\n \nPhyloPlots\n,\n \nRCall\n\n\nR\nname \n- function(x) file.path(\n..\n, \nassets\n, \nfigures\n, x)\n\n\nR\nsvg(name(\ntruenet.svg\n), width=8, height=4)\n\n\nR\npar(mar = c(0, 0, 0, 0))\n\n\nplot\n(\ntruenet\n,\n \n:\nR\n,\n \nuseEdgeLength\n=\ntrue\n,\n \nshowGamma\n=\ntrue\n);\n\n\nR\ndev.off()\n\n\n\n\n\n\n\n\n\n\nModel and Variance Matrix\n\n\nAssuming that the network is known and that the continuous traits evolve like a Brownian Motion (BM) in time, it is possible to compute the expected variance covariance matrix between tip measurements. This can be done using function \nvcv\n, whose syntax is inspired from the well known corresponding \nape\n function.\n\n\nC\n \n=\n \nvcv\n(\ntruenet\n)\n\n\n\n\n\n\n6\u00d76 DataFrames.DataFrame\n\u2502 Row \u2502 D    \u2502 C    \u2502 A     \u2502 B     \u2502 E    \u2502 O    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 11.2 \u2502 10.8 \u2502 4.8   \u2502 4.8   \u2502 2.0  \u2502 0.0  \u2502\n\u2502 2   \u2502 10.8 \u2502 11.2 \u2502 4.8   \u2502 4.8   \u2502 2.0  \u2502 0.0  \u2502\n\u2502 3   \u2502 4.8  \u2502 4.8  \u2502 8.596 \u2502 7.796 \u2502 3.86 \u2502 0.0  \u2502\n\u2502 4   \u2502 4.8  \u2502 4.8  \u2502 7.796 \u2502 8.596 \u2502 3.86 \u2502 0.0  \u2502\n\u2502 5   \u2502 2.0  \u2502 2.0  \u2502 3.86  \u2502 3.86  \u2502 11.2 \u2502 0.0  \u2502\n\u2502 6   \u2502 0.0  \u2502 0.0  \u2502 0.0   \u2502 0.0   \u2502 0.0  \u2502 11.2 \u2502\n\n\n\n\n\nThe matrix is returned as a \nDataFrame\n, with columns named by the tips of the network to allow for easy identification.\n\n\nThe computation of this matrix is based on the more general function \nsharedPathMatrix\n. It is at the core of all the Phylogenetic Comparative Methods described below.\n\n\n\n\nTrait simulation\n\n\nWe start by generating continuous traits to study. We simulate three traits on the network (two independent, one dependent), using a Brownian Motion (BM) model of trait evolution on the network. We start by choosing the parameters of the BM (ancestral mean and variance), by creating objects of class \nParamsBM\n:ParamsProcess\n.\n\n\nparams_trait1\n \n=\n \nParamsBM\n(\n \n2\n,\n \n0.5\n)\n \n# BM with mean  2 and variance 0.5\n\n\nparams_trait2\n \n=\n \nParamsBM\n(\n-\n2\n,\n \n1\n)\n   \n# BM with mean -2 and variance 1.0\n\n\n\n\n\n\nWe then simulate the independent traits according to these parameters, using function \nsimulate\n (fixing the seed, for reproducibility).\n\n\nsrand\n(\n18480224\n);\n\n\nsim1\n \n=\n \nsimulate\n(\ntruenet\n,\n \nparams_trait1\n)\n \n# simulate a BM on truenet\n\n\nsim2\n \n=\n \nsimulate\n(\ntruenet\n,\n \nparams_trait2\n)\n\n\n\n\n\n\nThis creates objects of class \nTraitSimulation\n, from which we can extract the data at the tips, thanks to the method \ngetindex(::TraitSimulation, ::Symbol)\n.\n\n\ntrait1\n \n=\n \nsim1\n[\n:\nTips\n]\n \n# trait 1 at the tips (data)\n\n\ntrait2\n \n=\n \nsim2\n[\n:\nTips\n]\n\n\n\n\n\n\nThis extractor creates an \nArray\n with one column, and as many lines as the number of tips there are in the phylogeny.  It is sorted in the same order as the tips of the phylogeny used to simulate it.   If needed, we could also extract the simulated values at the internal nodes in the network:\n\n\nsim1\n[\n:\nInternalNodes\n]\n\n\n\n\n\n\nFinally, we generate the last trait correlated with trait 1 (but not trait 2), with phylogenetic noise.\n\n\nsrand\n(\n18700904\n);\n\n\nnoise\n \n=\n \nsimulate\n(\ntruenet\n,\n \nParamsBM\n(\n0\n,\n \n0.1\n))\n \n# phylogenetic residuals\n\n\ntrait3\n \n=\n \n10\n \n+\n \n2\n \n*\n \ntrait1\n \n+\n \nnoise\n[\n:\nTips\n]\n \n# trait to study. independent of trait2\n\n\n\n\n\n\n\n\nPhylogenetic regression\n\n\nAssume that we measured the three traits above, and that we wanted to study the impact of traits 1 and 2 on trait 3. To do that, we can perform a phylogenetic regression.\n\n\nIn order to avoid confusion, the function takes in a \nDataFrame\n, that has an extra column with the names of the tips of the network, labeled \ntipNames\n. Here, we generated the traits ourselves, so they are all in the same order.\n\n\nusing\n \nDataFrames\n\n\ndat\n \n=\n \nDataFrame\n(\ntrait1\n \n=\n \ntrait1\n,\n \ntrait2\n \n=\n \ntrait2\n,\n \ntrait3\n \n=\n \ntrait3\n,\n\n                \ntipNames\n \n=\n \ntipLabels\n(\nsim1\n))\n\n\n\n\n\n\n6\u00d74 DataFrames.DataFrame\n\u2502 Row \u2502 trait1  \u2502 trait2   \u2502 trait3  \u2502 tipNames \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 4.08298 \u2502 -7.34186 \u2502 16.673  \u2502 D        \u2502\n\u2502 2   \u2502 3.10782 \u2502 -7.45085 \u2502 15.0831 \u2502 C        \u2502\n\u2502 3   \u2502 2.17078 \u2502 -3.32538 \u2502 14.4522 \u2502 A        \u2502\n\u2502 4   \u2502 1.87333 \u2502 -4.26472 \u2502 13.9712 \u2502 B        \u2502\n\u2502 5   \u2502 2.8445  \u2502 -5.96857 \u2502 16.417  \u2502 E        \u2502\n\u2502 6   \u2502 5.88204 \u2502 -1.99388 \u2502 22.0269 \u2502 O        \u2502\n\n\n\n\n\nPhylogenetic regression / ANOVA is based on the \nGLM\n package, with the network as an extra argument, using function \nphyloNetworklm\n.\n\n\nusing\n \nStatsModels\n \n# for statistical model formulas\n\n\nfitTrait3\n \n=\n \nphyloNetworklm\n(\n@formula\n(\ntrait3\n \n~\n \ntrait1\n \n+\n \ntrait2\n),\n \ndat\n,\n \ntruenet\n)\n\n\n\n\n\n\nStatsModels.DataFrameRegressionModel{PhyloNetworks.PhyloNetworkLinearModel,Array{Float64,2}}\n\nFormula: trait3 ~ 1 + trait1 + trait2\n\nModel: BM\n\nParameter(s) Estimates:\nSigma2: 0.034712\n\nCoefficients:\n             Estimate Std.Error t value Pr(\n|t|)\n(Intercept)   11.9564   1.15462 10.3552   0.0019\ntrait1        1.69111  0.183047 9.23868   0.0027\ntrait2       0.170664  0.155645  1.0965   0.3530\n\nLog Likelihood: -2.9851753461\nAIC: 13.9703506922\n\n\n\n\n\nFrom this, we can see that the intercept, the coefficient for trait 1 and the variance of the noise are correctly estimated (given that there are only 6 taxa). In addition, the Student T test for the coefficient associated with trait 2 has a high p-value, which means that this coefficient is not significantly different from 0. This is consistent with the way we simulated trait 3.\n\n\nThe function returns an object of type \nPhyloNetworkLinearModel\n:LinPredModel\n. It is a subtype of the GLM type \nLinPredModel\n, which means that all base functions from Julia \nStatsBase\n can be applied to it. See the documentation for this type for a list of all functions that can be used. Some functions allow the user to retrieve directly the estimated parameters of the BM, and are specific to this object.\n\n\njulia\n sigma2_estim(fitTrait3) # estimated variance of the BM\n0.03471195929806232\n\njulia\n mu_estim(fitTrait3) # estimated root value of the BM\n11.956367929622969\n\n\n\n\n\n\n\nAncestral State Reconstruction\n\n\n\n\nFrom known parameters\n\n\nIf we assume that we know the exact model of evolution that generated the traits, we can do ancestral trait reconstruction. Here, we simulated trait 1 ourselves, so we can use the true process, with the true parameters. In other words, we can reconstruct the state at the internal nodes, given the values at the tips, the known value at the root and the known BM variance.\n\n\nancTrait1\n \n=\n \nancestralStateReconstruction\n(\ntruenet\n,\n \ntrait1\n,\n \nparams_trait1\n)\n\n\n\n\n\n\nFunction \nancestralStateReconstruction\n creates an object with type \nReconstructedStates\n. Several extractors can be applied to it:\n\n\njulia\n expectations(ancTrait1) # predictions\n13\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 condExpectation \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502 3.55615         \u2502\n\u2502 2   \u2502 -7         \u2502 2.08473         \u2502\n\u2502 3   \u2502 5          \u2502 2.42943         \u2502\n\u2502 4   \u2502 -4         \u2502 2.61415         \u2502\n\u2502 5   \u2502 -8         \u2502 2.56143         \u2502\n\u2502 6   \u2502 -3         \u2502 2.26785         \u2502\n\u2502 7   \u2502 -2         \u2502 2.0             \u2502\n\u2502 8   \u2502 1          \u2502 4.08298         \u2502\n\u2502 9   \u2502 2          \u2502 3.10782         \u2502\n\u2502 10  \u2502 3          \u2502 2.17078         \u2502\n\u2502 11  \u2502 4          \u2502 1.87333         \u2502\n\u2502 12  \u2502 6          \u2502 2.8445          \u2502\n\u2502 13  \u2502 7          \u2502 5.88204         \u2502\n\njulia\n using StatsBase # for stderror(), aic(), likelihood() etc.\n\njulia\n stderror(ancTrait1) # associated standard errors\n7-element Array{Float64,1}:\n 0.312339\n 0.429933\n 0.812157\n 0.985996\n 1.00992\n 0.807042\n 0.0\n\njulia\n predint(ancTrait1, level=0.9) # prediction interval (with level 90%)\n13\u00d72 Array{Float64,2}:\n 3.0424    4.0699\n 1.37755   2.79191\n 1.09355   3.76531\n 0.992327  4.23596\n 0.90026   4.2226\n 0.940384  3.59532\n 2.0       2.0\n 4.08298   4.08298\n 3.10782   3.10782\n 2.17078   2.17078\n 1.87333   1.87333\n 2.8445    2.8445\n 5.88204   5.88204\n\n\n\n\n\nWe can plot the ancestral states or prediction intervals on the tree, using the \nnodeLabel\n argument of the \nplot\n function.\n\n\nancExpe\n \n=\n \nexpectationsPlot\n(\nancTrait1\n);\n \n# format expected ancestral states for the plot\n\n\nplot\n(\ntruenet\n,\n \n:\nR\n,\n \nnodeLabel\n \n=\n \nancExpe\n);\n\n\n\n\n\n\n\n\nancInt\n \n=\n \npredintPlot\n(\nancTrait1\n)\n \n# format the prediction intervals for the plot\n\n\nplot\n(\ntruenet\n,\n:\nR\n,\n \nnodeLabel\n \n=\n \nancInt\n);\n\n\n\n\n\n\n\n\nThe \npredint\n and \npredintPlot\n functions have an optional argument to state the \nlevel\n of the prediction interval. If not given, the default value is 0.95.\n\n\nIt is also possible to plot both the reconstructed state and the predicted value on the same plot, using the optional keyword argument \nwithExp\n. As shown below, we could also use the \n:RCall\n method from the \nplot\n function.\n\n\nplot\n(\ntruenet\n,\n \n:\nR\n,\n \nnodeLabel\n \n=\n \npredintPlot\n(\nancTrait1\n,\n \nwithExp\n=\ntrue\n));\n\n\n\n\n\n\nThese plots tend to be quite busy, even for small networks.\n\n\nAs we know the true ancestral states here, we can compare them to our estimation.\n\n\npredictions\n \n=\n \nDataFrame\n(\ninfPred\n=\npredint\n(\nancTrait1\n)[\n1\n:\n7\n,\n \n1\n],\n\n                        \ntrueValue\n=\nsim1\n[\n:\nInternalNodes\n],\n\n                        \nsupPred\n=\npredint\n(\nancTrait1\n)[\n1\n:\n7\n,\n \n2\n])\n\n\n\n\n\n\n7\u00d73 DataFrames.DataFrame\n\u2502 Row \u2502 infPred  \u2502 trueValue \u2502 supPred \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 2.94398  \u2502 2.74233   \u2502 4.16832 \u2502\n\u2502 2   \u2502 1.24207  \u2502 2.24355   \u2502 2.92738 \u2502\n\u2502 3   \u2502 0.837628 \u2502 1.38334   \u2502 4.02123 \u2502\n\u2502 4   \u2502 0.681629 \u2502 1.50076   \u2502 4.54666 \u2502\n\u2502 5   \u2502 0.582023 \u2502 2.84188   \u2502 4.54084 \u2502\n\u2502 6   \u2502 0.686076 \u2502 1.76745   \u2502 3.84962 \u2502\n\u2502 7   \u2502 2.0      \u2502 2.0       \u2502 2.0     \u2502\n\n\n\n\n\n\n\nFrom estimated parameters\n\n\nIn real applications though, we do not have access to the true parameters of the process that generated the data. We can estimate it using the previous function. To fit a regular BM, we just need to do a regression of trait 1 against a simple intercept:\n\n\nfitTrait1\n \n=\n \nphyloNetworklm\n(\n@formula\n(\ntrait1\n \n~\n \n1\n),\n \ndat\n,\n \ntruenet\n)\n\n\n\n\n\n\nWe can then apply the \nancestralStateReconstruction\n function directly to the fitted object:\n\n\nancTrait1Approx\n \n=\n \nancestralStateReconstruction\n(\nfitTrait1\n)\n\n\n\n\n\n\nWARNING\n:\n \nThese\n \nprediction\n \nintervals\n \nshow\n \nuncertainty\n \nin\n \nancestral\n \nvalues\n,\n\n\nassuming\n \nthat\n \nthe\n \nestimated\n \nvariance\n \nrate\n \nof\n \nevolution\n \nis\n \ncorrect\n.\n\n\nAdditional\n \nuncertainty\n \nin\n \nthe\n \nestimation\n \nof\n \nthis\n \nvariance\n \nrate\n \nis\n\n\nignored\n,\n \nso\n \nprediction\n \nintervals\n \nshould\n \nbe\n \nlarger\n.\n\n\n\n\n\n\nThe prediction intervals ignore the fact that we estimated the process parameters, so they are less accurate and the function throws a warning. The output is an object of the same \nReconstructedStates\n type as earlier, and the same extractors can be applied to it:\n\n\nplot\n(\ntruenet\n,\n \n:\nR\n,\n \nnodeLabel\n \n=\n \nexpectationsPlot\n(\nancTrait1Approx\n));\n\n\n\n\n\n\n\n\nFor convenience, the two steps described above (fitting against the intercept, and then do ancestral state reconstruction) can be done all at once with a single call of the function \nancestralStateReconstruction\n on a DataFrame with the trait to reconstruct, and the tip labels:\n\n\ndatTrait1\n \n=\n \nDataFrame\n(\ntrait1\n \n=\n \ntrait1\n,\n \ntipNames\n \n=\n \ntipLabels\n(\nsim1\n))\n\n\nancTrait1Approx\n \n=\n \nancestralStateReconstruction\n(\ndatTrait1\n,\n \ntruenet\n)\n\n\n\n\n\n\nWARNING\n:\n \nThese\n \nprediction\n \nintervals\n \nshow\n \nuncertainty\n \nin\n \nancestral\n \nvalues\n,\n\n\nassuming\n \nthat\n \nthe\n \nestimated\n \nvariance\n \nrate\n \nof\n \nevolution\n \nis\n \ncorrect\n.\n\n\nAdditional\n \nuncertainty\n \nin\n \nthe\n \nestimation\n \nof\n \nthis\n \nvariance\n \nrate\n \nis\n\n\nignored\n,\n \nso\n \nprediction\n \nintervals\n \nshould\n \nbe\n \nlarger\n.\n\n\n\n\n\n\nplot\n(\ntruenet\n,\n \n:\nR\n,\n \nnodeLabel\n \n=\n \npredintPlot\n(\nancTrait1Approx\n,\n \nlevel\n=\n0.9\n));\n\n\n\n\n\n\n\n\nThis produces the exact same results. Here, we chose a \nlevel\n of 90% for the plotted prediction intervals.\n\n\n\n\nData imputation\n\n\nNote that there is no theoretical difference between an internal node, for which we could not measure the value of the trait, and a missing value at a tip of the network. Consequently, the previous \nancestralStateReconstruction\n function can be used to do data imputation. To see this, let's add some missing values in trait 1.\n\n\ndatTrait1\n[\n:\ntrait1\n]\n \n=\n \nallowmissing\n(\ndatTrait1\n[\n:\ntrait1\n]);\n\n\ndatTrait1\n[[\n2\n],\n \n:\ntrait1\n]\n \n=\n \nmissing\n;\n \n# second row: for taxon C\n\n\nancTrait1Approx\n \n=\n \nancestralStateReconstruction\n(\ndatTrait1\n,\n \ntruenet\n)\n\n\n\n\n\n\nWARNING\n:\n \nThese\n \nprediction\n \nintervals\n \nshow\n \nuncertainty\n \nin\n \nancestral\n \nvalues\n,\n\n\nassuming\n \nthat\n \nthe\n \nestimated\n \nvariance\n \nrate\n \nof\n \nevolution\n \nis\n \ncorrect\n.\n\n\nAdditional\n \nuncertainty\n \nin\n \nthe\n \nestimation\n \nof\n \nthis\n \nvariance\n \nrate\n \nis\n\n\nignored\n,\n \nso\n \nprediction\n \nintervals\n \nshould\n \nbe\n \nlarger\n.\n\n\n\n\n\n\nplot\n(\ntruenet\n,\n \n:\nR\n,\n \nnodeLabel\n \n=\n \npredintPlot\n(\nancTrait1Approx\n));\n\n\n\n\n\n\n\n\nA prediction interval is shown for the missing values.\n\n\n\n\nWith known predictors\n\n\nAt this point, it might be tempting to apply this function to trait 3 we simulated earlier as a linear combination of trait 1 and a phylogenetic noise. However, this cannot be done directly:\n\n\nancTrait3\n \n=\n \nancestralStateReconstruction\n(\nfitTrait3\n)\n \n# Throws an error !\n\n\n\n\n\n\nThis is because the model we used to fit the trait (a regression with one predictor and an intercept) is not compatible with the simple model of Brownian evolution that we assumed for the ancestral state reconstruction. As the predictor used is not known for ancestral states, it is not possible to reconstruct the trait for this particular model.\n\n\nThe only option we have is to provide the function with the predictor's ancestral states, if they are known. They are known indeed in this toy example that we generated ourselves, so we can reconstruct our trait doing the following:\n\n\nancTrait3\n \n=\n \nancestralStateReconstruction\n(\nfitTrait3\n,\n\n              \n[\nones\n(\n7\n,\n \n1\n)\n \nsim1\n[\n:\nInternalNodes\n]\n \nsim2\n[\n:\nInternalNodes\n]])\n\n\n\n\n\n\nWARNING\n:\n \nThese\n \nprediction\n \nintervals\n \nshow\n \nuncertainty\n \nin\n \nancestral\n \nvalues\n,\n\n\nassuming\n \nthat\n \nthe\n \nestimated\n \nvariance\n \nrate\n \nof\n \nevolution\n \nis\n \ncorrect\n.\n\n\nAdditional\n \nuncertainty\n \nin\n \nthe\n \nestimation\n \nof\n \nthis\n \nvariance\n \nrate\n \nis\n\n\nignored\n,\n \nso\n \nprediction\n \nintervals\n \nshould\n \nbe\n \nlarger\n.\n\n\n\n\n\n\nplot\n(\ntruenet\n,\n \n:\nR\n,\n \nnodeLabel\n \n=\n \npredintPlot\n(\nancTrait3\n));\n\n\n\n\n\n\n\n\nwhere we provided the ancestral predictors as a matrix, containing the intercept, and the known predictor at the nodes. The user must be very careful with this function, as no check is done for the order of the predictors, that must be in the same order as the internal nodes of the phylogeny. As ancestral predictors are often unknown, the use of this functionality is discouraged.\n\n\n\n\nPhylogenetic ANOVA\n\n\nThe \nphyloNetworklm\n function is based on the \nlm\n function from \nGLM\n. This means that it inherits from most of its features, and in particular, it can handle formulas with factors or interactions. For example, in lizards, we might want to do a regression of toe length against body length and the region where each species is found, where this region is coded into 4 categories (say). We might also want to include an interaction effect between body length and region. (This model has no biological basis. It is just meant to show the possibilities of the function).\n\n\nTo illustrate the use of categorical predictors of particular interest in a network with reticulations, let's assume that some transgressive evolution took place after the hybridization event, so that tips \"A\" and \"B\" have larger mean compared to the others.\n\n\ndelta\n \n=\n \n5.0\n;\n \n# value of heterosis\n\n\nunderHyb\n \n=\n \n[(\nn\n \n==\n \nA\n \n||\n \nn\n \n==\n \nB\n)\n \nfor\n \nn\n \nin\n \ntipLabels\n(\nsim1\n)]\n \n# tips under hybrid\n\n\nunderHyb\n\n\nfor\n \ni\n \nin\n \n1\n:\nlength\n(\ntrait3\n)\n\n    \nunderHyb\n[\ni\n]\n \n \n(\ntrait3\n[\ni\n]\n+=\ndelta\n)\n \n# add delta to tips A and B\n\n\nend\n\n\n\n\n\n\njulia\n trait3 # changed: +5 was added by the previous loop to A and B\n6-element Array{Float64,1}:\n 16.673\n 15.0831\n 19.4522\n 18.9712\n 16.417\n 22.0269\n\n\n\n\n\nThe categorical variable \nunderHyb\n separates tips \"A\" and \"B\" from the others. We need to mark it as a factor, not a numerical variable, i.e. as a \nPooledDataArray\n.\n\n\ndat\n \n=\n \nDataFrame\n(\ntrait1\n \n=\n \ntrait1\n,\n \ntrait2\n \n=\n \ntrait2\n,\n \ntrait3\n \n=\n \ntrait3\n,\n\n                \nunderHyb\n \n=\n \nunderHyb\n,\n\n                \ntipNames\n \n=\n \ntipLabels\n(\nsim1\n))\n\n\ncategorical!\n(\ndat\n,\n \n:\nunderHyb\n)\n\n\n\n\n\n\njulia\n dat\n6\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 trait1  \u2502 trait2   \u2502 trait3  \u2502 underHyb \u2502 tipNames \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 4.08298 \u2502 -7.34186 \u2502 16.673  \u2502 false    \u2502 D        \u2502\n\u2502 2   \u2502 3.10782 \u2502 -7.45085 \u2502 15.0831 \u2502 false    \u2502 C        \u2502\n\u2502 3   \u2502 2.17078 \u2502 -3.32538 \u2502 19.4522 \u2502 true     \u2502 A        \u2502\n\u2502 4   \u2502 1.87333 \u2502 -4.26472 \u2502 18.9712 \u2502 true     \u2502 B        \u2502\n\u2502 5   \u2502 2.8445  \u2502 -5.96857 \u2502 16.417  \u2502 false    \u2502 E        \u2502\n\u2502 6   \u2502 5.88204 \u2502 -1.99388 \u2502 22.0269 \u2502 false    \u2502 O        \u2502\n\n\n\n\n\nNow we can include this factor in the regression.\n\n\nfitTrait\n \n=\n \nphyloNetworklm\n(\n@formula\n(\ntrait3\n \n~\n \ntrait1\n \n+\n \nunderHyb\n),\n \ndat\n,\n \ntruenet\n)\n\n\n\n\n\n\nStatsModels.DataFrameRegressionModel{PhyloNetworks.PhyloNetworkLinearModel,Array{Float64,2}}\n\nFormula: trait3 ~ 1 + trait1 + underHyb\n\nModel: BM\n\nParameter(s) Estimates:\nSigma2: 0.0484988\n\nCoefficients:\n                Estimate Std.Error t value Pr(\n|t|)\n(Intercept)      11.0616   1.19414 9.26324   0.0027\ntrait1           1.72504  0.240787 7.16418   0.0056\nunderHyb: true   5.07354  0.837326 6.05922   0.0090\n\nLog Likelihood: -3.9885372687\nAIC: 15.9770745374\n\n\n\n\n\nIn this case, the categorical variable indicating which tips are descendants of the reticulation event is indeed relevant, and the transgressive evolution effect is recovered.\n\n\nThis is a very simple example of how to include transgressive evolution, but some general functions to test for it, on networks with more than on hybrid, are also available.\n\n\n\n\nPagel's Lambda\n\n\nOne classical question about trait evolution is the amount of \"phylogenetic signal\" in a dataset, that is, the importance of the tree structure to explain variation in the observed traits. One way of doing measuring that is to use Pagel's lambda\n2\n transformation of the branch lengths. This model assumes a BM on a tree where the internal branches are multiplied by a factor \u03bb, while the external branches are modified so that the total height of the tree is constant. Hence, \u03bb varies between 0 (the tree has no influence on the data) and 1 (the tree is unchanged). Using the same branch length transformations, this model can be straightforwardly extended to phylogenetic networks.\n\n\nWe can illustrate this with the predictor trait we used earlier. We use the same function as before, only indicating the model we want to use:\n\n\nfitPagel\n \n=\n \nphyloNetworklm\n(\n@formula\n(\ntrait1\n \n~\n \n1\n),\n \ndat\n,\n \ntruenet\n,\n \nmodel\n=\nlambda\n)\n\n\n\n\n\n\nINFO\n:\n \nMaximum\n \nlambda\n \nvalue\n \nto\n \nmaintain\n \npositive\n \nbranch\n \nlengths\n:\n \n1.036\n\n\nStatsModels\n.\nDataFrameRegressionModel\n{\nPhyloNetworks\n.\nPhyloNetworkLinearModel\n,\nArray\n{\nFloat64\n,\n2\n}}\n\n\n\nFormula\n:\n \ntrait1\n \n~\n \n+\n1\n\n\n\nModel\n:\n \nlambda\n\n\n\nParameter\n(\ns\n)\n \nEstimates\n:\n\n\nSigma2\n:\n \n0.204079\n\n\nLambda\n:\n \n0.907356\n\n\n\nCoefficients\n:\n\n             \nEstimate\n \nStd\n.\nError\n \nt\n \nvalue\n \nPr\n(\n|\nt\n|)\n\n\n(\nIntercept\n)\n   \n3.78438\n  \n0.946551\n \n3.99808\n   \n0.0103\n\n\n\nLog\n \nLikelihood\n:\n \n-\n9.3167221118\n\n\nAIC\n:\n \n24.6334442235\n\n\n\n\n\n\nAs it is indeed generated according to a plain BM on the phylogeny, the estimated \u03bb should be close to 1. It can be extracted with function \nlambda_estim\n:\n\n\njulia\n lambda_estim(fitPagel)\n0.9073561228984233\n\n\n\n\n\n\n\nShifts and transgressive evolution\n\n\nIn the ANOVA section above, we showed how to include transgressive evolution in a simple case. In general, transgressive evolution can be seen as a particular example of a \nshifted BM\n on the phylogenetic network.\n\n\n\n\nSimulation of a Shifted BM\n\n\nIn a shifted BM, the trait evolves as a BM on the network most of the time, but \nshifts\n on some of the branches. The positions and values of the shifts can be stored in a \nShiftNet\n object. For identifiability reasons, shifts are only allowed on tree-like branches. The position of the shifts can be given using vector of edges. To see this, let's first plot the network with its associated edges and node numbers.\n\n\nplot\n(\ntruenet\n,\n \n:\nR\n,\n \nuseEdgeLength\n=\ntrue\n,\n \nshowEdgeNumber\n=\ntrue\n);\n\n\n\n\n\n\n\n\nLet's say that we want to add a shift with value 5.0 on the branch directly following the hybridization event, in order to model transgressive evolution. We can see on the plot above that this branch is number 6, so we define the following object:\n\n\nshift\n \n=\n \nShiftNet\n(\ntruenet\n.\nedge\n[\n6\n],\n \n5.0\n,\n  \ntruenet\n)\n\n\n\n\n\n\nNote that the edge numbers and values of a \nShiftNet\n object can be retrieved thanks to functions \ngetShiftEdgeNumber\n and \ngetShiftValue\n. The constructor can take a single edge and associated value, like here, or two vectors of edges and matching values.\n\n\nBecause we often need to put shifts only on edges right after hybrids, there is a special function \nshiftHybrid\n to do that, so that  we do not have to find out their edges number. Here, the \nshift\n object could hence have been defined as:\n\n\nshift\n \n=\n \nshiftHybrid\n(\n5.0\n,\n  \ntruenet\n)\n\n\n\n\n\n\nPhyloNetworks.ShiftNet:\n     Edge Number Shift Value\n             6.0         5.0\n\n\n\n\n\nThe parameters for the simulation are then defined as above, just adding the \nShiftNet\n object as a parameter.\n\n\nparams_sh\n \n=\n \nParamsBM\n(\n2\n,\n \n0.5\n,\n \nshift\n)\n \n# BM with mean 2, variance 0.5, and shifts.\n\n\n\n\n\n\nThe traits are simulated using the same function \nsimulate\n, and extracted at the tips as before.\n\n\nsrand\n(\n18700904\n)\n\n\nsim_sh\n \n=\n \nsimulate\n(\ntruenet\n,\n \nparams_sh\n)\n \n# simulate a shifted BM on truenet\n\n\ntrait_sh\n \n=\n \nsim_sh\n[\n:\nTips\n]\n              \n# trait at the tips (data)\n\n\n\n\n\n\n\n\nFit of a Shifted BM\n\n\nLet's assume that we measured \ntrait_sh\n, and that we want to test whether there were some ancestral hybridizations. To do that, we can use the  custom columns of the \ndescendenceMatrix\n, that can be directly defined thanks to function \nregressorHybrid\n.\n\n\ndf_shift\n \n=\n \nregressorHybrid\n(\ntruenet\n)\n \n# Regressors matching Hybrid Shifts\n\n\n\n\n\n\nThis creates a dataframe, with as many columns as the number of hybrids in the network, each named according to the number of the edge after the hybrid. We can use this dataframe as regressors in the \nphyloNetworklm\n function.\n\n\ndat\n \n=\n \nDataFrame\n(\ntrait\n \n=\n \ntrait_sh\n,\n \ntipNames\n \n=\n \ntipLabels\n(\nsim_sh\n))\n  \n# Data\n\n\ndat\n \n=\n \njoin\n(\ndat\n,\n \ndf_shift\n,\n \non\n=:\ntipNames\n)\n                          \n# join the two\n\n\nfit_sh\n \n=\n \nphyloNetworklm\n(\n@formula\n(\ntrait\n \n~\n \nshift_6\n),\n \ndat\n,\n \ntruenet\n)\n \n# fit\n\n\n\n\n\n\nStatsModels.DataFrameRegressionModel{PhyloNetworks.PhyloNetworkLinearModel,Array{Float64,2}}\n\nFormula: trait ~ 1 + shift_6\n\nModel: BM\n\nParameter(s) Estimates:\nSigma2: 0.347898\n\nCoefficients:\n             Estimate Std.Error t value Pr(\n|t|)\n(Intercept)    1.7885   1.46856 1.21786   0.2902\nshift_6       6.13121   1.73228 3.53939   0.0240\n\nLog Likelihood: -9.8996497316\nAIC: 25.7992994631\n\n\n\n\n\nHere, because there is only one hybrid in the network, we can directly see whether the ancestral transgressive evolution is significant or not thanks to the Student T test on the coefficient associated with \nshift_6\n. In more complex cases, it is possible to do a Fisher F test, thanks to the \nGLM\n function \nftest\n.\n\n\nfit_null\n \n=\n \nphyloNetworklm\n(\n@formula\n(\ntrait\n \n~\n \n1\n),\n \ndat\n,\n \ntruenet\n)\n \n# fit against the null (no shift)\n\n\nftest\n(\nfit_sh\n,\n \nfit_null\n)\n                                      \n# nested models, from more complex to most simple\n\n\n\n\n\n\n        Res. DOF DOF \u0394DOF    SSR    \u0394SSR      R\u00b2    \u0394R\u00b2      F*  p(\nF)\nModel 1        4   3      2.0874          0.6994\nModel 2        5   2   -1 8.6247 -6.5373 -0.2419 0.9413 12.5272 0.0240\n\n\n\n\n\nHere, this test is equivalent to the Fisher F test, and gives the same p-value.\n\n\nNote that, for conventional reasons, the \nftest\n function always takes the \nmost complex\n model as the first one. This means that, in the table of results, the models are actually named in a reverse order, so that \"Model 2\" is actually our model under H\n0\n (null model), and \"Model 1\" the one under H\n1\n (model with shifts).\n\n\n\n\n\n\n\n\n\n\nBastide, Sol\u00eds-Lemus, Kriebel, Sparks, An\u00e9 (2018):               Phylogenetic Comparative Methods for Phylogenetic Networks with Reticulations.               Systematic Biology 67(5):800\u2013820. doi:10.1093/sysbio/syy033\n\n\n\n\n\n\nPagel M (1999). Inferring the historical patterns of biological     evolution. Nature. 401: 877\u2013884. doi:10.1038/44766", 
            "title": "Continuous Trait Evolution"
        }, 
        {
            "location": "/man/trait_tree/#continuous-trait-evolution", 
            "text": "Once the network is inferred, we can take these species relationships into account when studying the distribution of quantitative traits measured for extant species. This is the goal of phylogenetic comparative methods (PCM). More details can be found on the developments below in Bastide et al. 2018 1  We assume a fixed network, correctly rooted, with branch lengths proportional to calendar time. Here, we consider the true network that was used in the previous sections, and which is ultrametric (all the tips are contemporary).  truenet   =   readTopology ( ((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2); );   As previously, we can plot the network thanks to the  RCall  package. The  name  function is only instrumental here, to ensure that the figure is saved in the correct directory when the documentation is built. We only show the commands to actually save the plot in this first example for the interested reader, but we will hide those in the rest of the chapter, for the sake of clarity.  using   PhyloPlots ,   RCall  R name  - function(x) file.path( .. ,  assets ,  figures , x)  R svg(name( truenet.svg ), width=8, height=4)  R par(mar = c(0, 0, 0, 0))  plot ( truenet ,   : R ,   useEdgeLength = true ,   showGamma = true );  R dev.off()", 
            "title": "Continuous Trait Evolution"
        }, 
        {
            "location": "/man/trait_tree/#model-and-variance-matrix", 
            "text": "Assuming that the network is known and that the continuous traits evolve like a Brownian Motion (BM) in time, it is possible to compute the expected variance covariance matrix between tip measurements. This can be done using function  vcv , whose syntax is inspired from the well known corresponding  ape  function.  C   =   vcv ( truenet )   6\u00d76 DataFrames.DataFrame\n\u2502 Row \u2502 D    \u2502 C    \u2502 A     \u2502 B     \u2502 E    \u2502 O    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 11.2 \u2502 10.8 \u2502 4.8   \u2502 4.8   \u2502 2.0  \u2502 0.0  \u2502\n\u2502 2   \u2502 10.8 \u2502 11.2 \u2502 4.8   \u2502 4.8   \u2502 2.0  \u2502 0.0  \u2502\n\u2502 3   \u2502 4.8  \u2502 4.8  \u2502 8.596 \u2502 7.796 \u2502 3.86 \u2502 0.0  \u2502\n\u2502 4   \u2502 4.8  \u2502 4.8  \u2502 7.796 \u2502 8.596 \u2502 3.86 \u2502 0.0  \u2502\n\u2502 5   \u2502 2.0  \u2502 2.0  \u2502 3.86  \u2502 3.86  \u2502 11.2 \u2502 0.0  \u2502\n\u2502 6   \u2502 0.0  \u2502 0.0  \u2502 0.0   \u2502 0.0   \u2502 0.0  \u2502 11.2 \u2502  The matrix is returned as a  DataFrame , with columns named by the tips of the network to allow for easy identification.  The computation of this matrix is based on the more general function  sharedPathMatrix . It is at the core of all the Phylogenetic Comparative Methods described below.", 
            "title": "Model and Variance Matrix"
        }, 
        {
            "location": "/man/trait_tree/#trait-simulation", 
            "text": "We start by generating continuous traits to study. We simulate three traits on the network (two independent, one dependent), using a Brownian Motion (BM) model of trait evolution on the network. We start by choosing the parameters of the BM (ancestral mean and variance), by creating objects of class  ParamsBM :ParamsProcess .  params_trait1   =   ParamsBM (   2 ,   0.5 )   # BM with mean  2 and variance 0.5  params_trait2   =   ParamsBM ( - 2 ,   1 )     # BM with mean -2 and variance 1.0   We then simulate the independent traits according to these parameters, using function  simulate  (fixing the seed, for reproducibility).  srand ( 18480224 );  sim1   =   simulate ( truenet ,   params_trait1 )   # simulate a BM on truenet  sim2   =   simulate ( truenet ,   params_trait2 )   This creates objects of class  TraitSimulation , from which we can extract the data at the tips, thanks to the method  getindex(::TraitSimulation, ::Symbol) .  trait1   =   sim1 [ : Tips ]   # trait 1 at the tips (data)  trait2   =   sim2 [ : Tips ]   This extractor creates an  Array  with one column, and as many lines as the number of tips there are in the phylogeny.  It is sorted in the same order as the tips of the phylogeny used to simulate it.   If needed, we could also extract the simulated values at the internal nodes in the network:  sim1 [ : InternalNodes ]   Finally, we generate the last trait correlated with trait 1 (but not trait 2), with phylogenetic noise.  srand ( 18700904 );  noise   =   simulate ( truenet ,   ParamsBM ( 0 ,   0.1 ))   # phylogenetic residuals  trait3   =   10   +   2   *   trait1   +   noise [ : Tips ]   # trait to study. independent of trait2", 
            "title": "Trait simulation"
        }, 
        {
            "location": "/man/trait_tree/#phylogenetic-regression", 
            "text": "Assume that we measured the three traits above, and that we wanted to study the impact of traits 1 and 2 on trait 3. To do that, we can perform a phylogenetic regression.  In order to avoid confusion, the function takes in a  DataFrame , that has an extra column with the names of the tips of the network, labeled  tipNames . Here, we generated the traits ourselves, so they are all in the same order.  using   DataFrames  dat   =   DataFrame ( trait1   =   trait1 ,   trait2   =   trait2 ,   trait3   =   trait3 , \n                 tipNames   =   tipLabels ( sim1 ))   6\u00d74 DataFrames.DataFrame\n\u2502 Row \u2502 trait1  \u2502 trait2   \u2502 trait3  \u2502 tipNames \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 4.08298 \u2502 -7.34186 \u2502 16.673  \u2502 D        \u2502\n\u2502 2   \u2502 3.10782 \u2502 -7.45085 \u2502 15.0831 \u2502 C        \u2502\n\u2502 3   \u2502 2.17078 \u2502 -3.32538 \u2502 14.4522 \u2502 A        \u2502\n\u2502 4   \u2502 1.87333 \u2502 -4.26472 \u2502 13.9712 \u2502 B        \u2502\n\u2502 5   \u2502 2.8445  \u2502 -5.96857 \u2502 16.417  \u2502 E        \u2502\n\u2502 6   \u2502 5.88204 \u2502 -1.99388 \u2502 22.0269 \u2502 O        \u2502  Phylogenetic regression / ANOVA is based on the  GLM  package, with the network as an extra argument, using function  phyloNetworklm .  using   StatsModels   # for statistical model formulas  fitTrait3   =   phyloNetworklm ( @formula ( trait3   ~   trait1   +   trait2 ),   dat ,   truenet )   StatsModels.DataFrameRegressionModel{PhyloNetworks.PhyloNetworkLinearModel,Array{Float64,2}}\n\nFormula: trait3 ~ 1 + trait1 + trait2\n\nModel: BM\n\nParameter(s) Estimates:\nSigma2: 0.034712\n\nCoefficients:\n             Estimate Std.Error t value Pr( |t|)\n(Intercept)   11.9564   1.15462 10.3552   0.0019\ntrait1        1.69111  0.183047 9.23868   0.0027\ntrait2       0.170664  0.155645  1.0965   0.3530\n\nLog Likelihood: -2.9851753461\nAIC: 13.9703506922  From this, we can see that the intercept, the coefficient for trait 1 and the variance of the noise are correctly estimated (given that there are only 6 taxa). In addition, the Student T test for the coefficient associated with trait 2 has a high p-value, which means that this coefficient is not significantly different from 0. This is consistent with the way we simulated trait 3.  The function returns an object of type  PhyloNetworkLinearModel :LinPredModel . It is a subtype of the GLM type  LinPredModel , which means that all base functions from Julia  StatsBase  can be applied to it. See the documentation for this type for a list of all functions that can be used. Some functions allow the user to retrieve directly the estimated parameters of the BM, and are specific to this object.  julia  sigma2_estim(fitTrait3) # estimated variance of the BM\n0.03471195929806232\n\njulia  mu_estim(fitTrait3) # estimated root value of the BM\n11.956367929622969", 
            "title": "Phylogenetic regression"
        }, 
        {
            "location": "/man/trait_tree/#ancestral-state-reconstruction", 
            "text": "", 
            "title": "Ancestral State Reconstruction"
        }, 
        {
            "location": "/man/trait_tree/#from-known-parameters", 
            "text": "If we assume that we know the exact model of evolution that generated the traits, we can do ancestral trait reconstruction. Here, we simulated trait 1 ourselves, so we can use the true process, with the true parameters. In other words, we can reconstruct the state at the internal nodes, given the values at the tips, the known value at the root and the known BM variance.  ancTrait1   =   ancestralStateReconstruction ( truenet ,   trait1 ,   params_trait1 )   Function  ancestralStateReconstruction  creates an object with type  ReconstructedStates . Several extractors can be applied to it:  julia  expectations(ancTrait1) # predictions\n13\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 condExpectation \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502 3.55615         \u2502\n\u2502 2   \u2502 -7         \u2502 2.08473         \u2502\n\u2502 3   \u2502 5          \u2502 2.42943         \u2502\n\u2502 4   \u2502 -4         \u2502 2.61415         \u2502\n\u2502 5   \u2502 -8         \u2502 2.56143         \u2502\n\u2502 6   \u2502 -3         \u2502 2.26785         \u2502\n\u2502 7   \u2502 -2         \u2502 2.0             \u2502\n\u2502 8   \u2502 1          \u2502 4.08298         \u2502\n\u2502 9   \u2502 2          \u2502 3.10782         \u2502\n\u2502 10  \u2502 3          \u2502 2.17078         \u2502\n\u2502 11  \u2502 4          \u2502 1.87333         \u2502\n\u2502 12  \u2502 6          \u2502 2.8445          \u2502\n\u2502 13  \u2502 7          \u2502 5.88204         \u2502\n\njulia  using StatsBase # for stderror(), aic(), likelihood() etc.\n\njulia  stderror(ancTrait1) # associated standard errors\n7-element Array{Float64,1}:\n 0.312339\n 0.429933\n 0.812157\n 0.985996\n 1.00992\n 0.807042\n 0.0\n\njulia  predint(ancTrait1, level=0.9) # prediction interval (with level 90%)\n13\u00d72 Array{Float64,2}:\n 3.0424    4.0699\n 1.37755   2.79191\n 1.09355   3.76531\n 0.992327  4.23596\n 0.90026   4.2226\n 0.940384  3.59532\n 2.0       2.0\n 4.08298   4.08298\n 3.10782   3.10782\n 2.17078   2.17078\n 1.87333   1.87333\n 2.8445    2.8445\n 5.88204   5.88204  We can plot the ancestral states or prediction intervals on the tree, using the  nodeLabel  argument of the  plot  function.  ancExpe   =   expectationsPlot ( ancTrait1 );   # format expected ancestral states for the plot  plot ( truenet ,   : R ,   nodeLabel   =   ancExpe );    ancInt   =   predintPlot ( ancTrait1 )   # format the prediction intervals for the plot  plot ( truenet , : R ,   nodeLabel   =   ancInt );    The  predint  and  predintPlot  functions have an optional argument to state the  level  of the prediction interval. If not given, the default value is 0.95.  It is also possible to plot both the reconstructed state and the predicted value on the same plot, using the optional keyword argument  withExp . As shown below, we could also use the  :RCall  method from the  plot  function.  plot ( truenet ,   : R ,   nodeLabel   =   predintPlot ( ancTrait1 ,   withExp = true ));   These plots tend to be quite busy, even for small networks.  As we know the true ancestral states here, we can compare them to our estimation.  predictions   =   DataFrame ( infPred = predint ( ancTrait1 )[ 1 : 7 ,   1 ], \n                         trueValue = sim1 [ : InternalNodes ], \n                         supPred = predint ( ancTrait1 )[ 1 : 7 ,   2 ])   7\u00d73 DataFrames.DataFrame\n\u2502 Row \u2502 infPred  \u2502 trueValue \u2502 supPred \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 2.94398  \u2502 2.74233   \u2502 4.16832 \u2502\n\u2502 2   \u2502 1.24207  \u2502 2.24355   \u2502 2.92738 \u2502\n\u2502 3   \u2502 0.837628 \u2502 1.38334   \u2502 4.02123 \u2502\n\u2502 4   \u2502 0.681629 \u2502 1.50076   \u2502 4.54666 \u2502\n\u2502 5   \u2502 0.582023 \u2502 2.84188   \u2502 4.54084 \u2502\n\u2502 6   \u2502 0.686076 \u2502 1.76745   \u2502 3.84962 \u2502\n\u2502 7   \u2502 2.0      \u2502 2.0       \u2502 2.0     \u2502", 
            "title": "From known parameters"
        }, 
        {
            "location": "/man/trait_tree/#from-estimated-parameters", 
            "text": "In real applications though, we do not have access to the true parameters of the process that generated the data. We can estimate it using the previous function. To fit a regular BM, we just need to do a regression of trait 1 against a simple intercept:  fitTrait1   =   phyloNetworklm ( @formula ( trait1   ~   1 ),   dat ,   truenet )   We can then apply the  ancestralStateReconstruction  function directly to the fitted object:  ancTrait1Approx   =   ancestralStateReconstruction ( fitTrait1 )   WARNING :   These   prediction   intervals   show   uncertainty   in   ancestral   values ,  assuming   that   the   estimated   variance   rate   of   evolution   is   correct .  Additional   uncertainty   in   the   estimation   of   this   variance   rate   is  ignored ,   so   prediction   intervals   should   be   larger .   The prediction intervals ignore the fact that we estimated the process parameters, so they are less accurate and the function throws a warning. The output is an object of the same  ReconstructedStates  type as earlier, and the same extractors can be applied to it:  plot ( truenet ,   : R ,   nodeLabel   =   expectationsPlot ( ancTrait1Approx ));    For convenience, the two steps described above (fitting against the intercept, and then do ancestral state reconstruction) can be done all at once with a single call of the function  ancestralStateReconstruction  on a DataFrame with the trait to reconstruct, and the tip labels:  datTrait1   =   DataFrame ( trait1   =   trait1 ,   tipNames   =   tipLabels ( sim1 ))  ancTrait1Approx   =   ancestralStateReconstruction ( datTrait1 ,   truenet )   WARNING :   These   prediction   intervals   show   uncertainty   in   ancestral   values ,  assuming   that   the   estimated   variance   rate   of   evolution   is   correct .  Additional   uncertainty   in   the   estimation   of   this   variance   rate   is  ignored ,   so   prediction   intervals   should   be   larger .   plot ( truenet ,   : R ,   nodeLabel   =   predintPlot ( ancTrait1Approx ,   level = 0.9 ));    This produces the exact same results. Here, we chose a  level  of 90% for the plotted prediction intervals.", 
            "title": "From estimated parameters"
        }, 
        {
            "location": "/man/trait_tree/#data-imputation", 
            "text": "Note that there is no theoretical difference between an internal node, for which we could not measure the value of the trait, and a missing value at a tip of the network. Consequently, the previous  ancestralStateReconstruction  function can be used to do data imputation. To see this, let's add some missing values in trait 1.  datTrait1 [ : trait1 ]   =   allowmissing ( datTrait1 [ : trait1 ]);  datTrait1 [[ 2 ],   : trait1 ]   =   missing ;   # second row: for taxon C  ancTrait1Approx   =   ancestralStateReconstruction ( datTrait1 ,   truenet )   WARNING :   These   prediction   intervals   show   uncertainty   in   ancestral   values ,  assuming   that   the   estimated   variance   rate   of   evolution   is   correct .  Additional   uncertainty   in   the   estimation   of   this   variance   rate   is  ignored ,   so   prediction   intervals   should   be   larger .   plot ( truenet ,   : R ,   nodeLabel   =   predintPlot ( ancTrait1Approx ));    A prediction interval is shown for the missing values.", 
            "title": "Data imputation"
        }, 
        {
            "location": "/man/trait_tree/#with-known-predictors", 
            "text": "At this point, it might be tempting to apply this function to trait 3 we simulated earlier as a linear combination of trait 1 and a phylogenetic noise. However, this cannot be done directly:  ancTrait3   =   ancestralStateReconstruction ( fitTrait3 )   # Throws an error !   This is because the model we used to fit the trait (a regression with one predictor and an intercept) is not compatible with the simple model of Brownian evolution that we assumed for the ancestral state reconstruction. As the predictor used is not known for ancestral states, it is not possible to reconstruct the trait for this particular model.  The only option we have is to provide the function with the predictor's ancestral states, if they are known. They are known indeed in this toy example that we generated ourselves, so we can reconstruct our trait doing the following:  ancTrait3   =   ancestralStateReconstruction ( fitTrait3 , \n               [ ones ( 7 ,   1 )   sim1 [ : InternalNodes ]   sim2 [ : InternalNodes ]])   WARNING :   These   prediction   intervals   show   uncertainty   in   ancestral   values ,  assuming   that   the   estimated   variance   rate   of   evolution   is   correct .  Additional   uncertainty   in   the   estimation   of   this   variance   rate   is  ignored ,   so   prediction   intervals   should   be   larger .   plot ( truenet ,   : R ,   nodeLabel   =   predintPlot ( ancTrait3 ));    where we provided the ancestral predictors as a matrix, containing the intercept, and the known predictor at the nodes. The user must be very careful with this function, as no check is done for the order of the predictors, that must be in the same order as the internal nodes of the phylogeny. As ancestral predictors are often unknown, the use of this functionality is discouraged.", 
            "title": "With known predictors"
        }, 
        {
            "location": "/man/trait_tree/#phylogenetic-anova", 
            "text": "The  phyloNetworklm  function is based on the  lm  function from  GLM . This means that it inherits from most of its features, and in particular, it can handle formulas with factors or interactions. For example, in lizards, we might want to do a regression of toe length against body length and the region where each species is found, where this region is coded into 4 categories (say). We might also want to include an interaction effect between body length and region. (This model has no biological basis. It is just meant to show the possibilities of the function).  To illustrate the use of categorical predictors of particular interest in a network with reticulations, let's assume that some transgressive evolution took place after the hybridization event, so that tips \"A\" and \"B\" have larger mean compared to the others.  delta   =   5.0 ;   # value of heterosis  underHyb   =   [( n   ==   A   ||   n   ==   B )   for   n   in   tipLabels ( sim1 )]   # tips under hybrid  underHyb  for   i   in   1 : length ( trait3 ) \n     underHyb [ i ]     ( trait3 [ i ] += delta )   # add delta to tips A and B  end   julia  trait3 # changed: +5 was added by the previous loop to A and B\n6-element Array{Float64,1}:\n 16.673\n 15.0831\n 19.4522\n 18.9712\n 16.417\n 22.0269  The categorical variable  underHyb  separates tips \"A\" and \"B\" from the others. We need to mark it as a factor, not a numerical variable, i.e. as a  PooledDataArray .  dat   =   DataFrame ( trait1   =   trait1 ,   trait2   =   trait2 ,   trait3   =   trait3 , \n                 underHyb   =   underHyb , \n                 tipNames   =   tipLabels ( sim1 ))  categorical! ( dat ,   : underHyb )   julia  dat\n6\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 trait1  \u2502 trait2   \u2502 trait3  \u2502 underHyb \u2502 tipNames \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 4.08298 \u2502 -7.34186 \u2502 16.673  \u2502 false    \u2502 D        \u2502\n\u2502 2   \u2502 3.10782 \u2502 -7.45085 \u2502 15.0831 \u2502 false    \u2502 C        \u2502\n\u2502 3   \u2502 2.17078 \u2502 -3.32538 \u2502 19.4522 \u2502 true     \u2502 A        \u2502\n\u2502 4   \u2502 1.87333 \u2502 -4.26472 \u2502 18.9712 \u2502 true     \u2502 B        \u2502\n\u2502 5   \u2502 2.8445  \u2502 -5.96857 \u2502 16.417  \u2502 false    \u2502 E        \u2502\n\u2502 6   \u2502 5.88204 \u2502 -1.99388 \u2502 22.0269 \u2502 false    \u2502 O        \u2502  Now we can include this factor in the regression.  fitTrait   =   phyloNetworklm ( @formula ( trait3   ~   trait1   +   underHyb ),   dat ,   truenet )   StatsModels.DataFrameRegressionModel{PhyloNetworks.PhyloNetworkLinearModel,Array{Float64,2}}\n\nFormula: trait3 ~ 1 + trait1 + underHyb\n\nModel: BM\n\nParameter(s) Estimates:\nSigma2: 0.0484988\n\nCoefficients:\n                Estimate Std.Error t value Pr( |t|)\n(Intercept)      11.0616   1.19414 9.26324   0.0027\ntrait1           1.72504  0.240787 7.16418   0.0056\nunderHyb: true   5.07354  0.837326 6.05922   0.0090\n\nLog Likelihood: -3.9885372687\nAIC: 15.9770745374  In this case, the categorical variable indicating which tips are descendants of the reticulation event is indeed relevant, and the transgressive evolution effect is recovered.  This is a very simple example of how to include transgressive evolution, but some general functions to test for it, on networks with more than on hybrid, are also available.", 
            "title": "Phylogenetic ANOVA"
        }, 
        {
            "location": "/man/trait_tree/#pagels-lambda", 
            "text": "One classical question about trait evolution is the amount of \"phylogenetic signal\" in a dataset, that is, the importance of the tree structure to explain variation in the observed traits. One way of doing measuring that is to use Pagel's lambda 2  transformation of the branch lengths. This model assumes a BM on a tree where the internal branches are multiplied by a factor \u03bb, while the external branches are modified so that the total height of the tree is constant. Hence, \u03bb varies between 0 (the tree has no influence on the data) and 1 (the tree is unchanged). Using the same branch length transformations, this model can be straightforwardly extended to phylogenetic networks.  We can illustrate this with the predictor trait we used earlier. We use the same function as before, only indicating the model we want to use:  fitPagel   =   phyloNetworklm ( @formula ( trait1   ~   1 ),   dat ,   truenet ,   model = lambda )   INFO :   Maximum   lambda   value   to   maintain   positive   branch   lengths :   1.036  StatsModels . DataFrameRegressionModel { PhyloNetworks . PhyloNetworkLinearModel , Array { Float64 , 2 }}  Formula :   trait1   ~   + 1  Model :   lambda  Parameter ( s )   Estimates :  Sigma2 :   0.204079  Lambda :   0.907356  Coefficients : \n              Estimate   Std . Error   t   value   Pr ( | t |)  ( Intercept )     3.78438    0.946551   3.99808     0.0103  Log   Likelihood :   - 9.3167221118  AIC :   24.6334442235   As it is indeed generated according to a plain BM on the phylogeny, the estimated \u03bb should be close to 1. It can be extracted with function  lambda_estim :  julia  lambda_estim(fitPagel)\n0.9073561228984233", 
            "title": "Pagel's Lambda"
        }, 
        {
            "location": "/man/trait_tree/#shifts-and-transgressive-evolution", 
            "text": "In the ANOVA section above, we showed how to include transgressive evolution in a simple case. In general, transgressive evolution can be seen as a particular example of a  shifted BM  on the phylogenetic network.", 
            "title": "Shifts and transgressive evolution"
        }, 
        {
            "location": "/man/trait_tree/#simulation-of-a-shifted-bm", 
            "text": "In a shifted BM, the trait evolves as a BM on the network most of the time, but  shifts  on some of the branches. The positions and values of the shifts can be stored in a  ShiftNet  object. For identifiability reasons, shifts are only allowed on tree-like branches. The position of the shifts can be given using vector of edges. To see this, let's first plot the network with its associated edges and node numbers.  plot ( truenet ,   : R ,   useEdgeLength = true ,   showEdgeNumber = true );    Let's say that we want to add a shift with value 5.0 on the branch directly following the hybridization event, in order to model transgressive evolution. We can see on the plot above that this branch is number 6, so we define the following object:  shift   =   ShiftNet ( truenet . edge [ 6 ],   5.0 ,    truenet )   Note that the edge numbers and values of a  ShiftNet  object can be retrieved thanks to functions  getShiftEdgeNumber  and  getShiftValue . The constructor can take a single edge and associated value, like here, or two vectors of edges and matching values.  Because we often need to put shifts only on edges right after hybrids, there is a special function  shiftHybrid  to do that, so that  we do not have to find out their edges number. Here, the  shift  object could hence have been defined as:  shift   =   shiftHybrid ( 5.0 ,    truenet )   PhyloNetworks.ShiftNet:\n     Edge Number Shift Value\n             6.0         5.0  The parameters for the simulation are then defined as above, just adding the  ShiftNet  object as a parameter.  params_sh   =   ParamsBM ( 2 ,   0.5 ,   shift )   # BM with mean 2, variance 0.5, and shifts.   The traits are simulated using the same function  simulate , and extracted at the tips as before.  srand ( 18700904 )  sim_sh   =   simulate ( truenet ,   params_sh )   # simulate a shifted BM on truenet  trait_sh   =   sim_sh [ : Tips ]                # trait at the tips (data)", 
            "title": "Simulation of a Shifted BM"
        }, 
        {
            "location": "/man/trait_tree/#fit-of-a-shifted-bm", 
            "text": "Let's assume that we measured  trait_sh , and that we want to test whether there were some ancestral hybridizations. To do that, we can use the  custom columns of the  descendenceMatrix , that can be directly defined thanks to function  regressorHybrid .  df_shift   =   regressorHybrid ( truenet )   # Regressors matching Hybrid Shifts   This creates a dataframe, with as many columns as the number of hybrids in the network, each named according to the number of the edge after the hybrid. We can use this dataframe as regressors in the  phyloNetworklm  function.  dat   =   DataFrame ( trait   =   trait_sh ,   tipNames   =   tipLabels ( sim_sh ))    # Data  dat   =   join ( dat ,   df_shift ,   on =: tipNames )                            # join the two  fit_sh   =   phyloNetworklm ( @formula ( trait   ~   shift_6 ),   dat ,   truenet )   # fit   StatsModels.DataFrameRegressionModel{PhyloNetworks.PhyloNetworkLinearModel,Array{Float64,2}}\n\nFormula: trait ~ 1 + shift_6\n\nModel: BM\n\nParameter(s) Estimates:\nSigma2: 0.347898\n\nCoefficients:\n             Estimate Std.Error t value Pr( |t|)\n(Intercept)    1.7885   1.46856 1.21786   0.2902\nshift_6       6.13121   1.73228 3.53939   0.0240\n\nLog Likelihood: -9.8996497316\nAIC: 25.7992994631  Here, because there is only one hybrid in the network, we can directly see whether the ancestral transgressive evolution is significant or not thanks to the Student T test on the coefficient associated with  shift_6 . In more complex cases, it is possible to do a Fisher F test, thanks to the  GLM  function  ftest .  fit_null   =   phyloNetworklm ( @formula ( trait   ~   1 ),   dat ,   truenet )   # fit against the null (no shift)  ftest ( fit_sh ,   fit_null )                                        # nested models, from more complex to most simple           Res. DOF DOF \u0394DOF    SSR    \u0394SSR      R\u00b2    \u0394R\u00b2      F*  p( F)\nModel 1        4   3      2.0874          0.6994\nModel 2        5   2   -1 8.6247 -6.5373 -0.2419 0.9413 12.5272 0.0240  Here, this test is equivalent to the Fisher F test, and gives the same p-value.  Note that, for conventional reasons, the  ftest  function always takes the  most complex  model as the first one. This means that, in the table of results, the models are actually named in a reverse order, so that \"Model 2\" is actually our model under H 0  (null model), and \"Model 1\" the one under H 1  (model with shifts).      Bastide, Sol\u00eds-Lemus, Kriebel, Sparks, An\u00e9 (2018):               Phylogenetic Comparative Methods for Phylogenetic Networks with Reticulations.               Systematic Biology 67(5):800\u2013820. doi:10.1093/sysbio/syy033    Pagel M (1999). Inferring the historical patterns of biological     evolution. Nature. 401: 877\u2013884. doi:10.1038/44766", 
            "title": "Fit of a Shifted BM"
        }, 
        {
            "location": "/man/parsimony/", 
            "text": "Parsimony on networks\n\n\n\n\nParsimony score of a given network\n\n\nWe can calculate the parsimony score of a given network topology and a given set of characters. The characters could be in a CSV file in this format:\n\n\n\n\n\n\n\n\ntaxon\n\n\ntrait1\n\n\ntrait2\n\n\ntrait3\n\n\ntrait4\n\n\ntrait5\n\n\ntrait6 ...\n\n\n\n\n\n\n\n\n\n\nEnglish\n\n\n1\n\n\n2\n\n\n1\n\n\n1\n\n\n1\n\n\n3\n\n\n\n\n\n\n...\n\n\n\n\n\n\n\n\n\n\n\n\n...\n\n\n\n\n\n\n\n\nThe trait values can be integer numbers, or strings. The data table may have missing data, and may contain extra taxa that we might want to exclude.\n\n\nAn example file comes with the package, available \nhere\n or \nhere\n.\n\n\nFirst, we need to read the trait table as a DataFrame object:\n\n\njulia\n using CSV, DataFrames\n\njulia\n csvfile = joinpath(Pkg.dir(\nPhyloNetworks\n),\nexamples\n,\nSwadesh.csv\n);\n\njulia\n dat = CSV.read(csvfile);\n\njulia\n head(dat) # head shows the first 6 rows only\n5\u00d711 DataFrames.DataFrame\n\u2502 Row \u2502 taxon      \u2502 x1 \u2502 x2 \u2502 x3 \u2502 x4 \u2502 x5 \u2502 x6 \u2502 x7 \u2502 x8 \u2502 x9 \u2502 x10 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 English    \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1   \u2502\n\u2502 2   \u2502 German     \u2502 1  \u2502 2  \u2502 2  \u2502 1  \u2502 2  \u2502 2  \u2502 1  \u2502 2  \u2502 1  \u2502 2   \u2502\n\u2502 3   \u2502 Norwegian  \u2502 1  \u2502 2  \u2502 1  \u2502 1  \u2502 3  \u2502 3  \u2502 1  \u2502 3  \u2502 1  \u2502 1   \u2502\n\u2502 4   \u2502 Spanish    \u2502 1  \u2502 2  \u2502 2  \u2502 2  \u2502 4  \u2502 4  \u2502 2  \u2502 4  \u2502 2  \u2502 3   \u2502\n\u2502 5   \u2502 Portuguese \u2502 1  \u2502 2  \u2502 2  \u2502 2  \u2502 4  \u2502 4  \u2502 2  \u2502 4  \u2502 2  \u2502 3   \u2502\n\n\n\n\n\nThen, we need to convert the DataFrame object \ndat\n into a vector of species and traits. The species names are in column 1 named \ntaxon\n, and the traits are in columns 2-11. The trait data need to be converted to a list of vectors, with one vector for each species. An internal function is provided for this:\n\n\njulia\n species, traits = PhyloNetworks.readCSVtoArray(dat);\n\njulia\n species\n5-element Array{String,1}:\n \nEnglish\n\n \nGerman\n\n \nNorwegian\n\n \nSpanish\n\n \nPortuguese\n\n\njulia\n traits\n5-element Array{Array{Any,1},1}:\n Any[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n Any[1, 2, 2, 1, 2, 2, 1, 2, 1, 2]\n Any[1, 2, 1, 1, 3, 3, 1, 3, 1, 1]\n Any[1, 2, 2, 2, 4, 4, 2, 4, 2, 3]\n Any[1, 2, 2, 2, 4, 4, 2, 4, 2, 3]\n\n\n\n\n\nThen, we read the network as usual:\n\n\njulia\n net = readTopology(\n(Spanish,((English)#H1,(Norwegian,(German,#H1))));\n);\n\n\n\n\n\nusing\n \nPhyloPlots\n,\n \nRCall\n\n\nR\npar\n(\nmar\n \n=\n \n[\n0\n,\n0\n,\n0\n,\n0\n]);\n\n\nplot\n(\nnet\n,\n \n:\nR\n,\n \nxlim\n=\n[\n0.8\n,\n7.5\n]);\n\n\n\n\n\n\n\n\nThere are different types of parsimony scores on networks. Currently, we have implemented the \nsoftwired\n criterion only, with two different functions: \nparsimonySoftwired\n and \nparsimonyGF\n.\n\n\nThe function \nparsimonySoftwired\n uses a faster algorithm than \nparsimonyGF\n, but can solve the softwired criterion only.\n\n\njulia\n score = parsimonySoftwired(net, species, traits)\n17.0\n\njulia\n score = parsimonyGF(net,species,traits,:softwired)\n17.0\n\n\n\n\n\n\n\nFinding the most parsimonious network\n\n\nThe function \nmaxParsimonyNet\n searches for the most parsimonious level-1 network. It uses the \nparsimonyGF\n function, with softwired criterion as default, which will be extended to other criteria later.\n\n\nJust like \nsnaq!\n, \nmaxParsimonyNet\n requires a starting topology, which can be a tree or a level-1 network, and returns a level-1 network. Taxa present in the data but absent from the starting topology will be ignored during the search.\n\n\nstarttree\n \n=\n \nreadTopology\n(\n(((English,German),Norwegian),Spanish);\n);\n\n\nnet1\n \n=\n \nmaxParsimonyNet\n(\nstarttree\n,\n \ndat\n,\n \nhmax\n=\n1\n,\n \noutgroup\n=\nSpanish\n,\n \nrootname\n=\nswadesh\n)\n\n\n\n\n\n\nThe example data is very small: only 1 of the 11 traits is parsimony informative, on the 4 taxa specified by the starting topology. So these data happen to be compatible with a tree, and that tree is returned despite allowing for up to 1 reticulation: \n(Spanish,((English,Norwegian),German));\n.", 
            "title": "Parsimony on networks"
        }, 
        {
            "location": "/man/parsimony/#parsimony-on-networks", 
            "text": "", 
            "title": "Parsimony on networks"
        }, 
        {
            "location": "/man/parsimony/#parsimony-score-of-a-given-network", 
            "text": "We can calculate the parsimony score of a given network topology and a given set of characters. The characters could be in a CSV file in this format:     taxon  trait1  trait2  trait3  trait4  trait5  trait6 ...      English  1  2  1  1  1  3    ...       ...     The trait values can be integer numbers, or strings. The data table may have missing data, and may contain extra taxa that we might want to exclude.  An example file comes with the package, available  here  or  here .  First, we need to read the trait table as a DataFrame object:  julia  using CSV, DataFrames\n\njulia  csvfile = joinpath(Pkg.dir( PhyloNetworks ), examples , Swadesh.csv );\n\njulia  dat = CSV.read(csvfile);\n\njulia  head(dat) # head shows the first 6 rows only\n5\u00d711 DataFrames.DataFrame\n\u2502 Row \u2502 taxon      \u2502 x1 \u2502 x2 \u2502 x3 \u2502 x4 \u2502 x5 \u2502 x6 \u2502 x7 \u2502 x8 \u2502 x9 \u2502 x10 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 English    \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1  \u2502 1   \u2502\n\u2502 2   \u2502 German     \u2502 1  \u2502 2  \u2502 2  \u2502 1  \u2502 2  \u2502 2  \u2502 1  \u2502 2  \u2502 1  \u2502 2   \u2502\n\u2502 3   \u2502 Norwegian  \u2502 1  \u2502 2  \u2502 1  \u2502 1  \u2502 3  \u2502 3  \u2502 1  \u2502 3  \u2502 1  \u2502 1   \u2502\n\u2502 4   \u2502 Spanish    \u2502 1  \u2502 2  \u2502 2  \u2502 2  \u2502 4  \u2502 4  \u2502 2  \u2502 4  \u2502 2  \u2502 3   \u2502\n\u2502 5   \u2502 Portuguese \u2502 1  \u2502 2  \u2502 2  \u2502 2  \u2502 4  \u2502 4  \u2502 2  \u2502 4  \u2502 2  \u2502 3   \u2502  Then, we need to convert the DataFrame object  dat  into a vector of species and traits. The species names are in column 1 named  taxon , and the traits are in columns 2-11. The trait data need to be converted to a list of vectors, with one vector for each species. An internal function is provided for this:  julia  species, traits = PhyloNetworks.readCSVtoArray(dat);\n\njulia  species\n5-element Array{String,1}:\n  English \n  German \n  Norwegian \n  Spanish \n  Portuguese \n\njulia  traits\n5-element Array{Array{Any,1},1}:\n Any[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n Any[1, 2, 2, 1, 2, 2, 1, 2, 1, 2]\n Any[1, 2, 1, 1, 3, 3, 1, 3, 1, 1]\n Any[1, 2, 2, 2, 4, 4, 2, 4, 2, 3]\n Any[1, 2, 2, 2, 4, 4, 2, 4, 2, 3]  Then, we read the network as usual:  julia  net = readTopology( (Spanish,((English)#H1,(Norwegian,(German,#H1)))); );  using   PhyloPlots ,   RCall  R par ( mar   =   [ 0 , 0 , 0 , 0 ]);  plot ( net ,   : R ,   xlim = [ 0.8 , 7.5 ]);    There are different types of parsimony scores on networks. Currently, we have implemented the  softwired  criterion only, with two different functions:  parsimonySoftwired  and  parsimonyGF .  The function  parsimonySoftwired  uses a faster algorithm than  parsimonyGF , but can solve the softwired criterion only.  julia  score = parsimonySoftwired(net, species, traits)\n17.0\n\njulia  score = parsimonyGF(net,species,traits,:softwired)\n17.0", 
            "title": "Parsimony score of a given network"
        }, 
        {
            "location": "/man/parsimony/#finding-the-most-parsimonious-network", 
            "text": "The function  maxParsimonyNet  searches for the most parsimonious level-1 network. It uses the  parsimonyGF  function, with softwired criterion as default, which will be extended to other criteria later.  Just like  snaq! ,  maxParsimonyNet  requires a starting topology, which can be a tree or a level-1 network, and returns a level-1 network. Taxa present in the data but absent from the starting topology will be ignored during the search.  starttree   =   readTopology ( (((English,German),Norwegian),Spanish); );  net1   =   maxParsimonyNet ( starttree ,   dat ,   hmax = 1 ,   outgroup = Spanish ,   rootname = swadesh )   The example data is very small: only 1 of the 11 traits is parsimony informative, on the 4 taxa specified by the starting topology. So these data happen to be compatible with a tree, and that tree is returned despite allowing for up to 1 reticulation:  (Spanish,((English,Norwegian),German)); .", 
            "title": "Finding the most parsimonious network"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\nDocumentation for \nPhyloNetworks\n's public (exported) interface.\n\n\nSee \nInternal Documentation\n for documentation on internal functions.\n\n\n\n\nPublic Documentation\n\n\nIndex\n\n\ntypes\n\n\nutilities\n\n\ndata and topology read/write\n\n\nnetwork inference\n\n\nnetwork Comparisons\n\n\ncontinuous trait evolution\n\n\ndiscrete trait evolution\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nPhyloNetworks.BinaryTraitSubstitutionModel\n\n\nPhyloNetworks.DataCF\n\n\nPhyloNetworks.EqualRatesSubstitutionModel\n\n\nPhyloNetworks.HybridNetwork\n\n\nPhyloNetworks.ParamsBM\n\n\nPhyloNetworks.PhyloNetworkLinearModel\n\n\nPhyloNetworks.Quartet\n\n\nPhyloNetworks.ReconstructedStates\n\n\nPhyloNetworks.ShiftNet\n\n\nPhyloNetworks.TraitSimulation\n\n\nPhyloNetworks.TraitSubstitutionModel\n\n\nPhyloNetworks.TwoBinaryTraitSubstitutionModel\n\n\nBase.getindex\n\n\nPhyloNetworks.P\n\n\nPhyloNetworks.Q\n\n\nPhyloNetworks.ancestralStateReconstruction\n\n\nPhyloNetworks.biconnectedComponents\n\n\nPhyloNetworks.blobDecomposition\n\n\nPhyloNetworks.bootsnaq\n\n\nPhyloNetworks.calibrateFromPairwiseDistances!\n\n\nPhyloNetworks.cladewiseorder!\n\n\nPhyloNetworks.deleteHybridThreshold!\n\n\nPhyloNetworks.deleteleaf!\n\n\nPhyloNetworks.descendenceMatrix\n\n\nPhyloNetworks.directEdges!\n\n\nPhyloNetworks.displayedNetworkAt!\n\n\nPhyloNetworks.displayedTrees\n\n\nPhyloNetworks.expectations\n\n\nPhyloNetworks.expectationsPlot\n\n\nPhyloNetworks.fitDiscrete\n\n\nPhyloNetworks.fittedQuartetCF\n\n\nPhyloNetworks.getNodeAges\n\n\nPhyloNetworks.getShiftEdgeNumber\n\n\nPhyloNetworks.getShiftValue\n\n\nPhyloNetworks.hardwiredCluster\n\n\nPhyloNetworks.hardwiredClusterDistance\n\n\nPhyloNetworks.hardwiredClusters\n\n\nPhyloNetworks.hybridBootstrapSupport\n\n\nPhyloNetworks.hybridatnode!\n\n\nPhyloNetworks.lambda_estim\n\n\nPhyloNetworks.majorTree\n\n\nPhyloNetworks.mapAllelesCFtable\n\n\nPhyloNetworks.maxParsimonyNet\n\n\nPhyloNetworks.minorTreeAt\n\n\nPhyloNetworks.mu_estim\n\n\nPhyloNetworks.nStates\n\n\nPhyloNetworks.pairwiseTaxonDistanceMatrix\n\n\nPhyloNetworks.parsimonyGF\n\n\nPhyloNetworks.parsimonySoftwired\n\n\nPhyloNetworks.phyloNetworklm\n\n\nPhyloNetworks.predint\n\n\nPhyloNetworks.predintPlot\n\n\nPhyloNetworks.preorder!\n\n\nPhyloNetworks.printEdges\n\n\nPhyloNetworks.printNodes\n\n\nPhyloNetworks.randomTrait\n\n\nPhyloNetworks.readBootstrapTrees\n\n\nPhyloNetworks.readInputTrees\n\n\nPhyloNetworks.readMultiTopology\n\n\nPhyloNetworks.readSnaqNetwork\n\n\nPhyloNetworks.readTableCF\n\n\nPhyloNetworks.readTableCF!\n\n\nPhyloNetworks.readTopology\n\n\nPhyloNetworks.readTopologyLevel1\n\n\nPhyloNetworks.readTrees2CF\n\n\nPhyloNetworks.regressorHybrid\n\n\nPhyloNetworks.regressorShift\n\n\nPhyloNetworks.rootatnode!\n\n\nPhyloNetworks.rootonedge!\n\n\nPhyloNetworks.rotate!\n\n\nPhyloNetworks.setGamma!\n\n\nPhyloNetworks.setLength!\n\n\nPhyloNetworks.sharedPathMatrix\n\n\nPhyloNetworks.shiftHybrid\n\n\nPhyloNetworks.sigma2_estim\n\n\nPhyloNetworks.simulate\n\n\nPhyloNetworks.snaq!\n\n\nPhyloNetworks.snaqDebug\n\n\nPhyloNetworks.sorttaxa!\n\n\nPhyloNetworks.summarizeDataCF\n\n\nPhyloNetworks.ticr\n\n\nPhyloNetworks.ticr!\n\n\nPhyloNetworks.tipLabels\n\n\nPhyloNetworks.topologyMaxQPseudolik!\n\n\nPhyloNetworks.topologyQPseudolik!\n\n\nPhyloNetworks.treeEdgesBootstrap\n\n\nPhyloNetworks.vcv\n\n\nPhyloNetworks.writeMultiTopology\n\n\nPhyloNetworks.writeSubTree!\n\n\nPhyloNetworks.writeTopology\n\n\n\n\n\n\ntypes\n\n\n#\n\n\nPhyloNetworks.BinaryTraitSubstitutionModel\n \n \nType\n.\n\n\nBinaryTraitSubstitutionModel(\u03b1, \u03b2 [, label])\n\n\n\n\n\nTraitSubstitutionModel\n for binary traits (with 2 states). Default labels are \"0\" and \"1\". \u03b1 is the rate of transition from \"0\" to \"1\", and \u03b2 from \"1\" to \"0\".\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.DataCF\n \n \nType\n.\n\n\nDataCF type\n\n\ntype that contains the following attributes:\n\n\n\n\nquartet (vector of Quartets)\n\n\nnumQuartets\n\n\ntree (vector of trees: empty if a table of CF was input instead of list of trees)\n\n\nnumTrees (-1 if a table CF was input instead of list of trees)\n\n\nrepSpecies (taxon names that were repeated in table of CF or input gene trees: used inside snaq for multiple alleles case)\n\n\n\n\nThe list of Quartet may be accessed with the attribute .quartet. If the input was a list of trees, the HybridNetwork's can be accessed with the attribute .tree. For example, if the DataCF object is named d, d.quartet[1] will show the first quartet and d.tree[1] will print the first input tree.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.EqualRatesSubstitutionModel\n \n \nType\n.\n\n\nEqualRatesSubstitutionModel(numberStates, \u03b1, labels)\n\n\n\n\n\nTraitSubstitutionModel\n for traits with any number of states and equal substitution rates \u03b1 between all states. Default labels are \"1\",\"2\",...\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.HybridNetwork\n \n \nType\n.\n\n\nHybridNetwork type\n Explicit network or tree with the following attributes:\n\n\n\n\nnumTaxa\n\n\nnumNodes (total number of nodes)\n\n\nnumEdges\n\n\nnumHybrids (number of hybrid nodes)\n\n\nedge (array of Edges)\n\n\nnode (array of Nodes)\n\n\nroot (index of root in vector 'node'. May be artificial, for printing and traversal purposes only.)\n\n\nhybrid (array of Nodes: those are are hybrid nodes)\n\n\nleaf (array of Nodes: those that are leaves)\n\n\nloglik (negative log pseudolik after estimation)\n\n\nisRooted (true or false)\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.ParamsBM\n \n \nType\n.\n\n\nParamsBM \n: ParamsProcess\n\n\n\n\n\nType for a BM process on a network. Fields are \nmu\n (expectation), \nsigma2\n (variance), \nrandomRoot\n (whether the root is random, default to \nfalse\n), and \nvarRoot\n (if the root is random, the variance of the root, defalut to \nNaN\n).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.PhyloNetworkLinearModel\n \n \nType\n.\n\n\nPhyloNetworkLinearModel\n:LinPredModel\n\n\n\n\n\nRegression object for a phylogenetic regression. Result of fitting function \nphyloNetworklm\n. Dominated by the \nLinPredModel\n class, from package \nGLM\n.\n\n\nThe following StatsBase functions can be applied to it: \ncoef\n, \nnobs\n, \nvcov\n, \nstderror\n, \nconfint\n, \ncoeftable\n, \ndof_residual\n, \ndof\n, \ndeviance\n, \nresiduals\n, \nmodel_response\n, \npredict\n, \nloglikelihood\n, \nnulldeviance\n, \nnullloglikelihood\n, \nr2\n, \nadjr2\n, \naic\n, \naicc\n, \nbic\n.\n\n\nThe following StatsModels functions can also be applied to it: \nModelFrame\n, \nModelMatrix\n, \nFormula\n.\n\n\nEstimated variance and mean of the BM process used can be retrieved with functions \nsigma2_estim\n and \nmu_estim\n.\n\n\nIf a Pagel's lambda model is fitted, the parameter can be retrieved with function \nlambda_estim\n.\n\n\nAn ancestral state reconstruction can be performed from this fitted object using function: \nancestralStateReconstruction\n.\n\n\nThe \nPhyloNetworkLinearModel\n object has fields: \nlm\n, \nV\n, \nVy\n, \nRL\n, \nY\n, \nX\n, \nlogdetVy\n, \nind\n, \nmsng\n, \nmodel\n, \nlambda\n. Type in \"?PhyloNetworkLinearModel.field\" to get help on a specific field.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.Quartet\n \n \nType\n.\n\n\nQuartet type\n\n\ntype that saves the information on a given 4-taxon subset. It contains the following attributes:\n\n\n\n\nnumber\n\n\ntaxon (vector of taxon names)\n\n\nobsCF (vector of observed CF)\n\n\nlogPseudoLik\n\n\nngenes (number of gene trees used to compute the observed CF: -1 if unknown)\n\n\nqnet (internal topological structure that saves the expCF after snaq estimation to emphasize that the expCF depend on a specific network, not the data)\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.ReconstructedStates\n \n \nType\n.\n\n\nReconstructedStates\n\n\n\n\n\nType containing the inferred information about the law of the ancestral states given the observed tips values. The missing tips are considered as ancestral states.\n\n\nThe following functions can be applied to it: \nexpectations\n (vector of expectations at all nodes), \nstderror\n (the standard error), \npredint\n (the prediction interval).\n\n\nThe \nReconstructedStates\n object has fields: \ntraits_nodes\n, \nvariances_nodes\n, \nNodeNumbers\n, \ntraits_tips\n, \ntipNumbers\n, \nmodel\n. Type in \"?ReconstructedStates.field\" to get help on a specific field.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.ShiftNet\n \n \nType\n.\n\n\nShiftNet\n\n\n\n\n\nShifts associated to a \nHybridNetwork\n sorted in topological order. Its \nshift\n field is a vector of shift values, one for each node, corresponding to the shift on the parent edge of the node (which makes sense for tree nodes only: they have a single parent edge).\n\n\nTwo \nShiftNet\n objects on the same network can be concatened with \n*\n.\n\n\nShiftNet(node::Vector{Node}, value::Vector{T} where T\n:Real, net::HybridNetwork; checkPreorder=true::Bool)\n\n\nConstructor from a vector of nodes and associated values. The shifts are located on the edges above the nodes provided. Warning, shifts on hybrid edges are not allowed.\n\n\nShiftNet(edge::Vector{Edge}, value::Vector{T} where T\n:Real, net::HybridNetwork; checkPreorder=true::Bool)\n\n\nConstructor from a vector of edges and associated values. Warning, shifts on hybrid edges are not allowed.\n\n\nExtractors: \ngetShiftEdgeNumber\n, \ngetShiftValue\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.TraitSimulation\n \n \nType\n.\n\n\nTraitSimulation\n\n\n\n\n\nResult of a trait simulation on an \nHybridNetwork\n with function \nsimulate\n.\n\n\nThe following functions and extractors can be applied to it: \ntipLabels\n, \nobj[:Tips]\n, \nobj[:InternalNodes]\n (see documentation for function \ngetindex(::TraitSimulation, ::Symbol)\n).\n\n\nThe \nTraitSimulation\n object has fields: \nM\n, \nparams\n, \nmodel\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.TraitSubstitutionModel\n \n \nType\n.\n\n\nTraitSubstitutionModel\n\n\n\n\n\nAbstract type for discrete trait substitution models, using a continous time Markov model on a phylogeny. Adapted from the substitutionModels module in BioJulia. The same \nQ\n and \nP\n function names are used for the transition rates and probabilities.\n\n\nsee \nBinaryTraitSubstitutionModel\n, \nEqualRatesSubstitutionModel\n, \nTwoBinaryTraitSubstitutionModel\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.TwoBinaryTraitSubstitutionModel\n \n \nType\n.\n\n\nTwoBinaryTraitSubstitutionModel(rate [, label])\n\n\n\n\n\nTraitSubstitutionModel\n for two binary traits, possibly correlated. Default labels are \"x0\", \"x1\" for trait 1, and \"y0\", \"y1\" for trait 2. If provided, \nlabel\n should be a vector of size 4, listing labels for trait 1 first then labels for trait 2. \nrate\n should be a vector of substitution rates of size 8. rate[1],...,rate[4] describe rates of changes in trait 1. rate[5],...,rate[8] describe rates of changes in trait 2.\n\n\nIn the transition matrix, trait combinations are listed in the following order: x0-y0, x0-y1, x1-y0, x1-y1.\n\n\nexample\n\n\nmodel\n \n=\n \nTwoBinaryTraitSubstitutionModel\n([\n2.0\n,\n1.2\n,\n1.1\n,\n2.2\n,\n1.0\n,\n3.1\n,\n2.0\n,\n1.1\n],\n\n        \n[\ncarnivory\n,\n \nnoncarnivory\n,\n \nwet\n,\n \ndry\n]);\n\n\nmodel\n\n\nusing\n \nPhyloPlots\n\n\nplot\n(\nmodel\n)\n \n# to visualize states and rates\n\n\n\n\n\n\nsource\n\n\n\n\nutilities\n\n\n#\n\n\nPhyloNetworks.tipLabels\n \n \nFunction\n.\n\n\ntipLabels(x)\n\n\n\n\n\nReturn a vector of taxon names at the leaves, for objects of various types: \nHybridNetwork\n, Vector of \nHybridNetwork\ns (in which case the union is taken then sorted), Vector of \nQuartet\ns, \nDataCF\n, \nTraitSimulation\n, \nMatrixTopologicalOrder\n.\n\n\nFor a network, the taxon names are coerced to strings.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sorttaxa!\n \n \nFunction\n.\n\n\nsorttaxa!(DataFrame, columns)\n\n\n\n\n\nReorder the 4 taxa and reorders the observed concordance factors accordingly, on each row of the data frame. If \ncolumns\n is committed, taxon names are assumed to be in columns 1-4 and CFs are assumed to be in columns 5-6 with quartets in this order: 12_34, 13_24, 14_23. Does \nnot\n reorder credibility interval values, if present.\n\n\nsorttaxa!(DataCF)\nsorttaxa!(Quartet, permutation_tax, permutation_cf)\n\n\n\n\n\nReorder the 4 taxa in each element of the DataCF \nquartet\n. For a given Quartet, reorder the 4 taxa in its fields \ntaxon\n and \nqnet.quartetTaxon\n (if non-empty) and reorder the 3 concordance values accordingly, in \nobsCF\n and \nqnet.expCF\n.\n\n\npermutation_tax\n and \npermutation_cf\n should be vectors of short integers (Int8) of length 4 and 3 respectively, whose memory allocation gets reused. Their length is \nnot checked\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.printEdges\n \n \nFunction\n.\n\n\nprintEdges(net)\nprintEdges(io::IO, net)\n\n\n\n\n\nPrint information on the edges of a \nHybridNetwork\n or \nQuartetNetwork\n object \nnet\n: edge number, numbers of nodes attached to it, edge length, whether it's a hybrid edge, its \u03b3 inheritance value, whether it's a major edge, if it could contain the root (this field is not always updated, though) and attributes pertaining to level-1 networks used in SNaQ: in which cycle it is contained (-1 if no cycle), and if the edge length is identifiable (based on quartet concordance factors).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.printNodes\n \n \nFunction\n.\n\n\nprintNodes(net)\nprintNodes(io, net)\n\n\n\n\n\nPrint information on the nodes of a \nHybridNetwork\n net: node number, whether it's a leaf, whether it's a hybrid node, whether it's connected to one or more hybrid edges, it's name (label), the cycle in which it is belong (-1 if no cycle; makes sense for level-1 networks), and the list of edges attached to it, by their numbers.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.summarizeDataCF\n \n \nFunction\n.\n\n\nsummarizeDataCF(d::DataCF)\n\n\nfunction to summarize the information contained in a DataCF object. It has the following optional arguments:\n\n\n\n\nfilename: if provided, the summary will be saved in the filename, not to screen\n\n\npc (number between (0,1)): threshold of percentage of missing genes to identify 4-taxon subsets with fewer genes than the threshold\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.directEdges!\n \n \nFunction\n.\n\n\ndirectEdges\n!(\nnet\n::\nHybridNetwork\n;\n \ncheckMajor\n=\ntrue\n::\nBool\n)\n\n\n\n\n\n\nUpdates the edges' attribute \nisChild1\n, according to the root placement. Also updates edges' attribute \ncontainRoot\n, for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if checkMajor=true.\n\n\nWarning: Assumes that isChild1 is correct on hybrid edges (to avoid changing the identity of which nodes are hybrids and which are not).\n\n\nReturns the network. Throws a 'RootMismatch' Exception if the root was found to conflict with the direction of any hybrid edge.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.preorder!\n \n \nFunction\n.\n\n\npreorder!(net::HybridNetwork)\n\n\nUpdates attribute net.nodes_changed in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges' direction needs to be correct before calling preorder!, using directEdges!\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.cladewiseorder!\n \n \nFunction\n.\n\n\ncladewiseorder!(net::HybridNetwork)\n\n\n\n\n\nUpdates attribute net.cladewiseorder_nodeIndex. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges' direction needs to be correct before calling \ncladewiseorder!\n, using \ndirectEdges!\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.rootatnode!\n \n \nFunction\n.\n\n\nrootatnode\n!(\nHybridNetwork\n,\n \nnodeNumber\n::\nInteger\n;\n \nindex\n=\nfalse\n::\nBool\n,\n \nverbose\n=\ntrue\n::\nBool\n)\n\n\nrootatnode\n!(\nHybridNetwork\n,\n \nNode\n;\n \nverbose\n=\ntrue\n)\n\n\nrootatnode\n!(\nHybridNetwork\n,\n \nnodeName\n::\nAbstractString\n;\n \nverbose\n=\ntrue\n)\n\n\n\n\n\n\nRoot the network/tree object at the node with name 'nodeName' or number 'nodeNumber' (by default) or with index 'nodeNumber' if index=true. Attributes isChild1 and containRoot are updated along the way. Use \nplot(net, showNodeNumber=true, showEdgeLength=false)\n to visualize and identify a node of interest. (see package \nPhyloPlots\n)\n\n\nReturn the network.\n\n\nWarnings:\n\n\n\n\nIf the node is a leaf, the root will be placed along the edge adjacent to the leaf. This might add a new node.\n\n\n\n\nIf the desired root placement is incompatible with one or more hybrids, then\n\n\n\n\na RootMismatch error is thrown; use \nverbose=false\n to silence the root mismatch info printed before the error is thrown.\n\n\nthe input network will still have some attributes modified.\n\n\n\n\n\n\n\n\nSee also: \nrootonedge!\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.rootonedge!\n \n \nFunction\n.\n\n\nrootonedge\n!(\nHybridNetwork\n,\n \nedgeNumber\n::\nInteger\n;\n \nindex\n=\nfalse\n::\nBool\n,\n \nverbose\n=\ntrue\n::\nBool\n)\n\n\nrootonedge\n!(\nHybridNetwork\n,\n \nEdge\n;\n \nverbose\n=\ntrue\n::\nBool\n)\n\n\n\n\n\n\nRoot the network/tree along an edge with number \nedgeNumber\n (by default) or with index \nedgeNumber\n if \nindex=true\n. Attributes \nisChild1\n and \ncontainRoot\n are updated along the way.\n\n\nThis adds a new node and a new edge to the network. Use \nplot(net, showEdgeNumber=true, showEdgeLength=false)\n to visualize and identify an edge of interest. (see package \nPhyloPlots\n)\n\n\nSee also: \nrootatnode!\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hybridatnode!\n \n \nFunction\n.\n\n\nhybridatnode!(net::HybridNetwork, nodeNumber::Integer)\n\n\n\n\n\nChange the status of edges in network \nnet\n, to move the hybrid node in a cycle to the node with number \nnodeNumber\n. This node must be in one (and only one) cycle, otherwise an error will be thrown.\n\n\nnet\n is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. Check and update the nodes' field \ninCycle\n.\n\n\nExample #\"\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\n);\n\n\njulia\n \nusing\n \nPhyloPlots\n\n\njulia\n \nplot\n(\nnet\n,\n \nshowNodeNumber\n=\ntrue\n)\n\n\njulia\n \nhybridatnode!\n(\nnet\n,\n \n-\n4\n)\n\n\njulia\n \nplot\n(\nnet\n)\n\n\n\n\n\n\nsource\n\n\nhybridatnode!(net, hybrid::Node, newNode::Node)\n\n\n\n\n\nMove the reticulation from \nhybrid\n to \nnewNode\n, which must in the same cycle. \nnet\n is assumed to be of level 1, but \nno checks\n are made and fields are supposed up-to-date.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.setLength!\n \n \nFunction\n.\n\n\nsetLength!(Edge,new length)\n\n\nset a new length for an object Edge. The new length needs to be positive. For example, if you have a HybridNetwork object net, and do printEdges(net), you can see the list of Edges and their lengths. You can then change the length of the 3rd edge with setLength!(net.edge[3],1.2). If \nnew length\n is above 10, the value 10 will be used, as an upper limit to coalescent units that can be reliably estimated.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.setGamma!\n \n \nFunction\n.\n\n\nsetGamma!(Edge, new \u03b3)\nsetGamma!(Edge, new \u03b3, change other=true::Bool)\n\n\n\n\n\nSet inheritance probability \u03b3 for an edge, which must be a hybrid edge. The new \u03b3 needs to be in [0,1]. The \u03b3 of the \"partner\" hybrid edge is changed accordingly, to 1-\u03b3. The field \nisMajor\n is also changed accordingly. If the new \u03b3 is approximately 0.5, \nEdge\n is set to the major parent, its partner is set to the minor parent.\n\n\nIf \nnet\n is a HybridNetwork object, \nprintEdges(net)\n will show the list of edges and their \u03b3's. The \u03b3 of the third hybrid edge (say) can be changed to 0.2 with \nsetGamma!(net.edge[3],0.2)\n. This will automatically set \u03b3 of the partner hybrid edge to 0.8.\n\n\nThe last argument is true by default. If false: the partner edge is not updated.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.deleteleaf!\n \n \nFunction\n.\n\n\ndeleteleaf\n!(\nHybridNetwork\n,\n \nleafName\n::\nAbstractString\n;\n \nsimplify\n=\ntrue\n)\n\n\ndeleteleaf\n!(\nHybridNetwork\n,\n \nNode\n;\n \nsimplify\n=\ntrue\n)\n\n\ndeleteleaf\n!(\nHybridNetwork\n,\n \nInteger\n;\n \nindex\n=\nfalse\n,\n \nsimplify\n=\ntrue\n)\n\n\n\n\n\n\nDeletes a leaf node from the network, possibly from its name, number, or index in the network's array of nodes.\n\n\nsimplify: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.\n\n\nThe first 2 versions require that \nnode\n is a leaf. The 3rd version does \nnot\n require that \nnode\n is a leaf. If \nnode\n has degree 3 or more, nothing happens. If it has degree 1 or 2, it is deleted.\n\n\nWarning: does \nnot\n update attributes related to level-1 networks, such as inCycle, partition, gammaz, etc. Does not require branch lengths, and designed to work on networks of all levels.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.deleteHybridThreshold!\n \n \nFunction\n.\n\n\ndeleteHybridThreshold!(net::HybridNetwork, threshold::Float64, keepNodes=false)\n\n\n\n\n\nDeletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.\n\n\n\n\nif threshold\n0.5: delete minor hybrid edges with \u03b3 \n threshold (or with a missing \u03b3, for any threshold \n -1.0)\n\n\nif threshold=0.5: delete all minor hybrid edges (i.e normally with \u03b3 \n 0.5, if \u03b3 non-missing)\n\n\nkeepNodes\n: if true, keep all original nodes; delete edges only.\n\n\n\n\nWarnings:\n\n\n\n\nby default, \nkeepNodes\n is false, and partner hybrid edges have their \u03b3 changed to 1.0. If \nkeepNodes\n is true: the \u03b3's of partner hybrid edges are unchanged.\n\n\nassumes correct isMajor attributes.\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.rotate!\n \n \nFunction\n.\n\n\nrotate\n!(\nnet\n::\nHybridNetwork\n,\n \nnodeNumber\n::\nInteger\n;\n \norderedEdgeNum\n::\nArray\n{\nInt,1\n}\n)\n\n\n\n\n\n\nRotates the order of the node's children edges. Useful for plotting, to remove crossing edges. If \nnode\n is a tree node with no polytomy, the 2 children edges are switched and the optional argument \norderedEdgeNum\n is ignored.\n\n\nUse \nplot(net, showNodeNumber=true, showEdgeNumber=false)\n to map node and edge numbers on the network, as shown in the examples below. (see package \nPhyloPlots\n)\n\n\nWarning: assumes that edges are correctly directed (isChild1 updated). This is done by \nplot(net)\n. Otherwise run \ndirectEdges!(net)\n.\n\n\nExample #\"\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\n);\n\n\njulia\n \nusing\n \nPhyloPlots\n\n\njulia\n \nplot\n(\nnet\n,\n \nshowNodeNumber\n=\ntrue\n)\n\n\njulia\n \nrotate!\n(\nnet\n,\n \n-\n4\n)\n\n\njulia\n \nplot\n(\nnet\n)\n\n\njulia\n \nnet\n=\nreadTopology\n(\n(4,((1,(2)#H7:::0.864):2.069,(6,5):3.423):0.265,(3,#H7:::0.136):10.0);\n);\n\n\njulia\n \nplot\n(\nnet\n,\n \nshowNodeNumber\n=\ntrue\n,\n \nshowEdgeNumber\n=\ntrue\n)\n\n\njulia\n \nrotate!\n(\nnet\n,\n \n-\n1\n,\n \norderedEdgeNum\n=\n[\n1\n,\n12\n,\n9\n])\n\n\njulia\n \nplot\n(\nnet\n,\n \nshowNodeNumber\n=\ntrue\n,\n \nshowEdgeNumber\n=\ntrue\n)\n\n\njulia\n \nrotate!\n(\nnet\n,\n \n-\n3\n)\n\n\njulia\n \nplot\n(\nnet\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\ngetindex(collection, key...)\n\n\n\n\n\nRetrieve the value(s) stored at the given key or index within a collection. The syntax \na[i,j,...]\n is converted by the compiler to \ngetindex(a, i, j, ...)\n.\n\n\nExample\n\n\njulia\n A = Dict(\na\n =\n 1, \nb\n =\n 2)\nDict{String,Int64} with 2 entries:\n  \nb\n =\n 2\n  \na\n =\n 1\n\njulia\n getindex(A, \na\n)\n1\n\n\n\n\n\nsource\n\n\ngetindex(obj, d)\n\n\n\n\n\nGetting submatrices of an object of type \nTraitSimulation\n.\n\n\nArguments\n\n\n\n\nobj::TraitSimulation\n: the matrix from which to extract.\n\n\n\n\nd::Symbol\n: a symbol precising which sub-matrix to extract. Can be:\n\n\n\n\n:Tips\n columns and/or rows corresponding to the tips\n\n\n:InternalNodes\n columns and/or rows corresponding to the internal nodes\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getNodeAges\n \n \nFunction\n.\n\n\ngetNodeAges(net)\n\n\n\n\n\nvector of node ages in pre-order, as in \nnodes_changed\n, which is assumed to have been calculated before.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.pairwiseTaxonDistanceMatrix\n \n \nFunction\n.\n\n\npairwiseTaxonDistanceMatrix(net; keepInternal=false,\n                            checkPreorder=true, nodeAges=[])\npairwiseTaxonDistanceMatrix!(M, net, nodeAges)\n\n\n\n\n\nReturn the matrix \nM\n of pairwise distances between nodes in the network:\n\n\n\n\nbetween all nodes (internal and leaves) if \nkeepInternal=true\n, in which case the nodes are listed in \nM\n in the order in which they appear in \nnet.nodes_changed\n\n\nbetween taxa only otherwise, in which case the nodes are listed in \nM\n in the order in which they appear in \ntipLabels(net)\n (i.e. same order as in \nnet.leaf\n)\n\n\n\n\nThe second form modifies \nM\n in place, assuming all nodes.\n\n\nThe distance between the root and a given hybrid node (to take an example) is the weighted average of path lengths from the root to that node, where each path is weighted by the product of \u03b3s of all edges on that path. This distance measures the average genetic distance across the genome, if branch lengths are in substitutions/site.\n\n\noptional arguments:\n\n\n\n\ncheckPreorder\n: if true, \nnet.nodes_changed\n is updated to get a topological ordering of nodes.\n\n\nnodeAges\n: if not provided, i.e. empty vector, the network is \nnot\n modified.   If provided and non-empty, \nnodeAges\n should list node ages in the pre-order in which nodes are listed in \nnodes_changed\n (including leaves), and \nedge lengths\n in \nnet\n \nare modified\n accordingly.\n\n\n\n\nProviding node ages hence makes the network time consistent: such that all paths from the root to a given hybrid node have the same length. If node ages are not provided, the network need not be time consistent.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.biconnectedComponents\n \n \nFunction\n.\n\n\nbiconnectedComponents(network, ignoreTrivial=false)\n\n\n\n\n\nCalculate biconnected components (aka \"blobs\") using Tarjan's algorithm: the output is an array of arrays of edges. These blobs are returned in post-order, but within a blob, edges are \nnot\n necessarily sorted in topological order. If \nignoreTrivial\n is true, trivial components (of a single edge) are not returned. The network is assumed to be connected.\n\n\nWarnings\n: for nodes, fields \nk\n, \ninCycle\n, and \nprev\n are modified during the algorithm. They are used to store the node's \"index\" (time of visitation), \"lowpoint\", and the node's \"parent\", as defined by the order in which nodes are visited.\n\n\nReferences:\n\n\n\n\np. 153 of \nTarjan (1972)\n. Depth first search and linear graph algorithms, SIAM Journal on Computing, 1(2):146-160\n\n\non \ngeeksforgeeks\n, there is an error (as of 2018-01-30): \nelif v != parent[u] and low[u] \n disc[v]:\n (python version) should be replaced by \nelif v != parent[u] and disc[u] \n disc[v]:\n\n\nnice explanation at this \nurl\n\n\n\n\nsource\n\n\nbiconnectedComponents(node, index, S, blobs, ignoreTrivial)\n\n\n\n\n\nHelper recursive function starting at a node (not a network). \nindex\n is an array containing a single integer, thus mutable: order in which nodes are visited.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.blobDecomposition\n \n \nFunction\n.\n\n\nblobDecomposition!(network)\nblobDecomposition(network)\n\n\n\n\n\nFind blobs using \nbiconnectedComponents\n; find their roots using \nblobInfo\n; create a forest in the form of a disconnected network (for efficiency), by deconnecting the root of each non-trivial blob from its parent. The root of each blob corresponds to a new leaf (in another tree of the forest): the number of the blob's root is given to the newly created leaf.\n\n\nThe first (bang) version modifies the network and returns the array of blob roots. The second version copies the network then returns a tuple: the forest and the blob roots.\n\n\nsource\n\n\n\n\ndata and topology read/write\n\n\n#\n\n\nPhyloNetworks.readTopology\n \n \nFunction\n.\n\n\nreadTopology(file name)\nreadTopology(parenthetical description)\n\n\n\n\n\nRead tree or network topology from parenthetical format (extended Newick). If the root node has a single child: ignore (i.e. delete from the topology) the root node and its child edge.\n\n\nInput: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readTopologyLevel1\n \n \nFunction\n.\n\n\nreadTopologyLevel1(filename)\nreadTopologyLevel1(parenthetical format)\n\n\n\n\n\nsame as readTopology, reads a tree or network from parenthetical format, but this function enforces the necessary conditions for any starting topology in SNaQ: non-intersecting cycles, no polytomies, unrooted. It sets any missing branch length to 1.0.\n\n\nIf the network has a bad diamond II (in which edge lengths are \u03b3's are not identifiable) and if the edge below this diamond has a length \nt\n different from 0, then this length is set back to 0 and the major parent hybrid edge is lengthened by \nt\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readInputTrees\n \n \nFunction\n.\n\n\nreadInputTrees(file)\n\n\nRead a text file with a list of trees/networks in parenthetical format (one tree per line) and transform them like \nreadTopologyLevel1\n does: to be unrooted, with resolved polytomies, missing branch lengths set to 1.0, etc. See \nreadMultiTopology\n to read multiple trees or networks with no modification.\n\n\nOutput: array of HybridNetwork objects.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readMultiTopology\n \n \nFunction\n.\n\n\nreadMultiTopology(file)\n\n\nRead a text file with a list of networks in parenthetical format (one per line). Each network is read with \nreadTopology\n. Return an array of HybridNetwork object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readSnaqNetwork\n \n \nFunction\n.\n\n\nreadSnaqNetwork(output file)\n\n\nfunction to read the estimated network from an .out file generated by the snaq function\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readTrees2CF\n \n \nFunction\n.\n\n\nreadTrees2CF(treefile)\nreadTrees2CF(vector of trees)\n\n\n\n\n\nRead trees in parenthetical format from a file, or take a vector of trees already read, and calculate the proportion of these trees having a given quartet (concordance factor: CF), for all quartets or for a sample of quartets. Optional arguments include:\n\n\n\n\nquartetfile: name of text file with list of 4-taxon subsets to be analyzed. If none is specified, the function will list all possible 4-taxon subsets.\n\n\nwhichQ=\"rand\": to choose a random sample of 4-taxon subsets\n\n\nnumQ: size of random sample (ignored if whichQ is not set to \"rand\")\n\n\nwriteTab=false: does not write the observedCF to a table (default true)\n\n\nCFfile: name of file to save the observedCF (default tableCF.txt)\n\n\nwriteQ=true: save intermediate files with the list of all 4-taxon subsets and chosen random sample (default false).\n\n\nwriteSummary: write descriptive stats of input data (default: true)\n\n\nnexus: if true, it assumes the gene trees are written in nexus file (default: false)\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readTableCF\n \n \nFunction\n.\n\n\nreadTableCF(file)\nreadTableCF(data frame)\nreadTableCF!(data frame)\n\n\n\n\n\nRead a file or DataFrame object containing a table of concordance factors (CF), with one row per 4-taxon set. The first 4 columns are assumed to give the labels of the 4 taxa in each set (tx1, tx2, tx3, tx4). Columns containing the CFs are assumed to be named 'CF12_34', 'CF13_24' and 'CF14_23', or else are assumed to be columns 5,6,7. If present, a column named 'ngenes' will be used to get the number of loci used to estimate the CFs for each 4-taxon set.\n\n\nOptional arguments:\n\n\n\n\nsummaryfile: if specified, a summary file will be created with that name.\n\n\ndelim (for the first form only): to specify how columns are delimited, with single quotes: delim=';'. Default is a \ncsv\n file, i.e. \ndelim=','\n.\n\n\n\n\nThe last version modifies the input data frame, if species are represented by multiple alleles for instance (see \nreadTableCF!\n).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readTableCF!\n \n \nFunction\n.\n\n\nreadTableCF!(data frame, columns)\n\n\n\n\n\nRead in quartet CFs from data frame, assuming information is in columns numbered \ncolumns\n, of length \n7 or 8\n: 4 taxon labels then 3 CFs then ngenes possibly.\n\n\nIf some species appears more than once in the same 4-taxon set (e.g. t1,t1,t2,t3), then the data frame is modified to remove rows (4-taxon sets) that are uninformative about between-species relationships. This situation may occur if multiple individuals are sampled from the same species. A 4-taxon set is uninformative (and its row is removed) if one taxon is repeated 3 or 4 times (like t1,t1,t1,t1 or t1,t2,t2,t2). The list of species appearing twice in some 4-taxon sets is stored in the output DataCF object. For these species, the length of their external edge is identifiable (in coalescent units). If multiple rows correspond to the same 4-taxon set, these rows are merged and their CF values (and number of genes) are averaged.\n\n\nreadTableCF!(DataCF, data frame, columns)\n\n\n\n\n\nModify the \n.quartet.obsCF\n values in the \nDataCF\n object with those read from the data frame in columns numbered \ncolumns\n. \ncolumns\n should have \n3\n columns numbers for the 3 CFs in this order: 12_34, 13_24 and 14_23. Assume the same 4-taxon sets in \nDataCF\n and in the data frame, and in the same order, but this assumption is \nnot checked\n (for speed, e.g. during bootstrapping).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readBootstrapTrees\n \n \nFunction\n.\n\n\nreadBootstrapTrees(filename)\n\n\n\n\n\ninput: name of file containing the path/name to multiple bootstrap files, one per line. Each bootstrap file corresponds to bootstrap trees from a single gene.\n\n\noutput: vector of vectors of trees.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.writeSubTree!\n \n \nFunction\n.\n\n\nwriteSubTree!(IO, network, dendroscope::Bool, names::Bool,\n              round_branch_lengths::Bool, digits::Integer)\n\n\n\n\n\nWrite to IO the extended newick format (parenthetical description) of a network. If written for dendroscope, inheritance \u03b3's are not written. If \nnames\n is true, taxon names are written, otherwise taxon numbers are written instead of taxon names. If unspecified, branch lengths and \u03b3's are rounded to 3 digits.\n\n\nsource\n\n\nwriteSubTree!(IO, node, edge, dendroscope::Bool, names::Bool,\n              round_branch_lengths::Bool, digits::Integer)\n\n\n\n\n\nWrite the extended newick format of the sub-network rooted at \nnode\n and assuming that \nedge\n is a parent of \nnode\n.\n\n\nIf \nparent\n is \nnothing\n, the edge attribute \nisChild1\n is used and assumed to be correct to write the subtree rooted at \nnode\n. This is useful to write a subtree starting at a non-root node. Example:\n\n\nnet\n \n=\n \nreadTopology\n(\n(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\n)\n\n\ndirectEdges!\n(\nnet\n)\n\n\ns\n \n=\n \nIOBuffer\n()\n\n\nPhyloNetworks\n.\nwriteSubTree!\n(\ns\n,\n \nnet\n.\nnode\n[\n7\n],\n \nnothing\n,\n \nfalse\n,\n \ntrue\n)\n\n\nString\n(\ns\n)\n\n\n\n\n\n\nUsed by \nwriteTopology\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.writeTopology\n \n \nFunction\n.\n\n\nwriteTopology(net)\nwriteTopology(net, filename)\nwriteTopology(net, IO)\n\n\n\n\n\nWrite the parenthetical extended Newick format of a network, as a string, to a file or to an IO buffer / stream. Optional arguments (default values):\n\n\n\n\ndi (false): write in format for Dendroscope\n\n\nround (false): rounds branch lengths and heritabilities \u03b3\n\n\ndigits (3): digits after the decimal place for rounding\n\n\nappend (false): if true, appends to the file\n\n\n\n\nIf the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.\n\n\nUses lower-level function \nwriteSubTree!\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.writeMultiTopology\n \n \nFunction\n.\n\n\nwriteMultiTopology(nets, file_name; append=false)\nwriteMultiTopology(nets, IO)\n\n\n\n\n\nWrite an array of networks in parenthetical extended Newick format, one network per line. Use the option append=true to append to the file. Otherwise, the default is to create a new file or overwrite it, if it already existed. Each network is written with \nwriteTopology\n.\n\n\nExamples #\"\n\n\njulia\n \nnet\n \n=\n \n[\nreadTopology\n(\n(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10);\n),\n\n              \nreadTopology\n(\n(A,(B,C));\n),\nreadTopology\n(\n(E,F);\n),\nreadTopology\n(\n(G,H,F);\n)\n]\n;\n\n\n\njulia\n \nwriteMultiTopology\n(\nnet\n,\n \nfournets.net\n)\n \n#\n \nto\n \n(\nover\n)\nwrite\n \nto\n \nfile\n \nfournets.net\n\n\njulia\n \nwriteMultiTopology\n(\nnet\n,\n \nfournets.net\n,\n \nappend\n=\ntrue\n)\n \n#\n \nto\n \nappend\n \nto\n \nthis\n \nfile\n\n\njulia\n \nwriteMultiTopology\n(\nnet\n,\n \nSTDOUT\n)\n         \n#\n \nto\n \nwrite\n \nto\n \nthe\n \nscreen\n \n(\nstandard\n \nout\n)\n\n\n(\nD\n,((\nA\n,(\nB\n)\n#\nH7\n:\n::\n0\n.\n864\n)\n:\n2\n.\n069\n,(\nF\n,\nE\n)\n:\n3\n.\n423\n)\n:\n0\n.\n265\n,(\nC\n,\n#\nH7\n:\n::\n0\n.\n1361111\n)\n:\n10\n.\n0\n);\n\n\n(\nA\n,(\nB\n,\nC\n));\n\n\n(\nE\n,\nF\n);\n\n\n(\nG\n,\nH\n,\nF\n);\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.mapAllelesCFtable\n \n \nFunction\n.\n\n\nmapAllelesCFtable(mapping file, CF file; filename, columns, delim)\n\n\n\n\n\nCreate a new DataFrame containing the same concordance factors as in the input CF file, but with modified taxon names. Each allele name in the input CF table is replaced by the species name that the allele maps onto, based on the mapping file. The mapping file should have column names: allele and species.\n\n\nOptional arguments:\n\n\n\n\nfile name to write/save resulting CF table. If not specified, then the output data frame is not saved to a file.\n\n\ncolumn numbers for the taxon names. 1-4 by default.\n\n\nany keyword arguments that \nCSV.read\n would accept. For example, delim=',' by default: columns are delimited by commas. Unless specified otherwise by the user, \ncategorical\n=false (to read taxon names as Strings, not levels of a categorical factor, for combining the 4 columns with taxon names more easily). The same CSV arguments are used to read both input file (mapping file and quartet file)\n\n\n\n\nSee also \nmapAllelesCFtable!\n to input DataFrames instead of file names.\n\n\nIf a \nfilename\n is specified, such as \"quartetCF_speciesNames.csv\" in the example below, this file is best read later with the option \ncategorical=false\n. example:\n\n\nmapAllelesCFtable\n(\nallele-species-map.csv\n,\n \nallele-quartet-CF.csv\n;\n\n                  \nfilename\n \n=\n \nquartetCF_speciesNames.csv\n)\n\n\ndf_sp\n \n=\n \nCSV\n.\nread\n(\nquartetCF_speciesNames.csv\n,\n \ncategorical\n=\nfalse\n);\n \n# DataFrame object\n\n\ndataCF_specieslevel\n \n=\n \nreadTableCF!\n(\ndf_sp\n);\n \n# DataCF object\n\n\n\n\n\n\nsource\n\n\n\n\nnetwork inference\n\n\n#\n\n\nPhyloNetworks.snaq!\n \n \nFunction\n.\n\n\nsnaq!(T::HybridNetwork, d::DataCF)\n\n\nEstimate the network (or tree) to fit observed quartet concordance factors (CFs) stored in a DataCF object, using maximum pseudo-likelihood. A level-1 network is assumed. The search starts from topology \nT\n, which can be a tree or a network with no more than \nhmax\n hybrid nodes. The function name ends with ! because it modifies the CF data \nd\n by updating its attributes \nexpCF\n: CFs expected under the network model. It does \nnot\n modify \nT\n. The quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.\n\n\nOutput:\n\n\n\n\nestimated network in file \n.out\n (also in \n.log\n): best network overall and list of networks from each individual run.\n\n\nthe best network and modifications of it, in file \n.networks\n. All networks in this file have the same undirected topology as the best network, but have different hybrid/gene flow directions. These other networks are reported with their pseudo-likelihood scores, because  non-identifiability issues can cause them to have very similar scores, and because  SNaQ was shown to estimate the undirected topology accurately but not the direction of  hybridization in cases of near non-identifiability.\n\n\nif any error occurred, file \n.err\n provides information (seed) to reproduce the error.\n\n\n\n\nThere are many optional arguments, including\n\n\n\n\nhmax: maximum number of hybridizations allowed (default 1)\n\n\nverbose: if true, print information about the numerical optimization\n\n\nruns: number of independent starting points for the search (default 10)\n\n\noutgroup: outgroup taxon to root the estimated topology at the very end\n\n\nfilename: root name for the output files. Default is \"snaq\". If empty (\"\"), files are \nnot\n created, progress log goes to the screen only (standard out).\n\n\nseed: seed to replicate a given search\n\n\n\n\nThe following optional arguments control when to stop the optimization of branch lengths and \u03b3's on each individual candidate network. Defaults are in parentheses:\n\n\n\n\nftolRel (1e-6) and ftolAbs (1e-6): relative and absolute differences of the network score between the current and proposed parameters,\n\n\nxtolRel (1e-2) and xtolAbs (1e-3): relative and absolute differences between the current and proposed parameters.\n\n\n\n\nGreater values will result in a less thorough but faster search. These parameters are used when evaluating candidate networks only. The following optional arguments control when to stop proposing new network topologies:\n\n\n\n\nNfail (75): maximum number of times that new topologies are proposed and rejected (in a row).\n\n\nliktolAbs (1e-6): the proposed network is accepted if its score is better than the current score by at least liktolAbs.\n\n\n\n\nLower values of Nfail and greater values of liktolAbs and ftolAbs would result in a less thorough but faster search.\n\n\nAt the end, branch lengths and \u03b3's are optimized on the last \"best\" network with different and very thorough tolerance parameters: 1e-12 for ftolRel, 1e-10 for ftolAbs, xtolRel, xtolAbs.\n\n\nSee also: \ntopologyMaxQPseudolik!\n to optimize parameters on a fixed topology, and \ntopologyQPseudolik!\n to get the deviance (pseudo log-likelihood up to a constant) of a fixed topology with fixed parameters.\n\n\nReference: Claudia Sol\u00eds-Lemus and C\u00e9cile An\u00e9 (2016). Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting. \nPLoS Genetics\n 12(3):e1005896\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.snaqDebug\n \n \nFunction\n.\n\n\nsnaqDebug(currT::HybridNetwork,d::DataCF)\n\n\nfunction to replicate a given run that produces error according to the .err file generated by snaq. The same settings used in that run should be used in this function, specially the seed. See the readme file online for more details.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.topologyMaxQPseudolik!\n \n \nFunction\n.\n\n\ntopologyMaxQPseudolik!(net::HybridNetwork, d::DataCF)\n\n\nEstimate the branch lengths and inheritance probabilities (\u03b3's) for a given network topology. The network is \nnot\n modified, only the object \nd\n is, with updated expected concordance factors.\n\n\nOuput: new network, with optimized parameters (branch lengths and gammas). The maximized quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0. This is also an attribute of the network, which can be accessed with \nnet.loglik\n.\n\n\nOptional arguments (default value):\n\n\n\n\nverbose (false): if true, information on the numerical optimization is printed to screen\n\n\nftolRel (1e-5), ftolAbs (1e-6), xtolRel (1e-3), xtolAbs (1e-4): absolute and relative tolerance values for the pseudo-deviance function and the parameters\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.topologyQPseudolik!\n \n \nFunction\n.\n\n\ntopologyQPseudolik!(net::HybridNetwork, d::DataCF)\n\n\nCalculate the quartet pseudo-deviance of a given network/tree for DataCF \nd\n. This is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.\n\n\nBe careful if the net object does not have all internal branch lengths specified because then the pseudolikelihood will be meaningless.\n\n\nThe loglik attribute of the network is undated, and \nd\n is updated with the expected concordance factors under the input network.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.fittedQuartetCF\n \n \nFunction\n.\n\n\nfittedQuartetCF(d::DataCF, format::Symbol)\n\n\nreturn a data frame with the observed and expected quartet concordance factors after estimation of a network with snaq(T,d). The format can be :wide (default) or :long.\n\n\n\n\nif wide, the output has one row per 4-taxon set, and each row has 10 columns: 4 columns for the taxon names, 3 columns for the observed CFs and 3 columns for the expected CF.\n\n\nif long, the output has one row per quartet, i.e. 3 rows per 4-taxon sets, and 7 columns: 4 columns for the taxon names, one column to give the quartet resolution, one column for the observed CF and the last column for the expected CF.\n\n\n\n\nsee also: \ntopologyQPseudolik!\n and \ntopologyMaxQPseudolik!\n to update the fitted CF expected under a specific network, inside the DataCF object \nd\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.bootsnaq\n \n \nFunction\n.\n\n\nbootsnaq(T::HybridNetwork, df::DataFrame)\nbootsnaq(T::HybridNetwork, vector of tree lists)\n\n\n\n\n\nBootstrap analysis for SNaQ. Bootstrap data can be quartet concordance factors (CF), drawn from sampling uniformly in their credibility intervals, as given in the data frame \ndf\n. Alternatively, bootstrap data can be gene trees sampled from a vector of tree lists: one list of bootstrap trees per locus (see \nreadBootstrapTrees\n to generate this, from a file containing a list of bootstrap files: one per locus).\n\n\nFrom each bootstrap replicate, a network is estimated with snaq!, with a search starting from topology \nT\n. Optional arguments include the following, with default values in parentheses:\n\n\n\n\nhmax (1): max number of reticulations in the estimated networks\n\n\nnrep (10): number of bootstrap replicates.\n\n\nruns (10): number of independent optimization runs for each replicate\n\n\nfilename (\"bootsnaq\"): root name for output files. No output files if \"\".\n\n\nseed (0 to get a random seed from the clock): seed for random number generator\n\n\notherNet (empty): another starting topology so that each replicate will start prcnet% runs on otherNet and (1-prcnet)% runs on T\n\n\nprcnet (0): percentage of runs starting on otherNet; error if different than 0.0, and otherNet not specified.\n\n\nftolRel, ftolAbs, xtolRel, xtolAbs, liktolAbs, Nfail: see \nsnaq!\n, same defaults.\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.calibrateFromPairwiseDistances!\n \n \nFunction\n.\n\n\ncalibrateFromPairwiseDistances!(net, distances::Matrix{Float64},\n    taxon_names::Vector{String})\n\n\n\n\n\nCalibrate the network to match (as best as possible) input pairwise distances between taxa, such as observed from sequence data. \ntaxon_names\n should provide the list of taxa, in the same order in which they they are considered in the \ndistances\n matrix. The optimization criterion is the sum of squares between the observed distances, and the distances from the network (weighted average of tree distances, weighted by \u03b3's). The network's edge lengths are modified.\n\n\nWarning: for many networks, mutiple calibrations can fit the pairwise distance data equally well (lack of identifiability). This function will output \none\n of these equally good calibrations.\n\n\noptional arguments (default):\n\n\n\n\ncheckPreorder (true)\n\n\nforceMinorLength0 (false) to force minor hybrid edges to have a length of 0\n\n\nNLoptMethod (:LD_MMA) for the optimization algorithm. Other options include :LN_COBYLA (derivative-free); see NLopt package.\n\n\ntolerance values to control when the optimization is stopped: ftolRel (1e-12), ftolAbs (1e-10) on the criterion, and xtolRel (1e-10), xtolAbs (1e-10) on branch lengths / divergence times.\n\n\nverbose (false)\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.ticr\n \n \nFunction\n.\n\n\nticr!(net, D::DataFrame, optimizeBL::Bool)\nticr!(net, D::DataCF,    optimizeBL::Bool)\nticr(D::DataCF)\n\n\n\n\n\nGoodness-of-fit test for the adequacy of the multispecies network coalescent, to see if a given population or species network explains the quartet concordance factor data adequately (see Stenz et al 2015 and \naddendum\n for the method on trees) Obviously the acronym TICR (Tree Incongruence Checking with R) becomes outdated: with a method extended to networks and implemented in Julia. Oh well :smiley:.\n\n\nThe tree / network needs to have branch lengths in coalescent units, must be fully resolved, and must be of level 1.\n\n\nThe model assumes a Dirichlet distribution for the observed quartet concordance factor, with concentration parameter estimated from the data. An outlier p-value is calculated for each four-taxon set. Four-taxon sets are then binned into  categories according to their p-values: \n0-0.01\n, \n0.01-0.05\n, \n0.05-0.10\n, and \n0.10-1\n. Finally, a chi-square goodness-of-fit test is performed on these binned frequency with 3 degrees of freedom, to determine if they departs from the expected proportions \n(0.01, 0.04, 0.05, 0.90)\n.\n\n\n\n\nThe first version takes a DataFrame object where each row corresponds to a given four-taxon set. The DataFrame is modified by having an additional another column containing the p-values corresponding to each four-taxon set.\n\n\nThe second version takes a DataCF object and modifies it by updating the expected concordance factors stored in that object.\n\n\nThe last version (which all others call) assumes that the expected concordance factors in the DataCF object are correctly calculated from the test network.\n\n\n\n\noptimizeBL\n: when false, the loglik field of \nnet\n is updated; when \ntrue\n, a copy of \nnet\n with updated branch lengths (in coalescent units) and update loglik is returned.\n\n\noutput:\n\n\n\n\np-value of the \u03c7^2 test\n\n\n\u03c7^2 statistic\n\n\nvalue of the pseudo likelihood\n\n\nvalue of the concentration parameter \u03b1\n\n\na vector of outlier p-values, one for each four-taxon set\n\n\nnetwork (first and second versions): \nnet\n with loglik field updated if \noptimizeBL\n is false;  copy of \nnet\n with optimized branch lengths and loglik if \noptimizeBL\n is true\n\n\n\n\nReferences\n\n\nNWM Stenz, B Larget, DA Baum and C Ane\u0301 (2015). Exploring tree-like and non-tree-like patterns using genome sequences: An example using the inbreeding plant species \nArabidopsis thaliana\n (L.) Heynh. Systematic Biology, 64(5):809-823. doi: 10.1093/sysbio/syv039\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.ticr!\n \n \nFunction\n.\n\n\nticr!(net, D::DataFrame, optimizeBL::Bool)\nticr!(net, D::DataCF,    optimizeBL::Bool)\nticr(D::DataCF)\n\n\n\n\n\nGoodness-of-fit test for the adequacy of the multispecies network coalescent, to see if a given population or species network explains the quartet concordance factor data adequately (see Stenz et al 2015 and \naddendum\n for the method on trees) Obviously the acronym TICR (Tree Incongruence Checking with R) becomes outdated: with a method extended to networks and implemented in Julia. Oh well :smiley:.\n\n\nThe tree / network needs to have branch lengths in coalescent units, must be fully resolved, and must be of level 1.\n\n\nThe model assumes a Dirichlet distribution for the observed quartet concordance factor, with concentration parameter estimated from the data. An outlier p-value is calculated for each four-taxon set. Four-taxon sets are then binned into  categories according to their p-values: \n0-0.01\n, \n0.01-0.05\n, \n0.05-0.10\n, and \n0.10-1\n. Finally, a chi-square goodness-of-fit test is performed on these binned frequency with 3 degrees of freedom, to determine if they departs from the expected proportions \n(0.01, 0.04, 0.05, 0.90)\n.\n\n\n\n\nThe first version takes a DataFrame object where each row corresponds to a given four-taxon set. The DataFrame is modified by having an additional another column containing the p-values corresponding to each four-taxon set.\n\n\nThe second version takes a DataCF object and modifies it by updating the expected concordance factors stored in that object.\n\n\nThe last version (which all others call) assumes that the expected concordance factors in the DataCF object are correctly calculated from the test network.\n\n\n\n\noptimizeBL\n: when false, the loglik field of \nnet\n is updated; when \ntrue\n, a copy of \nnet\n with updated branch lengths (in coalescent units) and update loglik is returned.\n\n\noutput:\n\n\n\n\np-value of the \u03c7^2 test\n\n\n\u03c7^2 statistic\n\n\nvalue of the pseudo likelihood\n\n\nvalue of the concentration parameter \u03b1\n\n\na vector of outlier p-values, one for each four-taxon set\n\n\nnetwork (first and second versions): \nnet\n with loglik field updated if \noptimizeBL\n is false;  copy of \nnet\n with optimized branch lengths and loglik if \noptimizeBL\n is true\n\n\n\n\nReferences\n\n\nNWM Stenz, B Larget, DA Baum and C Ane\u0301 (2015). Exploring tree-like and non-tree-like patterns using genome sequences: An example using the inbreeding plant species \nArabidopsis thaliana\n (L.) Heynh. Systematic Biology, 64(5):809-823. doi: 10.1093/sysbio/syv039\n\n\nsource\n\n\n\n\nnetwork Comparisons\n\n\n#\n\n\nPhyloNetworks.majorTree\n \n \nFunction\n.\n\n\nmajorTree(net::HybridNetwork)\n\n\nWarning: assumes correct isMajor attributes.\n\n\nExtracts the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node. Returns a HybridNetwork object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.minorTreeAt\n \n \nFunction\n.\n\n\nminorTreeAt(net::HybridNetwork, hybindex::Integer, keepNodes=false)\n\n\n\n\n\nExtract the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i=\nhybindex\n), where the minor hybrid edge is kept instead of the major hybrid edge. If \nkeepNodes\n is true, all nodes are kept during edge removal.\n\n\nWarning: assume correct \nisMajor\n fields.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.displayedTrees\n \n \nFunction\n.\n\n\ndisplayedTrees\n(\nnet\n::\nHybridNetwork\n,\n \ngamma\n::\nFloat64\n;\n \nkeepNodes\n=\nfalse\n::\nBool\n)\n\n\n\n\n\n\nExtracts all trees displayed in a network, following hybrid edges with heritability \n= \u03b3 threshold (or \n0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than \u03b3. Returns an array of trees, as HybridNetwork objects.\n\n\nkeepNodes\n: if true, keep all nodes during hybrid edge removal.\n\n\nWarnings:\n\n\n\n\nif \nkeepNodes\n is true: the retained partner hybrid edges have their \u03b3 values unchanged, but their \nisMajor\n is changed to true\n\n\nassume correct \nisMajor\n attributes.\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.displayedNetworkAt!\n \n \nFunction\n.\n\n\ndisplayedNetworkAt!(net::HybridNetwork, node::Node, keepNodes=false)\n\n\n\n\n\nDelete all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before. If \nkeepNodes\n is true, all nodes are kept during edge removal.\n\n\nWarning: assume correct \nisMajor\n fields.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hardwiredClusters\n \n \nFunction\n.\n\n\nhardwiredClusters(net::HybridNetwork, S::Union{Vector{String},Vector{Int}})\n\n\nReturns a matrix describing all the hardwired clusters in a network. Warnings: Clusters are rooted, so the root must be correct.           Allows for missing taxa, with entries all 0.\n\n\nEach row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).\n\n\n\n\nfirst column: edge number\n\n\nnext columns: 0/1 values. 1=descendant of edge, 0=not a descendant, or missing taxon.\n\n\nlast column:  10/11 values. 10=tree edge, 11=hybrid edge\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hardwiredCluster\n \n \nFunction\n.\n\n\nhardwiredCluster(edge::Edge,taxa::Union{Vector{String},Vector{Int}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}},\n                  visited::Vector{Int})\n\n\n\n\n\nCalculate the hardwired cluster of \nnode\n, coded a vector of booleans: true for taxa that are descendent of nodes, false for other taxa (including missing taxa).\n\n\nThe node should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.\n\n\nvisited: vector of node numbers, of all visited nodes.\n\n\nExamples: #\"\n\n\njulia\n net5 = \n(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));\n |\n readTopology |\n directEdges! ;\n\njulia\n taxa = net5 |\n tipLabels # ABC EF D\n6-element Array{String,1}:\n \nA\n\n \nB\n\n \nC\n\n \nE\n\n \nF\n\n \nD\n\n\njulia\n hardwiredCluster(net5.edge[12], taxa) # descendants of 12th edge = CEF\n6-element Array{Bool,1}:\n false\n false\n  true\n  true\n  true\n false\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hardwiredClusterDistance\n \n \nFunction\n.\n\n\nhardwiredClusterDistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)\n\n\nTakes 2 networks and returns their hardwired cluster distance, that is, the number of hardwired clusters found in one network and not in the other. Note that this is not a distance per se on the full space of hybrid networks: there are pairs of different networks for which this measure is 0. But it is a distance on some network subspaces.\n\n\nIf the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, the trees are considered unrooted.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.treeEdgesBootstrap\n \n \nFunction\n.\n\n\ntreeEdgesBootstrap(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork)\n\n\nread a list of bootstrap networks (\nboot_net\n) and a reference network (\nref_net\n), and calculate the bootstrap support of the tree edges in the reference network. All minor hybrid edges (\u03b3\n0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.\n\n\noutput:\n\n\n\n\na data frame with one row per tree edge and two columns: edge number, bootstrap support (as a percentage)\n\n\nthe major tree from the reference network, where minor hybrid edges (with \u03b3\n0.5) have been removed.\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hybridBootstrapSupport\n \n \nFunction\n.\n\n\nhybridBootstrapSupport(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)\n\n\nMatch hybrid nodes in a reference network with those in an array of networks, like bootstrap networks. All networks must be fully resolved, and on the same taxon set. If \nrooted=true\n, all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).\n\n\nTwo hybrid edges in two networks are said to match if they share the same \"hybrid\" clade (or recipient) and the same \"donor clade\", which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with \u03b3\n0.5) and one is its minor sister (following the major hybrid edge with \u03b3\n0.5).\n\n\nTo calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If \nrooted=false\n, sister clades are considered as bipartitions.\n\n\nOutput:\n\n\n\n\na \"node\" data frame (see below)\n\n\nan \"edge\" data frame (see below)\n\n\na \"clade\" data frame to describe the make up of all clades found as hybrids or sisters, starting with a column \ntaxa\n that lists all taxa. All other columns correspond to a given clade and contain true/false values. \ntrue\n means that a given taxon belongs in a given clade. For a clade named \nH1\n, for instance, and if the data frame was named \ncla\n, the list of taxa in this clade can be obtained with \ncla[:taxa][cla[:H1]]\n.\n\n\nan array of gamma values, with one row for each bootstrap network and two columns (major/minor) for each hybrid edge in the reference network. If this hybrid edge was found in the bootstrap network (i.e. same hybrid and sister clades, after removal of all other hybrid nodes), its bootstrap gamma value is recorded here. Otherwise, the gamma entry is 0.0.\n\n\na vector with the number of each hybrid edge in the reference network, in the same order as for the columns in the array of gamma values above.\n\n\n\n\nThe \"node\" data frame has one row per clade and 9 columns giving:\n\n\n\n\nclade\n: the clade's name, like the taxon name (if a hybrid is a single taxon) or the hybrid tag (like 'H1') in the reference network\n\n\nnode\n: the node number in the reference network. missing if the clade is not in this network.\n\n\nhybridnode\n: typically the same node number as above, except for hybrid clades in the reference network. For those, the hybrid node number is listed here.\n\n\nedge\n: number of the parent edge, parent to the node in column 2, if found in the ref network. missing otherwise.\n\n\nBS_hybrid\n: percentage of bootstrap networks in which the clade is found to be a hybrid clade.\n\n\nBS_sister\n: percentage of bootstrap networks in which the clade is found to be sister to some hybrid clade (sum of the next 2 columns)\n\n\nBS_major_sister\n: percentage of bootstrap networks in which the clade is found to be the major sister to some hybrid clade\n\n\nBS_minor_sister\n: same as previous, but minor\n\n\nBS_hybrid_samesisters\n: percentage of bootstrap networks in which the clade is found to be a hybrid and with the same set of sister clades as in the reference network. Applies to hybrid clades found in the reference network only, missing for all other clades.\n\n\n\n\nThe \"edge\" data frame has one row for each pair of clades, and 8 columns:\n\n\n\n\nedge\n: hybrid edge number, if the edge appears in the reference network. missing otherwise.\n\n\nhybrid_clade\n: name of the clade found to be a hybrid, descendent of 'edge'\n\n\nhybrid\n: node number of that clade, if it appears in the reference network. missing otherwise.\n\n\nsister_clade\n: name of the clade that is sister to 'edge', i.e. be sister to a hybrid\n\n\nsister\n: node number of that clade, if in the ref network.\n\n\nBS_hybrid_edge\n: percentage of bootstrap networks in which 'edge' is found to be a hybrid  edge, i.e. when the clade in the 'hybrid' column is found to be a hybrid and the clade in  the 'sister' column is one of its sisters.\n\n\nBS_major\n: percentage of bootstrap networks in which 'edge' is found to be a major hybrid  edge, i.e. when 'hybrid' is found to be a hybrid clade and 'sister' is found to be its  major sister.\n\n\nBS_minor\n: same as previous, but minor\n\n\n\n\nsource\n\n\n\n\ncontinuous trait evolution\n\n\n#\n\n\nPhyloNetworks.simulate\n \n \nFunction\n.\n\n\nsimulate(net::HybridNetwork, params::ParamsProcess, checkPreorder=true::Bool)\n\n\n\n\n\nSimualte some traits on \nnet\n using the parameters \nparams\n. For now, only parameters of type \nParamsBM\n (Brownian Motion) are accepted.\n\n\nAssumes that the network is in the pre-order. If \ncheckPreorder=true\n (default), then it runs function \npreoder\n on the network beforehand.\n\n\nReturns an object of type \nTraitSimulation\n.\n\n\nExamples\n\n\njulia\n phy = readTopology(joinpath(Pkg.dir(\nPhyloNetworks\n), \nexamples\n, \ncarnivores_tree.txt\n));\n\njulia\n par = ParamsBM(1, 0.1) # BM with expectation 1 and variance 0.1.\nPhyloNetworks.ParamsBM:\nParameters of a BM with fixed root:\nmu: 1\nSigma2: 0.1\n\n\njulia\n srand(17920921); # Seed for reproducibility\n\njulia\n sim = simulate(phy, par) # Simulate on the tree.\nPhyloNetworks.TraitSimulation:\nTrait simulation results on a network with 16 tips, using a BM model, with parameters:\nmu: 1\nSigma2: 0.1\n\n\njulia\n traits = sim[:Tips] # Extract simulated values at the tips.\n16-element Array{Float64,1}:\n  2.17618\n  1.03308\n  3.04898\n  3.03796\n  2.1897\n  4.03159\n  4.64773\n -0.877285\n  4.62512\n -0.511167\n  1.35604\n -0.103112\n -2.08847\n  2.63991\n  2.80512\n  3.19109\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.shiftHybrid\n \n \nFunction\n.\n\n\nshiftHybrid\n(\nvalue\n::\nVector\n{\nT\n}\n \nwhere\n \nT\n:\nReal\n,\n \nnet\n::\nHybridNetwork\n;\n \ncheckPreorder\n=\ntrue\n::\nBool\n)\n\n\n\n\n\n\nConstruct an object \nShiftNet\n with shifts on all the edges below hybrid nodes, with values provided. The vector of values must have the same length as the number of hybrids in the network.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getShiftEdgeNumber\n \n \nFunction\n.\n\n\ngetShiftEdgeNumber(shift::ShiftNet)\n\n\n\n\n\nGet the edge numbers where the shifts are located, for an object \nShiftNet\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getShiftValue\n \n \nFunction\n.\n\n\ngetShiftValue(shift::ShiftNet)\n\n\n\n\n\nGet the values of the shifts, for an object \nShiftNet\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.phyloNetworklm\n \n \nFunction\n.\n\n\nphyloNetworklm(f, fr, net, model=\nBM\n,\n    fTolRel=1e^-10, fTolAbs=1e^-10, xTolRel=1e^-10, xTolAbs=1e^-10,\n    startingValue=0.5)`\n\n\n\n\n\nPhylogenetic regression, using the correlation structure induced by the network.\n\n\nReturns an object of class \nPhyloNetworkLinearModel\n. See documentation for this type and example to see all the functions that can be applied to it.\n\n\nArguments\n\n\n\n\nf::Formula\n: formula to use for the regression (see the \nDataFrame\n package)\n\n\nfr::AbstractDataFrame\n: DataFrame containing the data and regressors at the tips. It should have an extra column labelled \"tipNames\", that gives the names of the taxa for each observation.\n\n\nnet::HybridNetwork\n: phylogenetic network to use. Should have labelled tips.\n\n\nmodel::AbstractString=\"BM\"\n: the model to use, \"BM\" (default) or \"lambda\" (for Pagel's lambda).\n\n\nno_names::Bool=false\n: if \ntrue\n, force the function to ignore the tips names. The data is then assumed to be in the same order as the tips of the network. Default to false, setting it to true is dangerous, and strongly discouraged.\n\n\n\n\nIf \nmodel=\"lambda\"\n, there are a some parameters to control the optimization in lambda:\n\n\n\n\nfTolRel::AbstractFloat=1e-10\n: relative tolerance on the likelihood value for the optimization in lambda.\n\n\nfTolAbs::AbstractFloat=1e-10\n: absolute tolerance on the likelihood value for the optimization in lambda.\n\n\nxTolRel::AbstractFloat=1e-10\n: relative tolerance on the parameter value for the optimization in lambda.\n\n\nxTolAbs::AbstractFloat=1e-10\n: absolute tolerance on the parameter value for the optimization in lambda.\n\n\nstartingValue::Real=0.5\n: the starting value for the parameter in the optimization in lambda.\n\n\n\n\nSee also\n\n\nType \nPhyloNetworkLinearModel\n, Function \nancestralStateReconstruction\n\n\nExamples\n\n\njulia\n phy = readTopology(joinpath(Pkg.dir(\nPhyloNetworks\n), \nexamples\n, \ncaudata_tree.txt\n));\n\njulia\n using CSV # to read data file, next\n\njulia\n dat = CSV.read(joinpath(Pkg.dir(\nPhyloNetworks\n), \nexamples\n, \ncaudata_trait.txt\n));\n\njulia\n using StatsModels # for stat model formulas\n\njulia\n fitBM = phyloNetworklm(@formula(trait ~ 1), dat, phy);\n\njulia\n fitBM # Shows a summary\nStatsModels.DataFrameRegressionModel{PhyloNetworks.PhyloNetworkLinearModel,Array{Float64,2}}\n\nFormula: trait ~ +1\n\nModel: BM\n\nParameter(s) Estimates:\nSigma2: 0.00294521\n\nCoefficients:\n             Estimate Std.Error t value Pr(\n|t|)\n(Intercept)     4.679  0.330627 14.1519   \n1e-31\n\nLog Likelihood: -78.9611507833\nAIC: 161.9223015666\n\njulia\n round(sigma2_estim(fitBM), 6) # rounding for jldoctest convenience\n0.002945\n\njulia\n round(mu_estim(fitBM), 4)\n4.679\n\njulia\n using StatsBase # for aic() stderror() loglikelihood() etc.\n\njulia\n round(loglikelihood(fitBM), 10)\n-78.9611507833\n\njulia\n round(aic(fitBM), 10)\n161.9223015666\n\njulia\n round(aicc(fitBM), 10)\n161.9841572367\n\njulia\n round(bic(fitBM), 10)\n168.4887090241\n\njulia\n coef(fitBM)\n1-element Array{Float64,1}:\n 4.679\n\njulia\n confint(fitBM)\n1\u00d72 Array{Float64,2}:\n 4.02696  5.33104\n\njulia\n abs(round(r2(fitBM), 10)) # absolute value for jldoctest convenience\n0.0\n\njulia\n abs(round(adjr2(fitBM), 10))\n0.0\n\njulia\n vcov(fitBM)\n1\u00d71 Array{Float64,2}:\n 0.109314\n\njulia\n residuals(fitBM)\n197-element Array{Float64,1}:\n -0.237648\n -0.357937\n -0.159387\n -0.691868\n -0.323977\n -0.270452\n -0.673486\n -0.584654\n -0.279882\n -0.302175\n  \u22ee\n -0.777026\n -0.385121\n -0.443444\n -0.327303\n -0.525953\n -0.673486\n -0.603158\n -0.211712\n -0.439833\n\njulia\n model_response(fitBM)\n197-element Array{Float64,1}:\n 4.44135\n 4.32106\n 4.51961\n 3.98713\n 4.35502\n 4.40855\n 4.00551\n 4.09434\n 4.39912\n 4.37682\n \u22ee\n 3.90197\n 4.29388\n 4.23555\n 4.3517\n 4.15305\n 4.00551\n 4.07584\n 4.46729\n 4.23917\n\njulia\n predict(fitBM)\n197-element Array{Float64,1}:\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n \u22ee\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sigma2_estim\n \n \nFunction\n.\n\n\nsigma2_estim(m::PhyloNetworkLinearModel)\n\n\n\n\n\nEstimated variance for a fitted object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.mu_estim\n \n \nFunction\n.\n\n\nmu_estim(m::PhyloNetworkLinearModel)\n\n\n\n\n\nEstimated root value for a fitted object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.lambda_estim\n \n \nFunction\n.\n\n\nlambda_estim(m::PhyloNetworkLinearModel)\n\n\n\n\n\nEstimated lambda parameter for a fitted object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.ancestralStateReconstruction\n \n \nFunction\n.\n\n\nancestralStateReconstruction(net::HybridNetwork, Y::Vector, params::ParamsBM)\n\n\n\n\n\nCompute the conditional expectations and variances of the ancestral (un-observed) traits values at the internal nodes of the phylogenetic network (\nnet\n), given the values of the traits at the tips of the network (\nY\n) and some known parameters of the process used for trait evolution (\nparams\n, only BM with fixed root works for now).\n\n\nThis function assumes that the parameters of the process are known. For a more general function, see \nancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])\n.\n\n\nsource\n\n\nancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])\n\n\n\n\n\nFunction to find the ancestral traits reconstruction on a network, given an object fitted by function \nphyloNetworklm\n. By default, the function assumes that the regressor is just an intercept. If the value of the regressor for all the ancestral states is known, it can be entered in X_n, a matrix with as many columns as the number of predictors used, and as many lines as the number of unknown nodes or tips.\n\n\nReturns an object of type \nReconstructedStates\n. See documentation for this type and examples for functions that can be applied to it.\n\n\nExamples\n\n\njulia\n using CSV \n# to read data file\n\n\njulia\n phy \n=\n readTopology\n(\njoinpath\n(\nPkg.dir\n(\nPhyloNetworks\n),\n \nexamples\n,\n \ncarnivores_tree.txt\n));\n\n\njulia\n dat \n=\n CSV.read\n(\njoinpath\n(\nPkg.dir\n(\nPhyloNetworks\n),\n \nexamples\n,\n \ncarnivores_trait.txt\n));\n\n\njulia\n using StatsModels \n# for statistical model formulas\n\n\njulia\n fitBM \n=\n phyloNetworklm\n(\n@\nformula\n(\ntrait \n~\n \n1\n),\n dat\n,\n phy\n);\n\n\njulia\n ancStates \n=\n ancestralStateReconstruction\n(\nfitBM\n)\n \n# Should produce a warning, as variance is unknown.\n\nWARNING\n:\n These prediction intervals show uncertainty \nin\n ancestral values\n,\n\nassuming that the estimated variance rate of evolution is correct.\nAdditional uncertainty \nin\n the estimation of this variance rate is\nignored\n,\n so prediction intervals should be larger.\nPhyloNetworks.ReconstructedStates\n:\n\n     Node index     Pred.       Min. Max. \n(\n95\n%\n)\n\n           \n-5.0\n   \n1.32139\n  \n-0.288423\n     \n2.9312\n\n           \n-8.0\n   \n1.03258\n  \n-0.539072\n    \n2.60423\n\n           \n-7.0\n   \n1.41575\n \n-0.0934395\n    \n2.92495\n\n           \n-6.0\n   \n1.39417\n \n-0.0643135\n    \n2.85265\n\n           \n-4.0\n   \n1.39961\n \n-0.0603343\n    \n2.85955\n\n           \n-3.0\n   \n1.51341\n  \n-0.179626\n    \n3.20644\n\n          \n-13.0\n    \n5.3192\n    \n3.96695\n    \n6.67145\n\n          \n-12.0\n   \n4.51176\n    \n2.94268\n    \n6.08085\n\n          \n-16.0\n   \n1.50947\n  \n0.0290151\n    \n2.98992\n\n          \n-15.0\n   \n1.67425\n   \n0.241696\n    \n3.10679\n\n          \n-14.0\n   \n1.80309\n   \n0.355568\n     \n3.2506\n\n          \n-11.0\n    \n2.7351\n    \n1.21896\n    \n4.25123\n\n          \n-10.0\n   \n2.73217\n    \n1.16545\n    \n4.29889\n\n           \n-9.0\n   \n2.41132\n   \n0.639075\n    \n4.18357\n\n           \n-2.0\n   \n2.04138\n \n-0.0340955\n    \n4.11686\n\n           \n14.0\n   \n1.64289\n    \n1.64289\n    \n1.64289\n\n            \n8.0\n   \n1.67724\n    \n1.67724\n    \n1.67724\n\n            \n5.0\n  \n0.331568\n   \n0.331568\n   \n0.331568\n\n            \n2.0\n   \n2.27395\n    \n2.27395\n    \n2.27395\n\n            \n4.0\n  \n0.275237\n   \n0.275237\n   \n0.275237\n\n            \n6.0\n   \n3.39094\n    \n3.39094\n    \n3.39094\n\n           \n13.0\n  \n0.355799\n   \n0.355799\n   \n0.355799\n\n           \n15.0\n  \n0.542565\n   \n0.542565\n   \n0.542565\n\n            \n7.0\n  \n0.773436\n   \n0.773436\n   \n0.773436\n\n           \n10.0\n   \n6.94985\n    \n6.94985\n    \n6.94985\n\n           \n11.0\n   \n4.78323\n    \n4.78323\n    \n4.78323\n\n           \n12.0\n   \n5.33016\n    \n5.33016\n    \n5.33016\n\n            \n1.0\n \n-0.122604\n  \n-0.122604\n  \n-0.122604\n\n           \n16.0\n   \n0.73989\n    \n0.73989\n    \n0.73989\n\n            \n9.0\n   \n4.84236\n    \n4.84236\n    \n4.84236\n\n            \n3.0\n    \n1.0695\n     \n1.0695\n     \n1.0695\n\n\n\njulia\n expectations\n(\nancStates\n)\n\n\n31\n\u00d7\n2\n DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 condExpectation \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \n1\n   \u2502 \n-5\n         \u2502 \n1.32139\n         \u2502\n\u2502 \n2\n   \u2502 \n-8\n         \u2502 \n1.03258\n         \u2502\n\u2502 \n3\n   \u2502 \n-7\n         \u2502 \n1.41575\n         \u2502\n\u2502 \n4\n   \u2502 \n-6\n         \u2502 \n1.39417\n         \u2502\n\u2502 \n5\n   \u2502 \n-4\n         \u2502 \n1.39961\n         \u2502\n\u2502 \n6\n   \u2502 \n-3\n         \u2502 \n1.51341\n         \u2502\n\u2502 \n7\n   \u2502 \n-13\n        \u2502 \n5.3192\n          \u2502\n\u2502 \n8\n   \u2502 \n-12\n        \u2502 \n4.51176\n         \u2502\n\u22ee\n\u2502 \n23\n  \u2502 \n15\n         \u2502 \n0.542565\n        \u2502\n\u2502 \n24\n  \u2502 \n7\n          \u2502 \n0.773436\n        \u2502\n\u2502 \n25\n  \u2502 \n10\n         \u2502 \n6.94985\n         \u2502\n\u2502 \n26\n  \u2502 \n11\n         \u2502 \n4.78323\n         \u2502\n\u2502 \n27\n  \u2502 \n12\n         \u2502 \n5.33016\n         \u2502\n\u2502 \n28\n  \u2502 \n1\n          \u2502 \n-0.122604\n       \u2502\n\u2502 \n29\n  \u2502 \n16\n         \u2502 \n0.73989\n         \u2502\n\u2502 \n30\n  \u2502 \n9\n          \u2502 \n4.84236\n         \u2502\n\u2502 \n31\n  \u2502 \n3\n          \u2502 \n1.0695\n          \u2502\n\njulia\n predint\n(\nancStates\n)\n\n\n31\n\u00d7\n2\n Array\n{\nFloat64\n,\n2\n}\n:\n\n \n-0.288423\n    \n2.9312\n\n \n-0.539072\n    \n2.60423\n\n \n-0.0934395\n   \n2.92495\n\n \n-0.0643135\n   \n2.85265\n\n \n-0.0603343\n   \n2.85955\n\n \n-0.179626\n    \n3.20644\n\n  \n3.96695\n     \n6.67145\n\n  \n2.94268\n     \n6.08085\n\n  \n0.0290151\n   \n2.98992\n\n  \n0.241696\n    \n3.10679\n\n  \u22ee\n  \n0.542565\n    \n0.542565\n\n  \n0.773436\n    \n0.773436\n\n  \n6.94985\n     \n6.94985\n\n  \n4.78323\n     \n4.78323\n\n  \n5.33016\n     \n5.33016\n\n \n-0.122604\n   \n-0.122604\n\n  \n0.73989\n     \n0.73989\n\n  \n4.84236\n     \n4.84236\n\n  \n1.0695\n      \n1.0695\n\n\njulia\n expectationsPlot\n(\nancStates\n)\n \n# format the ancestral states\n\n\n31\n\u00d7\n2\n DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \n1\n   \u2502 \n-5\n         \u2502 \n1.32\n    \u2502\n\u2502 \n2\n   \u2502 \n-8\n         \u2502 \n1.03\n    \u2502\n\u2502 \n3\n   \u2502 \n-7\n         \u2502 \n1.42\n    \u2502\n\u2502 \n4\n   \u2502 \n-6\n         \u2502 \n1.39\n    \u2502\n\u2502 \n5\n   \u2502 \n-4\n         \u2502 \n1.4\n     \u2502\n\u2502 \n6\n   \u2502 \n-3\n         \u2502 \n1.51\n    \u2502\n\u2502 \n7\n   \u2502 \n-13\n        \u2502 \n5.32\n    \u2502\n\u2502 \n8\n   \u2502 \n-12\n        \u2502 \n4.51\n    \u2502\n\u22ee\n\u2502 \n23\n  \u2502 \n15\n         \u2502 \n0.54\n    \u2502\n\u2502 \n24\n  \u2502 \n7\n          \u2502 \n0.77\n    \u2502\n\u2502 \n25\n  \u2502 \n10\n         \u2502 \n6.95\n    \u2502\n\u2502 \n26\n  \u2502 \n11\n         \u2502 \n4.78\n    \u2502\n\u2502 \n27\n  \u2502 \n12\n         \u2502 \n5.33\n    \u2502\n\u2502 \n28\n  \u2502 \n1\n          \u2502 \n-0.12\n   \u2502\n\u2502 \n29\n  \u2502 \n16\n         \u2502 \n0.74\n    \u2502\n\u2502 \n30\n  \u2502 \n9\n          \u2502 \n4.84\n    \u2502\n\u2502 \n31\n  \u2502 \n3\n          \u2502 \n1.07\n    \u2502\n\njulia\n using PhyloPlots \n# next: plot ancestral states on the tree\n\n\njulia\n plot\n(\nphy\n,\n \n:\nRCall\n,\n nodeLabel \n=\n expectationsPlot\n(\nancStates\n));\n\n\njulia\n predintPlot\n(\nancStates\n)\n\n\n31\n\u00d7\n2\n DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \n1\n   \u2502 \n-5\n         \u2502 \n[\n-0.29\n,\n \n2.93\n]\n \u2502\n\u2502 \n2\n   \u2502 \n-8\n         \u2502 \n[\n-0.54\n,\n \n2.6\n]\n  \u2502\n\u2502 \n3\n   \u2502 \n-7\n         \u2502 \n[\n-0.09\n,\n \n2.92\n]\n \u2502\n\u2502 \n4\n   \u2502 \n-6\n         \u2502 \n[\n-0.06\n,\n \n2.85\n]\n \u2502\n\u2502 \n5\n   \u2502 \n-4\n         \u2502 \n[\n-0.06\n,\n \n2.86\n]\n \u2502\n\u2502 \n6\n   \u2502 \n-3\n         \u2502 \n[\n-0.18\n,\n \n3.21\n]\n \u2502\n\u2502 \n7\n   \u2502 \n-13\n        \u2502 \n[\n3.97\n,\n \n6.67\n]\n  \u2502\n\u2502 \n8\n   \u2502 \n-12\n        \u2502 \n[\n2.94\n,\n \n6.08\n]\n  \u2502\n\u22ee\n\u2502 \n23\n  \u2502 \n15\n         \u2502 \n0.54\n          \u2502\n\u2502 \n24\n  \u2502 \n7\n          \u2502 \n0.77\n          \u2502\n\u2502 \n25\n  \u2502 \n10\n         \u2502 \n6.95\n          \u2502\n\u2502 \n26\n  \u2502 \n11\n         \u2502 \n4.78\n          \u2502\n\u2502 \n27\n  \u2502 \n12\n         \u2502 \n5.33\n          \u2502\n\u2502 \n28\n  \u2502 \n1\n          \u2502 \n-0.12\n         \u2502\n\u2502 \n29\n  \u2502 \n16\n         \u2502 \n0.74\n          \u2502\n\u2502 \n30\n  \u2502 \n9\n          \u2502 \n4.84\n          \u2502\n\u2502 \n31\n  \u2502 \n3\n          \u2502 \n1.07\n          \u2502\n\njulia\n plot\n(\nphy\n,\n \n:\nRCall\n,\n nodeLabel \n=\n predintPlot\n(\nancStates\n));\n\n\njulia\n using Missings\n;\n \n# preparation to mask 2 values next, for taxa in rows 2 and 5\n\n\njulia\n dat\n[\n:\ntrait\n]\n \n=\n allowmissing\n(\ndat\n[\n:\ntrait\n]);\n\n\njulia\n dat\n[[\n2\n,\n \n5\n],\n \n:\ntrait\n]\n \n=\n \nmissing\n;\n \n# missing values allowed to fit model\n\n\njulia\n fitBM \n=\n phyloNetworklm\n(\n@\nformula\n(\ntrait \n~\n \n1\n),\n dat\n,\n phy\n);\n\n\njulia\n ancStates \n=\n ancestralStateReconstruction\n(\nfitBM\n);\n\nWARNING\n:\n These prediction intervals show uncertainty \nin\n ancestral values\n,\n\nassuming that the estimated variance rate of evolution is correct.\nAdditional uncertainty \nin\n the estimation of this variance rate is\nignored\n,\n so prediction intervals should be larger.\n\njulia\n expectations\n(\nancStates\n)\n\n\n31\n\u00d7\n2\n DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 condExpectation \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \n1\n   \u2502 \n-5\n         \u2502 \n1.42724\n         \u2502\n\u2502 \n2\n   \u2502 \n-8\n         \u2502 \n1.35185\n         \u2502\n\u2502 \n3\n   \u2502 \n-7\n         \u2502 \n1.61993\n         \u2502\n\u2502 \n4\n   \u2502 \n-6\n         \u2502 \n1.54198\n         \u2502\n\u2502 \n5\n   \u2502 \n-4\n         \u2502 \n1.53916\n         \u2502\n\u2502 \n6\n   \u2502 \n-3\n         \u2502 \n1.64984\n         \u2502\n\u2502 \n7\n   \u2502 \n-13\n        \u2502 \n5.33508\n         \u2502\n\u2502 \n8\n   \u2502 \n-12\n        \u2502 \n4.55109\n         \u2502\n\u22ee\n\u2502 \n23\n  \u2502 \n15\n         \u2502 \n0.542565\n        \u2502\n\u2502 \n24\n  \u2502 \n7\n          \u2502 \n0.773436\n        \u2502\n\u2502 \n25\n  \u2502 \n10\n         \u2502 \n6.94985\n         \u2502\n\u2502 \n26\n  \u2502 \n11\n         \u2502 \n4.78323\n         \u2502\n\u2502 \n27\n  \u2502 \n12\n         \u2502 \n5.33016\n         \u2502\n\u2502 \n28\n  \u2502 \n1\n          \u2502 \n-0.122604\n       \u2502\n\u2502 \n29\n  \u2502 \n16\n         \u2502 \n0.73989\n         \u2502\n\u2502 \n30\n  \u2502 \n9\n          \u2502 \n4.84236\n         \u2502\n\u2502 \n31\n  \u2502 \n3\n          \u2502 \n1.0695\n          \u2502\n\njulia\n predint\n(\nancStates\n)\n\n\n31\n\u00d7\n2\n Array\n{\nFloat64\n,\n2\n}\n:\n\n \n-0.31245\n     \n3.16694\n\n \n-0.625798\n    \n3.3295\n\n \n-0.110165\n    \n3.35002\n\n \n-0.0710391\n   \n3.15501\n\n \n-0.0675924\n   \n3.14591\n\n \n-0.197236\n    \n3.49692\n\n  \n3.89644\n     \n6.77373\n\n  \n2.8741\n      \n6.22808\n\n \n-0.0358627\n   \n3.12834\n\n  \n0.182594\n    \n3.2534\n\n  \u22ee\n  \n0.542565\n    \n0.542565\n\n  \n0.773436\n    \n0.773436\n\n  \n6.94985\n     \n6.94985\n\n  \n4.78323\n     \n4.78323\n\n  \n5.33016\n     \n5.33016\n\n \n-0.122604\n   \n-0.122604\n\n  \n0.73989\n     \n0.73989\n\n  \n4.84236\n     \n4.84236\n\n  \n1.0695\n      \n1.0695\n\n\njulia\n expectationsPlot\n(\nancStates\n)\n \n# format node \n-\n ancestral state\n\n\n31\n\u00d7\n2\n DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \n1\n   \u2502 \n-5\n         \u2502 \n1.43\n    \u2502\n\u2502 \n2\n   \u2502 \n-8\n         \u2502 \n1.35\n    \u2502\n\u2502 \n3\n   \u2502 \n-7\n         \u2502 \n1.62\n    \u2502\n\u2502 \n4\n   \u2502 \n-6\n         \u2502 \n1.54\n    \u2502\n\u2502 \n5\n   \u2502 \n-4\n         \u2502 \n1.54\n    \u2502\n\u2502 \n6\n   \u2502 \n-3\n         \u2502 \n1.65\n    \u2502\n\u2502 \n7\n   \u2502 \n-13\n        \u2502 \n5.34\n    \u2502\n\u2502 \n8\n   \u2502 \n-12\n        \u2502 \n4.55\n    \u2502\n\u22ee\n\u2502 \n23\n  \u2502 \n15\n         \u2502 \n0.54\n    \u2502\n\u2502 \n24\n  \u2502 \n7\n          \u2502 \n0.77\n    \u2502\n\u2502 \n25\n  \u2502 \n10\n         \u2502 \n6.95\n    \u2502\n\u2502 \n26\n  \u2502 \n11\n         \u2502 \n4.78\n    \u2502\n\u2502 \n27\n  \u2502 \n12\n         \u2502 \n5.33\n    \u2502\n\u2502 \n28\n  \u2502 \n1\n          \u2502 \n-0.12\n   \u2502\n\u2502 \n29\n  \u2502 \n16\n         \u2502 \n0.74\n    \u2502\n\u2502 \n30\n  \u2502 \n9\n          \u2502 \n4.84\n    \u2502\n\u2502 \n31\n  \u2502 \n3\n          \u2502 \n1.07\n    \u2502\n\njulia\n plot\n(\nphy\n,\n \n:\nRCall\n,\n nodeLabel \n=\n expectationsPlot\n(\nancStates\n));\n\n\njulia\n predintPlot\n(\nancStates\n)\n \n# prediction intervals, in data frame, useful to plot\n\n\n31\n\u00d7\n2\n DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \n1\n   \u2502 \n-5\n         \u2502 \n[\n-0.31\n,\n \n3.17\n]\n \u2502\n\u2502 \n2\n   \u2502 \n-8\n         \u2502 \n[\n-0.63\n,\n \n3.33\n]\n \u2502\n\u2502 \n3\n   \u2502 \n-7\n         \u2502 \n[\n-0.11\n,\n \n3.35\n]\n \u2502\n\u2502 \n4\n   \u2502 \n-6\n         \u2502 \n[\n-0.07\n,\n \n3.16\n]\n \u2502\n\u2502 \n5\n   \u2502 \n-4\n         \u2502 \n[\n-0.07\n,\n \n3.15\n]\n \u2502\n\u2502 \n6\n   \u2502 \n-3\n         \u2502 \n[\n-0.2\n,\n \n3.5\n]\n   \u2502\n\u2502 \n7\n   \u2502 \n-13\n        \u2502 \n[\n3.9\n,\n \n6.77\n]\n   \u2502\n\u2502 \n8\n   \u2502 \n-12\n        \u2502 \n[\n2.87\n,\n \n6.23\n]\n  \u2502\n\u22ee\n\u2502 \n23\n  \u2502 \n15\n         \u2502 \n0.54\n          \u2502\n\u2502 \n24\n  \u2502 \n7\n          \u2502 \n0.77\n          \u2502\n\u2502 \n25\n  \u2502 \n10\n         \u2502 \n6.95\n          \u2502\n\u2502 \n26\n  \u2502 \n11\n         \u2502 \n4.78\n          \u2502\n\u2502 \n27\n  \u2502 \n12\n         \u2502 \n5.33\n          \u2502\n\u2502 \n28\n  \u2502 \n1\n          \u2502 \n-0.12\n         \u2502\n\u2502 \n29\n  \u2502 \n16\n         \u2502 \n0.74\n          \u2502\n\u2502 \n30\n  \u2502 \n9\n          \u2502 \n4.84\n          \u2502\n\u2502 \n31\n  \u2502 \n3\n          \u2502 \n1.07\n          \u2502\n\njulia\n plot\n(\nphy\n,\n \n:\nRCall\n,\n nodeLabel \n=\n predintPlot\n(\nancStates\n));\n\n\n\n\n\n\nsource\n\n\nancestralStateReconstruction\n(\nfr\n::\nAbstractDataFrame\n,\n \nnet\n::\nHybridNetwork\n;\n \nkwargs\n...)\n\n\n\n\n\n\nFunction to find the ancestral traits reconstruction on a network, given some data at the tips. Uses function \nphyloNetworklm\n to perform a phylogenetic regression of the data against an intercept (amounts to fitting an evolutionary model on the network, BM being the only option available for now).\n\n\nSee documentation on \nphyloNetworklm\n and \nancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])\n for further details.\n\n\nReturns an object of type \nReconstructedStates\n.\n\n\nsource\n\n\nancestralStateReconstruction(obj::SSM, trait::Integer)\nancestralStateReconstruction(obj::SSM)\n\n\n\n\n\nEstimate the marginal probability of ancestral states for discrete character number \ntrait\n, or for the active trait if \ntrait\n is unspecified: \nobj.activetrait\n. The parameters of the \nStatisticalSubstitutionModel\n object \nobj\n must first be fitted using \nfitDiscrete\n, and ancestral state reconstruction is conditional on the estimated parameters. If these parameters were estimated using all traits, they are used as is to do ancestral state reconstruction of the particular \ntrait\n of interest.\n\n\noutput\n: data frame with a first column for the node numbers, a second column for the node labels, and a column for each possible state: the entries in these columns give the marginal probability that a given node has a given state.\n\n\nwarnings\n\n\n\n\nnode numbers and node labels refer to those in \nobj.net\n, which might have a different internal representation of nodes than the original network used to build \nobj\n.\n\n\nobj\n is modified: its likelihood fields (forward, directional \n backward) are updated to make sure that they correspond to the current parameter values in \nobj.model\n, and to the \ntrait\n of interest.\n\n\n\n\nSee also \ndiscrete_backwardlikelihood_tree!\n to update \nobj.backwardlik\n.\n\n\nexamples\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\n);\n\n\n\njulia\n \nm1\n \n=\n \nBinaryTraitSubstitutionModel\n(\n[\n0.1\n,\n \n0.1\n]\n,\n \n[\nlo\n,\n \nhi\n]\n);\n\n\n\njulia\n \ndat\n \n=\n \nDataFrame\n(\nspecies\n=\n[\nC\n,\nA\n,\nB\n,\nD\n]\n,\n \ntrait\n=\n[\nhi\n,\nlo\n,\nlo\n,\nhi\n]\n);\n\n\n\njulia\n \nfit1\n \n=\n \nfitDiscrete\n(\nnet\n,\n \nm1\n,\n \ndat\n);\n\n\n\njulia\n \nasr\n \n=\n \nancestralStateReconstruction\n(\nfit1\n)\n\n\n9\n\u00d7\n4\n \nDataFrames\n.\nDataFrame\n\n\n\u2502\n \nRow\n \n\u2502\n \nnodenumber\n \n\u2502\n \nnodelabel\n \n\u2502\n \nlo\n       \n\u2502\n \nhi\n       \n\u2502\n\n\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n\n\u2502\n \n1\n   \n\u2502\n \n1\n          \n\u2502\n \nA\n         \n\u2502\n \n1\n.\n0\n      \n\u2502\n \n0\n.\n0\n      \n\u2502\n\n\n\u2502\n \n2\n   \n\u2502\n \n2\n          \n\u2502\n \nB\n         \n\u2502\n \n1\n.\n0\n      \n\u2502\n \n0\n.\n0\n      \n\u2502\n\n\n\u2502\n \n3\n   \n\u2502\n \n3\n          \n\u2502\n \nC\n         \n\u2502\n \n0\n.\n0\n      \n\u2502\n \n1\n.\n0\n      \n\u2502\n\n\n\u2502\n \n4\n   \n\u2502\n \n4\n          \n\u2502\n \nD\n         \n\u2502\n \n0\n.\n0\n      \n\u2502\n \n1\n.\n0\n      \n\u2502\n\n\n\u2502\n \n5\n   \n\u2502\n \n5\n          \n\u2502\n \n5\n         \n\u2502\n \n0\n.\n286019\n \n\u2502\n \n0\n.\n713981\n \n\u2502\n\n\n\u2502\n \n6\n   \n\u2502\n \n6\n          \n\u2502\n \n6\n         \n\u2502\n \n0\n.\n319454\n \n\u2502\n \n0\n.\n680546\n \n\u2502\n\n\n\u2502\n \n7\n   \n\u2502\n \n7\n          \n\u2502\n \n7\n         \n\u2502\n \n0\n.\n168549\n \n\u2502\n \n0\n.\n831451\n \n\u2502\n\n\n\u2502\n \n8\n   \n\u2502\n \n8\n          \n\u2502\n \n8\n         \n\u2502\n \n0\n.\n76736\n  \n\u2502\n \n0\n.\n23264\n  \n\u2502\n\n\n\u2502\n \n9\n   \n\u2502\n \n9\n          \n\u2502\n \n#\nH1\n       \n\u2502\n \n0\n.\n782777\n \n\u2502\n \n0\n.\n217223\n \n\u2502\n\n\n\njulia\n \nexp\n.(\nfit1\n.\npostltw\n)\n \n#\n \nmarginal\n \n(\nposterior\n)\n \nprobability\n \nthat\n \nthe\n \ntrait\n \nevolved\n \non\n \neach\n \ndisplayed\n \ntree\n\n\n2-element\n \nArray\n{\nFloat64,1\n}\n:\n\n \n0\n.\n919831\n \n \n0\n.\n0801689\n\n\n\njulia\n \nusing\n \nPhyloPlots\n\n\n\njulia\n \nplot\n(\nfit1\n.\nnet\n,\n \n:\nR\n,\n \nnodeLabel\n \n=\n \nasr\n[\n[\n:\nnodenumber\n,\n \n:\nlo\n]\n],\n \ntipOffset\n=\n0\n.\n2\n);\n \n#\n \npp\n \nfor\n \nlo\n \nstate\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.expectations\n \n \nFunction\n.\n\n\nexpectations(obj::ReconstructedStates)\n\n\n\n\n\nEstimated reconstructed states at the nodes and tips.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.predint\n \n \nFunction\n.\n\n\npredint\n(\nobj\n::\nReconstructedStates\n;\n \nlevel\n=\n0\n.\n95\n::\nReal\n)\n\n\n\n\n\n\nPrediction intervals with level \nlevel\n for internal nodes and missing tips.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.expectationsPlot\n \n \nFunction\n.\n\n\nexpectationsPlot(obj::ReconstructedStates)\n\n\n\n\n\nCompute and format the expected reconstructed states for the plotting function. The resulting dataframe can be readily used as a \nnodeLabel\n argument to \nplot\n from package \nPhyloPlots\n. Keyword argument \nmarkMissing\n is a string that is appended to predicted tip values, so that they can be distinguished from the actual datapoints. Default to \"*\". Set to \"\" to remove any visual cue.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.predintPlot\n \n \nFunction\n.\n\n\npredintPlot\n(\nobj\n::\nReconstructedStates\n;\n \nlevel\n=\n0\n.\n95\n::\nReal\n,\n \nwithExp\n=\nfalse\n::\nBool\n)\n\n\n\n\n\n\nCompute and format the prediction intervals for the plotting function. The resulting dataframe can be readily used as a \nnodeLabel\n argument to \nplot\n from package \nPhyloPlots\n. Keyworks argument \nlevel\n control the confidence level of the prediction interval. If \nwithExp\n is set to true, then the best predicted value is also shown along with the interval.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.descendenceMatrix\n \n \nFunction\n.\n\n\ndescendenceMatrix\n(\nnet\n::\nHybridNetwork\n;\n \ncheckPreorder\n=\ntrue\n::\nBool\n)\n\n\n\n\n\n\nThis function computes the inciednce matrix between all the nodes of a network. It assumes that the network is in the pre-order. If checkPreorder is true (default), then it runs function \npreoder\n on the network beforehand.\n\n\nReturns an object of type \nMatrixTopologicalOrder\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.regressorShift\n \n \nFunction\n.\n\n\nregressorShift\n(\nnode\n::\nVector\n{\nNode\n}\n,\n \nnet\n::\nHybridNetwork\n;\n \ncheckPreorder\n=\ntrue\n::\nBool\n)\n\n\n\n\n\n\nregressorShift(edge::Vector{Edge}, net::HybridNetwork; checkPreorder=true::Bool)\n\n\nCompute the regressor vectors associated with shifts on edges that are above nodes \nnode\n, or on edges \nedge\n, on a network \nnet\n. It uses function \ndescendenceMatrix\n, so \nnet\n might be modified to sort it in a pre-order. Return a \nDataFrame\n with as many rows as there are tips in net, and a column for each shift, each labelled according to the pattern shift_{number_of_edge}. It has an aditional column labelled \ntipNames\n to allow easy fitting afterward (see example).\n\n\nExamples\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n(A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5);\n);\n\n\n\njulia\n \npreorder\n!(\nnet\n)\n\n\n\njulia\n \nusing\n \nPhyloPlots\n\n\n\njulia\n \nplot\n(\nnet\n,\n \n:\nRCall\n,\n \nshowNodeNumber\n=\ntrue\n);\n \n#\n \nto\n \nlocate\n \nnodes\n\n\n\njulia\n \nnodes_shifts\n \n=\n \nindexin\n(\n[\n1\n,\n-\n5\n]\n,\n \n[\nn.number\n \nfor\n \nn\n \nin\n \nnet.node\n]\n)\n \n#\n \nPut\n \na\n \nshift\n \non\n \nedges\n \nending\n \nat\n \nnodes\n \n1\n \nand\n \n-5\n\n\n2-element\n \nArray\n{\nInt64,1\n}\n:\n\n \n1\n\n \n7\n\n\n\njulia\n \nparams\n \n=\n \nParamsBM\n(\n10\n,\n \n0\n.\n1\n,\n \nShiftNet\n(\nnet\n.\nnode\n[\nnodes_shifts\n]\n,\n \n[\n3.0\n,\n \n-\n3.0\n]\n,\n  \nnet\n))\n\n\nPhyloNetworks\n.\nParamsBM\n:\n\n\nParameters\n \nof\n \na\n \nBM\n \nwith\n \nfixed\n \nroot\n:\n\n\nmu\n:\n \n10\n\n\nSigma2\n:\n \n0\n.\n1\n\n\n\nThere\n \nare\n \n2\n \nshifts\n \non\n \nthe\n \nnetwork\n:\n\n     \nEdge\n \nNumber\n \nShift\n \nValue\n\n             \n8\n.\n0\n        \n-3\n.\n0\n\n             \n1\n.\n0\n         \n3\n.\n0\n\n\n\njulia\n \nsrand\n(\n2468\n);\n \n#\n \nsets\n \nthe\n \nseed\n \nfor\n \nreproducibility\n\n\n\njulia\n \nsim\n \n=\n \nsimulate\n(\nnet\n,\n \nparams\n);\n \n#\n \nsimulate\n \na\n \ndataset\n \nwith\n \nshifts\n\n\n\njulia\n \nusing\n \nDataFrames\n \n#\n \nto\n \nhandle\n \ndata\n \nframes\n\n\n\njulia\n \ndat\n \n=\n \nDataFrame\n(\ntrait\n \n=\n \nsim\n[\n:\nTips\n]\n,\n \ntipNames\n \n=\n \nsim\n.\nM\n.\ntipNames\n)\n\n\n4\n\u00d7\n2\n \nDataFrames\n.\nDataFrame\n\n\n\u2502\n \nRow\n \n\u2502\n \ntrait\n   \n\u2502\n \ntipNames\n \n\u2502\n\n\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n\n\u2502\n \n1\n   \n\u2502\n \n13\n.\n392\n  \n\u2502\n \nA\n        \n\u2502\n\n\n\u2502\n \n2\n   \n\u2502\n \n9\n.\n55741\n \n\u2502\n \nB\n        \n\u2502\n\n\n\u2502\n \n3\n   \n\u2502\n \n7\n.\n17704\n \n\u2502\n \nC\n        \n\u2502\n\n\n\u2502\n \n4\n   \n\u2502\n \n7\n.\n88906\n \n\u2502\n \nD\n        \n\u2502\n\n\n\njulia\n \ndfr_shift\n \n=\n \nregressorShift\n(\nnet\n.\nnode\n[\nnodes_shifts\n]\n,\n \nnet\n)\n \n#\n \nthe\n \nreressors\n \nmatching\n \nthe\n \nshifts\n.\n\n\n4\n\u00d7\n3\n \nDataFrames\n.\nDataFrame\n\n\n\u2502\n \nRow\n \n\u2502\n \nshift_1\n \n\u2502\n \nshift_8\n \n\u2502\n \ntipNames\n \n\u2502\n\n\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n\n\u2502\n \n1\n   \n\u2502\n \n1\n.\n0\n     \n\u2502\n \n0\n.\n0\n     \n\u2502\n \nA\n        \n\u2502\n\n\n\u2502\n \n2\n   \n\u2502\n \n0\n.\n0\n     \n\u2502\n \n0\n.\n0\n     \n\u2502\n \nB\n        \n\u2502\n\n\n\u2502\n \n3\n   \n\u2502\n \n0\n.\n0\n     \n\u2502\n \n1\n.\n0\n     \n\u2502\n \nC\n        \n\u2502\n\n\n\u2502\n \n4\n   \n\u2502\n \n0\n.\n0\n     \n\u2502\n \n0\n.\n6\n     \n\u2502\n \nD\n        \n\u2502\n\n\n\njulia\n \ndfr\n \n=\n \njoin\n(\ndat\n,\n \ndfr_shift\n,\n \non\n=\n:\ntipNames\n);\n \n#\n \njoin\n \ndata\n \nand\n \nregressors\n \nin\n \na\n \nsingle\n \ndataframe\n\n\n\njulia\n \nusing\n \nStatsModels\n \n#\n \nfor\n \nstatistical\n \nmodel\n \nformulas\n\n\n\njulia\n \nfitBM\n \n=\n \nphyloNetworklm\n(\n@\nformula\n(\ntrait\n \n~\n \nshift_1\n \n+\n \nshift_8\n),\n \ndfr\n,\n \nnet\n)\n \n#\n \nactual\n \nfit\n\n\nStatsModels\n.\nDataFrameRegressionModel\n{\nPhyloNetworks\n.\nPhyloNetworkLinearModel\n,\nArray\n{\nFloat64,2\n}}\n\n\n\nFormula\n:\n \ntrait\n \n~\n \n1\n \n+\n \nshift_1\n \n+\n \nshift_8\n\n\n\nModel\n:\n \nBM\n\n\n\nParameter\n(\ns\n)\n \nEstimates\n:\n\n\nSigma2\n:\n \n0\n.\n0112618\n\n\n\nCoefficients\n:\n\n             \nEstimate\n \nStd\n.\nError\n  \nt\n \nvalue\n \nPr\n(\n|\nt\n|)\n\n\n(\nIntercept\n)\n   \n9\n.\n48238\n  \n0\n.\n327089\n  \n28\n.\n9902\n   \n0\n.\n0220\n\n\nshift_1\n        \n3\n.\n9096\n   \n0\n.\n46862\n  \n8\n.\n34279\n   \n0\n.\n0759\n\n\nshift_8\n       \n-2\n.\n4179\n  \n0\n.\n422825\n \n-5\n.\n71843\n   \n0\n.\n1102\n\n\n\nLog\n \nLikelihood\n:\n \n1\n.\n8937302027\n\n\nAIC\n:\n \n4\n.\n2125395947\n\n\n\n\n\n\nSee also\n\n\nphyloNetworklm\n, \ndescendenceMatrix\n, \nregressorHybrid\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.regressorHybrid\n \n \nFunction\n.\n\n\nregressorHybrid\n(\nnet\n::\nHybridNetwork\n;\n \ncheckPreorder\n=\ntrue\n::\nBool\n)\n\n\n\n\n\n\nCompute the regressor vectors associated with shifts on edges that imediatly below all hybrid nodes of \nnet\n. It uses function \ndescendenceMatrix\n through a call to \nregressorShift\n, so \nnet\n might be modified to sort it in a pre-order. Return a \nDataFrame\n with as many rows as there are tips in net, and a column for each hybrid, each labelled according to the pattern shift_{number_of_edge}. It has an aditional column labelled \ntipNames\n to allow easy fitting afterward (see example).\n\n\nThis function can be used to test for heterosis.\n\n\nExamples\n\n\njulia\n \nusing\n \nDataFrames\n \n#\n \nNeeded\n \nto\n \nhandle\n \ndata\n \nframes\n.\n\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n(A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5);\n);\n\n\n\njulia\n \npreorder\n!(\nnet\n)\n\n\n\njulia\n \nusing\n \nPhyloPlots\n\n\n\njulia\n \nplot\n(\nnet\n,\n \n:\nRCall\n,\n \nshowNodeNumber\n=\ntrue\n);\n \n#\n \nto\n \nlocate\n \nnodes\n:\n \nnode\n \n5\n \nis\n \nchild\n \nof\n \nhybrid\n \nnode\n\n\n\njulia\n \nnodes_hybrids\n \n=\n \nindexin\n(\n[\n5\n]\n,\n \n[\nn.number\n \nfor\n \nn\n \nin\n \nnet.node\n]\n)\n \n#\n \nPut\n \na\n \nshift\n \non\n \nedges\n \nbelow\n \nhybrids\n\n\n1-element\n \nArray\n{\nInt64,1\n}\n:\n\n \n5\n\n\n\njulia\n \nparams\n \n=\n \nParamsBM\n(\n10\n,\n \n0\n.\n1\n,\n \nShiftNet\n(\nnet\n.\nnode\n[\nnodes_hybrids\n]\n,\n \n[\n3.0\n]\n,\n  \nnet\n))\n\n\nPhyloNetworks\n.\nParamsBM\n:\n\n\nParameters\n \nof\n \na\n \nBM\n \nwith\n \nfixed\n \nroot\n:\n\n\nmu\n:\n \n10\n\n\nSigma2\n:\n \n0\n.\n1\n\n\n\nThere\n \nare\n \n1\n \nshifts\n \non\n \nthe\n \nnetwork\n:\n\n     \nEdge\n \nNumber\n \nShift\n \nValue\n\n             \n6\n.\n0\n         \n3\n.\n0\n\n\n\n\n\njulia\n \nsrand\n(\n2468\n);\n \n#\n \nsets\n \nthe\n \nseed\n \nfor\n \nreproducibility\n\n\n\njulia\n \nsim\n \n=\n \nsimulate\n(\nnet\n,\n \nparams\n);\n \n#\n \nsimulate\n \na\n \ndataset\n \nwith\n \nshifts\n\n\n\njulia\n \ndat\n \n=\n \nDataFrame\n(\ntrait\n \n=\n \nsim\n[\n:\nTips\n]\n,\n \ntipNames\n \n=\n \nsim\n.\nM\n.\ntipNames\n)\n\n\n4\n\u00d7\n2\n \nDataFrames\n.\nDataFrame\n\n\n\u2502\n \nRow\n \n\u2502\n \ntrait\n   \n\u2502\n \ntipNames\n \n\u2502\n\n\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n\n\u2502\n \n1\n   \n\u2502\n \n10\n.\n392\n  \n\u2502\n \nA\n        \n\u2502\n\n\n\u2502\n \n2\n   \n\u2502\n \n9\n.\n55741\n \n\u2502\n \nB\n        \n\u2502\n\n\n\u2502\n \n3\n   \n\u2502\n \n10\n.\n177\n  \n\u2502\n \nC\n        \n\u2502\n\n\n\u2502\n \n4\n   \n\u2502\n \n12\n.\n6891\n \n\u2502\n \nD\n        \n\u2502\n\n\n\njulia\n \ndfr_hybrid\n \n=\n \nregressorHybrid\n(\nnet\n)\n \n#\n \nthe\n \nreressors\n \nmatching\n \nthe\n \nhybrids\n.\n\n\n4\n\u00d7\n3\n \nDataFrames\n.\nDataFrame\n\n\n\u2502\n \nRow\n \n\u2502\n \nshift_6\n \n\u2502\n \ntipNames\n \n\u2502\n \nsum\n \n\u2502\n\n\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\n\n\n\u2502\n \n1\n   \n\u2502\n \n0\n.\n0\n     \n\u2502\n \nA\n        \n\u2502\n \n0\n.\n0\n \n\u2502\n\n\n\u2502\n \n2\n   \n\u2502\n \n0\n.\n0\n     \n\u2502\n \nB\n        \n\u2502\n \n0\n.\n0\n \n\u2502\n\n\n\u2502\n \n3\n   \n\u2502\n \n0\n.\n0\n     \n\u2502\n \nC\n        \n\u2502\n \n0\n.\n0\n \n\u2502\n\n\n\u2502\n \n4\n   \n\u2502\n \n1\n.\n0\n     \n\u2502\n \nD\n        \n\u2502\n \n1\n.\n0\n \n\u2502\n\n\n\njulia\n \ndfr\n \n=\n \njoin\n(\ndat\n,\n \ndfr_hybrid\n,\n \non\n=\n:\ntipNames\n);\n \n#\n \njoin\n \ndata\n \nand\n \nregressors\n \nin\n \na\n \nsingle\n \ndataframe\n\n\n\njulia\n \nusing\n \nStatsModels\n\n\n\njulia\n \nfitBM\n \n=\n \nphyloNetworklm\n(\n@\nformula\n(\ntrait\n \n~\n \nshift_6\n),\n \ndfr\n,\n \nnet\n)\n \n#\n \nactual\n \nfit\n\n\nStatsModels\n.\nDataFrameRegressionModel\n{\nPhyloNetworks\n.\nPhyloNetworkLinearModel\n,\nArray\n{\nFloat64,2\n}}\n\n\n\nFormula\n:\n \ntrait\n \n~\n \n1\n \n+\n \nshift_6\n\n\n\nModel\n:\n \nBM\n\n\n\nParameter\n(\ns\n)\n \nEstimates\n:\n\n\nSigma2\n:\n \n0\n.\n041206\n\n\n\nCoefficients\n:\n\n             \nEstimate\n \nStd\n.\nError\n \nt\n \nvalue\n \nPr\n(\n|\nt\n|)\n\n\n(\nIntercept\n)\n    \n10\n.\n064\n  \n0\n.\n277959\n \n36\n.\n2068\n   \n0\n.\n0008\n\n\nshift_6\n       \n2\n.\n72526\n  \n0\n.\n315456\n \n8\n.\n63912\n   \n0\n.\n0131\n\n\n\nLog\n \nLikelihood\n:\n \n-0\n.\n7006021946\n\n\nAIC\n:\n \n7\n.\n4012043891\n\n\n\n\n\n\nSee also\n\n\nphyloNetworklm\n, \ndescendenceMatrix\n, \nregressorShift\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sharedPathMatrix\n \n \nFunction\n.\n\n\nsharedPathMatrix\n(\nnet\n::\nHybridNetwork\n;\n \ncheckPreorder\n=\ntrue\n::\nBool\n)\n\n\n\n\n\n\nThis function computes the shared path matrix between all the nodes of a network. It assumes that the network is in the pre-order. If checkPreorder is true (default), then it runs function \npreoder\n on the network beforehand.\n\n\nReturns an object of type \nMatrixTopologicalOrder\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.vcv\n \n \nFunction\n.\n\n\nvcv\n(\nnet\n::\nHybridNetwork\n;\n \nmodel\n=\nBM\n::\nAbstractString\n,\n \n                        \ncorr\n=\nfalse\n::\nBool\n,\n\n                        \ncheckPreorder\n=\ntrue\n::\nBool\n)\n\n\n\n\n\n\nThis function computes the variance covariance matrix between the tips of the network, assuming a Brownian model of trait evolution (with unit variance). If optional argument \ncorr\n is set to \ntrue\n, then the correlation matrix is returned instead.\n\n\nThe function returns a \nDataFrame\n object, with columns named by the tips of the network.\n\n\nThe calculation of the covariance matrix requires a pre-ordering of nodes to be fast. If \ncheckPreorder\n is true (default), then \npreorder\n is run on the network beforehand. Otherwise, the network is assumed to be already in pre-order.\n\n\nThis function internally calls \nsharedPathMatrix\n, that computes the variance matrix between all the nodes of the network.\n\n\nExamples\n\n\njulia\n \ntree_str\n \n=\n \n(((t2:0.14,t4:0.33):0.59,t3:0.96):0.14,(t5:0.70,t1:0.18):0.90);\n;\n\n\n\njulia\n \ntree\n \n=\n \nreadTopology\n(\ntree_str\n);\n\n\n\njulia\n \nC\n \n=\n \nvcv\n(\ntree\n)\n\n\n5\n\u00d7\n5\n \nDataFrames\n.\nDataFrame\n\n\n\u2502\n \nRow\n \n\u2502\n \nt2\n   \n\u2502\n \nt4\n   \n\u2502\n \nt3\n   \n\u2502\n \nt5\n  \n\u2502\n \nt1\n   \n\u2502\n\n\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n\n\u2502\n \n1\n   \n\u2502\n \n0\n.\n87\n \n\u2502\n \n0\n.\n73\n \n\u2502\n \n0\n.\n14\n \n\u2502\n \n0\n.\n0\n \n\u2502\n \n0\n.\n0\n  \n\u2502\n\n\n\u2502\n \n2\n   \n\u2502\n \n0\n.\n73\n \n\u2502\n \n1\n.\n06\n \n\u2502\n \n0\n.\n14\n \n\u2502\n \n0\n.\n0\n \n\u2502\n \n0\n.\n0\n  \n\u2502\n\n\n\u2502\n \n3\n   \n\u2502\n \n0\n.\n14\n \n\u2502\n \n0\n.\n14\n \n\u2502\n \n1\n.\n1\n  \n\u2502\n \n0\n.\n0\n \n\u2502\n \n0\n.\n0\n  \n\u2502\n\n\n\u2502\n \n4\n   \n\u2502\n \n0\n.\n0\n  \n\u2502\n \n0\n.\n0\n  \n\u2502\n \n0\n.\n0\n  \n\u2502\n \n1\n.\n6\n \n\u2502\n \n0\n.\n9\n  \n\u2502\n\n\n\u2502\n \n5\n   \n\u2502\n \n0\n.\n0\n  \n\u2502\n \n0\n.\n0\n  \n\u2502\n \n0\n.\n0\n  \n\u2502\n \n0\n.\n9\n \n\u2502\n \n1\n.\n08\n \n\u2502\n\n\n\n\n\n\nThe following block needs \nape\n to be installed (not run):\n\n\njulia\n \nusing\n \nRCall\n \n# Comparison with ape vcv function\n\n\n\njulia\n \nR\nape::vcv(ape::read.tree(text = \n$tree_str\n))\n\n\nRCall\n.\nRObject\n{\nRCall\n.\nRealSxp\n}\n\n     \nt2\n   \nt4\n   \nt3\n  \nt5\n   \nt1\n\n\nt2\n \n0.87\n \n0.73\n \n0.14\n \n0.0\n \n0.00\n\n\nt4\n \n0.73\n \n1.06\n \n0.14\n \n0.0\n \n0.00\n\n\nt3\n \n0.14\n \n0.14\n \n1.10\n \n0.0\n \n0.00\n\n\nt5\n \n0.00\n \n0.00\n \n0.00\n \n1.6\n \n0.90\n\n\nt1\n \n0.00\n \n0.00\n \n0.00\n \n0.9\n \n1.08\n\n\n\n\n\n\nThe covariance can also be calculated on a network (for the model, see for Bastide et al. 2018)\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n((t1:1.0,#H1:0.1::0.30):0.5,((t2:0.9)#H1:0.2::0.70,t3:1.1):0.4);\n);\n\n\n\njulia\n \nC\n \n=\n \nvcv\n(\nnet\n)\n\n\n3\n\u00d7\n3\n \nDataFrames\n.\nDataFrame\n\n\n\u2502\n \nRow\n \n\u2502\n \nt1\n   \n\u2502\n \nt2\n    \n\u2502\n \nt3\n   \n\u2502\n\n\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n\n\u2502\n \n1\n   \n\u2502\n \n1\n.\n5\n  \n\u2502\n \n0\n.\n15\n  \n\u2502\n \n0\n.\n0\n  \n\u2502\n\n\n\u2502\n \n2\n   \n\u2502\n \n0\n.\n15\n \n\u2502\n \n1\n.\n248\n \n\u2502\n \n0\n.\n28\n \n\u2502\n\n\n\u2502\n \n3\n   \n\u2502\n \n0\n.\n0\n  \n\u2502\n \n0\n.\n28\n  \n\u2502\n \n1\n.\n5\n  \n\u2502\n\n\n\n\n\n\nsource\n\n\n\n\ndiscrete trait evolution\n\n\n#\n\n\nPhyloNetworks.parsimonySoftwired\n \n \nFunction\n.\n\n\nparsimonySoftwired(net, tipdata)\nparsimonySoftwired(net, species, sequences)\n\n\n\n\n\nCalculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network.\n\n\nData can given in one of the following:\n\n\n\n\ntipdata\n: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named \"taxon\" or \"species\", and  trait values are to appear in column 2 or in a column named \"trait\".\n\n\ntipdata\n: dictionary taxon =\n state, for a single trait.\n\n\nspecies\n: array of strings, and \nsequences\n: array of sequences,  in the order corresponding to the order of species names.\n\n\n\n\nalgorithm\n\n\nThe dynamic programming algorithm by Fischer et al. (2015) is used. The function loops over all the displayed subtrees within a blob (biconnected component), so its complexity is of the order of \nn * m * c^2 * 2^level\n where \nn\n is the number of tips, \nm\n the number of traits, \nc\n the number of states, and \nlevel\n is the level of the network: the maximum number of hybridizations within a blob.\n\n\nSee \nparsimonyGF\n for a different algorithm, slower but extendable to other parsimony criteria.\n\n\nreferences\n\n\n\n\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.parsimonyGF\n \n \nFunction\n.\n\n\nparsimonyGF(net, tip_dictionary, criterion=:softwired)\nparsimonyGF(net, species, sequenceData, criterion=:softwired)\n\n\n\n\n\nCalculate the most parsimonious score of a network given discrete characters at the tips using a general framework (Van Iersel et al. 2018) allowing for various parsimony criteria: softwired (default), hardwired, parental etc. Only softwired is implemented at the moment.\n\n\nData can given in one of the following:\n\n\n\n\ntipdata\n: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named \"taxon\" or \"species\", and  trait values are to appear in column 2 or in a column named \"trait\".\n\n\ntipdata\n: dictionary taxon =\n state, for a single trait.\n\n\nspecies\n: array of strings, and \nsequences\n: array of sequences,   in the order corresponding to the order of species names.\n\n\n\n\nalgorithm\n\n\nThe complexity of the algorithm is exponential in the level of the network, that is, the maximum number of hybridizations in a single blob, or biconnected component (Fischer et al. 2015). The function loops over all the state assignments of the minor parent of each hybrid node within a blob, so its complexity is of the order of \nn * m * c^2 * c^level\n where \nn\n is the number of tips, \nm\n the number of traits and \nc\n the number of states.\n\n\nSee \nparsimonySoftwired\n for a faster algorithm, but solving the softwired criterion only.\n\n\nreferences\n\n\n\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\n\n\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\n\n\n\nUse the recursive helper function \nparsimonyBottomUpGF!\n. Use the fields \nisChild1\n, \nisExtBadTriangle\n to know which nodes are at the root of a blob, and \nfromBadDiamondI\n to know which edges are cut (below the minor parent of each hybrid).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.nStates\n \n \nFunction\n.\n\n\nnStates(model)\n\n\n\n\n\nNumber of character states for a given trait evolution model.\n\n\nsource\n\n\nExamples\n\n\njulia\n m1 = BinaryTraitSubstitutionModel([1.0,2.0], [\nlow\n,\nhigh\n])\njulia\n nStates(m1)\n2\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.Q\n \n \nFunction\n.\n\n\nQ(model)\n\n\n\n\n\nSubstitution rate matrix for a given substitution model: Q[i,j] is the rate of transitioning from state i to state j.\n\n\nsource\n\n\nFor a BinaryTraitSubstitutionModel, the rate matrix Q is of the form:\n\n\n-\u03b1  \u03b1\n \u03b2 -\u03b2\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.P\n \n \nFunction\n.\n\n\nP(mod, t)\n\n\n\n\n\nProbability transition matrix for a \nTraitSubstitutionModel\n, of the form\n\n\nP[1,1] ... P[1,k]\n   .          .\n   .          .\nP[k,1] ... P[k,k]\n\n\n\n\n\nwhere P[i,j] is the probability of ending in state j after time t, given that the process started in state i.\n\n\nsource\n\n\nP(mod, t::Array{Float64})\n\n\n\n\n\nWhen applied to a general substitution model, matrix exponentiation is used. The time argument \nt\n can be an array.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.randomTrait\n \n \nFunction\n.\n\n\nrandomTrait(model, t, start)\nrandomTrait!(end, model, t, start)\n\n\n\n\n\nSimulate traits along one edge of length t. \nstart\n must be a vector of integers, each representing the starting value of one trait. The bang version (ending with !) uses the vector \nend\n to store the simulated values.\n\n\nExamples\n\n\njulia\n m1 = BinaryTraitSubstitutionModel(1.0, 2.0)\n\njulia\n srand(12345);\n\njulia\n randomTrait(m1, 0.2, [1,2,1,2,2])\n 5-element Array{Int64,1}:\n 1\n 2\n 1\n 2\n 2\n\n\n\n\n\nsource\n\n\nrandomTrait(model, net; ntraits=1, keepInternal=true, checkPreorder=true)\n\n\n\n\n\nSimulate evolution of discrete traits on a rooted evolutionary network based on the supplied evolutionary model. Trait sampling is uniform at the root.\n\n\noptional arguments:\n\n\n\n\nntraits\n: number of traits to be simulated (default: 1 trait).\n\n\nkeepInternal\n: if true, export character states at all nodes, including internal nodes. if false, export character states at tips only.\n\n\n\n\noutput:\n\n\n\n\nmatrix of character states with one row per trait, one column per node; these states are \nindices\n in \nmodel.label\n, not the trait labels themselves.\n\n\nvector of node labels (for tips) or node numbers (for internal nodes) in the same order as columns in the character state matrix\n\n\n\n\nexamples\n\n\njulia\n \nm1\n \n=\n \nBinaryTraitSubstitutionModel\n(\n1\n.\n0\n,\n \n2\n.\n0\n,\n \n[\nlow\n,\nhigh\n]\n);\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n(((A:4.0,(B:1.0)#H1:1.1::0.9):0.5,(C:0.6,#H1:1.0::0.1):1.0):3.0,D:5.0);\n);\n\n\njulia\n \nsrand\n(\n1234\n);\n\n\njulia\n \ntrait\n,\n \nlab\n \n=\n \nrandomTrait\n(\nm1\n,\n \nnet\n)\n\n\n(\n[\n1\n \n2\n \n\u2026\n \n1\n \n1\n]\n,\n \nString\n[\n-2\n,\n \nD\n,\n \n-3\n,\n \n-6\n,\n \nC\n,\n \n-4\n,\n \n#H1\n,\n \nB\n,\n \nA\n]\n)\n\n\njulia\n \ntrait\n\n\n1\n\u00d7\n9\n \nArray\n{\nInt64,2\n}\n:\n\n \n1\n  \n2\n  \n1\n  \n1\n  \n2\n  \n2\n  \n1\n  \n1\n  \n1\n\n\njulia\n \nlab\n\n\n9-element\n \nArray\n{\nString,1\n}\n:\n\n \n-2\n \n \nD\n  \n \n-3\n \n \n-6\n \n \nC\n  \n \n-4\n \n \n#H1\n\n \nB\n  \n \nA\n  \n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.fitDiscrete\n \n \nFunction\n.\n\n\nfitDiscrete(net, model, tipdata)\nfitDiscrete(net, model, species, traits)\n\n\n\n\n\nCalculate the maximum likelihood (ML) score of a network given one or more discrete characters at the tips. Along each edge, transitions are modelled with a continous time Markov \nmodel\n, whose parameters are estimated (by maximizing the likelihood). At each hybrid node, the trait is assumed to be inherited from either of the two immediate parents according to the parents' average genetic contributions (inheritance \u03b3). The model ignores incomplete lineage sorting. The algorithm extracts all trees displayed in the network.\n\n\nData can given in one of the following:\n\n\n\n\ntipdata\n: dictionary taxon =\n state label, for a single trait.\n\n\ntipdata\n: data frame for a single trait, in which case the taxon names are to appear in column 1 or in a column named \"taxon\" or \"species\", and trait \nlabels\n are to appear in column 2 or in a column named \"trait\". Here, trait labels should be as they appear in \nmodel.label\n.\n\n\nspecies\n: vector of strings, and \ntraits\n: DataFrame of traits, with rows in the order corresponding to the order of species names. Again, trait labels should be as they appear in \nmodel.label\n. All traits are assumed to follow the same model, with same parameters.\n\n\n\n\nOptional arguments (default):\n\n\n\n\nfixedparam\n (false): should model rate parameters be fixed, or should they be optimized?\n\n\nNLoptMethod\n (\n:LN_COBYLA\n, derivative-free) for the optimization algorithm. For other options, see the \nNLopt\n.\n\n\ntolerance values to control when the optimization is stopped: \nftolRel\n (1e-12), \nftolAbs\n (1e-10) on the likelihood, and \nxtolRel\n (1e-10), \nxtolAbs\n (1e-10) on the model parameters.\n\n\nverbose\n (false): if true, more information is output.\n\n\n\n\nexamples:\n\n\njulia\n \nnet =\n readTopology\n(\n(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\n);\n\n\njulia\n \nm1 =\n BinaryTraitSubstitutionModel\n([\n0\n.\n1\n,\n \n0\n.\n1\n],\n \n[\nlo\n,\n \nhi\n]);\n\n\njulia\n \ndat =\n DataFrame\n(\nspecies=\n[\nC\n,\nA\n,\nB\n,\nD\n],\n \ntrait=\n[\nhi\n,\nlo\n,\nlo\n,\nhi\n]);\n\n\njulia\n \nfit1 =\n fitDiscrete\n(\nnet\n,\n m1\n,\n dat\n;\n \nfixedparam=\ntrue\n)\n\nPhyloNetworks\n.\nStatisticalSubstitutionModel\n{\nString\n}:\n\nBinary Trait Substitution Model\n:\n\nrate lo\n\u2192\nhi \n\u03b1=\n0\n.\n1\n\nrate hi\n\u2192\nlo \n\u03b2=\n0\n.\n1\n\n\n1\n traits\n,\n \n4\n species\n,\n on a network \nwith\n \n1\n reticulations\nlog-likelihood\n:\n \n-\n3\n.\n107539646785388\n\n\njulia\n PhyloNetworks\n.\nfit\n!\n(\nfit1\n;\n \nfixedparam=\nfalse\n)\n\nPhyloNetworks\n.\nStatisticalSubstitutionModel\n{\nString\n}:\n\nBinary Trait Substitution Model\n:\n\nrate lo\n\u2192\nhi \n\u03b1=\n0\n.\n2722215661432007\n\nrate hi\n\u2192\nlo \n\u03b2=\n0\n.\n3498103666174014\n\n\n1\n traits\n,\n \n4\n species\n,\n on a network \nwith\n \n1\n reticulations\nlog-likelihood\n:\n \n-\n2\n.\n727701700712135\n\n\njulia\n \ntips =\n Dict\n(\nA\n \n=\n \nlo\n,\n \nB\n \n=\n \nlo\n,\n \nC\n \n=\n \nhi\n,\n \nD\n \n=\n \nhi\n);\n\n\njulia\n \nfit2 =\n fitDiscrete\n(\nnet\n,\n m1\n,\n tips\n;\n \nxtolRel=\n1\ne-16\n,\n \nxtolAbs=\n1\ne-16\n,\n \nftolRel=\n1\ne-16\n)\n\nPhyloNetworks\n.\nStatisticalSubstitutionModel\n{\nString\n}:\n\nBinary Trait Substitution Model\n:\n\nrate lo\n\u2192\nhi \n\u03b1=\n0\n.\n2722215661432007\n\nrate hi\n\u2192\nlo \n\u03b2=\n0\n.\n3498103666174014\n\n\n1\n traits\n,\n \n4\n species\n,\n on a network \nwith\n \n1\n reticulations\nlog-likelihood\n:\n \n-\n2\n.\n727701700712135\n\n\n\n\n\n\nNote that a copy of the network is stored in the fitted object, but the internal representation of the network may be different in \nfit1.net\n and in the original network \nnet\n:\n\n\njulia\n [n.number for n in fit2.net.node]\n9-element Array{Int64,1}:\n 1\n 2\n 9\n 8\n 3\n 7\n 6\n 4\n 5\n\njulia\n [n.number for n in net.node]\n9-element Array{Int64,1}:\n  1\n  2\n  3\n -4\n  4\n -6\n -3\n  5\n -2\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.maxParsimonyNet\n \n \nFunction\n.\n\n\nmaxParsimonyNet(T::HybridNetwork, df::DataFrame)\n\n\n\n\n\nSearch for the most parsimonious network (or tree). A level-1 network is assumed. \ndf\n should be a data frame containing the species names in column 1, or in a column named \nspecies\n or \ntaxon\n. Trait data are assumed to be in all other columns. The search starts from topology \nT\n, which can be a tree or a network with no more than \nhmax\n hybrid nodes (see optional arguments below for \nhmax\n).\n\n\nOutput:\n\n\n\n\nestimated network in file \n.out\n (also in \n.log\n): best network overall and list of networks from each individual run.\n\n\nif any error occurred, file \n.err\n provides information (seed) to reproduce the error.\n\n\n\n\nOptional arguments include\n\n\n\n\nhmax: maximum number of hybridizations allowed (default 1)\n\n\nruns: number of starting points for the search (default 10); each starting point is \nT\n with probability \nprobST\n=0.3 or a modification of \nT\n otherwise (using a NNI move, or a hybrid edge direction change)\n\n\nNfail: number of failures (proposed networks with equal or worse score) before the search is aborted. 75 by default: this is quite small, which is okay for a first trial. Larger values are recommended.\n\n\noutgroup: outgroup taxon.           It can be a taxon name (String) or Node number (Integer).           If none provided, or if the outgroup conflicts the starting           topology, the function returns an error\n\n\nfilename: root name for the output files. Default is \"mp\". If empty (\"\"), files are \nnot\n created, progress log goes to the screen only (standard out).\n\n\nseed: seed to replicate a given search\n\n\ncriterion: parsimony score could be hardwired, softwired (default) or parental. Currently,            only softwired is implemented\n\n\n\n\nReferences\n\n\n\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\n\n\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\n\n\n\nFor a roadmap of the functions inside maxParsimonyNet, see \nmaxParsimonyNetRun1!\n.\n\n\nsource", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public-documentation", 
            "text": "Documentation for  PhyloNetworks 's public (exported) interface.  See  Internal Documentation  for documentation on internal functions.   Public Documentation  Index  types  utilities  data and topology read/write  network inference  network Comparisons  continuous trait evolution  discrete trait evolution", 
            "title": "Public Documentation"
        }, 
        {
            "location": "/lib/public/#index", 
            "text": "PhyloNetworks.BinaryTraitSubstitutionModel  PhyloNetworks.DataCF  PhyloNetworks.EqualRatesSubstitutionModel  PhyloNetworks.HybridNetwork  PhyloNetworks.ParamsBM  PhyloNetworks.PhyloNetworkLinearModel  PhyloNetworks.Quartet  PhyloNetworks.ReconstructedStates  PhyloNetworks.ShiftNet  PhyloNetworks.TraitSimulation  PhyloNetworks.TraitSubstitutionModel  PhyloNetworks.TwoBinaryTraitSubstitutionModel  Base.getindex  PhyloNetworks.P  PhyloNetworks.Q  PhyloNetworks.ancestralStateReconstruction  PhyloNetworks.biconnectedComponents  PhyloNetworks.blobDecomposition  PhyloNetworks.bootsnaq  PhyloNetworks.calibrateFromPairwiseDistances!  PhyloNetworks.cladewiseorder!  PhyloNetworks.deleteHybridThreshold!  PhyloNetworks.deleteleaf!  PhyloNetworks.descendenceMatrix  PhyloNetworks.directEdges!  PhyloNetworks.displayedNetworkAt!  PhyloNetworks.displayedTrees  PhyloNetworks.expectations  PhyloNetworks.expectationsPlot  PhyloNetworks.fitDiscrete  PhyloNetworks.fittedQuartetCF  PhyloNetworks.getNodeAges  PhyloNetworks.getShiftEdgeNumber  PhyloNetworks.getShiftValue  PhyloNetworks.hardwiredCluster  PhyloNetworks.hardwiredClusterDistance  PhyloNetworks.hardwiredClusters  PhyloNetworks.hybridBootstrapSupport  PhyloNetworks.hybridatnode!  PhyloNetworks.lambda_estim  PhyloNetworks.majorTree  PhyloNetworks.mapAllelesCFtable  PhyloNetworks.maxParsimonyNet  PhyloNetworks.minorTreeAt  PhyloNetworks.mu_estim  PhyloNetworks.nStates  PhyloNetworks.pairwiseTaxonDistanceMatrix  PhyloNetworks.parsimonyGF  PhyloNetworks.parsimonySoftwired  PhyloNetworks.phyloNetworklm  PhyloNetworks.predint  PhyloNetworks.predintPlot  PhyloNetworks.preorder!  PhyloNetworks.printEdges  PhyloNetworks.printNodes  PhyloNetworks.randomTrait  PhyloNetworks.readBootstrapTrees  PhyloNetworks.readInputTrees  PhyloNetworks.readMultiTopology  PhyloNetworks.readSnaqNetwork  PhyloNetworks.readTableCF  PhyloNetworks.readTableCF!  PhyloNetworks.readTopology  PhyloNetworks.readTopologyLevel1  PhyloNetworks.readTrees2CF  PhyloNetworks.regressorHybrid  PhyloNetworks.regressorShift  PhyloNetworks.rootatnode!  PhyloNetworks.rootonedge!  PhyloNetworks.rotate!  PhyloNetworks.setGamma!  PhyloNetworks.setLength!  PhyloNetworks.sharedPathMatrix  PhyloNetworks.shiftHybrid  PhyloNetworks.sigma2_estim  PhyloNetworks.simulate  PhyloNetworks.snaq!  PhyloNetworks.snaqDebug  PhyloNetworks.sorttaxa!  PhyloNetworks.summarizeDataCF  PhyloNetworks.ticr  PhyloNetworks.ticr!  PhyloNetworks.tipLabels  PhyloNetworks.topologyMaxQPseudolik!  PhyloNetworks.topologyQPseudolik!  PhyloNetworks.treeEdgesBootstrap  PhyloNetworks.vcv  PhyloNetworks.writeMultiTopology  PhyloNetworks.writeSubTree!  PhyloNetworks.writeTopology", 
            "title": "Index"
        }, 
        {
            "location": "/lib/public/#types", 
            "text": "#  PhyloNetworks.BinaryTraitSubstitutionModel     Type .  BinaryTraitSubstitutionModel(\u03b1, \u03b2 [, label])  TraitSubstitutionModel  for binary traits (with 2 states). Default labels are \"0\" and \"1\". \u03b1 is the rate of transition from \"0\" to \"1\", and \u03b2 from \"1\" to \"0\".  source  #  PhyloNetworks.DataCF     Type .  DataCF type  type that contains the following attributes:   quartet (vector of Quartets)  numQuartets  tree (vector of trees: empty if a table of CF was input instead of list of trees)  numTrees (-1 if a table CF was input instead of list of trees)  repSpecies (taxon names that were repeated in table of CF or input gene trees: used inside snaq for multiple alleles case)   The list of Quartet may be accessed with the attribute .quartet. If the input was a list of trees, the HybridNetwork's can be accessed with the attribute .tree. For example, if the DataCF object is named d, d.quartet[1] will show the first quartet and d.tree[1] will print the first input tree.  source  #  PhyloNetworks.EqualRatesSubstitutionModel     Type .  EqualRatesSubstitutionModel(numberStates, \u03b1, labels)  TraitSubstitutionModel  for traits with any number of states and equal substitution rates \u03b1 between all states. Default labels are \"1\",\"2\",...  source  #  PhyloNetworks.HybridNetwork     Type .  HybridNetwork type  Explicit network or tree with the following attributes:   numTaxa  numNodes (total number of nodes)  numEdges  numHybrids (number of hybrid nodes)  edge (array of Edges)  node (array of Nodes)  root (index of root in vector 'node'. May be artificial, for printing and traversal purposes only.)  hybrid (array of Nodes: those are are hybrid nodes)  leaf (array of Nodes: those that are leaves)  loglik (negative log pseudolik after estimation)  isRooted (true or false)   source  #  PhyloNetworks.ParamsBM     Type .  ParamsBM  : ParamsProcess  Type for a BM process on a network. Fields are  mu  (expectation),  sigma2  (variance),  randomRoot  (whether the root is random, default to  false ), and  varRoot  (if the root is random, the variance of the root, defalut to  NaN ).  source  #  PhyloNetworks.PhyloNetworkLinearModel     Type .  PhyloNetworkLinearModel :LinPredModel  Regression object for a phylogenetic regression. Result of fitting function  phyloNetworklm . Dominated by the  LinPredModel  class, from package  GLM .  The following StatsBase functions can be applied to it:  coef ,  nobs ,  vcov ,  stderror ,  confint ,  coeftable ,  dof_residual ,  dof ,  deviance ,  residuals ,  model_response ,  predict ,  loglikelihood ,  nulldeviance ,  nullloglikelihood ,  r2 ,  adjr2 ,  aic ,  aicc ,  bic .  The following StatsModels functions can also be applied to it:  ModelFrame ,  ModelMatrix ,  Formula .  Estimated variance and mean of the BM process used can be retrieved with functions  sigma2_estim  and  mu_estim .  If a Pagel's lambda model is fitted, the parameter can be retrieved with function  lambda_estim .  An ancestral state reconstruction can be performed from this fitted object using function:  ancestralStateReconstruction .  The  PhyloNetworkLinearModel  object has fields:  lm ,  V ,  Vy ,  RL ,  Y ,  X ,  logdetVy ,  ind ,  msng ,  model ,  lambda . Type in \"?PhyloNetworkLinearModel.field\" to get help on a specific field.  source  #  PhyloNetworks.Quartet     Type .  Quartet type  type that saves the information on a given 4-taxon subset. It contains the following attributes:   number  taxon (vector of taxon names)  obsCF (vector of observed CF)  logPseudoLik  ngenes (number of gene trees used to compute the observed CF: -1 if unknown)  qnet (internal topological structure that saves the expCF after snaq estimation to emphasize that the expCF depend on a specific network, not the data)   source  #  PhyloNetworks.ReconstructedStates     Type .  ReconstructedStates  Type containing the inferred information about the law of the ancestral states given the observed tips values. The missing tips are considered as ancestral states.  The following functions can be applied to it:  expectations  (vector of expectations at all nodes),  stderror  (the standard error),  predint  (the prediction interval).  The  ReconstructedStates  object has fields:  traits_nodes ,  variances_nodes ,  NodeNumbers ,  traits_tips ,  tipNumbers ,  model . Type in \"?ReconstructedStates.field\" to get help on a specific field.  source  #  PhyloNetworks.ShiftNet     Type .  ShiftNet  Shifts associated to a  HybridNetwork  sorted in topological order. Its  shift  field is a vector of shift values, one for each node, corresponding to the shift on the parent edge of the node (which makes sense for tree nodes only: they have a single parent edge).  Two  ShiftNet  objects on the same network can be concatened with  * .  ShiftNet(node::Vector{Node}, value::Vector{T} where T :Real, net::HybridNetwork; checkPreorder=true::Bool)  Constructor from a vector of nodes and associated values. The shifts are located on the edges above the nodes provided. Warning, shifts on hybrid edges are not allowed.  ShiftNet(edge::Vector{Edge}, value::Vector{T} where T :Real, net::HybridNetwork; checkPreorder=true::Bool)  Constructor from a vector of edges and associated values. Warning, shifts on hybrid edges are not allowed.  Extractors:  getShiftEdgeNumber ,  getShiftValue  source  #  PhyloNetworks.TraitSimulation     Type .  TraitSimulation  Result of a trait simulation on an  HybridNetwork  with function  simulate .  The following functions and extractors can be applied to it:  tipLabels ,  obj[:Tips] ,  obj[:InternalNodes]  (see documentation for function  getindex(::TraitSimulation, ::Symbol) ).  The  TraitSimulation  object has fields:  M ,  params ,  model .  source  #  PhyloNetworks.TraitSubstitutionModel     Type .  TraitSubstitutionModel  Abstract type for discrete trait substitution models, using a continous time Markov model on a phylogeny. Adapted from the substitutionModels module in BioJulia. The same  Q  and  P  function names are used for the transition rates and probabilities.  see  BinaryTraitSubstitutionModel ,  EqualRatesSubstitutionModel ,  TwoBinaryTraitSubstitutionModel  source  #  PhyloNetworks.TwoBinaryTraitSubstitutionModel     Type .  TwoBinaryTraitSubstitutionModel(rate [, label])  TraitSubstitutionModel  for two binary traits, possibly correlated. Default labels are \"x0\", \"x1\" for trait 1, and \"y0\", \"y1\" for trait 2. If provided,  label  should be a vector of size 4, listing labels for trait 1 first then labels for trait 2.  rate  should be a vector of substitution rates of size 8. rate[1],...,rate[4] describe rates of changes in trait 1. rate[5],...,rate[8] describe rates of changes in trait 2.  In the transition matrix, trait combinations are listed in the following order: x0-y0, x0-y1, x1-y0, x1-y1.  example  model   =   TwoBinaryTraitSubstitutionModel ([ 2.0 , 1.2 , 1.1 , 2.2 , 1.0 , 3.1 , 2.0 , 1.1 ], \n         [ carnivory ,   noncarnivory ,   wet ,   dry ]);  model  using   PhyloPlots  plot ( model )   # to visualize states and rates   source", 
            "title": "types"
        }, 
        {
            "location": "/lib/public/#utilities", 
            "text": "#  PhyloNetworks.tipLabels     Function .  tipLabels(x)  Return a vector of taxon names at the leaves, for objects of various types:  HybridNetwork , Vector of  HybridNetwork s (in which case the union is taken then sorted), Vector of  Quartet s,  DataCF ,  TraitSimulation ,  MatrixTopologicalOrder .  For a network, the taxon names are coerced to strings.  source  #  PhyloNetworks.sorttaxa!     Function .  sorttaxa!(DataFrame, columns)  Reorder the 4 taxa and reorders the observed concordance factors accordingly, on each row of the data frame. If  columns  is committed, taxon names are assumed to be in columns 1-4 and CFs are assumed to be in columns 5-6 with quartets in this order: 12_34, 13_24, 14_23. Does  not  reorder credibility interval values, if present.  sorttaxa!(DataCF)\nsorttaxa!(Quartet, permutation_tax, permutation_cf)  Reorder the 4 taxa in each element of the DataCF  quartet . For a given Quartet, reorder the 4 taxa in its fields  taxon  and  qnet.quartetTaxon  (if non-empty) and reorder the 3 concordance values accordingly, in  obsCF  and  qnet.expCF .  permutation_tax  and  permutation_cf  should be vectors of short integers (Int8) of length 4 and 3 respectively, whose memory allocation gets reused. Their length is  not checked .  source  #  PhyloNetworks.printEdges     Function .  printEdges(net)\nprintEdges(io::IO, net)  Print information on the edges of a  HybridNetwork  or  QuartetNetwork  object  net : edge number, numbers of nodes attached to it, edge length, whether it's a hybrid edge, its \u03b3 inheritance value, whether it's a major edge, if it could contain the root (this field is not always updated, though) and attributes pertaining to level-1 networks used in SNaQ: in which cycle it is contained (-1 if no cycle), and if the edge length is identifiable (based on quartet concordance factors).  source  #  PhyloNetworks.printNodes     Function .  printNodes(net)\nprintNodes(io, net)  Print information on the nodes of a  HybridNetwork  net: node number, whether it's a leaf, whether it's a hybrid node, whether it's connected to one or more hybrid edges, it's name (label), the cycle in which it is belong (-1 if no cycle; makes sense for level-1 networks), and the list of edges attached to it, by their numbers.  source  #  PhyloNetworks.summarizeDataCF     Function .  summarizeDataCF(d::DataCF)  function to summarize the information contained in a DataCF object. It has the following optional arguments:   filename: if provided, the summary will be saved in the filename, not to screen  pc (number between (0,1)): threshold of percentage of missing genes to identify 4-taxon subsets with fewer genes than the threshold   source  #  PhyloNetworks.directEdges!     Function .  directEdges !( net :: HybridNetwork ;   checkMajor = true :: Bool )   Updates the edges' attribute  isChild1 , according to the root placement. Also updates edges' attribute  containRoot , for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if checkMajor=true.  Warning: Assumes that isChild1 is correct on hybrid edges (to avoid changing the identity of which nodes are hybrids and which are not).  Returns the network. Throws a 'RootMismatch' Exception if the root was found to conflict with the direction of any hybrid edge.  source  #  PhyloNetworks.preorder!     Function .  preorder!(net::HybridNetwork)  Updates attribute net.nodes_changed in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges' direction needs to be correct before calling preorder!, using directEdges!  source  #  PhyloNetworks.cladewiseorder!     Function .  cladewiseorder!(net::HybridNetwork)  Updates attribute net.cladewiseorder_nodeIndex. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges' direction needs to be correct before calling  cladewiseorder! , using  directEdges!  source  #  PhyloNetworks.rootatnode!     Function .  rootatnode !( HybridNetwork ,   nodeNumber :: Integer ;   index = false :: Bool ,   verbose = true :: Bool )  rootatnode !( HybridNetwork ,   Node ;   verbose = true )  rootatnode !( HybridNetwork ,   nodeName :: AbstractString ;   verbose = true )   Root the network/tree object at the node with name 'nodeName' or number 'nodeNumber' (by default) or with index 'nodeNumber' if index=true. Attributes isChild1 and containRoot are updated along the way. Use  plot(net, showNodeNumber=true, showEdgeLength=false)  to visualize and identify a node of interest. (see package  PhyloPlots )  Return the network.  Warnings:   If the node is a leaf, the root will be placed along the edge adjacent to the leaf. This might add a new node.   If the desired root placement is incompatible with one or more hybrids, then   a RootMismatch error is thrown; use  verbose=false  to silence the root mismatch info printed before the error is thrown.  the input network will still have some attributes modified.     See also:  rootonedge! .  source  #  PhyloNetworks.rootonedge!     Function .  rootonedge !( HybridNetwork ,   edgeNumber :: Integer ;   index = false :: Bool ,   verbose = true :: Bool )  rootonedge !( HybridNetwork ,   Edge ;   verbose = true :: Bool )   Root the network/tree along an edge with number  edgeNumber  (by default) or with index  edgeNumber  if  index=true . Attributes  isChild1  and  containRoot  are updated along the way.  This adds a new node and a new edge to the network. Use  plot(net, showEdgeNumber=true, showEdgeLength=false)  to visualize and identify an edge of interest. (see package  PhyloPlots )  See also:  rootatnode! .  source  #  PhyloNetworks.hybridatnode!     Function .  hybridatnode!(net::HybridNetwork, nodeNumber::Integer)  Change the status of edges in network  net , to move the hybrid node in a cycle to the node with number  nodeNumber . This node must be in one (and only one) cycle, otherwise an error will be thrown.  net  is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. Check and update the nodes' field  inCycle .  Example #\"  julia   net   =   readTopology ( (A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1; );  julia   using   PhyloPlots  julia   plot ( net ,   showNodeNumber = true )  julia   hybridatnode! ( net ,   - 4 )  julia   plot ( net )   source  hybridatnode!(net, hybrid::Node, newNode::Node)  Move the reticulation from  hybrid  to  newNode , which must in the same cycle.  net  is assumed to be of level 1, but  no checks  are made and fields are supposed up-to-date.  source  #  PhyloNetworks.setLength!     Function .  setLength!(Edge,new length)  set a new length for an object Edge. The new length needs to be positive. For example, if you have a HybridNetwork object net, and do printEdges(net), you can see the list of Edges and their lengths. You can then change the length of the 3rd edge with setLength!(net.edge[3],1.2). If  new length  is above 10, the value 10 will be used, as an upper limit to coalescent units that can be reliably estimated.  source  #  PhyloNetworks.setGamma!     Function .  setGamma!(Edge, new \u03b3)\nsetGamma!(Edge, new \u03b3, change other=true::Bool)  Set inheritance probability \u03b3 for an edge, which must be a hybrid edge. The new \u03b3 needs to be in [0,1]. The \u03b3 of the \"partner\" hybrid edge is changed accordingly, to 1-\u03b3. The field  isMajor  is also changed accordingly. If the new \u03b3 is approximately 0.5,  Edge  is set to the major parent, its partner is set to the minor parent.  If  net  is a HybridNetwork object,  printEdges(net)  will show the list of edges and their \u03b3's. The \u03b3 of the third hybrid edge (say) can be changed to 0.2 with  setGamma!(net.edge[3],0.2) . This will automatically set \u03b3 of the partner hybrid edge to 0.8.  The last argument is true by default. If false: the partner edge is not updated.  source  #  PhyloNetworks.deleteleaf!     Function .  deleteleaf !( HybridNetwork ,   leafName :: AbstractString ;   simplify = true )  deleteleaf !( HybridNetwork ,   Node ;   simplify = true )  deleteleaf !( HybridNetwork ,   Integer ;   index = false ,   simplify = true )   Deletes a leaf node from the network, possibly from its name, number, or index in the network's array of nodes.  simplify: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.  The first 2 versions require that  node  is a leaf. The 3rd version does  not  require that  node  is a leaf. If  node  has degree 3 or more, nothing happens. If it has degree 1 or 2, it is deleted.  Warning: does  not  update attributes related to level-1 networks, such as inCycle, partition, gammaz, etc. Does not require branch lengths, and designed to work on networks of all levels.  source  #  PhyloNetworks.deleteHybridThreshold!     Function .  deleteHybridThreshold!(net::HybridNetwork, threshold::Float64, keepNodes=false)  Deletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.   if threshold 0.5: delete minor hybrid edges with \u03b3   threshold (or with a missing \u03b3, for any threshold   -1.0)  if threshold=0.5: delete all minor hybrid edges (i.e normally with \u03b3   0.5, if \u03b3 non-missing)  keepNodes : if true, keep all original nodes; delete edges only.   Warnings:   by default,  keepNodes  is false, and partner hybrid edges have their \u03b3 changed to 1.0. If  keepNodes  is true: the \u03b3's of partner hybrid edges are unchanged.  assumes correct isMajor attributes.   source  #  PhyloNetworks.rotate!     Function .  rotate !( net :: HybridNetwork ,   nodeNumber :: Integer ;   orderedEdgeNum :: Array { Int,1 } )   Rotates the order of the node's children edges. Useful for plotting, to remove crossing edges. If  node  is a tree node with no polytomy, the 2 children edges are switched and the optional argument  orderedEdgeNum  is ignored.  Use  plot(net, showNodeNumber=true, showEdgeNumber=false)  to map node and edge numbers on the network, as shown in the examples below. (see package  PhyloPlots )  Warning: assumes that edges are correctly directed (isChild1 updated). This is done by  plot(net) . Otherwise run  directEdges!(net) .  Example #\"  julia   net   =   readTopology ( (A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1; );  julia   using   PhyloPlots  julia   plot ( net ,   showNodeNumber = true )  julia   rotate! ( net ,   - 4 )  julia   plot ( net )  julia   net = readTopology ( (4,((1,(2)#H7:::0.864):2.069,(6,5):3.423):0.265,(3,#H7:::0.136):10.0); );  julia   plot ( net ,   showNodeNumber = true ,   showEdgeNumber = true )  julia   rotate! ( net ,   - 1 ,   orderedEdgeNum = [ 1 , 12 , 9 ])  julia   plot ( net ,   showNodeNumber = true ,   showEdgeNumber = true )  julia   rotate! ( net ,   - 3 )  julia   plot ( net )   source  #  Base.getindex     Method .  getindex(collection, key...)  Retrieve the value(s) stored at the given key or index within a collection. The syntax  a[i,j,...]  is converted by the compiler to  getindex(a, i, j, ...) .  Example  julia  A = Dict( a  =  1,  b  =  2)\nDict{String,Int64} with 2 entries:\n   b  =  2\n   a  =  1\n\njulia  getindex(A,  a )\n1  source  getindex(obj, d)  Getting submatrices of an object of type  TraitSimulation .  Arguments   obj::TraitSimulation : the matrix from which to extract.   d::Symbol : a symbol precising which sub-matrix to extract. Can be:   :Tips  columns and/or rows corresponding to the tips  :InternalNodes  columns and/or rows corresponding to the internal nodes     source  #  PhyloNetworks.getNodeAges     Function .  getNodeAges(net)  vector of node ages in pre-order, as in  nodes_changed , which is assumed to have been calculated before.  source  #  PhyloNetworks.pairwiseTaxonDistanceMatrix     Function .  pairwiseTaxonDistanceMatrix(net; keepInternal=false,\n                            checkPreorder=true, nodeAges=[])\npairwiseTaxonDistanceMatrix!(M, net, nodeAges)  Return the matrix  M  of pairwise distances between nodes in the network:   between all nodes (internal and leaves) if  keepInternal=true , in which case the nodes are listed in  M  in the order in which they appear in  net.nodes_changed  between taxa only otherwise, in which case the nodes are listed in  M  in the order in which they appear in  tipLabels(net)  (i.e. same order as in  net.leaf )   The second form modifies  M  in place, assuming all nodes.  The distance between the root and a given hybrid node (to take an example) is the weighted average of path lengths from the root to that node, where each path is weighted by the product of \u03b3s of all edges on that path. This distance measures the average genetic distance across the genome, if branch lengths are in substitutions/site.  optional arguments:   checkPreorder : if true,  net.nodes_changed  is updated to get a topological ordering of nodes.  nodeAges : if not provided, i.e. empty vector, the network is  not  modified.   If provided and non-empty,  nodeAges  should list node ages in the pre-order in which nodes are listed in  nodes_changed  (including leaves), and  edge lengths  in  net   are modified  accordingly.   Providing node ages hence makes the network time consistent: such that all paths from the root to a given hybrid node have the same length. If node ages are not provided, the network need not be time consistent.  source  #  PhyloNetworks.biconnectedComponents     Function .  biconnectedComponents(network, ignoreTrivial=false)  Calculate biconnected components (aka \"blobs\") using Tarjan's algorithm: the output is an array of arrays of edges. These blobs are returned in post-order, but within a blob, edges are  not  necessarily sorted in topological order. If  ignoreTrivial  is true, trivial components (of a single edge) are not returned. The network is assumed to be connected.  Warnings : for nodes, fields  k ,  inCycle , and  prev  are modified during the algorithm. They are used to store the node's \"index\" (time of visitation), \"lowpoint\", and the node's \"parent\", as defined by the order in which nodes are visited.  References:   p. 153 of  Tarjan (1972) . Depth first search and linear graph algorithms, SIAM Journal on Computing, 1(2):146-160  on  geeksforgeeks , there is an error (as of 2018-01-30):  elif v != parent[u] and low[u]   disc[v]:  (python version) should be replaced by  elif v != parent[u] and disc[u]   disc[v]:  nice explanation at this  url   source  biconnectedComponents(node, index, S, blobs, ignoreTrivial)  Helper recursive function starting at a node (not a network).  index  is an array containing a single integer, thus mutable: order in which nodes are visited.  source  #  PhyloNetworks.blobDecomposition     Function .  blobDecomposition!(network)\nblobDecomposition(network)  Find blobs using  biconnectedComponents ; find their roots using  blobInfo ; create a forest in the form of a disconnected network (for efficiency), by deconnecting the root of each non-trivial blob from its parent. The root of each blob corresponds to a new leaf (in another tree of the forest): the number of the blob's root is given to the newly created leaf.  The first (bang) version modifies the network and returns the array of blob roots. The second version copies the network then returns a tuple: the forest and the blob roots.  source", 
            "title": "utilities"
        }, 
        {
            "location": "/lib/public/#data-and-topology-readwrite", 
            "text": "#  PhyloNetworks.readTopology     Function .  readTopology(file name)\nreadTopology(parenthetical description)  Read tree or network topology from parenthetical format (extended Newick). If the root node has a single child: ignore (i.e. delete from the topology) the root node and its child edge.  Input: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description.  source  #  PhyloNetworks.readTopologyLevel1     Function .  readTopologyLevel1(filename)\nreadTopologyLevel1(parenthetical format)  same as readTopology, reads a tree or network from parenthetical format, but this function enforces the necessary conditions for any starting topology in SNaQ: non-intersecting cycles, no polytomies, unrooted. It sets any missing branch length to 1.0.  If the network has a bad diamond II (in which edge lengths are \u03b3's are not identifiable) and if the edge below this diamond has a length  t  different from 0, then this length is set back to 0 and the major parent hybrid edge is lengthened by  t .  source  #  PhyloNetworks.readInputTrees     Function .  readInputTrees(file)  Read a text file with a list of trees/networks in parenthetical format (one tree per line) and transform them like  readTopologyLevel1  does: to be unrooted, with resolved polytomies, missing branch lengths set to 1.0, etc. See  readMultiTopology  to read multiple trees or networks with no modification.  Output: array of HybridNetwork objects.  source  #  PhyloNetworks.readMultiTopology     Function .  readMultiTopology(file)  Read a text file with a list of networks in parenthetical format (one per line). Each network is read with  readTopology . Return an array of HybridNetwork object.  source  #  PhyloNetworks.readSnaqNetwork     Function .  readSnaqNetwork(output file)  function to read the estimated network from an .out file generated by the snaq function  source  #  PhyloNetworks.readTrees2CF     Function .  readTrees2CF(treefile)\nreadTrees2CF(vector of trees)  Read trees in parenthetical format from a file, or take a vector of trees already read, and calculate the proportion of these trees having a given quartet (concordance factor: CF), for all quartets or for a sample of quartets. Optional arguments include:   quartetfile: name of text file with list of 4-taxon subsets to be analyzed. If none is specified, the function will list all possible 4-taxon subsets.  whichQ=\"rand\": to choose a random sample of 4-taxon subsets  numQ: size of random sample (ignored if whichQ is not set to \"rand\")  writeTab=false: does not write the observedCF to a table (default true)  CFfile: name of file to save the observedCF (default tableCF.txt)  writeQ=true: save intermediate files with the list of all 4-taxon subsets and chosen random sample (default false).  writeSummary: write descriptive stats of input data (default: true)  nexus: if true, it assumes the gene trees are written in nexus file (default: false)   source  #  PhyloNetworks.readTableCF     Function .  readTableCF(file)\nreadTableCF(data frame)\nreadTableCF!(data frame)  Read a file or DataFrame object containing a table of concordance factors (CF), with one row per 4-taxon set. The first 4 columns are assumed to give the labels of the 4 taxa in each set (tx1, tx2, tx3, tx4). Columns containing the CFs are assumed to be named 'CF12_34', 'CF13_24' and 'CF14_23', or else are assumed to be columns 5,6,7. If present, a column named 'ngenes' will be used to get the number of loci used to estimate the CFs for each 4-taxon set.  Optional arguments:   summaryfile: if specified, a summary file will be created with that name.  delim (for the first form only): to specify how columns are delimited, with single quotes: delim=';'. Default is a  csv  file, i.e.  delim=',' .   The last version modifies the input data frame, if species are represented by multiple alleles for instance (see  readTableCF! ).  source  #  PhyloNetworks.readTableCF!     Function .  readTableCF!(data frame, columns)  Read in quartet CFs from data frame, assuming information is in columns numbered  columns , of length  7 or 8 : 4 taxon labels then 3 CFs then ngenes possibly.  If some species appears more than once in the same 4-taxon set (e.g. t1,t1,t2,t3), then the data frame is modified to remove rows (4-taxon sets) that are uninformative about between-species relationships. This situation may occur if multiple individuals are sampled from the same species. A 4-taxon set is uninformative (and its row is removed) if one taxon is repeated 3 or 4 times (like t1,t1,t1,t1 or t1,t2,t2,t2). The list of species appearing twice in some 4-taxon sets is stored in the output DataCF object. For these species, the length of their external edge is identifiable (in coalescent units). If multiple rows correspond to the same 4-taxon set, these rows are merged and their CF values (and number of genes) are averaged.  readTableCF!(DataCF, data frame, columns)  Modify the  .quartet.obsCF  values in the  DataCF  object with those read from the data frame in columns numbered  columns .  columns  should have  3  columns numbers for the 3 CFs in this order: 12_34, 13_24 and 14_23. Assume the same 4-taxon sets in  DataCF  and in the data frame, and in the same order, but this assumption is  not checked  (for speed, e.g. during bootstrapping).  source  #  PhyloNetworks.readBootstrapTrees     Function .  readBootstrapTrees(filename)  input: name of file containing the path/name to multiple bootstrap files, one per line. Each bootstrap file corresponds to bootstrap trees from a single gene.  output: vector of vectors of trees.  source  #  PhyloNetworks.writeSubTree!     Function .  writeSubTree!(IO, network, dendroscope::Bool, names::Bool,\n              round_branch_lengths::Bool, digits::Integer)  Write to IO the extended newick format (parenthetical description) of a network. If written for dendroscope, inheritance \u03b3's are not written. If  names  is true, taxon names are written, otherwise taxon numbers are written instead of taxon names. If unspecified, branch lengths and \u03b3's are rounded to 3 digits.  source  writeSubTree!(IO, node, edge, dendroscope::Bool, names::Bool,\n              round_branch_lengths::Bool, digits::Integer)  Write the extended newick format of the sub-network rooted at  node  and assuming that  edge  is a parent of  node .  If  parent  is  nothing , the edge attribute  isChild1  is used and assumed to be correct to write the subtree rooted at  node . This is useful to write a subtree starting at a non-root node. Example:  net   =   readTopology ( (((A,(B)#H1:::0.9),(C,#H1:::0.1)),D); )  directEdges! ( net )  s   =   IOBuffer ()  PhyloNetworks . writeSubTree! ( s ,   net . node [ 7 ],   nothing ,   false ,   true )  String ( s )   Used by  writeTopology .  source  #  PhyloNetworks.writeTopology     Function .  writeTopology(net)\nwriteTopology(net, filename)\nwriteTopology(net, IO)  Write the parenthetical extended Newick format of a network, as a string, to a file or to an IO buffer / stream. Optional arguments (default values):   di (false): write in format for Dendroscope  round (false): rounds branch lengths and heritabilities \u03b3  digits (3): digits after the decimal place for rounding  append (false): if true, appends to the file   If the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.  Uses lower-level function  writeSubTree! .  source  #  PhyloNetworks.writeMultiTopology     Function .  writeMultiTopology(nets, file_name; append=false)\nwriteMultiTopology(nets, IO)  Write an array of networks in parenthetical extended Newick format, one network per line. Use the option append=true to append to the file. Otherwise, the default is to create a new file or overwrite it, if it already existed. Each network is written with  writeTopology .  Examples #\"  julia   net   =   [ readTopology ( (D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10); ), \n               readTopology ( (A,(B,C)); ), readTopology ( (E,F); ), readTopology ( (G,H,F); ) ] ;  julia   writeMultiTopology ( net ,   fournets.net )   #   to   ( over ) write   to   file   fournets.net  julia   writeMultiTopology ( net ,   fournets.net ,   append = true )   #   to   append   to   this   file  julia   writeMultiTopology ( net ,   STDOUT )           #   to   write   to   the   screen   ( standard   out )  ( D ,(( A ,( B ) # H7 : :: 0 . 864 ) : 2 . 069 ,( F , E ) : 3 . 423 ) : 0 . 265 ,( C , # H7 : :: 0 . 1361111 ) : 10 . 0 );  ( A ,( B , C ));  ( E , F );  ( G , H , F );   source  #  PhyloNetworks.mapAllelesCFtable     Function .  mapAllelesCFtable(mapping file, CF file; filename, columns, delim)  Create a new DataFrame containing the same concordance factors as in the input CF file, but with modified taxon names. Each allele name in the input CF table is replaced by the species name that the allele maps onto, based on the mapping file. The mapping file should have column names: allele and species.  Optional arguments:   file name to write/save resulting CF table. If not specified, then the output data frame is not saved to a file.  column numbers for the taxon names. 1-4 by default.  any keyword arguments that  CSV.read  would accept. For example, delim=',' by default: columns are delimited by commas. Unless specified otherwise by the user,  categorical =false (to read taxon names as Strings, not levels of a categorical factor, for combining the 4 columns with taxon names more easily). The same CSV arguments are used to read both input file (mapping file and quartet file)   See also  mapAllelesCFtable!  to input DataFrames instead of file names.  If a  filename  is specified, such as \"quartetCF_speciesNames.csv\" in the example below, this file is best read later with the option  categorical=false . example:  mapAllelesCFtable ( allele-species-map.csv ,   allele-quartet-CF.csv ; \n                   filename   =   quartetCF_speciesNames.csv )  df_sp   =   CSV . read ( quartetCF_speciesNames.csv ,   categorical = false );   # DataFrame object  dataCF_specieslevel   =   readTableCF! ( df_sp );   # DataCF object   source", 
            "title": "data and topology read/write"
        }, 
        {
            "location": "/lib/public/#network-inference", 
            "text": "#  PhyloNetworks.snaq!     Function .  snaq!(T::HybridNetwork, d::DataCF)  Estimate the network (or tree) to fit observed quartet concordance factors (CFs) stored in a DataCF object, using maximum pseudo-likelihood. A level-1 network is assumed. The search starts from topology  T , which can be a tree or a network with no more than  hmax  hybrid nodes. The function name ends with ! because it modifies the CF data  d  by updating its attributes  expCF : CFs expected under the network model. It does  not  modify  T . The quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.  Output:   estimated network in file  .out  (also in  .log ): best network overall and list of networks from each individual run.  the best network and modifications of it, in file  .networks . All networks in this file have the same undirected topology as the best network, but have different hybrid/gene flow directions. These other networks are reported with their pseudo-likelihood scores, because  non-identifiability issues can cause them to have very similar scores, and because  SNaQ was shown to estimate the undirected topology accurately but not the direction of  hybridization in cases of near non-identifiability.  if any error occurred, file  .err  provides information (seed) to reproduce the error.   There are many optional arguments, including   hmax: maximum number of hybridizations allowed (default 1)  verbose: if true, print information about the numerical optimization  runs: number of independent starting points for the search (default 10)  outgroup: outgroup taxon to root the estimated topology at the very end  filename: root name for the output files. Default is \"snaq\". If empty (\"\"), files are  not  created, progress log goes to the screen only (standard out).  seed: seed to replicate a given search   The following optional arguments control when to stop the optimization of branch lengths and \u03b3's on each individual candidate network. Defaults are in parentheses:   ftolRel (1e-6) and ftolAbs (1e-6): relative and absolute differences of the network score between the current and proposed parameters,  xtolRel (1e-2) and xtolAbs (1e-3): relative and absolute differences between the current and proposed parameters.   Greater values will result in a less thorough but faster search. These parameters are used when evaluating candidate networks only. The following optional arguments control when to stop proposing new network topologies:   Nfail (75): maximum number of times that new topologies are proposed and rejected (in a row).  liktolAbs (1e-6): the proposed network is accepted if its score is better than the current score by at least liktolAbs.   Lower values of Nfail and greater values of liktolAbs and ftolAbs would result in a less thorough but faster search.  At the end, branch lengths and \u03b3's are optimized on the last \"best\" network with different and very thorough tolerance parameters: 1e-12 for ftolRel, 1e-10 for ftolAbs, xtolRel, xtolAbs.  See also:  topologyMaxQPseudolik!  to optimize parameters on a fixed topology, and  topologyQPseudolik!  to get the deviance (pseudo log-likelihood up to a constant) of a fixed topology with fixed parameters.  Reference: Claudia Sol\u00eds-Lemus and C\u00e9cile An\u00e9 (2016). Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting.  PLoS Genetics  12(3):e1005896  source  #  PhyloNetworks.snaqDebug     Function .  snaqDebug(currT::HybridNetwork,d::DataCF)  function to replicate a given run that produces error according to the .err file generated by snaq. The same settings used in that run should be used in this function, specially the seed. See the readme file online for more details.  source  #  PhyloNetworks.topologyMaxQPseudolik!     Function .  topologyMaxQPseudolik!(net::HybridNetwork, d::DataCF)  Estimate the branch lengths and inheritance probabilities (\u03b3's) for a given network topology. The network is  not  modified, only the object  d  is, with updated expected concordance factors.  Ouput: new network, with optimized parameters (branch lengths and gammas). The maximized quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0. This is also an attribute of the network, which can be accessed with  net.loglik .  Optional arguments (default value):   verbose (false): if true, information on the numerical optimization is printed to screen  ftolRel (1e-5), ftolAbs (1e-6), xtolRel (1e-3), xtolAbs (1e-4): absolute and relative tolerance values for the pseudo-deviance function and the parameters   source  #  PhyloNetworks.topologyQPseudolik!     Function .  topologyQPseudolik!(net::HybridNetwork, d::DataCF)  Calculate the quartet pseudo-deviance of a given network/tree for DataCF  d . This is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.  Be careful if the net object does not have all internal branch lengths specified because then the pseudolikelihood will be meaningless.  The loglik attribute of the network is undated, and  d  is updated with the expected concordance factors under the input network.  source  #  PhyloNetworks.fittedQuartetCF     Function .  fittedQuartetCF(d::DataCF, format::Symbol)  return a data frame with the observed and expected quartet concordance factors after estimation of a network with snaq(T,d). The format can be :wide (default) or :long.   if wide, the output has one row per 4-taxon set, and each row has 10 columns: 4 columns for the taxon names, 3 columns for the observed CFs and 3 columns for the expected CF.  if long, the output has one row per quartet, i.e. 3 rows per 4-taxon sets, and 7 columns: 4 columns for the taxon names, one column to give the quartet resolution, one column for the observed CF and the last column for the expected CF.   see also:  topologyQPseudolik!  and  topologyMaxQPseudolik!  to update the fitted CF expected under a specific network, inside the DataCF object  d .  source  #  PhyloNetworks.bootsnaq     Function .  bootsnaq(T::HybridNetwork, df::DataFrame)\nbootsnaq(T::HybridNetwork, vector of tree lists)  Bootstrap analysis for SNaQ. Bootstrap data can be quartet concordance factors (CF), drawn from sampling uniformly in their credibility intervals, as given in the data frame  df . Alternatively, bootstrap data can be gene trees sampled from a vector of tree lists: one list of bootstrap trees per locus (see  readBootstrapTrees  to generate this, from a file containing a list of bootstrap files: one per locus).  From each bootstrap replicate, a network is estimated with snaq!, with a search starting from topology  T . Optional arguments include the following, with default values in parentheses:   hmax (1): max number of reticulations in the estimated networks  nrep (10): number of bootstrap replicates.  runs (10): number of independent optimization runs for each replicate  filename (\"bootsnaq\"): root name for output files. No output files if \"\".  seed (0 to get a random seed from the clock): seed for random number generator  otherNet (empty): another starting topology so that each replicate will start prcnet% runs on otherNet and (1-prcnet)% runs on T  prcnet (0): percentage of runs starting on otherNet; error if different than 0.0, and otherNet not specified.  ftolRel, ftolAbs, xtolRel, xtolAbs, liktolAbs, Nfail: see  snaq! , same defaults.   source  #  PhyloNetworks.calibrateFromPairwiseDistances!     Function .  calibrateFromPairwiseDistances!(net, distances::Matrix{Float64},\n    taxon_names::Vector{String})  Calibrate the network to match (as best as possible) input pairwise distances between taxa, such as observed from sequence data.  taxon_names  should provide the list of taxa, in the same order in which they they are considered in the  distances  matrix. The optimization criterion is the sum of squares between the observed distances, and the distances from the network (weighted average of tree distances, weighted by \u03b3's). The network's edge lengths are modified.  Warning: for many networks, mutiple calibrations can fit the pairwise distance data equally well (lack of identifiability). This function will output  one  of these equally good calibrations.  optional arguments (default):   checkPreorder (true)  forceMinorLength0 (false) to force minor hybrid edges to have a length of 0  NLoptMethod (:LD_MMA) for the optimization algorithm. Other options include :LN_COBYLA (derivative-free); see NLopt package.  tolerance values to control when the optimization is stopped: ftolRel (1e-12), ftolAbs (1e-10) on the criterion, and xtolRel (1e-10), xtolAbs (1e-10) on branch lengths / divergence times.  verbose (false)   source  #  PhyloNetworks.ticr     Function .  ticr!(net, D::DataFrame, optimizeBL::Bool)\nticr!(net, D::DataCF,    optimizeBL::Bool)\nticr(D::DataCF)  Goodness-of-fit test for the adequacy of the multispecies network coalescent, to see if a given population or species network explains the quartet concordance factor data adequately (see Stenz et al 2015 and  addendum  for the method on trees) Obviously the acronym TICR (Tree Incongruence Checking with R) becomes outdated: with a method extended to networks and implemented in Julia. Oh well :smiley:.  The tree / network needs to have branch lengths in coalescent units, must be fully resolved, and must be of level 1.  The model assumes a Dirichlet distribution for the observed quartet concordance factor, with concentration parameter estimated from the data. An outlier p-value is calculated for each four-taxon set. Four-taxon sets are then binned into  categories according to their p-values:  0-0.01 ,  0.01-0.05 ,  0.05-0.10 , and  0.10-1 . Finally, a chi-square goodness-of-fit test is performed on these binned frequency with 3 degrees of freedom, to determine if they departs from the expected proportions  (0.01, 0.04, 0.05, 0.90) .   The first version takes a DataFrame object where each row corresponds to a given four-taxon set. The DataFrame is modified by having an additional another column containing the p-values corresponding to each four-taxon set.  The second version takes a DataCF object and modifies it by updating the expected concordance factors stored in that object.  The last version (which all others call) assumes that the expected concordance factors in the DataCF object are correctly calculated from the test network.   optimizeBL : when false, the loglik field of  net  is updated; when  true , a copy of  net  with updated branch lengths (in coalescent units) and update loglik is returned.  output:   p-value of the \u03c7^2 test  \u03c7^2 statistic  value of the pseudo likelihood  value of the concentration parameter \u03b1  a vector of outlier p-values, one for each four-taxon set  network (first and second versions):  net  with loglik field updated if  optimizeBL  is false;  copy of  net  with optimized branch lengths and loglik if  optimizeBL  is true   References  NWM Stenz, B Larget, DA Baum and C Ane\u0301 (2015). Exploring tree-like and non-tree-like patterns using genome sequences: An example using the inbreeding plant species  Arabidopsis thaliana  (L.) Heynh. Systematic Biology, 64(5):809-823. doi: 10.1093/sysbio/syv039  source  #  PhyloNetworks.ticr!     Function .  ticr!(net, D::DataFrame, optimizeBL::Bool)\nticr!(net, D::DataCF,    optimizeBL::Bool)\nticr(D::DataCF)  Goodness-of-fit test for the adequacy of the multispecies network coalescent, to see if a given population or species network explains the quartet concordance factor data adequately (see Stenz et al 2015 and  addendum  for the method on trees) Obviously the acronym TICR (Tree Incongruence Checking with R) becomes outdated: with a method extended to networks and implemented in Julia. Oh well :smiley:.  The tree / network needs to have branch lengths in coalescent units, must be fully resolved, and must be of level 1.  The model assumes a Dirichlet distribution for the observed quartet concordance factor, with concentration parameter estimated from the data. An outlier p-value is calculated for each four-taxon set. Four-taxon sets are then binned into  categories according to their p-values:  0-0.01 ,  0.01-0.05 ,  0.05-0.10 , and  0.10-1 . Finally, a chi-square goodness-of-fit test is performed on these binned frequency with 3 degrees of freedom, to determine if they departs from the expected proportions  (0.01, 0.04, 0.05, 0.90) .   The first version takes a DataFrame object where each row corresponds to a given four-taxon set. The DataFrame is modified by having an additional another column containing the p-values corresponding to each four-taxon set.  The second version takes a DataCF object and modifies it by updating the expected concordance factors stored in that object.  The last version (which all others call) assumes that the expected concordance factors in the DataCF object are correctly calculated from the test network.   optimizeBL : when false, the loglik field of  net  is updated; when  true , a copy of  net  with updated branch lengths (in coalescent units) and update loglik is returned.  output:   p-value of the \u03c7^2 test  \u03c7^2 statistic  value of the pseudo likelihood  value of the concentration parameter \u03b1  a vector of outlier p-values, one for each four-taxon set  network (first and second versions):  net  with loglik field updated if  optimizeBL  is false;  copy of  net  with optimized branch lengths and loglik if  optimizeBL  is true   References  NWM Stenz, B Larget, DA Baum and C Ane\u0301 (2015). Exploring tree-like and non-tree-like patterns using genome sequences: An example using the inbreeding plant species  Arabidopsis thaliana  (L.) Heynh. Systematic Biology, 64(5):809-823. doi: 10.1093/sysbio/syv039  source", 
            "title": "network inference"
        }, 
        {
            "location": "/lib/public/#network-comparisons", 
            "text": "#  PhyloNetworks.majorTree     Function .  majorTree(net::HybridNetwork)  Warning: assumes correct isMajor attributes.  Extracts the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node. Returns a HybridNetwork object.  source  #  PhyloNetworks.minorTreeAt     Function .  minorTreeAt(net::HybridNetwork, hybindex::Integer, keepNodes=false)  Extract the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i= hybindex ), where the minor hybrid edge is kept instead of the major hybrid edge. If  keepNodes  is true, all nodes are kept during edge removal.  Warning: assume correct  isMajor  fields.  source  #  PhyloNetworks.displayedTrees     Function .  displayedTrees ( net :: HybridNetwork ,   gamma :: Float64 ;   keepNodes = false :: Bool )   Extracts all trees displayed in a network, following hybrid edges with heritability  = \u03b3 threshold (or  0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than \u03b3. Returns an array of trees, as HybridNetwork objects.  keepNodes : if true, keep all nodes during hybrid edge removal.  Warnings:   if  keepNodes  is true: the retained partner hybrid edges have their \u03b3 values unchanged, but their  isMajor  is changed to true  assume correct  isMajor  attributes.   source  #  PhyloNetworks.displayedNetworkAt!     Function .  displayedNetworkAt!(net::HybridNetwork, node::Node, keepNodes=false)  Delete all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before. If  keepNodes  is true, all nodes are kept during edge removal.  Warning: assume correct  isMajor  fields.  source  #  PhyloNetworks.hardwiredClusters     Function .  hardwiredClusters(net::HybridNetwork, S::Union{Vector{String},Vector{Int}})  Returns a matrix describing all the hardwired clusters in a network. Warnings: Clusters are rooted, so the root must be correct.           Allows for missing taxa, with entries all 0.  Each row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).   first column: edge number  next columns: 0/1 values. 1=descendant of edge, 0=not a descendant, or missing taxon.  last column:  10/11 values. 10=tree edge, 11=hybrid edge   source  #  PhyloNetworks.hardwiredCluster     Function .  hardwiredCluster(edge::Edge,taxa::Union{Vector{String},Vector{Int}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}},\n                  visited::Vector{Int})  Calculate the hardwired cluster of  node , coded a vector of booleans: true for taxa that are descendent of nodes, false for other taxa (including missing taxa).  The node should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.  visited: vector of node numbers, of all visited nodes.  Examples: #\"  julia  net5 =  (A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));  |  readTopology |  directEdges! ;\n\njulia  taxa = net5 |  tipLabels # ABC EF D\n6-element Array{String,1}:\n  A \n  B \n  C \n  E \n  F \n  D \n\njulia  hardwiredCluster(net5.edge[12], taxa) # descendants of 12th edge = CEF\n6-element Array{Bool,1}:\n false\n false\n  true\n  true\n  true\n false  source  #  PhyloNetworks.hardwiredClusterDistance     Function .  hardwiredClusterDistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)  Takes 2 networks and returns their hardwired cluster distance, that is, the number of hardwired clusters found in one network and not in the other. Note that this is not a distance per se on the full space of hybrid networks: there are pairs of different networks for which this measure is 0. But it is a distance on some network subspaces.  If the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, the trees are considered unrooted.  source  #  PhyloNetworks.treeEdgesBootstrap     Function .  treeEdgesBootstrap(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork)  read a list of bootstrap networks ( boot_net ) and a reference network ( ref_net ), and calculate the bootstrap support of the tree edges in the reference network. All minor hybrid edges (\u03b3 0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.  output:   a data frame with one row per tree edge and two columns: edge number, bootstrap support (as a percentage)  the major tree from the reference network, where minor hybrid edges (with \u03b3 0.5) have been removed.   source  #  PhyloNetworks.hybridBootstrapSupport     Function .  hybridBootstrapSupport(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)  Match hybrid nodes in a reference network with those in an array of networks, like bootstrap networks. All networks must be fully resolved, and on the same taxon set. If  rooted=true , all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).  Two hybrid edges in two networks are said to match if they share the same \"hybrid\" clade (or recipient) and the same \"donor clade\", which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with \u03b3 0.5) and one is its minor sister (following the major hybrid edge with \u03b3 0.5).  To calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If  rooted=false , sister clades are considered as bipartitions.  Output:   a \"node\" data frame (see below)  an \"edge\" data frame (see below)  a \"clade\" data frame to describe the make up of all clades found as hybrids or sisters, starting with a column  taxa  that lists all taxa. All other columns correspond to a given clade and contain true/false values.  true  means that a given taxon belongs in a given clade. For a clade named  H1 , for instance, and if the data frame was named  cla , the list of taxa in this clade can be obtained with  cla[:taxa][cla[:H1]] .  an array of gamma values, with one row for each bootstrap network and two columns (major/minor) for each hybrid edge in the reference network. If this hybrid edge was found in the bootstrap network (i.e. same hybrid and sister clades, after removal of all other hybrid nodes), its bootstrap gamma value is recorded here. Otherwise, the gamma entry is 0.0.  a vector with the number of each hybrid edge in the reference network, in the same order as for the columns in the array of gamma values above.   The \"node\" data frame has one row per clade and 9 columns giving:   clade : the clade's name, like the taxon name (if a hybrid is a single taxon) or the hybrid tag (like 'H1') in the reference network  node : the node number in the reference network. missing if the clade is not in this network.  hybridnode : typically the same node number as above, except for hybrid clades in the reference network. For those, the hybrid node number is listed here.  edge : number of the parent edge, parent to the node in column 2, if found in the ref network. missing otherwise.  BS_hybrid : percentage of bootstrap networks in which the clade is found to be a hybrid clade.  BS_sister : percentage of bootstrap networks in which the clade is found to be sister to some hybrid clade (sum of the next 2 columns)  BS_major_sister : percentage of bootstrap networks in which the clade is found to be the major sister to some hybrid clade  BS_minor_sister : same as previous, but minor  BS_hybrid_samesisters : percentage of bootstrap networks in which the clade is found to be a hybrid and with the same set of sister clades as in the reference network. Applies to hybrid clades found in the reference network only, missing for all other clades.   The \"edge\" data frame has one row for each pair of clades, and 8 columns:   edge : hybrid edge number, if the edge appears in the reference network. missing otherwise.  hybrid_clade : name of the clade found to be a hybrid, descendent of 'edge'  hybrid : node number of that clade, if it appears in the reference network. missing otherwise.  sister_clade : name of the clade that is sister to 'edge', i.e. be sister to a hybrid  sister : node number of that clade, if in the ref network.  BS_hybrid_edge : percentage of bootstrap networks in which 'edge' is found to be a hybrid  edge, i.e. when the clade in the 'hybrid' column is found to be a hybrid and the clade in  the 'sister' column is one of its sisters.  BS_major : percentage of bootstrap networks in which 'edge' is found to be a major hybrid  edge, i.e. when 'hybrid' is found to be a hybrid clade and 'sister' is found to be its  major sister.  BS_minor : same as previous, but minor   source", 
            "title": "network Comparisons"
        }, 
        {
            "location": "/lib/public/#continuous-trait-evolution", 
            "text": "#  PhyloNetworks.simulate     Function .  simulate(net::HybridNetwork, params::ParamsProcess, checkPreorder=true::Bool)  Simualte some traits on  net  using the parameters  params . For now, only parameters of type  ParamsBM  (Brownian Motion) are accepted.  Assumes that the network is in the pre-order. If  checkPreorder=true  (default), then it runs function  preoder  on the network beforehand.  Returns an object of type  TraitSimulation .  Examples  julia  phy = readTopology(joinpath(Pkg.dir( PhyloNetworks ),  examples ,  carnivores_tree.txt ));\n\njulia  par = ParamsBM(1, 0.1) # BM with expectation 1 and variance 0.1.\nPhyloNetworks.ParamsBM:\nParameters of a BM with fixed root:\nmu: 1\nSigma2: 0.1\n\n\njulia  srand(17920921); # Seed for reproducibility\n\njulia  sim = simulate(phy, par) # Simulate on the tree.\nPhyloNetworks.TraitSimulation:\nTrait simulation results on a network with 16 tips, using a BM model, with parameters:\nmu: 1\nSigma2: 0.1\n\n\njulia  traits = sim[:Tips] # Extract simulated values at the tips.\n16-element Array{Float64,1}:\n  2.17618\n  1.03308\n  3.04898\n  3.03796\n  2.1897\n  4.03159\n  4.64773\n -0.877285\n  4.62512\n -0.511167\n  1.35604\n -0.103112\n -2.08847\n  2.63991\n  2.80512\n  3.19109  source  #  PhyloNetworks.shiftHybrid     Function .  shiftHybrid ( value :: Vector { T }   where   T : Real ,   net :: HybridNetwork ;   checkPreorder = true :: Bool )   Construct an object  ShiftNet  with shifts on all the edges below hybrid nodes, with values provided. The vector of values must have the same length as the number of hybrids in the network.  source  #  PhyloNetworks.getShiftEdgeNumber     Function .  getShiftEdgeNumber(shift::ShiftNet)  Get the edge numbers where the shifts are located, for an object  ShiftNet .  source  #  PhyloNetworks.getShiftValue     Function .  getShiftValue(shift::ShiftNet)  Get the values of the shifts, for an object  ShiftNet .  source  #  PhyloNetworks.phyloNetworklm     Function .  phyloNetworklm(f, fr, net, model= BM ,\n    fTolRel=1e^-10, fTolAbs=1e^-10, xTolRel=1e^-10, xTolAbs=1e^-10,\n    startingValue=0.5)`  Phylogenetic regression, using the correlation structure induced by the network.  Returns an object of class  PhyloNetworkLinearModel . See documentation for this type and example to see all the functions that can be applied to it.  Arguments   f::Formula : formula to use for the regression (see the  DataFrame  package)  fr::AbstractDataFrame : DataFrame containing the data and regressors at the tips. It should have an extra column labelled \"tipNames\", that gives the names of the taxa for each observation.  net::HybridNetwork : phylogenetic network to use. Should have labelled tips.  model::AbstractString=\"BM\" : the model to use, \"BM\" (default) or \"lambda\" (for Pagel's lambda).  no_names::Bool=false : if  true , force the function to ignore the tips names. The data is then assumed to be in the same order as the tips of the network. Default to false, setting it to true is dangerous, and strongly discouraged.   If  model=\"lambda\" , there are a some parameters to control the optimization in lambda:   fTolRel::AbstractFloat=1e-10 : relative tolerance on the likelihood value for the optimization in lambda.  fTolAbs::AbstractFloat=1e-10 : absolute tolerance on the likelihood value for the optimization in lambda.  xTolRel::AbstractFloat=1e-10 : relative tolerance on the parameter value for the optimization in lambda.  xTolAbs::AbstractFloat=1e-10 : absolute tolerance on the parameter value for the optimization in lambda.  startingValue::Real=0.5 : the starting value for the parameter in the optimization in lambda.   See also  Type  PhyloNetworkLinearModel , Function  ancestralStateReconstruction  Examples  julia  phy = readTopology(joinpath(Pkg.dir( PhyloNetworks ),  examples ,  caudata_tree.txt ));\n\njulia  using CSV # to read data file, next\n\njulia  dat = CSV.read(joinpath(Pkg.dir( PhyloNetworks ),  examples ,  caudata_trait.txt ));\n\njulia  using StatsModels # for stat model formulas\n\njulia  fitBM = phyloNetworklm(@formula(trait ~ 1), dat, phy);\n\njulia  fitBM # Shows a summary\nStatsModels.DataFrameRegressionModel{PhyloNetworks.PhyloNetworkLinearModel,Array{Float64,2}}\n\nFormula: trait ~ +1\n\nModel: BM\n\nParameter(s) Estimates:\nSigma2: 0.00294521\n\nCoefficients:\n             Estimate Std.Error t value Pr( |t|)\n(Intercept)     4.679  0.330627 14.1519    1e-31\n\nLog Likelihood: -78.9611507833\nAIC: 161.9223015666\n\njulia  round(sigma2_estim(fitBM), 6) # rounding for jldoctest convenience\n0.002945\n\njulia  round(mu_estim(fitBM), 4)\n4.679\n\njulia  using StatsBase # for aic() stderror() loglikelihood() etc.\n\njulia  round(loglikelihood(fitBM), 10)\n-78.9611507833\n\njulia  round(aic(fitBM), 10)\n161.9223015666\n\njulia  round(aicc(fitBM), 10)\n161.9841572367\n\njulia  round(bic(fitBM), 10)\n168.4887090241\n\njulia  coef(fitBM)\n1-element Array{Float64,1}:\n 4.679\n\njulia  confint(fitBM)\n1\u00d72 Array{Float64,2}:\n 4.02696  5.33104\n\njulia  abs(round(r2(fitBM), 10)) # absolute value for jldoctest convenience\n0.0\n\njulia  abs(round(adjr2(fitBM), 10))\n0.0\n\njulia  vcov(fitBM)\n1\u00d71 Array{Float64,2}:\n 0.109314\n\njulia  residuals(fitBM)\n197-element Array{Float64,1}:\n -0.237648\n -0.357937\n -0.159387\n -0.691868\n -0.323977\n -0.270452\n -0.673486\n -0.584654\n -0.279882\n -0.302175\n  \u22ee\n -0.777026\n -0.385121\n -0.443444\n -0.327303\n -0.525953\n -0.673486\n -0.603158\n -0.211712\n -0.439833\n\njulia  model_response(fitBM)\n197-element Array{Float64,1}:\n 4.44135\n 4.32106\n 4.51961\n 3.98713\n 4.35502\n 4.40855\n 4.00551\n 4.09434\n 4.39912\n 4.37682\n \u22ee\n 3.90197\n 4.29388\n 4.23555\n 4.3517\n 4.15305\n 4.00551\n 4.07584\n 4.46729\n 4.23917\n\njulia  predict(fitBM)\n197-element Array{Float64,1}:\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n \u22ee\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679  source  #  PhyloNetworks.sigma2_estim     Function .  sigma2_estim(m::PhyloNetworkLinearModel)  Estimated variance for a fitted object.  source  #  PhyloNetworks.mu_estim     Function .  mu_estim(m::PhyloNetworkLinearModel)  Estimated root value for a fitted object.  source  #  PhyloNetworks.lambda_estim     Function .  lambda_estim(m::PhyloNetworkLinearModel)  Estimated lambda parameter for a fitted object.  source  #  PhyloNetworks.ancestralStateReconstruction     Function .  ancestralStateReconstruction(net::HybridNetwork, Y::Vector, params::ParamsBM)  Compute the conditional expectations and variances of the ancestral (un-observed) traits values at the internal nodes of the phylogenetic network ( net ), given the values of the traits at the tips of the network ( Y ) and some known parameters of the process used for trait evolution ( params , only BM with fixed root works for now).  This function assumes that the parameters of the process are known. For a more general function, see  ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix]) .  source  ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])  Function to find the ancestral traits reconstruction on a network, given an object fitted by function  phyloNetworklm . By default, the function assumes that the regressor is just an intercept. If the value of the regressor for all the ancestral states is known, it can be entered in X_n, a matrix with as many columns as the number of predictors used, and as many lines as the number of unknown nodes or tips.  Returns an object of type  ReconstructedStates . See documentation for this type and examples for functions that can be applied to it.  Examples  julia  using CSV  # to read data file \n\njulia  phy  =  readTopology ( joinpath ( Pkg.dir ( PhyloNetworks ),   examples ,   carnivores_tree.txt )); \n\njulia  dat  =  CSV.read ( joinpath ( Pkg.dir ( PhyloNetworks ),   examples ,   carnivores_trait.txt )); \n\njulia  using StatsModels  # for statistical model formulas \n\njulia  fitBM  =  phyloNetworklm ( @ formula ( trait  ~   1 ),  dat ,  phy ); \n\njulia  ancStates  =  ancestralStateReconstruction ( fitBM )   # Should produce a warning, as variance is unknown. \nWARNING :  These prediction intervals show uncertainty  in  ancestral values , \nassuming that the estimated variance rate of evolution is correct.\nAdditional uncertainty  in  the estimation of this variance rate is\nignored ,  so prediction intervals should be larger.\nPhyloNetworks.ReconstructedStates : \n     Node index     Pred.       Min. Max.  ( 95 % ) \n            -5.0     1.32139    -0.288423       2.9312 \n            -8.0     1.03258    -0.539072      2.60423 \n            -7.0     1.41575   -0.0934395      2.92495 \n            -6.0     1.39417   -0.0643135      2.85265 \n            -4.0     1.39961   -0.0603343      2.85955 \n            -3.0     1.51341    -0.179626      3.20644 \n           -13.0      5.3192      3.96695      6.67145 \n           -12.0     4.51176      2.94268      6.08085 \n           -16.0     1.50947    0.0290151      2.98992 \n           -15.0     1.67425     0.241696      3.10679 \n           -14.0     1.80309     0.355568       3.2506 \n           -11.0      2.7351      1.21896      4.25123 \n           -10.0     2.73217      1.16545      4.29889 \n            -9.0     2.41132     0.639075      4.18357 \n            -2.0     2.04138   -0.0340955      4.11686 \n            14.0     1.64289      1.64289      1.64289 \n             8.0     1.67724      1.67724      1.67724 \n             5.0    0.331568     0.331568     0.331568 \n             2.0     2.27395      2.27395      2.27395 \n             4.0    0.275237     0.275237     0.275237 \n             6.0     3.39094      3.39094      3.39094 \n            13.0    0.355799     0.355799     0.355799 \n            15.0    0.542565     0.542565     0.542565 \n             7.0    0.773436     0.773436     0.773436 \n            10.0     6.94985      6.94985      6.94985 \n            11.0     4.78323      4.78323      4.78323 \n            12.0     5.33016      5.33016      5.33016 \n             1.0   -0.122604    -0.122604    -0.122604 \n            16.0     0.73989      0.73989      0.73989 \n             9.0     4.84236      4.84236      4.84236 \n             3.0      1.0695       1.0695       1.0695 \n\n\njulia  expectations ( ancStates )  31 \u00d7 2  DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 condExpectation \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  1    \u2502  -5          \u2502  1.32139          \u2502\n\u2502  2    \u2502  -8          \u2502  1.03258          \u2502\n\u2502  3    \u2502  -7          \u2502  1.41575          \u2502\n\u2502  4    \u2502  -6          \u2502  1.39417          \u2502\n\u2502  5    \u2502  -4          \u2502  1.39961          \u2502\n\u2502  6    \u2502  -3          \u2502  1.51341          \u2502\n\u2502  7    \u2502  -13         \u2502  5.3192           \u2502\n\u2502  8    \u2502  -12         \u2502  4.51176          \u2502\n\u22ee\n\u2502  23   \u2502  15          \u2502  0.542565         \u2502\n\u2502  24   \u2502  7           \u2502  0.773436         \u2502\n\u2502  25   \u2502  10          \u2502  6.94985          \u2502\n\u2502  26   \u2502  11          \u2502  4.78323          \u2502\n\u2502  27   \u2502  12          \u2502  5.33016          \u2502\n\u2502  28   \u2502  1           \u2502  -0.122604        \u2502\n\u2502  29   \u2502  16          \u2502  0.73989          \u2502\n\u2502  30   \u2502  9           \u2502  4.84236          \u2502\n\u2502  31   \u2502  3           \u2502  1.0695           \u2502\n\njulia  predint ( ancStates )  31 \u00d7 2  Array { Float64 , 2 } : \n  -0.288423      2.9312 \n  -0.539072      2.60423 \n  -0.0934395     2.92495 \n  -0.0643135     2.85265 \n  -0.0603343     2.85955 \n  -0.179626      3.20644 \n   3.96695       6.67145 \n   2.94268       6.08085 \n   0.0290151     2.98992 \n   0.241696      3.10679 \n  \u22ee\n   0.542565      0.542565 \n   0.773436      0.773436 \n   6.94985       6.94985 \n   4.78323       4.78323 \n   5.33016       5.33016 \n  -0.122604     -0.122604 \n   0.73989       0.73989 \n   4.84236       4.84236 \n   1.0695        1.0695 \n\njulia  expectationsPlot ( ancStates )   # format the ancestral states  31 \u00d7 2  DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  1    \u2502  -5          \u2502  1.32     \u2502\n\u2502  2    \u2502  -8          \u2502  1.03     \u2502\n\u2502  3    \u2502  -7          \u2502  1.42     \u2502\n\u2502  4    \u2502  -6          \u2502  1.39     \u2502\n\u2502  5    \u2502  -4          \u2502  1.4      \u2502\n\u2502  6    \u2502  -3          \u2502  1.51     \u2502\n\u2502  7    \u2502  -13         \u2502  5.32     \u2502\n\u2502  8    \u2502  -12         \u2502  4.51     \u2502\n\u22ee\n\u2502  23   \u2502  15          \u2502  0.54     \u2502\n\u2502  24   \u2502  7           \u2502  0.77     \u2502\n\u2502  25   \u2502  10          \u2502  6.95     \u2502\n\u2502  26   \u2502  11          \u2502  4.78     \u2502\n\u2502  27   \u2502  12          \u2502  5.33     \u2502\n\u2502  28   \u2502  1           \u2502  -0.12    \u2502\n\u2502  29   \u2502  16          \u2502  0.74     \u2502\n\u2502  30   \u2502  9           \u2502  4.84     \u2502\n\u2502  31   \u2502  3           \u2502  1.07     \u2502\n\njulia  using PhyloPlots  # next: plot ancestral states on the tree \n\njulia  plot ( phy ,   : RCall ,  nodeLabel  =  expectationsPlot ( ancStates )); \n\njulia  predintPlot ( ancStates )  31 \u00d7 2  DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  1    \u2502  -5          \u2502  [ -0.29 ,   2.93 ]  \u2502\n\u2502  2    \u2502  -8          \u2502  [ -0.54 ,   2.6 ]   \u2502\n\u2502  3    \u2502  -7          \u2502  [ -0.09 ,   2.92 ]  \u2502\n\u2502  4    \u2502  -6          \u2502  [ -0.06 ,   2.85 ]  \u2502\n\u2502  5    \u2502  -4          \u2502  [ -0.06 ,   2.86 ]  \u2502\n\u2502  6    \u2502  -3          \u2502  [ -0.18 ,   3.21 ]  \u2502\n\u2502  7    \u2502  -13         \u2502  [ 3.97 ,   6.67 ]   \u2502\n\u2502  8    \u2502  -12         \u2502  [ 2.94 ,   6.08 ]   \u2502\n\u22ee\n\u2502  23   \u2502  15          \u2502  0.54           \u2502\n\u2502  24   \u2502  7           \u2502  0.77           \u2502\n\u2502  25   \u2502  10          \u2502  6.95           \u2502\n\u2502  26   \u2502  11          \u2502  4.78           \u2502\n\u2502  27   \u2502  12          \u2502  5.33           \u2502\n\u2502  28   \u2502  1           \u2502  -0.12          \u2502\n\u2502  29   \u2502  16          \u2502  0.74           \u2502\n\u2502  30   \u2502  9           \u2502  4.84           \u2502\n\u2502  31   \u2502  3           \u2502  1.07           \u2502\n\njulia  plot ( phy ,   : RCall ,  nodeLabel  =  predintPlot ( ancStates )); \n\njulia  using Missings ;   # preparation to mask 2 values next, for taxa in rows 2 and 5 \n\njulia  dat [ : trait ]   =  allowmissing ( dat [ : trait ]); \n\njulia  dat [[ 2 ,   5 ],   : trait ]   =   missing ;   # missing values allowed to fit model \n\njulia  fitBM  =  phyloNetworklm ( @ formula ( trait  ~   1 ),  dat ,  phy ); \n\njulia  ancStates  =  ancestralStateReconstruction ( fitBM ); \nWARNING :  These prediction intervals show uncertainty  in  ancestral values , \nassuming that the estimated variance rate of evolution is correct.\nAdditional uncertainty  in  the estimation of this variance rate is\nignored ,  so prediction intervals should be larger.\n\njulia  expectations ( ancStates )  31 \u00d7 2  DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 condExpectation \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  1    \u2502  -5          \u2502  1.42724          \u2502\n\u2502  2    \u2502  -8          \u2502  1.35185          \u2502\n\u2502  3    \u2502  -7          \u2502  1.61993          \u2502\n\u2502  4    \u2502  -6          \u2502  1.54198          \u2502\n\u2502  5    \u2502  -4          \u2502  1.53916          \u2502\n\u2502  6    \u2502  -3          \u2502  1.64984          \u2502\n\u2502  7    \u2502  -13         \u2502  5.33508          \u2502\n\u2502  8    \u2502  -12         \u2502  4.55109          \u2502\n\u22ee\n\u2502  23   \u2502  15          \u2502  0.542565         \u2502\n\u2502  24   \u2502  7           \u2502  0.773436         \u2502\n\u2502  25   \u2502  10          \u2502  6.94985          \u2502\n\u2502  26   \u2502  11          \u2502  4.78323          \u2502\n\u2502  27   \u2502  12          \u2502  5.33016          \u2502\n\u2502  28   \u2502  1           \u2502  -0.122604        \u2502\n\u2502  29   \u2502  16          \u2502  0.73989          \u2502\n\u2502  30   \u2502  9           \u2502  4.84236          \u2502\n\u2502  31   \u2502  3           \u2502  1.0695           \u2502\n\njulia  predint ( ancStates )  31 \u00d7 2  Array { Float64 , 2 } : \n  -0.31245       3.16694 \n  -0.625798      3.3295 \n  -0.110165      3.35002 \n  -0.0710391     3.15501 \n  -0.0675924     3.14591 \n  -0.197236      3.49692 \n   3.89644       6.77373 \n   2.8741        6.22808 \n  -0.0358627     3.12834 \n   0.182594      3.2534 \n  \u22ee\n   0.542565      0.542565 \n   0.773436      0.773436 \n   6.94985       6.94985 \n   4.78323       4.78323 \n   5.33016       5.33016 \n  -0.122604     -0.122604 \n   0.73989       0.73989 \n   4.84236       4.84236 \n   1.0695        1.0695 \n\njulia  expectationsPlot ( ancStates )   # format node  -  ancestral state  31 \u00d7 2  DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  1    \u2502  -5          \u2502  1.43     \u2502\n\u2502  2    \u2502  -8          \u2502  1.35     \u2502\n\u2502  3    \u2502  -7          \u2502  1.62     \u2502\n\u2502  4    \u2502  -6          \u2502  1.54     \u2502\n\u2502  5    \u2502  -4          \u2502  1.54     \u2502\n\u2502  6    \u2502  -3          \u2502  1.65     \u2502\n\u2502  7    \u2502  -13         \u2502  5.34     \u2502\n\u2502  8    \u2502  -12         \u2502  4.55     \u2502\n\u22ee\n\u2502  23   \u2502  15          \u2502  0.54     \u2502\n\u2502  24   \u2502  7           \u2502  0.77     \u2502\n\u2502  25   \u2502  10          \u2502  6.95     \u2502\n\u2502  26   \u2502  11          \u2502  4.78     \u2502\n\u2502  27   \u2502  12          \u2502  5.33     \u2502\n\u2502  28   \u2502  1           \u2502  -0.12    \u2502\n\u2502  29   \u2502  16          \u2502  0.74     \u2502\n\u2502  30   \u2502  9           \u2502  4.84     \u2502\n\u2502  31   \u2502  3           \u2502  1.07     \u2502\n\njulia  plot ( phy ,   : RCall ,  nodeLabel  =  expectationsPlot ( ancStates )); \n\njulia  predintPlot ( ancStates )   # prediction intervals, in data frame, useful to plot  31 \u00d7 2  DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  1    \u2502  -5          \u2502  [ -0.31 ,   3.17 ]  \u2502\n\u2502  2    \u2502  -8          \u2502  [ -0.63 ,   3.33 ]  \u2502\n\u2502  3    \u2502  -7          \u2502  [ -0.11 ,   3.35 ]  \u2502\n\u2502  4    \u2502  -6          \u2502  [ -0.07 ,   3.16 ]  \u2502\n\u2502  5    \u2502  -4          \u2502  [ -0.07 ,   3.15 ]  \u2502\n\u2502  6    \u2502  -3          \u2502  [ -0.2 ,   3.5 ]    \u2502\n\u2502  7    \u2502  -13         \u2502  [ 3.9 ,   6.77 ]    \u2502\n\u2502  8    \u2502  -12         \u2502  [ 2.87 ,   6.23 ]   \u2502\n\u22ee\n\u2502  23   \u2502  15          \u2502  0.54           \u2502\n\u2502  24   \u2502  7           \u2502  0.77           \u2502\n\u2502  25   \u2502  10          \u2502  6.95           \u2502\n\u2502  26   \u2502  11          \u2502  4.78           \u2502\n\u2502  27   \u2502  12          \u2502  5.33           \u2502\n\u2502  28   \u2502  1           \u2502  -0.12          \u2502\n\u2502  29   \u2502  16          \u2502  0.74           \u2502\n\u2502  30   \u2502  9           \u2502  4.84           \u2502\n\u2502  31   \u2502  3           \u2502  1.07           \u2502\n\njulia  plot ( phy ,   : RCall ,  nodeLabel  =  predintPlot ( ancStates ));   source  ancestralStateReconstruction ( fr :: AbstractDataFrame ,   net :: HybridNetwork ;   kwargs ...)   Function to find the ancestral traits reconstruction on a network, given some data at the tips. Uses function  phyloNetworklm  to perform a phylogenetic regression of the data against an intercept (amounts to fitting an evolutionary model on the network, BM being the only option available for now).  See documentation on  phyloNetworklm  and  ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])  for further details.  Returns an object of type  ReconstructedStates .  source  ancestralStateReconstruction(obj::SSM, trait::Integer)\nancestralStateReconstruction(obj::SSM)  Estimate the marginal probability of ancestral states for discrete character number  trait , or for the active trait if  trait  is unspecified:  obj.activetrait . The parameters of the  StatisticalSubstitutionModel  object  obj  must first be fitted using  fitDiscrete , and ancestral state reconstruction is conditional on the estimated parameters. If these parameters were estimated using all traits, they are used as is to do ancestral state reconstruction of the particular  trait  of interest.  output : data frame with a first column for the node numbers, a second column for the node labels, and a column for each possible state: the entries in these columns give the marginal probability that a given node has a given state.  warnings   node numbers and node labels refer to those in  obj.net , which might have a different internal representation of nodes than the original network used to build  obj .  obj  is modified: its likelihood fields (forward, directional   backward) are updated to make sure that they correspond to the current parameter values in  obj.model , and to the  trait  of interest.   See also  discrete_backwardlikelihood_tree!  to update  obj.backwardlik .  examples  julia   net   =   readTopology ( (((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0); );  julia   m1   =   BinaryTraitSubstitutionModel ( [ 0.1 ,   0.1 ] ,   [ lo ,   hi ] );  julia   dat   =   DataFrame ( species = [ C , A , B , D ] ,   trait = [ hi , lo , lo , hi ] );  julia   fit1   =   fitDiscrete ( net ,   m1 ,   dat );  julia   asr   =   ancestralStateReconstruction ( fit1 )  9 \u00d7 4   DataFrames . DataFrame  \u2502   Row   \u2502   nodenumber   \u2502   nodelabel   \u2502   lo         \u2502   hi         \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502   1     \u2502   1            \u2502   A           \u2502   1 . 0        \u2502   0 . 0        \u2502  \u2502   2     \u2502   2            \u2502   B           \u2502   1 . 0        \u2502   0 . 0        \u2502  \u2502   3     \u2502   3            \u2502   C           \u2502   0 . 0        \u2502   1 . 0        \u2502  \u2502   4     \u2502   4            \u2502   D           \u2502   0 . 0        \u2502   1 . 0        \u2502  \u2502   5     \u2502   5            \u2502   5           \u2502   0 . 286019   \u2502   0 . 713981   \u2502  \u2502   6     \u2502   6            \u2502   6           \u2502   0 . 319454   \u2502   0 . 680546   \u2502  \u2502   7     \u2502   7            \u2502   7           \u2502   0 . 168549   \u2502   0 . 831451   \u2502  \u2502   8     \u2502   8            \u2502   8           \u2502   0 . 76736    \u2502   0 . 23264    \u2502  \u2502   9     \u2502   9            \u2502   # H1         \u2502   0 . 782777   \u2502   0 . 217223   \u2502  julia   exp .( fit1 . postltw )   #   marginal   ( posterior )   probability   that   the   trait   evolved   on   each   displayed   tree  2-element   Array { Float64,1 } : \n  0 . 919831  \n  0 . 0801689  julia   using   PhyloPlots  julia   plot ( fit1 . net ,   : R ,   nodeLabel   =   asr [ [ : nodenumber ,   : lo ] ],   tipOffset = 0 . 2 );   #   pp   for   lo   state   source  #  PhyloNetworks.expectations     Function .  expectations(obj::ReconstructedStates)  Estimated reconstructed states at the nodes and tips.  source  #  PhyloNetworks.predint     Function .  predint ( obj :: ReconstructedStates ;   level = 0 . 95 :: Real )   Prediction intervals with level  level  for internal nodes and missing tips.  source  #  PhyloNetworks.expectationsPlot     Function .  expectationsPlot(obj::ReconstructedStates)  Compute and format the expected reconstructed states for the plotting function. The resulting dataframe can be readily used as a  nodeLabel  argument to  plot  from package  PhyloPlots . Keyword argument  markMissing  is a string that is appended to predicted tip values, so that they can be distinguished from the actual datapoints. Default to \"*\". Set to \"\" to remove any visual cue.  source  #  PhyloNetworks.predintPlot     Function .  predintPlot ( obj :: ReconstructedStates ;   level = 0 . 95 :: Real ,   withExp = false :: Bool )   Compute and format the prediction intervals for the plotting function. The resulting dataframe can be readily used as a  nodeLabel  argument to  plot  from package  PhyloPlots . Keyworks argument  level  control the confidence level of the prediction interval. If  withExp  is set to true, then the best predicted value is also shown along with the interval.  source  #  PhyloNetworks.descendenceMatrix     Function .  descendenceMatrix ( net :: HybridNetwork ;   checkPreorder = true :: Bool )   This function computes the inciednce matrix between all the nodes of a network. It assumes that the network is in the pre-order. If checkPreorder is true (default), then it runs function  preoder  on the network beforehand.  Returns an object of type  MatrixTopologicalOrder .  source  #  PhyloNetworks.regressorShift     Function .  regressorShift ( node :: Vector { Node } ,   net :: HybridNetwork ;   checkPreorder = true :: Bool )   regressorShift(edge::Vector{Edge}, net::HybridNetwork; checkPreorder=true::Bool)  Compute the regressor vectors associated with shifts on edges that are above nodes  node , or on edges  edge , on a network  net . It uses function  descendenceMatrix , so  net  might be modified to sort it in a pre-order. Return a  DataFrame  with as many rows as there are tips in net, and a column for each shift, each labelled according to the pattern shift_{number_of_edge}. It has an aditional column labelled  tipNames  to allow easy fitting afterward (see example).  Examples  julia   net   =   readTopology ( (A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5); );  julia   preorder !( net )  julia   using   PhyloPlots  julia   plot ( net ,   : RCall ,   showNodeNumber = true );   #   to   locate   nodes  julia   nodes_shifts   =   indexin ( [ 1 , - 5 ] ,   [ n.number   for   n   in   net.node ] )   #   Put   a   shift   on   edges   ending   at   nodes   1   and   -5  2-element   Array { Int64,1 } : \n  1 \n  7  julia   params   =   ParamsBM ( 10 ,   0 . 1 ,   ShiftNet ( net . node [ nodes_shifts ] ,   [ 3.0 ,   - 3.0 ] ,    net ))  PhyloNetworks . ParamsBM :  Parameters   of   a   BM   with   fixed   root :  mu :   10  Sigma2 :   0 . 1  There   are   2   shifts   on   the   network : \n      Edge   Number   Shift   Value \n              8 . 0          -3 . 0 \n              1 . 0           3 . 0  julia   srand ( 2468 );   #   sets   the   seed   for   reproducibility  julia   sim   =   simulate ( net ,   params );   #   simulate   a   dataset   with   shifts  julia   using   DataFrames   #   to   handle   data   frames  julia   dat   =   DataFrame ( trait   =   sim [ : Tips ] ,   tipNames   =   sim . M . tipNames )  4 \u00d7 2   DataFrames . DataFrame  \u2502   Row   \u2502   trait     \u2502   tipNames   \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502   1     \u2502   13 . 392    \u2502   A          \u2502  \u2502   2     \u2502   9 . 55741   \u2502   B          \u2502  \u2502   3     \u2502   7 . 17704   \u2502   C          \u2502  \u2502   4     \u2502   7 . 88906   \u2502   D          \u2502  julia   dfr_shift   =   regressorShift ( net . node [ nodes_shifts ] ,   net )   #   the   reressors   matching   the   shifts .  4 \u00d7 3   DataFrames . DataFrame  \u2502   Row   \u2502   shift_1   \u2502   shift_8   \u2502   tipNames   \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502   1     \u2502   1 . 0       \u2502   0 . 0       \u2502   A          \u2502  \u2502   2     \u2502   0 . 0       \u2502   0 . 0       \u2502   B          \u2502  \u2502   3     \u2502   0 . 0       \u2502   1 . 0       \u2502   C          \u2502  \u2502   4     \u2502   0 . 0       \u2502   0 . 6       \u2502   D          \u2502  julia   dfr   =   join ( dat ,   dfr_shift ,   on = : tipNames );   #   join   data   and   regressors   in   a   single   dataframe  julia   using   StatsModels   #   for   statistical   model   formulas  julia   fitBM   =   phyloNetworklm ( @ formula ( trait   ~   shift_1   +   shift_8 ),   dfr ,   net )   #   actual   fit  StatsModels . DataFrameRegressionModel { PhyloNetworks . PhyloNetworkLinearModel , Array { Float64,2 }}  Formula :   trait   ~   1   +   shift_1   +   shift_8  Model :   BM  Parameter ( s )   Estimates :  Sigma2 :   0 . 0112618  Coefficients : \n              Estimate   Std . Error    t   value   Pr ( | t |)  ( Intercept )     9 . 48238    0 . 327089    28 . 9902     0 . 0220  shift_1          3 . 9096     0 . 46862    8 . 34279     0 . 0759  shift_8         -2 . 4179    0 . 422825   -5 . 71843     0 . 1102  Log   Likelihood :   1 . 8937302027  AIC :   4 . 2125395947   See also  phyloNetworklm ,  descendenceMatrix ,  regressorHybrid .  source  #  PhyloNetworks.regressorHybrid     Function .  regressorHybrid ( net :: HybridNetwork ;   checkPreorder = true :: Bool )   Compute the regressor vectors associated with shifts on edges that imediatly below all hybrid nodes of  net . It uses function  descendenceMatrix  through a call to  regressorShift , so  net  might be modified to sort it in a pre-order. Return a  DataFrame  with as many rows as there are tips in net, and a column for each hybrid, each labelled according to the pattern shift_{number_of_edge}. It has an aditional column labelled  tipNames  to allow easy fitting afterward (see example).  This function can be used to test for heterosis.  Examples  julia   using   DataFrames   #   Needed   to   handle   data   frames .  julia   net   =   readTopology ( (A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5); );  julia   preorder !( net )  julia   using   PhyloPlots  julia   plot ( net ,   : RCall ,   showNodeNumber = true );   #   to   locate   nodes :   node   5   is   child   of   hybrid   node  julia   nodes_hybrids   =   indexin ( [ 5 ] ,   [ n.number   for   n   in   net.node ] )   #   Put   a   shift   on   edges   below   hybrids  1-element   Array { Int64,1 } : \n  5  julia   params   =   ParamsBM ( 10 ,   0 . 1 ,   ShiftNet ( net . node [ nodes_hybrids ] ,   [ 3.0 ] ,    net ))  PhyloNetworks . ParamsBM :  Parameters   of   a   BM   with   fixed   root :  mu :   10  Sigma2 :   0 . 1  There   are   1   shifts   on   the   network : \n      Edge   Number   Shift   Value \n              6 . 0           3 . 0  julia   srand ( 2468 );   #   sets   the   seed   for   reproducibility  julia   sim   =   simulate ( net ,   params );   #   simulate   a   dataset   with   shifts  julia   dat   =   DataFrame ( trait   =   sim [ : Tips ] ,   tipNames   =   sim . M . tipNames )  4 \u00d7 2   DataFrames . DataFrame  \u2502   Row   \u2502   trait     \u2502   tipNames   \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502   1     \u2502   10 . 392    \u2502   A          \u2502  \u2502   2     \u2502   9 . 55741   \u2502   B          \u2502  \u2502   3     \u2502   10 . 177    \u2502   C          \u2502  \u2502   4     \u2502   12 . 6891   \u2502   D          \u2502  julia   dfr_hybrid   =   regressorHybrid ( net )   #   the   reressors   matching   the   hybrids .  4 \u00d7 3   DataFrames . DataFrame  \u2502   Row   \u2502   shift_6   \u2502   tipNames   \u2502   sum   \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524  \u2502   1     \u2502   0 . 0       \u2502   A          \u2502   0 . 0   \u2502  \u2502   2     \u2502   0 . 0       \u2502   B          \u2502   0 . 0   \u2502  \u2502   3     \u2502   0 . 0       \u2502   C          \u2502   0 . 0   \u2502  \u2502   4     \u2502   1 . 0       \u2502   D          \u2502   1 . 0   \u2502  julia   dfr   =   join ( dat ,   dfr_hybrid ,   on = : tipNames );   #   join   data   and   regressors   in   a   single   dataframe  julia   using   StatsModels  julia   fitBM   =   phyloNetworklm ( @ formula ( trait   ~   shift_6 ),   dfr ,   net )   #   actual   fit  StatsModels . DataFrameRegressionModel { PhyloNetworks . PhyloNetworkLinearModel , Array { Float64,2 }}  Formula :   trait   ~   1   +   shift_6  Model :   BM  Parameter ( s )   Estimates :  Sigma2 :   0 . 041206  Coefficients : \n              Estimate   Std . Error   t   value   Pr ( | t |)  ( Intercept )      10 . 064    0 . 277959   36 . 2068     0 . 0008  shift_6         2 . 72526    0 . 315456   8 . 63912     0 . 0131  Log   Likelihood :   -0 . 7006021946  AIC :   7 . 4012043891   See also  phyloNetworklm ,  descendenceMatrix ,  regressorShift .  source  #  PhyloNetworks.sharedPathMatrix     Function .  sharedPathMatrix ( net :: HybridNetwork ;   checkPreorder = true :: Bool )   This function computes the shared path matrix between all the nodes of a network. It assumes that the network is in the pre-order. If checkPreorder is true (default), then it runs function  preoder  on the network beforehand.  Returns an object of type  MatrixTopologicalOrder .  source  #  PhyloNetworks.vcv     Function .  vcv ( net :: HybridNetwork ;   model = BM :: AbstractString ,  \n                         corr = false :: Bool , \n                         checkPreorder = true :: Bool )   This function computes the variance covariance matrix between the tips of the network, assuming a Brownian model of trait evolution (with unit variance). If optional argument  corr  is set to  true , then the correlation matrix is returned instead.  The function returns a  DataFrame  object, with columns named by the tips of the network.  The calculation of the covariance matrix requires a pre-ordering of nodes to be fast. If  checkPreorder  is true (default), then  preorder  is run on the network beforehand. Otherwise, the network is assumed to be already in pre-order.  This function internally calls  sharedPathMatrix , that computes the variance matrix between all the nodes of the network.  Examples  julia   tree_str   =   (((t2:0.14,t4:0.33):0.59,t3:0.96):0.14,(t5:0.70,t1:0.18):0.90); ;  julia   tree   =   readTopology ( tree_str );  julia   C   =   vcv ( tree )  5 \u00d7 5   DataFrames . DataFrame  \u2502   Row   \u2502   t2     \u2502   t4     \u2502   t3     \u2502   t5    \u2502   t1     \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502   1     \u2502   0 . 87   \u2502   0 . 73   \u2502   0 . 14   \u2502   0 . 0   \u2502   0 . 0    \u2502  \u2502   2     \u2502   0 . 73   \u2502   1 . 06   \u2502   0 . 14   \u2502   0 . 0   \u2502   0 . 0    \u2502  \u2502   3     \u2502   0 . 14   \u2502   0 . 14   \u2502   1 . 1    \u2502   0 . 0   \u2502   0 . 0    \u2502  \u2502   4     \u2502   0 . 0    \u2502   0 . 0    \u2502   0 . 0    \u2502   1 . 6   \u2502   0 . 9    \u2502  \u2502   5     \u2502   0 . 0    \u2502   0 . 0    \u2502   0 . 0    \u2502   0 . 9   \u2502   1 . 08   \u2502   The following block needs  ape  to be installed (not run):  julia   using   RCall   # Comparison with ape vcv function  julia   R ape::vcv(ape::read.tree(text =  $tree_str ))  RCall . RObject { RCall . RealSxp } \n      t2     t4     t3    t5     t1  t2   0.87   0.73   0.14   0.0   0.00  t4   0.73   1.06   0.14   0.0   0.00  t3   0.14   0.14   1.10   0.0   0.00  t5   0.00   0.00   0.00   1.6   0.90  t1   0.00   0.00   0.00   0.9   1.08   The covariance can also be calculated on a network (for the model, see for Bastide et al. 2018)  julia   net   =   readTopology ( ((t1:1.0,#H1:0.1::0.30):0.5,((t2:0.9)#H1:0.2::0.70,t3:1.1):0.4); );  julia   C   =   vcv ( net )  3 \u00d7 3   DataFrames . DataFrame  \u2502   Row   \u2502   t1     \u2502   t2      \u2502   t3     \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502   1     \u2502   1 . 5    \u2502   0 . 15    \u2502   0 . 0    \u2502  \u2502   2     \u2502   0 . 15   \u2502   1 . 248   \u2502   0 . 28   \u2502  \u2502   3     \u2502   0 . 0    \u2502   0 . 28    \u2502   1 . 5    \u2502   source", 
            "title": "continuous trait evolution"
        }, 
        {
            "location": "/lib/public/#discrete-trait-evolution", 
            "text": "#  PhyloNetworks.parsimonySoftwired     Function .  parsimonySoftwired(net, tipdata)\nparsimonySoftwired(net, species, sequences)  Calculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network.  Data can given in one of the following:   tipdata : data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named \"taxon\" or \"species\", and  trait values are to appear in column 2 or in a column named \"trait\".  tipdata : dictionary taxon =  state, for a single trait.  species : array of strings, and  sequences : array of sequences,  in the order corresponding to the order of species names.   algorithm  The dynamic programming algorithm by Fischer et al. (2015) is used. The function loops over all the displayed subtrees within a blob (biconnected component), so its complexity is of the order of  n * m * c^2 * 2^level  where  n  is the number of tips,  m  the number of traits,  c  the number of states, and  level  is the level of the network: the maximum number of hybridizations within a blob.  See  parsimonyGF  for a different algorithm, slower but extendable to other parsimony criteria.  references   Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.   source  #  PhyloNetworks.parsimonyGF     Function .  parsimonyGF(net, tip_dictionary, criterion=:softwired)\nparsimonyGF(net, species, sequenceData, criterion=:softwired)  Calculate the most parsimonious score of a network given discrete characters at the tips using a general framework (Van Iersel et al. 2018) allowing for various parsimony criteria: softwired (default), hardwired, parental etc. Only softwired is implemented at the moment.  Data can given in one of the following:   tipdata : data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named \"taxon\" or \"species\", and  trait values are to appear in column 2 or in a column named \"trait\".  tipdata : dictionary taxon =  state, for a single trait.  species : array of strings, and  sequences : array of sequences,   in the order corresponding to the order of species names.   algorithm  The complexity of the algorithm is exponential in the level of the network, that is, the maximum number of hybridizations in a single blob, or biconnected component (Fischer et al. 2015). The function loops over all the state assignments of the minor parent of each hybrid node within a blob, so its complexity is of the order of  n * m * c^2 * c^level  where  n  is the number of tips,  m  the number of traits and  c  the number of states.  See  parsimonySoftwired  for a faster algorithm, but solving the softwired criterion only.  references   Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).  Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.   Use the recursive helper function  parsimonyBottomUpGF! . Use the fields  isChild1 ,  isExtBadTriangle  to know which nodes are at the root of a blob, and  fromBadDiamondI  to know which edges are cut (below the minor parent of each hybrid).  source  #  PhyloNetworks.nStates     Function .  nStates(model)  Number of character states for a given trait evolution model.  source  Examples  julia  m1 = BinaryTraitSubstitutionModel([1.0,2.0], [ low , high ])\njulia  nStates(m1)\n2  source  #  PhyloNetworks.Q     Function .  Q(model)  Substitution rate matrix for a given substitution model: Q[i,j] is the rate of transitioning from state i to state j.  source  For a BinaryTraitSubstitutionModel, the rate matrix Q is of the form:  -\u03b1  \u03b1\n \u03b2 -\u03b2  source  #  PhyloNetworks.P     Function .  P(mod, t)  Probability transition matrix for a  TraitSubstitutionModel , of the form  P[1,1] ... P[1,k]\n   .          .\n   .          .\nP[k,1] ... P[k,k]  where P[i,j] is the probability of ending in state j after time t, given that the process started in state i.  source  P(mod, t::Array{Float64})  When applied to a general substitution model, matrix exponentiation is used. The time argument  t  can be an array.  source  #  PhyloNetworks.randomTrait     Function .  randomTrait(model, t, start)\nrandomTrait!(end, model, t, start)  Simulate traits along one edge of length t.  start  must be a vector of integers, each representing the starting value of one trait. The bang version (ending with !) uses the vector  end  to store the simulated values.  Examples  julia  m1 = BinaryTraitSubstitutionModel(1.0, 2.0)\n\njulia  srand(12345);\n\njulia  randomTrait(m1, 0.2, [1,2,1,2,2])\n 5-element Array{Int64,1}:\n 1\n 2\n 1\n 2\n 2  source  randomTrait(model, net; ntraits=1, keepInternal=true, checkPreorder=true)  Simulate evolution of discrete traits on a rooted evolutionary network based on the supplied evolutionary model. Trait sampling is uniform at the root.  optional arguments:   ntraits : number of traits to be simulated (default: 1 trait).  keepInternal : if true, export character states at all nodes, including internal nodes. if false, export character states at tips only.   output:   matrix of character states with one row per trait, one column per node; these states are  indices  in  model.label , not the trait labels themselves.  vector of node labels (for tips) or node numbers (for internal nodes) in the same order as columns in the character state matrix   examples  julia   m1   =   BinaryTraitSubstitutionModel ( 1 . 0 ,   2 . 0 ,   [ low , high ] );  julia   net   =   readTopology ( (((A:4.0,(B:1.0)#H1:1.1::0.9):0.5,(C:0.6,#H1:1.0::0.1):1.0):3.0,D:5.0); );  julia   srand ( 1234 );  julia   trait ,   lab   =   randomTrait ( m1 ,   net )  ( [ 1   2   \u2026   1   1 ] ,   String [ -2 ,   D ,   -3 ,   -6 ,   C ,   -4 ,   #H1 ,   B ,   A ] )  julia   trait  1 \u00d7 9   Array { Int64,2 } : \n  1    2    1    1    2    2    1    1    1  julia   lab  9-element   Array { String,1 } : \n  -2  \n  D   \n  -3  \n  -6  \n  C   \n  -4  \n  #H1 \n  B   \n  A     source  #  PhyloNetworks.fitDiscrete     Function .  fitDiscrete(net, model, tipdata)\nfitDiscrete(net, model, species, traits)  Calculate the maximum likelihood (ML) score of a network given one or more discrete characters at the tips. Along each edge, transitions are modelled with a continous time Markov  model , whose parameters are estimated (by maximizing the likelihood). At each hybrid node, the trait is assumed to be inherited from either of the two immediate parents according to the parents' average genetic contributions (inheritance \u03b3). The model ignores incomplete lineage sorting. The algorithm extracts all trees displayed in the network.  Data can given in one of the following:   tipdata : dictionary taxon =  state label, for a single trait.  tipdata : data frame for a single trait, in which case the taxon names are to appear in column 1 or in a column named \"taxon\" or \"species\", and trait  labels  are to appear in column 2 or in a column named \"trait\". Here, trait labels should be as they appear in  model.label .  species : vector of strings, and  traits : DataFrame of traits, with rows in the order corresponding to the order of species names. Again, trait labels should be as they appear in  model.label . All traits are assumed to follow the same model, with same parameters.   Optional arguments (default):   fixedparam  (false): should model rate parameters be fixed, or should they be optimized?  NLoptMethod  ( :LN_COBYLA , derivative-free) for the optimization algorithm. For other options, see the  NLopt .  tolerance values to control when the optimization is stopped:  ftolRel  (1e-12),  ftolAbs  (1e-10) on the likelihood, and  xtolRel  (1e-10),  xtolAbs  (1e-10) on the model parameters.  verbose  (false): if true, more information is output.   examples:  julia   net =  readTopology ( (((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0); ); \n\njulia   m1 =  BinaryTraitSubstitutionModel ([ 0 . 1 ,   0 . 1 ],   [ lo ,   hi ]); \n\njulia   dat =  DataFrame ( species= [ C , A , B , D ],   trait= [ hi , lo , lo , hi ]); \n\njulia   fit1 =  fitDiscrete ( net ,  m1 ,  dat ;   fixedparam= true ) \nPhyloNetworks . StatisticalSubstitutionModel { String }: \nBinary Trait Substitution Model : \nrate lo \u2192 hi  \u03b1= 0 . 1 \nrate hi \u2192 lo  \u03b2= 0 . 1  1  traits ,   4  species ,  on a network  with   1  reticulations\nlog-likelihood :   - 3 . 107539646785388 \n\njulia  PhyloNetworks . fit ! ( fit1 ;   fixedparam= false ) \nPhyloNetworks . StatisticalSubstitutionModel { String }: \nBinary Trait Substitution Model : \nrate lo \u2192 hi  \u03b1= 0 . 2722215661432007 \nrate hi \u2192 lo  \u03b2= 0 . 3498103666174014  1  traits ,   4  species ,  on a network  with   1  reticulations\nlog-likelihood :   - 2 . 727701700712135 \n\njulia   tips =  Dict ( A   =   lo ,   B   =   lo ,   C   =   hi ,   D   =   hi ); \n\njulia   fit2 =  fitDiscrete ( net ,  m1 ,  tips ;   xtolRel= 1 e-16 ,   xtolAbs= 1 e-16 ,   ftolRel= 1 e-16 ) \nPhyloNetworks . StatisticalSubstitutionModel { String }: \nBinary Trait Substitution Model : \nrate lo \u2192 hi  \u03b1= 0 . 2722215661432007 \nrate hi \u2192 lo  \u03b2= 0 . 3498103666174014  1  traits ,   4  species ,  on a network  with   1  reticulations\nlog-likelihood :   - 2 . 727701700712135   Note that a copy of the network is stored in the fitted object, but the internal representation of the network may be different in  fit1.net  and in the original network  net :  julia  [n.number for n in fit2.net.node]\n9-element Array{Int64,1}:\n 1\n 2\n 9\n 8\n 3\n 7\n 6\n 4\n 5\n\njulia  [n.number for n in net.node]\n9-element Array{Int64,1}:\n  1\n  2\n  3\n -4\n  4\n -6\n -3\n  5\n -2  source  #  PhyloNetworks.maxParsimonyNet     Function .  maxParsimonyNet(T::HybridNetwork, df::DataFrame)  Search for the most parsimonious network (or tree). A level-1 network is assumed.  df  should be a data frame containing the species names in column 1, or in a column named  species  or  taxon . Trait data are assumed to be in all other columns. The search starts from topology  T , which can be a tree or a network with no more than  hmax  hybrid nodes (see optional arguments below for  hmax ).  Output:   estimated network in file  .out  (also in  .log ): best network overall and list of networks from each individual run.  if any error occurred, file  .err  provides information (seed) to reproduce the error.   Optional arguments include   hmax: maximum number of hybridizations allowed (default 1)  runs: number of starting points for the search (default 10); each starting point is  T  with probability  probST =0.3 or a modification of  T  otherwise (using a NNI move, or a hybrid edge direction change)  Nfail: number of failures (proposed networks with equal or worse score) before the search is aborted. 75 by default: this is quite small, which is okay for a first trial. Larger values are recommended.  outgroup: outgroup taxon.           It can be a taxon name (String) or Node number (Integer).           If none provided, or if the outgroup conflicts the starting           topology, the function returns an error  filename: root name for the output files. Default is \"mp\". If empty (\"\"), files are  not  created, progress log goes to the screen only (standard out).  seed: seed to replicate a given search  criterion: parsimony score could be hardwired, softwired (default) or parental. Currently,            only softwired is implemented   References   Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).  Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.   For a roadmap of the functions inside maxParsimonyNet, see  maxParsimonyNetRun1! .  source", 
            "title": "discrete trait evolution"
        }, 
        {
            "location": "/lib/internals/", 
            "text": "Internal Documentation\n\n\n\n\nContents\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\ntypes\n\n\nfunctions\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nPhyloNetworks.ANode\n\n\nPhyloNetworks.MatrixTopologicalOrder\n\n\nPhyloNetworks.StatisticalSubstitutionModel\n\n\nBase.getindex\n\n\nBase.getindex\n\n\nPhyloNetworks.addAlternativeHybridizations!\n\n\nPhyloNetworks.afterOptBL!\n\n\nPhyloNetworks.afterOptBLAll!\n\n\nPhyloNetworks.afterOptBLRepeat!\n\n\nPhyloNetworks.anova\n\n\nPhyloNetworks.assignhybridnames!\n\n\nPhyloNetworks.blobInfo\n\n\nPhyloNetworks.breakedge!\n\n\nPhyloNetworks.calculateObsCFAll!\n\n\nPhyloNetworks.checkNumHybEdges!\n\n\nPhyloNetworks.check_matchtaxonnames!\n\n\nPhyloNetworks.deleteEdge!\n\n\nPhyloNetworks.deleteHybridEdge!\n\n\nPhyloNetworks.deleteLeaf!\n\n\nPhyloNetworks.deleteNode!\n\n\nPhyloNetworks.descendants\n\n\nPhyloNetworks.discrete_backwardlikelihood_tree!\n\n\nPhyloNetworks.discrete_corelikelihood!\n\n\nPhyloNetworks.discrete_corelikelihood_tree!\n\n\nPhyloNetworks.displayedNetworks!\n\n\nPhyloNetworks.fuseedgesat!\n\n\nPhyloNetworks.gammaZero!\n\n\nPhyloNetworks.getChild\n\n\nPhyloNetworks.getChildren\n\n\nPhyloNetworks.getDataValue!\n\n\nPhyloNetworks.getGammas\n\n\nPhyloNetworks.getHeights\n\n\nPhyloNetworks.getMajorParent\n\n\nPhyloNetworks.getMajorParentEdge\n\n\nPhyloNetworks.getMinorParent\n\n\nPhyloNetworks.getMinorParentEdge\n\n\nPhyloNetworks.getParent\n\n\nPhyloNetworks.getParents\n\n\nPhyloNetworks.getPartner\n\n\nPhyloNetworks.getTipSubmatrix\n\n\nPhyloNetworks.hybridEdges\n\n\nPhyloNetworks.hybridEdges\n\n\nPhyloNetworks.inheritanceWeight\n\n\nPhyloNetworks.initializeWeightsFromLeaves!\n\n\nPhyloNetworks.initializeWeightsFromLeavesSoftwired!\n\n\nPhyloNetworks.majoredgelength\n\n\nPhyloNetworks.majoredgematrix\n\n\nPhyloNetworks.makemissing!\n\n\nPhyloNetworks.mapAllelesCFtable!\n\n\nPhyloNetworks.maxParsimonyNetRun1\n\n\nPhyloNetworks.maxParsimonyNetRun1!\n\n\nPhyloNetworks.minorreticulationgamma\n\n\nPhyloNetworks.minorreticulationlength\n\n\nPhyloNetworks.minorreticulationmatrix\n\n\nPhyloNetworks.moveHybrid!\n\n\nPhyloNetworks.nparams\n\n\nPhyloNetworks.optBL!\n\n\nPhyloNetworks.optTopLevel!\n\n\nPhyloNetworks.optTopRun1!\n\n\nPhyloNetworks.optTopRuns!\n\n\nPhyloNetworks.pairwiseTaxonDistanceGrad\n\n\nPhyloNetworks.parseEdgeData!\n\n\nPhyloNetworks.parseHybridNode!\n\n\nPhyloNetworks.parseRemainingSubtree!\n\n\nPhyloNetworks.parseTreeNode!\n\n\nPhyloNetworks.parsimonyBottomUpFitch!\n\n\nPhyloNetworks.parsimonyBottomUpGF!\n\n\nPhyloNetworks.parsimonyBottomUpSoftwired!\n\n\nPhyloNetworks.parsimonyDiscreteFitch\n\n\nPhyloNetworks.parsimonySummaryFitch\n\n\nPhyloNetworks.parsimonyTopDownFitch!\n\n\nPhyloNetworks.proposedTop!\n\n\nPhyloNetworks.readCSVtoArray\n\n\nPhyloNetworks.readStartTop\n\n\nPhyloNetworks.readSubtree!\n\n\nPhyloNetworks.recursionPostOrder\n\n\nPhyloNetworks.recursionPreOrder\n\n\nPhyloNetworks.recursionPreOrder!\n\n\nPhyloNetworks.removeHybrid!\n\n\nPhyloNetworks.resetEdgeNumbers!\n\n\nPhyloNetworks.resetNodeNumbers!\n\n\nPhyloNetworks.sameTaxa\n\n\nPhyloNetworks.sampleBootstrapTrees\n\n\nPhyloNetworks.sampleCFfromCI\n\n\nPhyloNetworks.setBLGammaParsimony!\n\n\nPhyloNetworks.setBranchLength!\n\n\nPhyloNetworks.setGammaBLfromGammaz!\n\n\nPhyloNetworks.setGammas!\n\n\nPhyloNetworks.setNonIdBL!\n\n\nPhyloNetworks.showQ\n\n\nPhyloNetworks.sortUnionTaxa!\n\n\nPhyloNetworks.symmetricNet\n\n\nPhyloNetworks.symmetricNet\n\n\nPhyloNetworks.symmetricTree\n\n\nPhyloNetworks.synchronizePartnersData!\n\n\nPhyloNetworks.taxadiff\n\n\nPhyloNetworks.ticr_optimalpha\n\n\nPhyloNetworks.traitlabels2indices\n\n\nPhyloNetworks.traverseContainRoot!\n\n\nPhyloNetworks.updatePostOrder!\n\n\nPhyloNetworks.updatePreOrder!\n\n\nPhyloNetworks.writeTopologyLevel1\n\n\nStatsBase.fit\n\n\n\n\n\n\ntypes\n\n\n#\n\n\nPhyloNetworks.ANode\n \n \nType\n.\n\n\nANode\n\n\nAbstract node. An object of type \nEdge\n has a \nnode\n attribute, which is an vector of (2) ANode objects. The object of type \nNode\n is an \nANode\n, and has an \nedge\n attribute, which is vector of \nEdge\n objects.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.MatrixTopologicalOrder\n \n \nType\n.\n\n\nMatrixTopologicalOrder\n\n\n\n\n\nMatrix associated to an \nHybridNetwork\n sorted in topological order.\n\n\nThe following functions and extractors can be applied to it: \ntipLabels\n, \nobj[:Tips]\n, \nobj[:InternalNodes]\n, \nobj[:TipsNodes]\n (see documentation for function \ngetindex(::MatrixTopologicalOrder, ::Symbol)\n).\n\n\nFunctions \nsharedPathMatrix\n and \nsimulate\n return objects of this type.\n\n\nThe \nMatrixTopologicalOrder\n object has fields: \nV\n, \nnodeNumbersTopOrder\n, \ninternalNodeNumbers\n, \ntipNumbers\n, \ntipNames\n, \nindexation\n. Type in \"?MatrixTopologicalOrder.field\" to get documentation on a specific field.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.StatisticalSubstitutionModel\n \n \nType\n.\n\n\nStatisticalSubstitutionModel\n\n\n\n\n\nSubtype of \nStatsBase.StatisticalModel\n, to fit discrete data to a model of trait substitution along a network. See \nfitDiscrete\n to fit a trait substitution model to discrete data. It returns an object of type \nStatisticalSubstitutionModel\n, to which standard functions can be applied, like \nloglikelihood(object)\n, \naic(object)\n etc.\n\n\nsource\n\n\n\n\nfunctions\n\n\n#\n\n\nBase.getindex\n \n \nFunction\n.\n\n\ngetindex(obj, d,[ indTips, msng])\n\n\n\n\n\nGetting submatrices of an object of type \nMatrixTopologicalOrder\n.\n\n\nArguments\n\n\n\n\nobj::MatrixTopologicalOrder\n: the matrix from which to extract.\n\n\n\n\nd::Symbol\n: a symbol precising which sub-matrix to extract. Can be:\n\n\n\n\n:Tips\n columns and/or rows corresponding to the tips\n\n\n:InternalNodes\n columns and/or rows corresponding to the internal nodes\n\n\n:TipsNodes\n columns corresponding to internal nodes, and row to tips (works only is indexation=\"b\")\n\n\nindTips::Vector{Int}\n: optional argument precising a specific order for the tips (internal use).\n\n\nmsng::BitArray{1}\n: optional argument precising the missing tips (internal use).\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nFunction\n.\n\n\ngetindex(obj, d)\n\n\n\n\n\nGetting submatrices of an object of type \nTraitSimulation\n.\n\n\nArguments\n\n\n\n\nobj::TraitSimulation\n: the matrix from which to extract.\n\n\n\n\nd::Symbol\n: a symbol precising which sub-matrix to extract. Can be:\n\n\n\n\n:Tips\n columns and/or rows corresponding to the tips\n\n\n:InternalNodes\n columns and/or rows corresponding to the internal nodes\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.addAlternativeHybridizations!\n \n \nMethod\n.\n\n\naddAlternativeHybridizations\n!(\nnet\n::\nHybridNetwork\n,\n \nBSe\n::\nDataFrame\n;\n\n                              \ncutoff\n=\n10\n::\nNumber\n,\n \ntop\n=\n3\n::\nInt\n)\n\n\n\n\n\n\nModify the network \nnet\n (the best network estimated with snaq) by adding other hybridizations that are present in the bootstrap networks. By default, it will only consider hybrid edges with more than 10% bootstrap support (\ncutoff\n) and it will only include the three top hybridizations (\ntop\n) sorted by bootstrap support. The function also modifies the dataframe \nBSe\n obtained with \nhybridBootstrapSupport\n. In the original \nBSe\n dataframe, hybrid edges that do not appear in the best network have a missing number. After the hybrid edges are added with \naddAlternativeHybridizations\n, \nBSe\n is modified to include the edge numbers of the newly added hybrid edges. Note that the function only adds the hybrid edges as minor to keep the underlying tree topology.\n\n\nexample\n\n\nbootnet\n \n=\n \nreadMultiTopology\n(\nbootstrap-networks.txt\n)\n\n\nbestnet\n \n=\n \nreadTopology\n(\nbest.tre\n)\n\n\nBSn\n,\n \nBSe\n,\n \nBSc\n,\n \nBSgam\n,\n \nBSedgenum\n \n=\n \nhybridBootstrapSupport\n(\nbootnet\n,\n \nbestnet\n);\n\n\naddAlternativeHybridizations!\n(\nbestnet\n,\nBSe\n)\n\n\nusing\n \nPhyloPlots\n\n\nplot\n(\nbestnet\n,\n \nedgeLabel\n=\nBSe\n[[\n:\nedge\n,\n:\nBS_hybrid_edge\n]])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.afterOptBL!\n \n \nMethod\n.\n\n\nafterOptBL\n road map\n\n\nFunction that will check if there are \nh==0,1;t==0,hz==0,1\n cases in a network after calling \noptBL!\n.\n\n\nArguments:\n\n\n\n\ncloseN=true\n will move origin/target, if false, add/delete N times before giving up (we have only tested \ncloseN=true\n)\n\n\norigin=true\n will move origin, false will move target. We added this to avoid going back and forth between the same networks\n\n\nmovesgamma\n vector of counts of number of times each move is proposed to fix a gamma zero problem: \n(add,mvorigin,mvtarget,chdir,delete,nni)\n\n\n\n\nProcedure:\n\n\n\n\nFirst we split the \nht\n vector in \nnh,nt,nhz\n (gammas, lengths, gammaz)\n\n\n\n\nIf we find a \nh==0,1\n, we loop through \nnh\n to find a hybrid edge with h==0 or 1 and want to try to fix this by doing:\n\n\n\n\ngammaZero!(currT,d,edge,closeN,origin,N,movesgamma)\n which returns true if there was a successful change, and we stop the loop\n\n\nIf we find a \nt==0\n, we loop through all \nnt\n to find such edge, and do NNI move on this edge; return true if change successful and we stop the loop\n\n\nIf we find a \nhz==0,1\n, we loop through \nnhz\n to find such hybrid edge and call \ngammaZero\n again\n\n\nIf we did a successful change, we run \noptBL\n again, and recheck if there are no more problems.\n\n\nReturns successchange, flagh, flagt,flaghz (flag=true means no problems)\n\n\nIf it is the multiple alleles case, it will not try to fix \nh==0,1;hz==0,1\n because it can reach a case that violates the multiple alleles condition. If we add a check here, things become horribly slow and inefficient, so we just delete a hybridization that has \nh==0,1;hz==0,1\n\n\n\n\n\n\n\n\n Important: \n \nafterOptBL\n is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call \nafterOptBLRepeat\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.afterOptBLAll!\n \n \nMethod\n.\n\n\nafterOptBLAll\n road map\n\n\nAfter \noptBL\n, we want to call \nafterOptBLAll\n (or \nafterOptBLAllMultipleAlleles\n) to check if there are \nh==0,1\n; \nt==0\n; \nhz==0,1\n. This function will try to fix the gamma zero problem, but if it cannot, it will call \nmoveDownLevel\n, to delete the hybridization from the network.\n\n\nProcedure:\n\n\nWhile \nstartover=true\n and \ntries\nN\n\n\n\n\n\n\nWhile \nbadliks \n N2\n (number of bad pseudolikelihoods are less than \nN2\n)\n\n\n\n\nRun \nsuccess = afterOptBLRepeat\n\n\n\n\nIf \nsuccess = true\n (it changed something):\n\n\n\n\nIf worse pseudolik, then go back to original topology \ncurrT\n, set \nstartover=true\n and \nbadliks++\n\n\n\n\nIf better pseudolik, then check flags. If all good, then \nstartover=false\n; otherwise \nstartover = true\n\n\n\n\nIf \nsuccess = false\n (nothing changed), then set \nbadliks=N2+1\n (to end the while on \ncurrT\n)\n\n\n\n\n\n\n\n\nIf all flags are ok, then \nstartover = false\n\n\n\n\nIf bad h or hz, then call \nmoveDownLevel\n (delete one hybridization), and set \nstartover = true\n (maybe deleting that hybridization did not fix other gamma zero problems)\n\n\nIf bad t, then set \nstartover = false\n\n\nIf left second while by back to original \ncurrT\n, and still bad h/hz, then move down one level, and \nstartover=true\n; otherwise \nstartover=false\n\n\n\n\n\n\n\n\n\n\n\n\nIf first while ends by \ntries\nN\n, then it checks one last time the flags, if bad h/hz will move down one level, and exit\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.afterOptBLRepeat!\n \n \nMethod\n.\n\n\nafterOptBLRepeat\n road map\n\n\nafterOptBL\n is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call \nafterOptBLRepeat\n. This function will repeat \nafterOptBL\n every time a successful change happened; this is done only if \ncloseN=false\n, because we would delete/add hybridizations and need to stop after tried N times. If \ncloseN=true\n (default), then \nafterOptBLRepeat\n only does one \nafterOptBL\n, because in this case, only the neighbor edges need to be tested, and this would have been done already in \ngammaZero\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.anova\n \n \nMethod\n.\n\n\nanova(objs::PhyloNetworkLinearModel...)\n\n\n\n\n\nTakes several nested fits of the same data, and computes the F statistic for each pair of models.\n\n\nThe fits must be results of function \nphyloNetworklm\n called on the same data, for models that have more and more effects.\n\n\nReturns a DataFrame object with the anova table.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.assignhybridnames!\n \n \nMethod\n.\n\n\nassignhybridnames!(net)\n\n\nAssign names to hybrid nodes in the network \nnet\n. Hybrid nodes with an empty \nname\n field (\"\") are modified with a name that does not conflict with other hybrid names in the network. The preferred name is \"#H3\" if the node number is 3 or -3, but an index other than 3 would be used if \"#H3\" were the name of another hybrid node already.\n\n\nIf two hybrid nodes have non-empty and equal names, the name of one of them is changed and re-assigned as described above (with a warning).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.blobInfo\n \n \nFunction\n.\n\n\nblobInfo(network, ignoreTrivial=true)\n\n\n\n\n\nCalculate the biconnected components (blobs) using function \nbiconnectedComponents\n then:\n\n\n\n\nset node field \nisExtBadTriangle\n to true at the root of each non-trivial blob (and at the network root), false otherwise. (a better name for the field would be something like \"isBlobRoot\".)\n\n\n\n\noutput:\n\n\n\n\narray of nodes that are the roots of each non-trivial blob,\n\n\n\n\nand the network root. If the root of the full network is   not part of a non-trivial blob, a corresponding blob is   added to the list.\n\n\n\n\narray of arrays: for each non-trivial blob, array of major hybrid edges in that blob.\n\n\narray of arrays: same as #2 but for minor hybrid edges, with hybrids listed in the same order, for each blob.\n\n\n\n\n\n\n\n\nBlobs are ordered in reverse topological ordering (aka post order). If \nignoreTrivial\n is true, trivial components are ignored.\n\n\nkeyword argument: \ncheckPreorder\n, true by default. If false, the \nisChild1\n edge field and the \nnet.nodes_changed\n network field are supposed to be correct.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.breakedge!\n \n \nMethod\n.\n\n\nbreakedge!(Edge, HybridNetwork)\n\n\n\n\n\nbreaks an edge into 2 edges (each of length half that of original edge). creates new node of degree 2. Useful to root network along an edge.\n\n\nwarning: updates \nisChild1\n and \ncontainRoot\n, but does NOT update attributes like: inCycle, partition, gammaz, etc.\n\n\nreturns the index of the newly created node in the network\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.calculateObsCFAll!\n \n \nMethod\n.\n\n\ncalculateObsCFAll!(DataCF, taxa::Union{Vector{String}, Vector{Int}})\n\n\n\n\n\nupdate the .quartet[i].obsCF values of the DataCF object, based on its .tree vector.\n\n\ncalculateObsCFAll!(vector of quartets, vector of trees, taxa)\n\n\n\n\n\nupdate the .obsCF values of the quartets, based on the trees, and returns a new DataCF object with these updated quartets and trees.\n\n\ncalculateObsCFAll_noDataCF!(vector of quartets, vector of trees, taxa)\n\n\n\n\n\nupdate the .obsCF values of the quartets based on the trees, but returns nothing.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.checkNumHybEdges!\n \n \nMethod\n.\n\n\n`checkNumHybEdges!(net)`\n\n\n\n\n\nCheck for consistency between hybrid-related attributes in the network:\n\n\n\n\nfor each hybrid node: 2 or more hybrid edges\n\n\nexception: allows for a leaf to be attached to a single hybrid edge\n\n\nexactly 2 incoming parent hybrid edges\n\n\n\n\nRun after \nstoreHybrids!\n. See also \ncheck2HybEdges\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.check_matchtaxonnames!\n \n \nMethod\n.\n\n\ncheck_matchtaxonnames!(species, data, net)\n\n\n\n\n\nModify \nspecies\n and \ndat\n by removing the species (rows) absent from the network. Return a new network (\nnet\n is \nnot\n modified) with tips matching those in species: if some species in \nnet\n have no data, these species are pruned from the network. The network also has its node names reset, such that leaves have nodes have consecutive numbers starting at 1, with leaves first. Used by \nfitDiscrete\n to build a new \nStatisticalSubstitutionModel\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.deleteEdge!\n \n \nMethod\n.\n\n\ndeleteEdge!(net::HybridNetwork,  e::Edge, part=true)\ndeleteEdge!(net::QuartetNetwork, e::Edge)\n\n\n\n\n\nDelete edge \ne\n from \nnet.edge\n and update \nnet.numEdges\n. If \npart\n is true, update the network's partition field.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.deleteHybridEdge!\n \n \nFunction\n.\n\n\ndeleteHybridEdge!(net::HybridNetwork, edge::Edge, keepNodes=false)\n\n\n\n\n\nDeletes a hybrid edge from a network. The network does not have to be of level 1, and may contain some polytomies. Updates branch lengths, allowing for missing values. Returns the network.\n\n\nAt each of the 2 junctions, the child edge is retained (below the hybrid node). If \nkeepNodes\n is true, all nodes are retained during edge removal.\n\n\nWarnings:\n\n\n\n\nif \nkeepNodes\n is true: partner hybrid parent edge has its \u03b3 value unchanged\n\n\nif the parent of \nedge\n is the root and if \nkeepNodes\n is false, the root is moved to keep the network unrooted with a root of degree two.\n\n\ndoes \nnot\n update containRoot (could be implemented later)\n\n\ndoes \nnot\n update attributes needed for snaq! (like containRoot, inCycle, edge.z, edge.y etc.)\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.deleteLeaf!\n \n \nMethod\n.\n\n\ndeleteLeaf!(net::HybridNetwork, leaf::AbstractString)\n \ndeleteLeaf!(net::Network, leaf::Node)\n\n\nDeletes the leaf taxon from the network. The leaf argument is the name of the taxon to delete.\n\n\nWarnings:\n\n\n\n\nrequires a level-1 network with up-to-date attributes for snaq! (e.g. non-missing branch lengths, gammaz, etc.)\n\n\ndoes not care where the root is and does not update it to a sensible location if the root is affected by the leaf removal.\n\n\ndoes not merge edges, i.e. does not remove all nodes of degree 2. Within snaq!, this is used to extract quartets and to keep track of which edge lengths in the original network map to the quartet network.\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.deleteNode!\n \n \nMethod\n.\n\n\ndeleteNode!(net::HybridNetwork, n::Node)\n\n\ndeletes a Node from a network, i.e. removes it from net.node, and from net.hybrid or net.leaf as appropriate. Updates attributes numNodes, numTaxa, numHybrids (it does not update net.names though).\n\n\nWarning: if the root is deleted, the new root is arbitrarily set to the first node in the list. This is intentional to save time because this function is used frequently in snaq!, which handles semi-directed (unrooted) networks.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.descendants\n \n \nMethod\n.\n\n\ndescendants(edge::Edge)\n\n\n\n\n\nReturn the node numbers of all the descendants of a given edge.\n\n\nThe node should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.\n\n\nExamples: #\"\n\n\njulia\n net5 = \n(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));\n |\n readTopology |\n directEdges! ;\n\njulia\n PhyloNetworks.descendants(net5.edge[12]) # descendants of 12th\n7-element Array{Int64,1}:\n -6\n -7\n  4\n  6\n  5\n -9\n  7\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.discrete_backwardlikelihood_tree!\n \n \nMethod\n.\n\n\ndiscrete_backwardlikelihood_tree!(obj::SSM, tree::Integer, trait::Integer)\n\n\n\n\n\nUpdate \nobj.backwardlik\n; assume correct forward likelihood, directional likelihood and transition probabilities.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.discrete_corelikelihood!\n \n \nMethod\n.\n\n\ndiscrete_corelikelihood\n!(\nobj\n::\nStatisticalSubstitutionModel\n;\n \nwhichtrait\n=\n:\nall\n)\n\n\ndiscrete_corelikelihood_tree\n!(\nobj\n,\n \nt\n::\nInteger\n,\n \ntraitrange\n::\nAbstractArray\n)\n\n\n\n\n\n\nCalculate the likelihood and update \nobj.loglik\n for discrete characters on a network (or on a single tree: \nt\nth tree displayed in the network, for the second form). Update forward and direct partial likelihoods while doing so. The algorithm extracts all displayed trees and weights the likelihood under all these trees.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.discrete_corelikelihood_tree!\n \n \nFunction\n.\n\n\ndiscrete_corelikelihood\n!(\nobj\n::\nStatisticalSubstitutionModel\n;\n \nwhichtrait\n=\n:\nall\n)\n\n\ndiscrete_corelikelihood_tree\n!(\nobj\n,\n \nt\n::\nInteger\n,\n \ntraitrange\n::\nAbstractArray\n)\n\n\n\n\n\n\nCalculate the likelihood and update \nobj.loglik\n for discrete characters on a network (or on a single tree: \nt\nth tree displayed in the network, for the second form). Update forward and direct partial likelihoods while doing so. The algorithm extracts all displayed trees and weights the likelihood under all these trees.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.displayedNetworks!\n \n \nFunction\n.\n\n\ndisplayedNetworks!(net::HybridNetwork, node::Node, keepNode=false)\n\n\n\n\n\nExtracts the two networks that simplify a given network at a given hybrid node: deleting either one or the other parent hybrid edge. If \nkeepNodes\n is true, all original nodes are kept in both networks.\n\n\n\n\nthe original network is modified: the minor edge removed.\n\n\nreturns one HybridNetwork object: the network with the major edge removed\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.fuseedgesat!\n \n \nMethod\n.\n\n\nfuseedgesat!(i::Integer,net::HybridNetwork)\n\n\n\n\n\nRemoves \ni\nth node in net.node, if it is of degree 2. The parent and child edges of this node are fused. Reverts the action of breakedge!.\n\n\nreturns the fused edge.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.gammaZero!\n \n \nMethod\n.\n\n\ngammaZero\n road map\n\n\nFunction that tries to fix a gamma zero problem (\nh==0,1; t==0; hz==0,1\n)\n\n\n\n\nFirst tries to do \nchangeDirection\n\n\nIf not successful from start, we call \nmoveHybrid\n\n\nIf successful move (change direction), we call \noptBL\n and check if we fixed the problem\n\n\nIf problem fixed and we do not have worse pseudolik, we return \nsuccess=true\n\n\nIf still problem or worse pseudolik, we call \nmoveHybrid\n\n\n\n\n Important: \n Any function (\nafterOptBL\n) calling \ngammaZero\n is assuming that it only made a change, so if the returned value is true, then a change was made, and the other function needs to run \noptBL\n and check that all parameters are 'valid'. If the returned value is false, then no change was possible and we need to remove a hybridization if the problem is h==0,1; hz==0,1. If the problem is t==0, we ignore this problem.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getChild\n \n \nMethod\n.\n\n\ngetChild(edge::Edge)\n\n\n\n\n\nReturn child node using the \nisChild1\n attribute of the edge.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getChildren\n \n \nMethod\n.\n\n\ngetChildren(node)\n\n\n\n\n\nreturn a vector with all children \nnodes\n of \nnode\n.   \nwarning\n: assume \nisChild1\n field (for edges) are correct\n\n\nTo get all parent \nnodes\n: see \ngetParents\n.  \n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getDataValue!\n \n \nMethod\n.\n\n\ngetdataValue!(s::IO, int, numLeft::Array{Int,1})\n\n\n\n\n\nHelper function for \nparseEdgeData!\n. Read a single floating point edge data value in a tree topology. Return -1.0 if no value exists before the next colon, return the value as a float otherwise. Modifies s by advancing past the next colon character. Only call this function to read a value when you know a numerical value exists!\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getGammas\n \n \nMethod\n.\n\n\ngetGammas(net)\n\n\n\n\n\nGet inheritance \u03b3's of major hybrid edges. Assume pre-order calculated already (with up-to-date field \nnodes_changed\n). See \nsetGammas!\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getHeights\n \n \nMethod\n.\n\n\ngetHeights(net)\n\n\n\n\n\nReturn the height (distance to the root) of all nodes, assuming a time-consistent network (where all paths from the root to a given hybrid node have the same length). Also assumes that the network has been preordered, because it uses \ngetGammas\n and \nsetGammas!\n).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getMajorParent\n \n \nMethod\n.\n\n\ngetMajorParent(node::Node)\ngetMinorParent(node::Node)\n\n\n\n\n\nReturn major or minor parent of a node using the \nisChild1\n field of edges (and assuming correct \nisMajor\n field). See also \ngetMajorParentEdge\n and \ngetMinorParentEdge\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getMajorParentEdge\n \n \nMethod\n.\n\n\ngetMajorParentEdge(node)\ngetMinorParentEdge(node)\n\n\n\n\n\nreturn the parent edge of a given node: the major / minor if hybrid.   \nwarning\n: assume isChild1 and isMajor attributes are correct\n\n\nTo get all parent \nnodes\n: see \ngetParents\n.  \n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getMinorParent\n \n \nFunction\n.\n\n\ngetMajorParent(node::Node)\ngetMinorParent(node::Node)\n\n\n\n\n\nReturn major or minor parent of a node using the \nisChild1\n field of edges (and assuming correct \nisMajor\n field). See also \ngetMajorParentEdge\n and \ngetMinorParentEdge\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getMinorParentEdge\n \n \nFunction\n.\n\n\ngetMajorParentEdge(node)\ngetMinorParentEdge(node)\n\n\n\n\n\nreturn the parent edge of a given node: the major / minor if hybrid.   \nwarning\n: assume isChild1 and isMajor attributes are correct\n\n\nTo get all parent \nnodes\n: see \ngetParents\n.  \n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getParent\n \n \nMethod\n.\n\n\ngetParent(e::Edge)\n\n\n\n\n\nReturn parent node of edge \ne\n using the \nisChild1\n attribute of the edge. To get parents of nodes: see \ngetParents\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getParents\n \n \nMethod\n.\n\n\ngetParents(n::Node)\n\n\n\n\n\nGet vector of all parent nodes of \nn\n, based on \nisChild1\n field (for edges). To get the parent node of an edge: see \ngetParent\n.   To get individual parent edges (rather than all parent \nnodes\n): see \ngetMajorParentEdge\n and \ngetMinorParentEdge\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getPartner\n \n \nMethod\n.\n\n\ngetPartner(edge::Edge)\ngetPartner(edge::Edge, node::Node)\n\n\n\n\n\nReturn hybrid partner of edge, that is, hybrid edge pointing to the same child as \nedge\n. Assumptions (not checked):\n\n\n\n\ncorrect \nisChild1\n field for \nedge\n and for hybrid edges\n\n\nno in-coming polytomy: a node has 0, 1 or 2 parents, no more\n\n\n\n\nWhen \nnode\n is given, it is assumed to be the child of \nedge\n (the first form calls the second).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.getTipSubmatrix\n \n \nMethod\n.\n\n\ngetTipSubmatrix(M, net; indexation=:both)\n\n\n\n\n\nExtract submatrix of M, with rows and/or columns corresponding to tips in the network, ordered like in \nnet.leaf\n. In M, rows and/or columns are assumed ordered as in \nnet.nodes_changed\n.\n\n\nindexation: one of \n:rows\n, \n:cols\n or \n:both\n: are nodes numbers indexed in the matrix by rows, by columns, or both? Subsetting is taken accordingly.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hybridEdges\n \n \nMethod\n.\n\n\nhybridEdges(node::Node, e::Edge)\n\n\n\n\n\nReturn the 2 edges connected to \nnode\n other than \ne\n, in the same order as \nnode.edge\n, except that \ne\n absent from the list.\n\n\nDespite what the name suggest, \nnode\n need not be a hybrid node! \nnode\n is assumed to have 3 edges, though.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hybridEdges\n \n \nMethod\n.\n\n\nhybridEdges(node::Node)\n\n\n\n\n\nReturn the 3 edges attached to \nnode\n in a specific order [e1,e2,e3]. \nWarning\n: assume a level-1 network with node field \nhasHybEdge\n and edge field \ninCycle\n up-to-date.\n\n\nIf \nnode\n is a hybrid node:\n\n\n\n\ne1 is the major hybrid parent edge of \nnode\n\n\ne2 is the minor hybrid parent edge\n\n\ne3 is the tree edge, child of \nnode\n.\n\n\n\n\nIf \nnode\n is a tree node parent of one child edge:\n\n\n\n\ne1 is the hybrid edge, child of \nnode\n\n\ne2 is the tree edge that belongs to the cycle created by e1\n\n\ne3 is the other tree edge attached to \nnode\n (not in a cycle)\n\n\n\n\nOtherwise:\n\n\n\n\ne3 is an external edge from \nnode\n to a leaf, if one exists.\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.inheritanceWeight\n \n \nMethod\n.\n\n\ninheritanceWeight(tree::HybridNetwork)\n\n\n\n\n\nReturn the \nlog\n inheritance weight of a network or tree (as provided by \ndisplayedTrees\n with \nkeepNodes\n = true for instance). For a tree displayed in a network, its inheritance weight is the log of the product of \u03b3's of all edges retained in the tree. To avoid underflow, the log is calculated: i.e. sum of log(\u03b3) across retained edges.\n\n\nIf any edge has a negative \u03b3, it is assumed to mean that its \u03b3 is missing, and the function returns \nmissing\n.\n\n\nExample\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\n);\n\n\n\njulia\n \ntrees\n \n=\n \ndisplayedTrees\n(\nnet\n,\n0\n.\n0\n;\n \nkeepNodes\n=\ntrue\n);\n\n\n\njulia\n \nPhyloNetworks\n.\ninheritanceWeight\n.(\ntrees\n)\n\n\n2-element\n \nArray\n{\nFloat64,1\n}\n:\n\n \n-0\n.\n105361\n\n \n-2\n.\n30259\n \n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.initializeWeightsFromLeaves!\n \n \nMethod\n.\n\n\ninitializeWeightsFromLeaves!(w, net, tips, stateset, criterion)\n\n\n\n\n\nModify weight in w: to Inf for w[n, i] if the \"tips\" data has a state different from the lineage state of index i at node number n. Assumes that w was initialized to 0 for the leaves.\n\n\ncriterion: should be one of \n:softwired\n, \n:parental\n or \n:hardwired\n.\n\n\n\n\nsoftwired parsimony: lineage states are in this order: \u2205,{1},{2},{3},...,{nstates}\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.initializeWeightsFromLeavesSoftwired!\n \n \nMethod\n.\n\n\ninitializeWeightsFromLeavesSoftwired!(w, net, tips, charset)\n\n\n\n\n\nModify weight in w: to Inf for w[n, s] if the \"tips\" data has a state different from s at node number n. Assumes that w was initialized to 0 for the leaves.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.majoredgelength\n \n \nMethod\n.\n\n\nmajoredgelength(net::HybridNetwork)\n\n\n\n\n\nGenerate vector of edge lengths of major \nnet\n edges organized in the same order as the \nedge\n matrix created via \nmajoredgematrix\n. Considers values of \n-1.0\n as missing values, recognized as NA in \nR\n. Output: vector allowing for missing values.\n\n\nAssume \nnodes_changed\n was updated, to list nodes in pre-order.\n\n\nExamples\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n(((A:3.1,(B:0.2)#H1:0.3::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);\n);\n\n\n\njulia\n \ndirectEdges\n!(\nnet\n);\n \npreorder\n!(\nnet\n);\n\n\n\njulia\n \nPhyloNetworks\n.\nmajoredgelength\n(\nnet\n)\n\n\n8-element\n \nArray\n{\nUnion{Float64,\n \nMissings.Missing\n}\n,\n1\n}\n:\n\n  \nmissing\n\n \n0\n.\n7\n     \n  \nmissing\n\n \n1\n.\n1\n     \n  \nmissing\n\n \n3\n.\n1\n     \n \n0\n.\n3\n     \n \n0\n.\n2\n     \n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.majoredgematrix\n \n \nMethod\n.\n\n\nmajoredgematrix(net::HybridNetwork)\n\n\n\n\n\nMatrix of major edges from \nnet\n where edge[i,1] is the number of the parent node of edge i and edge[i,2] is the number of the child node of edge i. Assume \nnodes_changed\n was updated, to list nodes in pre-order.\n\n\nExamples\n\n\njulia\n net = readTopology(\n(A,(B,(C,D)));\n);\n\njulia\n PhyloNetworks.resetNodeNumbers!(net);\n\njulia\n PhyloNetworks.majoredgematrix(net)\n6\u00d72 Array{Int64,2}:\n 5  1\n 5  6\n 6  2\n 6  7\n 7  3\n 7  4\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.makemissing!\n \n \nMethod\n.\n\n\nmakemissing!(x::AbstractVector)\n\n\n\n\n\nTurn to \nmissing\n any element of \nx\n exactly equal to -1.0. Used for branch lengths and \u03b3s. \nx\n needs to accept missing values. If not, this can be done with \nallowmissing(x)\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.mapAllelesCFtable!\n \n \nMethod\n.\n\n\nmapAllelesCFtable!(quartet CF DataFrame, mapping DataFrame, columns, write?, filename)\n\n\n\n\n\nModify (and return) the quartet concordance factor (CF) DataFrame: replace each allele name by the species name that the allele maps onto based on the mapping data frame. This mapping data frame should have columns named \"allele\" and \"species\" (see \nrename!\n to change column names if need be).\n\n\nIf \nwrite?\n is \ntrue\n, the modified data frame is written to a file named \"filename\".\n\n\nWarning: \nmapAllelesCFtable\n takes the quartet data file as its second argument, while \nmapAllelesCFtable!\n takes the quartet data (which it modifies) as its first argument.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.maxParsimonyNetRun1\n \n \nFunction\n.\n\n\nRoad map for various functions behind maxParsimonyNet\n\n\nmaxParsimonyNet\nmaxParsimonyNetRun1\nmaxParsimonyNetRun1!\n\n\n\n\n\nAll return their optimized network. Only maxParsimonyNet returns a rooted network (though all functions guarantee that the returned networks agree with the outgroup).\n\n\n\n\nmaxParsimonyNet calls maxParsimonyNetRun1 per run, after a read(write(.)) of the starting network (to ensure level-1 and semi-directedness).\n\n\nmaxParsimonyNetRun1 will make a copy of the topology, and will call findStartingTopology! to modify the topology according to random NNI/move origin/move target moves. It then calls maxParsimonyNetRun1! on the modified network\n\n\nmaxParsimonyNetRun1! proposes new network with various moves (same moves as snaq), and stops when it finds the most parsimonious network, using \nparsimonyGF\n.\n\n\n\n\nNone of these functions allow for multiple alleles yet.\n\n\nNote that the search algorithm keeps two HybridNetworks at a time: currT (current topology) and newT (proposed topology). Both are kept unrooted (semi-directed), otherwise the moves in proposedTop! function fail. We only root the topologies to calculate the parsimony, so we create a rooted copy (currTr, newTr) to compute parsimony score in this copied topology. We do not root and calculate parsimony score in the original HybridNetworks objects (currT,newT) because the computation of the parsimony score overwrites the inCycle attribute of the Nodes, which messes with the search moves.\n\n\nExtensions:\n\n\n\n\nother criteria: hardwired, parental (only softwired implemented now)\n\n\n\n\nremove level-1 restriction: this will involve changing the proposedTop! function to use rSPR or rNNI moves (instead of the level-1 moves coded for snaq!). We need:\n\n\n\n\nfunctions for rSPR and rNNI moves\n\n\ncreate new proposedTop! function (proposedRootedTop?) to choose from the rSPR/rNNI/other moves\n\n\nhave the search in maxParsimonuNetRun1! to have rooted currT and rooted newT, instead of keeping semi-directed objects (currT, newT), only to root for the parsimony score (currTr, newTr)\n\n\noutgroup is currently String or Node number, but it would be good if it allowed Edge number as an option too. Not sure best way to distinguish between Node number and Edge number, which is why left as Node number for now.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.maxParsimonyNetRun1!\n \n \nFunction\n.\n\n\nRoad map for various functions behind maxParsimonyNet\n\n\nmaxParsimonyNet\nmaxParsimonyNetRun1\nmaxParsimonyNetRun1!\n\n\n\n\n\nAll return their optimized network. Only maxParsimonyNet returns a rooted network (though all functions guarantee that the returned networks agree with the outgroup).\n\n\n\n\nmaxParsimonyNet calls maxParsimonyNetRun1 per run, after a read(write(.)) of the starting network (to ensure level-1 and semi-directedness).\n\n\nmaxParsimonyNetRun1 will make a copy of the topology, and will call findStartingTopology! to modify the topology according to random NNI/move origin/move target moves. It then calls maxParsimonyNetRun1! on the modified network\n\n\nmaxParsimonyNetRun1! proposes new network with various moves (same moves as snaq), and stops when it finds the most parsimonious network, using \nparsimonyGF\n.\n\n\n\n\nNone of these functions allow for multiple alleles yet.\n\n\nNote that the search algorithm keeps two HybridNetworks at a time: currT (current topology) and newT (proposed topology). Both are kept unrooted (semi-directed), otherwise the moves in proposedTop! function fail. We only root the topologies to calculate the parsimony, so we create a rooted copy (currTr, newTr) to compute parsimony score in this copied topology. We do not root and calculate parsimony score in the original HybridNetworks objects (currT,newT) because the computation of the parsimony score overwrites the inCycle attribute of the Nodes, which messes with the search moves.\n\n\nExtensions:\n\n\n\n\nother criteria: hardwired, parental (only softwired implemented now)\n\n\n\n\nremove level-1 restriction: this will involve changing the proposedTop! function to use rSPR or rNNI moves (instead of the level-1 moves coded for snaq!). We need:\n\n\n\n\nfunctions for rSPR and rNNI moves\n\n\ncreate new proposedTop! function (proposedRootedTop?) to choose from the rSPR/rNNI/other moves\n\n\nhave the search in maxParsimonuNetRun1! to have rooted currT and rooted newT, instead of keeping semi-directed objects (currT, newT), only to root for the parsimony score (currTr, newTr)\n\n\noutgroup is currently String or Node number, but it would be good if it allowed Edge number as an option too. Not sure best way to distinguish between Node number and Edge number, which is why left as Node number for now.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.minorreticulationgamma\n \n \nMethod\n.\n\n\nminorreticulationgamma(net::HybridNetwork)\n\n\n\n\n\nVector of minor edge gammas (inheritance probabilities) organized in the same order as in the matrix created via \nminorreticulationmatrix\n. Considers values of \n-1.0\n as missing values, recognized as NA in \nR\n. Output: vector allowing for missing values.\n\n\nExamples\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\n);\n\n\n\njulia\n \nPhyloNetworks\n.\nminorreticulationgamma\n(\nnet\n)\n\n\n1-element\n \nArray\n{\nUnion{Float64,\n \nMissings.Missing\n}\n,\n1\n}\n:\n\n \n0\n.\n1\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.minorreticulationlength\n \n \nMethod\n.\n\n\nminorreticulationlength(net::HybridNetwork)\n\n\n\n\n\nVector of lengths for the minor hybrid edges, organized in the same order as in the matrix created via \nminorreticulationmatrix\n. Replace values of \n-1.0\n with missing values recognized by \nR\n. Output: vector allowing for missing values.\n\n\nExamples\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n(((A:3.1,(B:0.2)#H1:0.4::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);\n);\n\n\n\njulia\n \nPhyloNetworks\n.\nminorreticulationlength\n(\nnet\n)\n\n\n1-element\n \nArray\n{\nUnion{Float64,\n \nMissings.Missing\n}\n,\n1\n}\n:\n\n \n0\n.\n3\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.minorreticulationmatrix\n \n \nMethod\n.\n\n\nminorreticulationmatrix(net::HybridNetwork)\n\n\n\n\n\nMatrix of integers, representing the minor hybrid edges in \nnet\n. edge[i,1] is the number of the parent node of the ith minor hybrid edge, and edge[i,2] is the number of its child node. Node numbers may be negative, unless they were modified by \nresetNodeNumbers!\n. Assumes correct \nisChild1\n fields.\n\n\nExamples\n\n\njulia\n \nnet\n \n=\n \nreadTopology\n(\n(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\n);\n\n\njulia\n \nPhyloNetworks\n.\nminorreticulationmatrix\n(\nnet\n)\n\n\n1\n\u00d7\n2\n \nArray\n{\nInt64,2\n}\n:\n\n \n-6\n  \n3\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.moveHybrid!\n \n \nMethod\n.\n\n\nmoveHybrid\n road map\n\n\nFunction that tries to fix a gamma zero problem (\nh==0,1; t==0; hz==0,1\n) after changing direction of hybrid edge failed. This function is called in \ngammaZero\n.\n\n\nArguments:\n\n\n\n\ncloseN=true\n will try move origin/target on all neighbors (first choose minor/major edge at random, then make list of all neighbor edges and tries to put the hybrid node in all the neighbors until successful move); if false, will delete and add hybrid until successful move up to N times (this is never tested)\n\n\n\n\nReturns true if change was successful (not testing \noptBL\n again), and false if we could not move anything\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.nparams\n \n \nMethod\n.\n\n\nnparams(model)\n\n\n\n\n\nNumber of parameters for a given trait evolution model (length of field \nmodel.rate\n).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.optBL!\n \n \nMethod\n.\n\n\noptBL\n road map\n\n\nFunction that optimizes the numerical parameters (branch lengths and inheritance probabilities) for a given network. This function is called multiple times inside \noptTopLevel!\n.\n\n\n\n\nInput: network \nnet\n, data \nd\n\n\nNumerical tolerances: \nftolAbs, ftolRel, xtolAbs, xtolRel\n\n\nFunction based on \nMixedModels\n \nfit\n function\n\n\nThe function assumes \nnet\n has all the right attributes, and cannot check this inside because it would be inefficient\n\n\n\n\nProcedure:\n\n\n\n\nht = parameters!(net)\n extracts the vector of parameters to estimate \n(h,t,gammaz)\n, and sets as \nnet.ht\n; identifies a bad diamond I, sets \nnet.numht\n (vector of hybrid node numbers for h, edge numbers for t, hybrid node numbers for gammaz), and \nnet.index\n to keep track of the vector of parameters to estimate\n\n\n\n\nextractQuartet!(net,d)\n does the following for all quartets in \nd.quartet\n:\n\n\n\n\nExtract quartet by deleting all leaves not in q -\n create \nQuartetNetwork\n object saved in \nq.qnet\n\n\nThis network is ugly and does not have edges collapsed. This is done to keep a one-to-one correspondence between the edges in \nq.qnet\n and the edges in \nnet\n (if we remove nodes with only two edges, we will lose this correspondence)\n\n\nCalculate expected CF with \ncalculateExpCFAll\n for a copy of \nq.qnet\n. We do this copy because we want to keep \nq.qnet\n as it is (without collapsed edges into one). The function will then save the \nexpCF\n in \nq.qnet.expCF\n\n\n\n\ncalculateExpCFAll!(qnet)\n will\n\n\n\n\n\n\nidentify the type of quartet as type 1 (equivalent to a tree) or type 2 (minor CF different). Here the code will first clean up any hybrid node by removing nodes with only two edges before identifying the \nqnet\n (because identification depends on neighbor nodes to hybrid node); later, set \nqnet.which\n (1 or 2), \nnode.prev\n (neighbor node to hybrid node), updates \nnode.k\n (number of nodes in hybridization cycle, this can change after deleting the nodes with only two edges), \nnode.typeHyb\n (1,2,3,4,5 depending on the number of nodes in the hybridization cycle and the origin/target of the minor hybrid edge; this attribute is never used).\n\n\n\n\neliminate hybridization: this will remove type 1 hybridizations first. If \nqnet.which=1\n, then the \nqnet\n is similar to a tree quartet, so it will calculate the internal length of the tree quartet: \nqnet.t1\n.\n\n\nupdate split for \nqnet.which=1\n, to determine which taxa are together. For example, for the quartet 12|34, the split is \n1,1,2,2\n, that is, taxon 1 and 2 are on the same side of the split. This will update \nqnet.split\n\n\nupdate formula for \nqnet.which=1\n to know the order of minorCF and majorCF in the vector \nqnet.expCF\n. That is, if the quartet is 1342 (order in \nqnet.quartet.taxon\n), then the expected CF should match the observed CF in 13|42, 14|32, 12|34 and the \nqnet\n is 12|34 (given by \nqnet.split\n), \nqnet.formula\n will be [2,2,1] minor, minor, major\n\n\ncalculateExpCF!(qnet)\n for \nqnet.which=1\n, it will do \n1-2/3exp(-qnet.t1)\n if \nqnet.formula[i]==1\n, and \n1/3exp(qnet.t1)\n if \nqnet.formula[i]==2\n. For \nqnet.which=2\n, we need to make sure that there is only one hybrid node, and compute the major, minor1,minor2 expected CF in the order 12|34, 13|24, 14|23 of the taxa in \nqnet.quartet.taxon\n\n\n\n\n\n\n\n\nThen we create a \nNLopt\n object with algorithm BOBYQA and k parameters (length of ht). We define upper and lower bounds and define the objective function that should only depend on \nx=(h,t,gz)\n and g (gradient, which we do not have, but still need to put as argument).\n\n\nThe objective function \nobj(x,g)\n calls\n\n\n\n\n\n\ncalculateExpCFAll!(d,x,net)\n needs to be run after \nextractQuartet(net,d)\n that will update \nq.qnet\n for all quartet.  Assumes that \nqnet.indexht\n is updated already: we only need to do this at the beginning of \noptBL!\n because the topology is fixed at this point)\n\n\n\n\nFirst it will update the edge lengths according to x\n\n\nIf the \nq.qnet.changed=true\n (that is, any of \nqnet\n branches changed value), we need to call \ncalculateExpCFAll!(qnet)\n on a copy of \nq.qnet\n (again because we want to leave \nq.qnet\n with the edge correspondence to \nnet\n)\n\n\nupdate!(net,x)\n simply saves the new x in \nnet.ht\n\n\n\n\n\n\n\n\nFinally, we call \nNLopt.optimize\n, and we update the \nnet.loglik\n and \nnet.ht\n at the end. After \noptBL\n, we want to call \nafterOptBLAll\n (or \nafterOptBLAllMultipleAlleles\n) to check if there are \nh==0,1\n; \nt==0\n; \nhz==0,1\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.optTopLevel!\n \n \nMethod\n.\n\n\noptTopLevel\n road map\n\n\nFunction that does most of the heavy-lifting of \nsnaq\n. It optimizes the pseudolikelihood for a given starting topology, and returns the best network. Assumes that the starting topology is level-1 network, and has all the attributes correctly updated.\n\n\nInput parameters:\n\n\n\n\nStarting topology \ncurrT\n, input data \nDataCF\n \nd\n, maximum number of hybridizations \nhmax\n\n\nNumerical optimization parameters: \nliktolAbs, Nfail, ftolRel, ftolAbs, xtolRel, xtolAbs\n\n\nPrint parameters: \nverbose, sout, logfile, writelog\n\n\nParameters to tune the search in space of networks: \ncloseN=true\n only propose move origin/target to neighbor edges (coded, but not tested with \ncloseN=false\n), \nNmov0\n vector with maximum number of trials allowed per type of move \n(add, mvorigin, mvtarget, chdir, delete, nni)\n, by default computed inside with coupon\u2019s collector formulas\n\n\n\n\nThe optimization procedure keeps track of\n\n\n\n\nmovescount\n: count of proposed moves,\n\n\nmovesgamma\n: count of proposed moves to fix a gamma zero situation (see below for definition of this situation),\n\n\nmovesfail\n: count of failed moves by violation of level-1 network (\ninCycle\n attribute) or worse pseudolikelihood than current,\n\n\nfailures\n: number of failed proposals that had a worse pseudolikelihood\n\n\n\n\nOptimization procedure:\n\n\nWhile the difference between current loglik and proposed loglik is greater than \nliktolAbs\n, or \nfailures\nNfail\n, or \nstillmoves=true\n:\n\n\n\n\nNmov\n is updated based on \nnewT\n. The type of move proposed will depend on \nnewT\n (which is the same as \ncurrT\n at this point). For example, if \ncurrT\n is a tree, we cannot propose move origin/target.\n\n\nmove = whichMove\n selects randomly a type of move, depending on \nNmov,movesfail,hmax,newT\n with weights 1/5 by default for all, and 0 for delete. These weights are adjusted depending on \nnewT.numHybrids\n and \nhmax\n. If \nnewT.numHybrids\n is far from \nhmax\n, we give higher probability to adding a new hybrid (we want to reach the \nhmax\n sooner, maybe not the best strategy, easy to change).  Later, we adjust the weights by \nmovesfail\n (first, give weight of 0 if \nmovesfail[i]\nNmov[i]\n, that is, if we reached the maximum possible number of moves allowed for a certain type) and then increase the probability of the other moves.  So, unless one move has \nw=0\n, nothing changes. This could be improved by using the outlier quartets to guide the proposal of moves.\n\n\nwhichMove\n will choose a move randomly from the weights, it will return \nnone\n if no more moves allowed, in which case, the optimization ends\n\n\n\n\nflag=proposedTop!(move, newT)\n will modify \nnewT\n based on \nmove\n. The function \nproposedTop\n will return \nflag=true\n if the move was successful (the move succeeded by \ninCycle\n, \ncontainRoot\n, available edge to make the move (more details in \nproposedTop\n)). If \nflag=false\n, then \nnewT\n is cleaned, except for the case of multiple alleles. The function \nproposedTop\n keeps count of \nmovescount\n (successful move), \nmovesfail\n (unsuccessful move),\n\n\nOptions:\n\n\nrandom=true\n: moves major/minor hybrid edge with prob h,1-h, respectively\n\n\nN=10\n: number of trials for NNI edge.\n  * if(flag) Optimize branch lengths with \noptBL\n\n\nIf \nnewT.loglik\n is better than \ncurrT.loglik\n by \nliktolAbs\n, jump to \nnewT\n (\naccepted=true\n) and fix \ngamma=0, t=0\n problems (more info on \nafterOptBL\n)\n\n\nIf(accepted)   \nfailures=0\n, \nmovesfail=zeros\n, \nmovescount\n for successful move +1\n\n\n\n\n\n\nend while\n\n\nAfter choosing the best network \nnewT\n, we do one last more thorough optimization of branch lengths with \noptBL\n, we change non identifiable branch lengths to -1 and return \nnewT\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.optTopRun1!\n \n \nMethod\n.\n\n\noptTopRun1\n roadmap\n\n\nThe function will run 1 run by modifying the starting topology and calling \noptTopLevel\n.\n\n\n\n\nprobST\n (default in snaq is 0.3) is the probability of starting one run in the same starting tree. So, with probability \n1-probST\n, we will change the topology by a NNI move on a tree edge without neighbor hybrid.\n\n\n\n\nIf the starting topology is a network, then with probability \n1-probST\n it will modify one randomly chosen hybrid edge: with prob 0.5, the function will move origin, with prob 0.5 will do move target\n\n\nIf there are multiple alleles (\nd.repSpecies\n not empty), then the function has to check that the starting topology does not violate the multiple alleles condition.\n\n\nAfter modifying the starting topology with NNI and/or move origin/target, the function calls \noptTopLevel\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.optTopRuns!\n \n \nMethod\n.\n\n\nRoad map for various functions behind snaq!\n\n\nsnaq!\noptTopRuns!\noptTopRun1!\noptTopLevel!\noptBL!\nsnaqDebug\n\n\n\n\n\nAll return their optimized network.\n\n\n\n\nsnaq! calls optTopRuns! once, after a deep copy of the starting network. If the data contain multiple alleles from a given species, \nsnaq!\n first expands the leaf for that species into 2 separate leaves, and merges them back into a single leaf after calling \noptTopRuns!\n.\n\n\noptTopRuns! calls optTopRun1! several (nrun) times. assumes level-1 network with \n0 branch lengths. assumes same tips in network as in data: i.e. 2 separate tips per species                                          that has multiple alleles. each call to optTopRun1! gets the same starting network.\n\n\noptTopRun1! calls optTopLevel! once, after deep copying + changing the starting network slightly.\n\n\noptTopLevel! calls optBL! various times and proposes new network with various moves.\n\n\nsnaqDebug calls optTopRun1! once\n\n\n\n\nFunctions that are no longer used, and not tested as much:\n\n\noptTop! : optimizes at h=0, then h=1 etc.\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.pairwiseTaxonDistanceGrad\n \n \nMethod\n.\n\n\npairwiseTaxonDistanceGrad(net; checkEdgeNumber=true, nodeAges=[])\n\n\n\n\n\n3-dim array: gradient of pairwise distances between all nodes. (internal and leaves); gradient with respect to edge lengths if \nnodeAges\n is empty; with respect to node ages otherwise. Assume correct \nnet.nodes_changed\n (preorder).   This gradient depends on the network's topology and \u03b3's only, not on branch lengths or node ages (distances are linear in either).\n\n\nWARNING: edge numbers need to range between 1 and #edges.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.parseEdgeData!\n \n \nMethod\n.\n\n\nparseEdgeData!(s::IO, edge, node, numberOfLeftParentheses::Array{Int,1})\n\n\n\n\n\nHelper function for readSubtree!, fixes a bug from using setGamma Modifies \ne\n according to the specified edge length and gamma values in the tree topology. Advances the stream \ns\n past any existing edge data. Edges in a topology may optionally be followed by \":edgeLen:bootstrap:gamma\" where edgeLen, bootstrap, and gamma are decimal values.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.parseHybridNode!\n \n \nMethod\n.\n\n\nparseHybridNode!(node, parentNode, hybridName, net, hybrids)\n\n\n\n\n\nHelper function for \nreadSubtree!\n. Create the parent edge for \nnode\n. Return this edge, and the hybrid node retained (\nnode\n or its clone in the newick string). Insert new edge and appropriate node into \nnet\n and \nhybrids\n accordingly. Handles any type of given hybrid node. Called after a \n#\n has been found in a tree topology.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.parseRemainingSubtree!\n \n \nMethod\n.\n\n\nparseRemainingSubtree!(s::IO, numLeft, net, hybrids)\n\n\n\n\n\nCreate internal node. Helper for \nreadSubtree!\n, which creates the parent edge of the node created by \nparseRemainingSubtree!\n: \nreadSubtree!\n calls \nparseRemainingSubtree!\n, and vice versa. Called once a \n(\n has been read in a tree topology and reads until the corresponding \n)\n has been found. This function performs the recursive step for \nreadSubtree!\n. Advances \ns\n past the subtree, adds discovered nodes and edges to \nnet\n, and \nhybrids\n.\n\n\nDoes \nnot\n read the node name and the edge information of the subtree root: this is done by \nreadSubtree!\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.parseTreeNode!\n \n \nMethod\n.\n\n\nparseTreeNode!(node, parentNode, net)\n\n\n\n\n\nHelper function for \nreadSubtree!\n. Insert the input tree node and associated edge (created here) into \nnet\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.parsimonyBottomUpFitch!\n \n \nMethod\n.\n\n\nparsimonyBottomUpFitch!(node, states, score)\n\n\nBottom-up phase (from tips to root) of the Fitch algorithm: assign sets of character states to internal nodes based on character states at tips. Polytomies okay. Assumes a \ntree\n (no reticulation) and correct isChild1 attribute.\n\n\noutput: dictionary with state sets and most parsimonious score\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.parsimonyBottomUpGF!\n \n \nMethod\n.\n\n\n`parsimonyBottomUpGF!(node, blobroot, nchar, w, scores,\n    costmatrix1, costmatrix2)`\n\n\n\n\n\nCompute the MP scores (one for each assignment of the blob root state) given the descendants of a blob, conditional on the states at predefined parents of hybrids in the blobs (one parent per hybrid) as described in\n\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\n\n\nAssumes a set of state \nguesses\n, ie correct initialization of \nw\n for predefined hybrid parents, and correct \nfromBadDiamondI\n field for the children edges of these predefined parents. \nfromBadDiamondI\n is true for edges that are cut.\n\n\nThe field \nisExtBadTriangle\n is used to know which nodes are at the root of a blob. The field \nisChild1\n is used (and assumed correct). Field \ninCycle\n is assumed to store the # of detached parents (with guessed states)\n\n\n\n\nnchar\n: number of characters considered at internal lineages. For softwired parsimony, this is # states + 1, because characters at internal nodes are \u2205, {1}, {2}, etc. For parental parsimony, this is 2^#states -1, because characters are all sets on {1,2,...} except for the empty set \u2205.\n\n\ncostmatrix1\n[i,j] and \ncostmatrix2\n[k][i,j]: 2d array and vector of 2d arrays containing the cost of going to character j starting from character i when the end node has a single parent, or the cost of a child node having character j when its parents have characters k and i. These cost matrices are pre-computed depending on the parsimony criterion (softwired, hardwired, parental etc.)\n\n\n\n\nused by \nparsimonyGF\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.parsimonyBottomUpSoftwired!\n \n \nMethod\n.\n\n\nparsimonyBottomUpSoftwired!(node, blobroot, states, w, scores)\n\n\nComputing the MP scores (one for each assignment of the root state) of a swicthing as described in Algorithm 1 in the following paper:\n\n\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\n\nAssumes a \nswitching\n (ie correct \nfromBadDiamondI\n field) and correct isChild1 field. The field \nisExtBadTriangle\n is used to know which nodes are at the root of a blob.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.parsimonyDiscreteFitch\n \n \nMethod\n.\n\n\nparsimonyDiscreteFitch(net, tipdata)\n\n\n\n\n\nCalculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network. Tip data can be given in a data frame, in which case the taxon names are to appear in column 1 or in a column named \"taxon\" or \"species\", and trait values are to appear in column 2 or in a column named \"trait\". Alternatively, tip data can be given as a dictionary taxon =\n trait.\n\n\nalso return the union of all optimized character states at each internal node as obtained by Fitch algorithm, where the union is taken over displayed trees with the MP score.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.parsimonySummaryFitch\n \n \nMethod\n.\n\n\nparsimonySummaryFitch(tree, nodestates)\n\n\nsummarize character states at nodes, assuming a \ntree\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.parsimonyTopDownFitch!\n \n \nMethod\n.\n\n\nparsimonyTopDownFitch!(node, states)\n\n\nTop-down phase (root to tips) of the Fitch algorithm: constrains character states at internal nodes based on the state of the root. Assumes a \ntree\n: no reticulation.\n\n\noutput: dictionary with state sets\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.proposedTop!\n \n \nMethod\n.\n\n\nproposedTop!(move,newT,random,count,N,movescount,movesfail,multall)\n road map\n\n\nFunction to change the current network \nnewT\n by a given \nmove\n, and checks that the move was successful (correct attributes). If not successful, \nnewT\n is changed back to its original state, except for the case of multiple alleles.\n\n\nNote\n that the update of attributes by each move is not done in all the network, but only in the local edges that were changed by the move. This is efficient (and makes a move easy to undo), but makes the code of each move function very clunky.\n\n\nArguments:\n\n\n\n\nmove chosen from \nwhichMove\n as described in \noptTopLevel\n\n\nnewT\n is the topology that will be modified inside with the move\n\n\nrandom=true\n: chooses minor hybrid edge with prob 1-h, and major edge with prob h, if false, always chooses minor hybrid edge\n\n\ncount\n: simply which likelihood step we are in in the optimization at \noptTopLevel\n\n\nmovescount\n and \nmovesfail\n: vector of counts of number of moves proposed\n\n\nmultall=true\n if multiple alleles case: we need to check if the move did not violate the multiple alleles condition (sister alleles together and no gene flow into the alleles). This is inefficient because we are proposing moves that we can reject later, instead of being smart about the moves we propose: for example, move origin/target could rule out some neighbors that move gene flow into the alleles, the same for add hybridization; nni move can check if it is trying to separate the alleles)\n\n\n\n\nMoves:\n\n\n\n\naddHybridizationUpdate(newT,N)\n:\n\n\n\n\nwill choose a partition first (to avoid choosing edges that will create a non level-1 network) will choose two edges from this partition randomly, will not allow two edges in a cherry (non-identifiable), or sister edges that are not identifiable (the blacklist was a way to keep track of \"bad edges\" were we should not waste time trying to put hybridizations, it has never been used nor tested). Also choose gamma from U(0,0.5). The \"Update\" in the function name means that it creates the new hybrid, and also updates all the attributes of \nnewT\n\n\n\n\nnode = chooseHybrid(newT)\n choose a hybrid randomly for the next moves:\n\n\nmoveOriginUpdateRepeat!(newT,node,random)\n\n\n\n\nwill choose randomly the minor/major hybrid edge to move (if \nrandom=true\n); will get the list of all neighbor edges where to move the origin, will move the origin and update all the attributes and check if the move was successful (not conflicting attributes); if not, will undo the move, and try with a different neighbor until it runs out of neighbors. Return true if the move was successful.\n\n\n\n\nmoveTargetUpdateRepeat!(newT,node,random)\n\n\n\n\nsame as move origin but moving the target\n\n\n\n\nchangeDirectionUpdate!(newT,node,random)\n\n\n\n\nchooses minor/major hybrid edge at random (if `random=true), and changes the direction, and updates all the attributes. Checks if the move was successful (returns true), or undoes the change and returns false.\n\n\n\n\ndeleteHybridizationUpdate!(newT,node)\n\n\n\n\nremoves the hybrid node, updates the attributes, no need to check any attributes, always successful move\n\n\n\n\nNNIRepeat!(newT,N)\n\n\n\n\nchoose an edge for nni that does not have a neighbor hybrid. It will try to find such an edge N times, and if it fails, it will return false (unsuccessful move). N=10 by default. If N=1, it rarely finds such an edge if the network is small or complex. The function cannot choose an external edge. it will update locally the attributes.\n\n\n Important: \n All the moves undo what they did if the move was not successful, so at the end you either have a \nnewT\n with a new move and with all good attributes, or the same \nnewT\n that started. This is important to avoid having to do deepcopy of the network before doing the move. Also, after each move, when we update the attributes, we do not update the attributes of the whole network, we only update the attributes of the edges that were affected by the move. This saves time, but makes the code quite clunky. Only the case of multiple alleles the moves does not undo what it did, because it finds out that it failed after the function is over, so just need to treat this case special.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readCSVtoArray\n \n \nMethod\n.\n\n\nreadCSVtoArray(dat::DataFrame)\nreadCSVtoArray(filename::String)\n\n\n\n\n\nRead a CSV table containing both species names and data, create two separate arrays: one for the species names, a second for the data, in a format that \nparsimonyGF\n needs.\n\n\nWarning:\n\n\n\n\nit will try to find a column 'taxon' or 'species' for the taxon names. If none found, it will assume the taxon names are in column 1.\n\n\nwill use all other columns as characters\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readStartTop\n \n \nMethod\n.\n\n\nreadStartTop(treefile,d::DataCF)\n\n\nfunction to read a tree in parenthetical format from text file treefile and a DataCF object to update the branch lengths according to the average observed CF for any given edge.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readSubtree!\n \n \nMethod\n.\n\n\nreadSubtree!(s::IO, parentNode, numLeft, net, hybrids)\n\n\n\n\n\nRecursive helper method for \nreadTopology\n: read a subtree from an extended Newick topology. input \ns\n: IOStream/IOBuffer.\n\n\nReads additional info formatted as: \n:length:bootstrap:gamma\n. Allows for name of internal nodes without # after closing parenthesis: (1,2)A. Warning if hybrid edge without \u03b3, or if \u03b3 (ignored) without hybrid edge\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.recursionPostOrder\n \n \nMethod\n.\n\n\nrecursionPostOrder(nodes, init_function, tip_function, node_function,\n                   parameters)\nupdatePostOrder(index, nodes, updated_matrix, tip_function, node_function,\n                parameters)\n\n\n\n\n\nGeneric tool to apply a post-order (or topological ordering) algorithm. Used by \ndescendenceMatrix\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.recursionPreOrder!\n \n \nFunction\n.\n\n\nrecursionPreOrder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters)\nrecursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,\n                   hybrid_node_function, parameters)\nupdatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,\n               hybrid_node_function, parameters)\n\n\n\n\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by \nsharedPathMatrix\n and by \npairwiseTaxonDistanceMatrix\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.recursionPreOrder\n \n \nMethod\n.\n\n\nrecursionPreOrder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters)\nrecursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,\n                   hybrid_node_function, parameters)\nupdatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,\n               hybrid_node_function, parameters)\n\n\n\n\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by \nsharedPathMatrix\n and by \npairwiseTaxonDistanceMatrix\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.removeHybrid!\n \n \nMethod\n.\n\n\nremoveHybrid!(net::Network, n::Node)\n\n\n\n\n\nDelete a hybrid node \nn\n from \nnet.hybrid\n, and update \nnet.numHybrid\n. The actual node \nn\n is not deleted. It is kept in the full list \nnet.node\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.resetEdgeNumbers!\n \n \nMethod\n.\n\n\nresetEdgeNumbers\n!(\nnet\n::\nHybridNetwork\n;\n \ncheckPreorder\n=\ntrue\n,\n \nape\n=\ntrue\n)\n\n\n\n\n\n\nCheck that edge numbers of \nnet\n are consecutive numbers from 1 to the total number of edges. If not, reset the edge numbers to be so.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.resetNodeNumbers!\n \n \nMethod\n.\n\n\nresetNodeNumbers\n!(\nnet\n::\nHybridNetwork\n;\n \ncheckPreorder\n=\ntrue\n,\n \nape\n=\ntrue\n)\n\n\n\n\n\n\nChange internal node numbers of \nnet\n to consecutive numbers from 1 to the total number of nodes.\n\n\nkeyword arguments:\n\n\n\n\nape\n: if true, the new numbers satisfy the conditions assumed by the \nape\n R package: leaves are 1 to n, the root is n+1, and internal nodes are higher consecutive integers. If false, nodes are numbered in post-order, with leaves from 1 to n (and the root last).\n\n\ncheckPreorder\n: if false, the \nisChild1\n edge field and the \nnet.nodes_changed\n network field are supposed to be correct (to get nodes in preorder)\n\n\n\n\nExamples\n\n\njulia\n net = readTopology(\n(A,(B,(C,D)));\n);\njulia\n PhyloNetworks.resetNodeNumbers!(net)\njulia\n printNodes(net)\nNode    In Cycle        isHybrid        hasHybEdge      Node label      isLeaf  Edges numbers\n1       -1              false           false           A               true    1\n2       -1              false           false           B               true    2\n3       -1              false           false           C               true    3\n4       -1              false           false           D               true    4\n7       -1              false           false                           false   3       4       5\n6       -1              false           false                           false   2       5       6\n5       -1              false           false                           false   1       6\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sameTaxa\n \n \nMethod\n.\n\n\nsameTaxa(Quartet, HybridNetwork)\n\n\n\n\n\nReturn \ntrue\n if all taxa in the quartet are represented in the network, \nfalse\n if one or more taxa in the quartet does not appear in the network.\n\n\nwarning: the name can cause confusion. A more appropriate name might be \"in\", or \"taxain\", or \"taxonsubset\", or etc.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sampleBootstrapTrees\n \n \nMethod\n.\n\n\nsampleBootstrapTrees(vector of tree lists; seed=0::Integer, generesampling=false, row=0)\nsampleBootstrapTrees!(tree list, vector of tree lists; seed=0::Integer, generesampling=false, row=0)\n\n\n\n\n\nSample bootstrap gene trees, 1 tree per gene. Set the seed with keyword argument \nseed\n, which is 0 by default. When \nseed=0\n, the actual seed is set using the clock. Assumes a vector of vectors of networks (see \nreadBootstrapTrees\n), each one of length 1 or more (error if one vector is empty, tested in \nbootsnaq\n).\n\n\n\n\nsite resampling: always, from sampling one bootstrap tree from each given list. This tree is sampled at \nrandom\n unless \nrow\n0\n (see below).\n\n\ngene resampling: if \ngeneresampling=true\n (default is false), genes (i.e. lists) are sampled with replacement.\n\n\nrow=i\n: samples the ith bootstrap tree for each gene. \nrow\n is turned back to 0 if gene resampling is true.\n\n\n\n\noutput: one vector of trees. the modifying function (!) modifies the input tree list and returns it.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sampleCFfromCI\n \n \nFunction\n.\n\n\nsampleCFfromCI(data frame, seed=0)\nsampleCFfromCI!(data frame, seed=0)\n\n\n\n\n\nRead a data frame containing CFs and their credibility intervals, and sample new obsCF uniformly within the CIs. These CFs are then rescaled to sum up to 1 for each 4-taxon sets. Return a data frame with taxon labels in first 4 columns, sampled obs CFs in columns 5-7 and credibility intervals in columns 8-13.\n\n\n\n\nThe non-modifying function creates a new data frame (with re-ordered columns) and returns it. If \nseed=-1\n, the new df is a deep copy of the input df, with no call to the random number generator. Otherwise, \nseed\n is passed to the modifying function.\n\n\nThe modifying function overwrites the input data frame with the sampled CFs and returns it. If \nseed=0\n, the random generator is seeded from the clock. Otherwise the random generator is seeded using \nseed\n.\n\n\n\n\nWarning: the modifying version does \nnot\n check the data frame: assumes correct columns.\n\n\noptional argument: \ndelim=','\n by default: how columns are delimited.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.setBLGammaParsimony!\n \n \nMethod\n.\n\n\nsetBLGammaParsimony!(net::HybridNetwork)\n\n\nMaximum parsimony function does not provide estimates for branch lengths, or gamma. But since the \nmaxParsimonyNet\n function is using snaq move functions, branch lengths and gamma values are set randomly (to initialize optimization). We need to remove these random values before returning the maximum parsimony network.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.setBranchLength!\n \n \nMethod\n.\n\n\nsetBranchLength!(Edge,new length)\n\n\nsets the length of an Edge object. The new length needs to be non-negative, or -1.0 to be interpreted as missing. Example: if net is a HybridNetwork object, do printEdges(net) to see the list of all edges with their lengths. The length of the 3rd edge can be changed to 1.2 with setBranchLength!(net.edge[3],1.2). It can also be set to missing with setBranchLength!(net.edge[3],-1.0)\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.setGammaBLfromGammaz!\n \n \nMethod\n.\n\n\nsetGammaBLfromGammaz!(node, network)\n\n\nUpdate the \u03b3 values of the two sister hybrid edges in a bad diamond I, given the \ngammaz\n values of their parent nodes, and updates the branch lengths t1 and t2 of their parent edges (those across from the hybrid nodes), in such a way that t1=t2 and that these branch lengths and \u03b3 values are consistent with the \ngammaz\n values in the network.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.setGammas!\n \n \nMethod\n.\n\n\nsetGammas!(net, \u03b3 vector)\n\n\n\n\n\nSet inheritance \u03b3's of hybrid edges, using input vector for \nmajor\n edges. Assume pre-order calculated already, with up-to-date field \nnodes_changed\n. See \ngetGammas\n.\n\n\nVery different from \nsetGamma!\n, which focuses on a single hybrid event, updates the field \nisMajor\n according to the new \u03b3, and is not used here.\n\n\nMay assume a tree-child network.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.setNonIdBL!\n \n \nMethod\n.\n\n\nsetNonIdBL!(net)\n\n\nSet non-identifiable edge branch lengths to -1.0 (i.e. missing) for a level-1 network \nnet\n, except for edges in\n\n\n\n\na good triangle: the edge below the hybrid is constrained to 0.\n\n\na bad diamond II: the edge below the hybrid is constrained to 0\n\n\na bad diamond I: the edges across from the hybrid node have non identifiable lengths but are kept, because the two \u03b3*(1-exp(-t)) values are identifiable.\n\n\n\n\nwill break if \ninCycle\n attributes are not initialized (at -1) or giving a correct node number.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.showQ\n \n \nMethod\n.\n\n\nshowQ(IO, model)\n\n\n\n\n\nPrint the Q matrix to the screen, with trait states as labels on rows and columns. adapted from prettyprint function by mcreel, found 2017/10 at https://discourse.julialang.org/t/display-of-arrays-with-row-and-column-names/1961/6\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sortUnionTaxa!\n \n \nMethod\n.\n\n\nsortUnionTaxa!(taxa)\n\n\n\n\n\nTake a vector of strings \ntaxa\n, sort it numerically if elements can be parsed as an integer, alphabetically otherwise.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.symmetricNet\n \n \nFunction\n.\n\n\nsymmetricNet(n, h, gamma)\n\n\n\n\n\nCreate a string with a symmetric net with 2^n tips, numbered from 1 to 2^n The total height of the network is set to 1. Hybrids are added from level h to h-1 symmetrically.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.symmetricNet\n \n \nMethod\n.\n\n\nsymmetricNet(n, i, j, gamma)\n\n\n\n\n\nCreate a string with a symmetric net with 2^n tips, numbered from 1 to 2^n All the branch length are set equal to 1. One hybrid branch, going from level i to level j is added, with weigth gamma. The tree can be created with function readTopology.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.symmetricTree\n \n \nFunction\n.\n\n\nsymmetricTree(n, i=1)\n\n\n\n\n\nCreate a string with a symmetric tree with 2^n tips, numbered from i to i+2^n-1. All the branch length are set equal to 1. The tree can be created with function readTopology.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.synchronizePartnersData!\n \n \nMethod\n.\n\n\nsynchronizePartnersData!(e::Edge, n::Node)\n\n\n\n\n\nSynchronize \u03b3 and isMajor for edges \ne\n and its partner, both hybrid edges with the same child \nn\n:\n\n\n\n\nif one \u03b3 is missing and the other is not: set the missing \u03b3 to 1 - the other\n\n\n\u03b3's should sum up to 1.0\n\n\nupdate \nisMajor\n to match the \u03b3 information: the major edge is the one with \u03b3 \n 0.5.\n\n\n\n\nWarnings\n: does not check that \ne\n is a hybrid edge, nor that \nn\n is the child of \ne\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.taxadiff\n \n \nMethod\n.\n\n\ntaxadiff(Vector{Quartet}, network; multiplealleles=true)\ntaxadiff(DataCF, network; multiplealleles=true)\n\n\n\n\n\nReturn 2 vectors:\n\n\n\n\ntaxa in at least 1 of the quartets but not in the network, and\n\n\ntaxa in the network but in none of the quartets.\n\n\n\n\nWhen \nmultiplealleles\n is true, the taxon names that end with \"__2\" are ignored in the quartets: they are not expected to appear in the networks that users give as input, or get as output.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.ticr_optimalpha\n \n \nMethod\n.\n\n\nticr_optimalpha(D::DataCF)\n\n\n\n\n\nFind the concentration parameter \u03b1 by maximizing the pseudo-log-likelihood of observed quartet concordance factors. The model assumes a Dirichlet distribution with mean equal to the expected concordance factors calculated from a phylogenetic network (under ILS and reticulation). These expected CFs are assumed to be already calculated, and stored in D.\n\n\nWhen calculating the pseudo-log-likelihood, this function will check the observed concordance factors for any values equal to zero: they cause a problem because the Dirichlet density is 0 at 0 (for concentrations \n 1). Those 0.0 observed CF values are re-set to the minimum of:\n\n\n\n\nthe minimum of all expected concordance factors, and\n\n\nthe minimum of all nonzero observed concordance factors.\n\n\n\n\noutput:\n\n\n\n\nmaximized pseudo-loglikelihood\n\n\nvalue of \u03b1 where the pseudo-loglikelihood is maximized\n\n\nreturn code of the optimization\n\n\n\n\nThe optimization uses NLOpt, with the \n:LN_BOBYQA\n method. Optional arguments can tune the optimization differently: \nNLoptMethod\n, \nxtol_rel\n (1e-6 by default), starting \u03b1 value \nx_start\n (1.0 by default).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.traitlabels2indices\n \n \nMethod\n.\n\n\ntraitlabels2indices(data, model::TraitSubstitutionModel)\n\n\n\n\n\nCheck that the character states in \ndata\n are compatible with (i.e. subset of) the trait labels in \nmodel\n. All columns are used. \ndata\n can be a DataFrame or a Matrix (multiple traits), or a Vector (one trait).\n\n\nReturn a vector of vectors (one per species) with integer entries, where each state (label) is replaced by its index in \nmodel\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.traverseContainRoot!\n \n \nMethod\n.\n\n\nupdateContainRoot!(HybridNetwork, Node)\ntraverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})\n\n\n\n\n\nThe input \nnode\n to \nupdateContainRoot!\n must be a hybrid node (can come from searchHybridNode). \nupdateContainRoot!\n starts at the input node and calls \ntraverseContainRoot!\n, which traverses the network recursively. By default, containRoot attributes of edges are true. Changes containRoot to false for all the visited edges: those below the input node, but not beyond any other hybrid node.\n\n\nupdateContainRoot!\n Returns a \nflag\n and an array of edges whose containRoot has been changed from true to false. \nflag\n is false if the set of edges to place the root is empty\n\n\nIn \ntraverseContainRoot!\n, \nrightDir\n turns false if hybridizations have incompatible directions (vector of length 1, to be modified).\n\n\nWarning:\n\n\n\n\ndoes \nnot\n update containRoot of minor hybrid edges.\n\n\nassumes correct isMajor attributes: to stop the recursion at minor hybrid edges.\n\n\nassumes correct hybrid attributes of both nodes \n edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.updatePostOrder!\n \n \nFunction\n.\n\n\nrecursionPostOrder(nodes, init_function, tip_function, node_function,\n                   parameters)\nupdatePostOrder(index, nodes, updated_matrix, tip_function, node_function,\n                parameters)\n\n\n\n\n\nGeneric tool to apply a post-order (or topological ordering) algorithm. Used by \ndescendenceMatrix\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.updatePreOrder!\n \n \nFunction\n.\n\n\nrecursionPreOrder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters)\nrecursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,\n                   hybrid_node_function, parameters)\nupdatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,\n               hybrid_node_function, parameters)\n\n\n\n\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by \nsharedPathMatrix\n and by \npairwiseTaxonDistanceMatrix\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.writeTopologyLevel1\n \n \nMethod\n.\n\n\nwriteTopologyLevel1(net::HybridNetwork)\n\n\nWrite the extended Newick parenthetical format of a level-1 network object with many optional arguments (see below). Makes a deep copy of net: does \nnot\n modify \nnet\n.\n\n\n\n\ndi=true: write in format for Dendroscope (default false)\n\n\nnames=false: write the leaf nodes numbers instead of taxon names (default true)\n\n\noutgroup (string): name of outgroup to root the tree/network. if \"none\" is given, the root is placed wherever possible.\n\n\nprintID=true, only print branch lengths for identifiable egdes according to the snaq estimation procedure (default false) (true inside of \nsnaq!\n.)\n\n\nround: rounds branch lengths and heritabilities \u03b3 (default: true)\n\n\ndigits: digits after the decimal place for rounding (defult: 3)\n\n\nstring: if true (default), returns a string, otherwise returns an IOBuffer object.\n\n\nmultall: (default false). set to true when there are multiple alleles per population.\n\n\n\n\nThe topology may be written using a root different than net.root, if net.root is incompatible with one of more hybrid node. Missing hybrid names are written as \"#Hi\" where \"i\" is the hybrid node number if possible.\n\n\nsource\n\n\n#\n\n\nStatsBase.fit\n \n \nMethod\n.\n\n\nfit(StatisticalSubstitutionModel, net, model, traits; kwargs...)\nfit!(StatisticalSubstitutionModel; kwargs...)\n\n\n\n\n\nInternal function called by \nfitDiscrete\n: with same key word arguments \nkwargs\n. But dangerous: \ntraits\n should be a vector of vectors as for \nfitDiscrete\n \nbut\n here \ntraits\n need to contain the \nindices\n of trait values corresponding to the indices in \nmodel.label\n, and species should appear in \ntraits\n in the order corresponding to the node numbers in \nnet\n. See \ntraitlabels2indices\n to convert trait labels to trait indices.\n\n\nWarning\n: does \nnot\n perform checks. \nfitDiscrete\n calls this function after doing checks, preordering nodes in the network, making sure nodes have consecutive numbers, species are matched between data and network etc.\n\n\nsource", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/internals/#internal-documentation", 
            "text": "", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/lib/internals/#contents", 
            "text": "Internal Documentation  Contents  Index  types  functions", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/internals/#index", 
            "text": "PhyloNetworks.ANode  PhyloNetworks.MatrixTopologicalOrder  PhyloNetworks.StatisticalSubstitutionModel  Base.getindex  Base.getindex  PhyloNetworks.addAlternativeHybridizations!  PhyloNetworks.afterOptBL!  PhyloNetworks.afterOptBLAll!  PhyloNetworks.afterOptBLRepeat!  PhyloNetworks.anova  PhyloNetworks.assignhybridnames!  PhyloNetworks.blobInfo  PhyloNetworks.breakedge!  PhyloNetworks.calculateObsCFAll!  PhyloNetworks.checkNumHybEdges!  PhyloNetworks.check_matchtaxonnames!  PhyloNetworks.deleteEdge!  PhyloNetworks.deleteHybridEdge!  PhyloNetworks.deleteLeaf!  PhyloNetworks.deleteNode!  PhyloNetworks.descendants  PhyloNetworks.discrete_backwardlikelihood_tree!  PhyloNetworks.discrete_corelikelihood!  PhyloNetworks.discrete_corelikelihood_tree!  PhyloNetworks.displayedNetworks!  PhyloNetworks.fuseedgesat!  PhyloNetworks.gammaZero!  PhyloNetworks.getChild  PhyloNetworks.getChildren  PhyloNetworks.getDataValue!  PhyloNetworks.getGammas  PhyloNetworks.getHeights  PhyloNetworks.getMajorParent  PhyloNetworks.getMajorParentEdge  PhyloNetworks.getMinorParent  PhyloNetworks.getMinorParentEdge  PhyloNetworks.getParent  PhyloNetworks.getParents  PhyloNetworks.getPartner  PhyloNetworks.getTipSubmatrix  PhyloNetworks.hybridEdges  PhyloNetworks.hybridEdges  PhyloNetworks.inheritanceWeight  PhyloNetworks.initializeWeightsFromLeaves!  PhyloNetworks.initializeWeightsFromLeavesSoftwired!  PhyloNetworks.majoredgelength  PhyloNetworks.majoredgematrix  PhyloNetworks.makemissing!  PhyloNetworks.mapAllelesCFtable!  PhyloNetworks.maxParsimonyNetRun1  PhyloNetworks.maxParsimonyNetRun1!  PhyloNetworks.minorreticulationgamma  PhyloNetworks.minorreticulationlength  PhyloNetworks.minorreticulationmatrix  PhyloNetworks.moveHybrid!  PhyloNetworks.nparams  PhyloNetworks.optBL!  PhyloNetworks.optTopLevel!  PhyloNetworks.optTopRun1!  PhyloNetworks.optTopRuns!  PhyloNetworks.pairwiseTaxonDistanceGrad  PhyloNetworks.parseEdgeData!  PhyloNetworks.parseHybridNode!  PhyloNetworks.parseRemainingSubtree!  PhyloNetworks.parseTreeNode!  PhyloNetworks.parsimonyBottomUpFitch!  PhyloNetworks.parsimonyBottomUpGF!  PhyloNetworks.parsimonyBottomUpSoftwired!  PhyloNetworks.parsimonyDiscreteFitch  PhyloNetworks.parsimonySummaryFitch  PhyloNetworks.parsimonyTopDownFitch!  PhyloNetworks.proposedTop!  PhyloNetworks.readCSVtoArray  PhyloNetworks.readStartTop  PhyloNetworks.readSubtree!  PhyloNetworks.recursionPostOrder  PhyloNetworks.recursionPreOrder  PhyloNetworks.recursionPreOrder!  PhyloNetworks.removeHybrid!  PhyloNetworks.resetEdgeNumbers!  PhyloNetworks.resetNodeNumbers!  PhyloNetworks.sameTaxa  PhyloNetworks.sampleBootstrapTrees  PhyloNetworks.sampleCFfromCI  PhyloNetworks.setBLGammaParsimony!  PhyloNetworks.setBranchLength!  PhyloNetworks.setGammaBLfromGammaz!  PhyloNetworks.setGammas!  PhyloNetworks.setNonIdBL!  PhyloNetworks.showQ  PhyloNetworks.sortUnionTaxa!  PhyloNetworks.symmetricNet  PhyloNetworks.symmetricNet  PhyloNetworks.symmetricTree  PhyloNetworks.synchronizePartnersData!  PhyloNetworks.taxadiff  PhyloNetworks.ticr_optimalpha  PhyloNetworks.traitlabels2indices  PhyloNetworks.traverseContainRoot!  PhyloNetworks.updatePostOrder!  PhyloNetworks.updatePreOrder!  PhyloNetworks.writeTopologyLevel1  StatsBase.fit", 
            "title": "Index"
        }, 
        {
            "location": "/lib/internals/#types", 
            "text": "#  PhyloNetworks.ANode     Type .  ANode  Abstract node. An object of type  Edge  has a  node  attribute, which is an vector of (2) ANode objects. The object of type  Node  is an  ANode , and has an  edge  attribute, which is vector of  Edge  objects.  source  #  PhyloNetworks.MatrixTopologicalOrder     Type .  MatrixTopologicalOrder  Matrix associated to an  HybridNetwork  sorted in topological order.  The following functions and extractors can be applied to it:  tipLabels ,  obj[:Tips] ,  obj[:InternalNodes] ,  obj[:TipsNodes]  (see documentation for function  getindex(::MatrixTopologicalOrder, ::Symbol) ).  Functions  sharedPathMatrix  and  simulate  return objects of this type.  The  MatrixTopologicalOrder  object has fields:  V ,  nodeNumbersTopOrder ,  internalNodeNumbers ,  tipNumbers ,  tipNames ,  indexation . Type in \"?MatrixTopologicalOrder.field\" to get documentation on a specific field.  source  #  PhyloNetworks.StatisticalSubstitutionModel     Type .  StatisticalSubstitutionModel  Subtype of  StatsBase.StatisticalModel , to fit discrete data to a model of trait substitution along a network. See  fitDiscrete  to fit a trait substitution model to discrete data. It returns an object of type  StatisticalSubstitutionModel , to which standard functions can be applied, like  loglikelihood(object) ,  aic(object)  etc.  source", 
            "title": "types"
        }, 
        {
            "location": "/lib/internals/#functions", 
            "text": "#  Base.getindex     Function .  getindex(obj, d,[ indTips, msng])  Getting submatrices of an object of type  MatrixTopologicalOrder .  Arguments   obj::MatrixTopologicalOrder : the matrix from which to extract.   d::Symbol : a symbol precising which sub-matrix to extract. Can be:   :Tips  columns and/or rows corresponding to the tips  :InternalNodes  columns and/or rows corresponding to the internal nodes  :TipsNodes  columns corresponding to internal nodes, and row to tips (works only is indexation=\"b\")  indTips::Vector{Int} : optional argument precising a specific order for the tips (internal use).  msng::BitArray{1} : optional argument precising the missing tips (internal use).     source  #  Base.getindex     Function .  getindex(obj, d)  Getting submatrices of an object of type  TraitSimulation .  Arguments   obj::TraitSimulation : the matrix from which to extract.   d::Symbol : a symbol precising which sub-matrix to extract. Can be:   :Tips  columns and/or rows corresponding to the tips  :InternalNodes  columns and/or rows corresponding to the internal nodes     source  #  PhyloNetworks.addAlternativeHybridizations!     Method .  addAlternativeHybridizations !( net :: HybridNetwork ,   BSe :: DataFrame ; \n                               cutoff = 10 :: Number ,   top = 3 :: Int )   Modify the network  net  (the best network estimated with snaq) by adding other hybridizations that are present in the bootstrap networks. By default, it will only consider hybrid edges with more than 10% bootstrap support ( cutoff ) and it will only include the three top hybridizations ( top ) sorted by bootstrap support. The function also modifies the dataframe  BSe  obtained with  hybridBootstrapSupport . In the original  BSe  dataframe, hybrid edges that do not appear in the best network have a missing number. After the hybrid edges are added with  addAlternativeHybridizations ,  BSe  is modified to include the edge numbers of the newly added hybrid edges. Note that the function only adds the hybrid edges as minor to keep the underlying tree topology.  example  bootnet   =   readMultiTopology ( bootstrap-networks.txt )  bestnet   =   readTopology ( best.tre )  BSn ,   BSe ,   BSc ,   BSgam ,   BSedgenum   =   hybridBootstrapSupport ( bootnet ,   bestnet );  addAlternativeHybridizations! ( bestnet , BSe )  using   PhyloPlots  plot ( bestnet ,   edgeLabel = BSe [[ : edge , : BS_hybrid_edge ]])   source  #  PhyloNetworks.afterOptBL!     Method .  afterOptBL  road map  Function that will check if there are  h==0,1;t==0,hz==0,1  cases in a network after calling  optBL! .  Arguments:   closeN=true  will move origin/target, if false, add/delete N times before giving up (we have only tested  closeN=true )  origin=true  will move origin, false will move target. We added this to avoid going back and forth between the same networks  movesgamma  vector of counts of number of times each move is proposed to fix a gamma zero problem:  (add,mvorigin,mvtarget,chdir,delete,nni)   Procedure:   First we split the  ht  vector in  nh,nt,nhz  (gammas, lengths, gammaz)   If we find a  h==0,1 , we loop through  nh  to find a hybrid edge with h==0 or 1 and want to try to fix this by doing:   gammaZero!(currT,d,edge,closeN,origin,N,movesgamma)  which returns true if there was a successful change, and we stop the loop  If we find a  t==0 , we loop through all  nt  to find such edge, and do NNI move on this edge; return true if change successful and we stop the loop  If we find a  hz==0,1 , we loop through  nhz  to find such hybrid edge and call  gammaZero  again  If we did a successful change, we run  optBL  again, and recheck if there are no more problems.  Returns successchange, flagh, flagt,flaghz (flag=true means no problems)  If it is the multiple alleles case, it will not try to fix  h==0,1;hz==0,1  because it can reach a case that violates the multiple alleles condition. If we add a check here, things become horribly slow and inefficient, so we just delete a hybridization that has  h==0,1;hz==0,1      Important:    afterOptBL  is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call  afterOptBLRepeat  source  #  PhyloNetworks.afterOptBLAll!     Method .  afterOptBLAll  road map  After  optBL , we want to call  afterOptBLAll  (or  afterOptBLAllMultipleAlleles ) to check if there are  h==0,1 ;  t==0 ;  hz==0,1 . This function will try to fix the gamma zero problem, but if it cannot, it will call  moveDownLevel , to delete the hybridization from the network.  Procedure:  While  startover=true  and  tries N    While  badliks   N2  (number of bad pseudolikelihoods are less than  N2 )   Run  success = afterOptBLRepeat   If  success = true  (it changed something):   If worse pseudolik, then go back to original topology  currT , set  startover=true  and  badliks++   If better pseudolik, then check flags. If all good, then  startover=false ; otherwise  startover = true   If  success = false  (nothing changed), then set  badliks=N2+1  (to end the while on  currT )     If all flags are ok, then  startover = false   If bad h or hz, then call  moveDownLevel  (delete one hybridization), and set  startover = true  (maybe deleting that hybridization did not fix other gamma zero problems)  If bad t, then set  startover = false  If left second while by back to original  currT , and still bad h/hz, then move down one level, and  startover=true ; otherwise  startover=false       If first while ends by  tries N , then it checks one last time the flags, if bad h/hz will move down one level, and exit  source  #  PhyloNetworks.afterOptBLRepeat!     Method .  afterOptBLRepeat  road map  afterOptBL  is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call  afterOptBLRepeat . This function will repeat  afterOptBL  every time a successful change happened; this is done only if  closeN=false , because we would delete/add hybridizations and need to stop after tried N times. If  closeN=true  (default), then  afterOptBLRepeat  only does one  afterOptBL , because in this case, only the neighbor edges need to be tested, and this would have been done already in  gammaZero .  source  #  PhyloNetworks.anova     Method .  anova(objs::PhyloNetworkLinearModel...)  Takes several nested fits of the same data, and computes the F statistic for each pair of models.  The fits must be results of function  phyloNetworklm  called on the same data, for models that have more and more effects.  Returns a DataFrame object with the anova table.  source  #  PhyloNetworks.assignhybridnames!     Method .  assignhybridnames!(net)  Assign names to hybrid nodes in the network  net . Hybrid nodes with an empty  name  field (\"\") are modified with a name that does not conflict with other hybrid names in the network. The preferred name is \"#H3\" if the node number is 3 or -3, but an index other than 3 would be used if \"#H3\" were the name of another hybrid node already.  If two hybrid nodes have non-empty and equal names, the name of one of them is changed and re-assigned as described above (with a warning).  source  #  PhyloNetworks.blobInfo     Function .  blobInfo(network, ignoreTrivial=true)  Calculate the biconnected components (blobs) using function  biconnectedComponents  then:   set node field  isExtBadTriangle  to true at the root of each non-trivial blob (and at the network root), false otherwise. (a better name for the field would be something like \"isBlobRoot\".)   output:   array of nodes that are the roots of each non-trivial blob,   and the network root. If the root of the full network is   not part of a non-trivial blob, a corresponding blob is   added to the list.   array of arrays: for each non-trivial blob, array of major hybrid edges in that blob.  array of arrays: same as #2 but for minor hybrid edges, with hybrids listed in the same order, for each blob.     Blobs are ordered in reverse topological ordering (aka post order). If  ignoreTrivial  is true, trivial components are ignored.  keyword argument:  checkPreorder , true by default. If false, the  isChild1  edge field and the  net.nodes_changed  network field are supposed to be correct.  source  #  PhyloNetworks.breakedge!     Method .  breakedge!(Edge, HybridNetwork)  breaks an edge into 2 edges (each of length half that of original edge). creates new node of degree 2. Useful to root network along an edge.  warning: updates  isChild1  and  containRoot , but does NOT update attributes like: inCycle, partition, gammaz, etc.  returns the index of the newly created node in the network  source  #  PhyloNetworks.calculateObsCFAll!     Method .  calculateObsCFAll!(DataCF, taxa::Union{Vector{String}, Vector{Int}})  update the .quartet[i].obsCF values of the DataCF object, based on its .tree vector.  calculateObsCFAll!(vector of quartets, vector of trees, taxa)  update the .obsCF values of the quartets, based on the trees, and returns a new DataCF object with these updated quartets and trees.  calculateObsCFAll_noDataCF!(vector of quartets, vector of trees, taxa)  update the .obsCF values of the quartets based on the trees, but returns nothing.  source  #  PhyloNetworks.checkNumHybEdges!     Method .  `checkNumHybEdges!(net)`  Check for consistency between hybrid-related attributes in the network:   for each hybrid node: 2 or more hybrid edges  exception: allows for a leaf to be attached to a single hybrid edge  exactly 2 incoming parent hybrid edges   Run after  storeHybrids! . See also  check2HybEdges .  source  #  PhyloNetworks.check_matchtaxonnames!     Method .  check_matchtaxonnames!(species, data, net)  Modify  species  and  dat  by removing the species (rows) absent from the network. Return a new network ( net  is  not  modified) with tips matching those in species: if some species in  net  have no data, these species are pruned from the network. The network also has its node names reset, such that leaves have nodes have consecutive numbers starting at 1, with leaves first. Used by  fitDiscrete  to build a new  StatisticalSubstitutionModel .  source  #  PhyloNetworks.deleteEdge!     Method .  deleteEdge!(net::HybridNetwork,  e::Edge, part=true)\ndeleteEdge!(net::QuartetNetwork, e::Edge)  Delete edge  e  from  net.edge  and update  net.numEdges . If  part  is true, update the network's partition field.  source  #  PhyloNetworks.deleteHybridEdge!     Function .  deleteHybridEdge!(net::HybridNetwork, edge::Edge, keepNodes=false)  Deletes a hybrid edge from a network. The network does not have to be of level 1, and may contain some polytomies. Updates branch lengths, allowing for missing values. Returns the network.  At each of the 2 junctions, the child edge is retained (below the hybrid node). If  keepNodes  is true, all nodes are retained during edge removal.  Warnings:   if  keepNodes  is true: partner hybrid parent edge has its \u03b3 value unchanged  if the parent of  edge  is the root and if  keepNodes  is false, the root is moved to keep the network unrooted with a root of degree two.  does  not  update containRoot (could be implemented later)  does  not  update attributes needed for snaq! (like containRoot, inCycle, edge.z, edge.y etc.)   source  #  PhyloNetworks.deleteLeaf!     Method .  deleteLeaf!(net::HybridNetwork, leaf::AbstractString)   deleteLeaf!(net::Network, leaf::Node)  Deletes the leaf taxon from the network. The leaf argument is the name of the taxon to delete.  Warnings:   requires a level-1 network with up-to-date attributes for snaq! (e.g. non-missing branch lengths, gammaz, etc.)  does not care where the root is and does not update it to a sensible location if the root is affected by the leaf removal.  does not merge edges, i.e. does not remove all nodes of degree 2. Within snaq!, this is used to extract quartets and to keep track of which edge lengths in the original network map to the quartet network.   source  #  PhyloNetworks.deleteNode!     Method .  deleteNode!(net::HybridNetwork, n::Node)  deletes a Node from a network, i.e. removes it from net.node, and from net.hybrid or net.leaf as appropriate. Updates attributes numNodes, numTaxa, numHybrids (it does not update net.names though).  Warning: if the root is deleted, the new root is arbitrarily set to the first node in the list. This is intentional to save time because this function is used frequently in snaq!, which handles semi-directed (unrooted) networks.  source  #  PhyloNetworks.descendants     Method .  descendants(edge::Edge)  Return the node numbers of all the descendants of a given edge.  The node should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.  Examples: #\"  julia  net5 =  (A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));  |  readTopology |  directEdges! ;\n\njulia  PhyloNetworks.descendants(net5.edge[12]) # descendants of 12th\n7-element Array{Int64,1}:\n -6\n -7\n  4\n  6\n  5\n -9\n  7  source  #  PhyloNetworks.discrete_backwardlikelihood_tree!     Method .  discrete_backwardlikelihood_tree!(obj::SSM, tree::Integer, trait::Integer)  Update  obj.backwardlik ; assume correct forward likelihood, directional likelihood and transition probabilities.  source  #  PhyloNetworks.discrete_corelikelihood!     Method .  discrete_corelikelihood !( obj :: StatisticalSubstitutionModel ;   whichtrait = : all )  discrete_corelikelihood_tree !( obj ,   t :: Integer ,   traitrange :: AbstractArray )   Calculate the likelihood and update  obj.loglik  for discrete characters on a network (or on a single tree:  t th tree displayed in the network, for the second form). Update forward and direct partial likelihoods while doing so. The algorithm extracts all displayed trees and weights the likelihood under all these trees.  source  #  PhyloNetworks.discrete_corelikelihood_tree!     Function .  discrete_corelikelihood !( obj :: StatisticalSubstitutionModel ;   whichtrait = : all )  discrete_corelikelihood_tree !( obj ,   t :: Integer ,   traitrange :: AbstractArray )   Calculate the likelihood and update  obj.loglik  for discrete characters on a network (or on a single tree:  t th tree displayed in the network, for the second form). Update forward and direct partial likelihoods while doing so. The algorithm extracts all displayed trees and weights the likelihood under all these trees.  source  #  PhyloNetworks.displayedNetworks!     Function .  displayedNetworks!(net::HybridNetwork, node::Node, keepNode=false)  Extracts the two networks that simplify a given network at a given hybrid node: deleting either one or the other parent hybrid edge. If  keepNodes  is true, all original nodes are kept in both networks.   the original network is modified: the minor edge removed.  returns one HybridNetwork object: the network with the major edge removed   source  #  PhyloNetworks.fuseedgesat!     Method .  fuseedgesat!(i::Integer,net::HybridNetwork)  Removes  i th node in net.node, if it is of degree 2. The parent and child edges of this node are fused. Reverts the action of breakedge!.  returns the fused edge.  source  #  PhyloNetworks.gammaZero!     Method .  gammaZero  road map  Function that tries to fix a gamma zero problem ( h==0,1; t==0; hz==0,1 )   First tries to do  changeDirection  If not successful from start, we call  moveHybrid  If successful move (change direction), we call  optBL  and check if we fixed the problem  If problem fixed and we do not have worse pseudolik, we return  success=true  If still problem or worse pseudolik, we call  moveHybrid    Important:   Any function ( afterOptBL ) calling  gammaZero  is assuming that it only made a change, so if the returned value is true, then a change was made, and the other function needs to run  optBL  and check that all parameters are 'valid'. If the returned value is false, then no change was possible and we need to remove a hybridization if the problem is h==0,1; hz==0,1. If the problem is t==0, we ignore this problem.  source  #  PhyloNetworks.getChild     Method .  getChild(edge::Edge)  Return child node using the  isChild1  attribute of the edge.  source  #  PhyloNetworks.getChildren     Method .  getChildren(node)  return a vector with all children  nodes  of  node .    warning : assume  isChild1  field (for edges) are correct  To get all parent  nodes : see  getParents .    source  #  PhyloNetworks.getDataValue!     Method .  getdataValue!(s::IO, int, numLeft::Array{Int,1})  Helper function for  parseEdgeData! . Read a single floating point edge data value in a tree topology. Return -1.0 if no value exists before the next colon, return the value as a float otherwise. Modifies s by advancing past the next colon character. Only call this function to read a value when you know a numerical value exists!  source  #  PhyloNetworks.getGammas     Method .  getGammas(net)  Get inheritance \u03b3's of major hybrid edges. Assume pre-order calculated already (with up-to-date field  nodes_changed ). See  setGammas!  source  #  PhyloNetworks.getHeights     Method .  getHeights(net)  Return the height (distance to the root) of all nodes, assuming a time-consistent network (where all paths from the root to a given hybrid node have the same length). Also assumes that the network has been preordered, because it uses  getGammas  and  setGammas! ).  source  #  PhyloNetworks.getMajorParent     Method .  getMajorParent(node::Node)\ngetMinorParent(node::Node)  Return major or minor parent of a node using the  isChild1  field of edges (and assuming correct  isMajor  field). See also  getMajorParentEdge  and  getMinorParentEdge  source  #  PhyloNetworks.getMajorParentEdge     Method .  getMajorParentEdge(node)\ngetMinorParentEdge(node)  return the parent edge of a given node: the major / minor if hybrid.    warning : assume isChild1 and isMajor attributes are correct  To get all parent  nodes : see  getParents .    source  #  PhyloNetworks.getMinorParent     Function .  getMajorParent(node::Node)\ngetMinorParent(node::Node)  Return major or minor parent of a node using the  isChild1  field of edges (and assuming correct  isMajor  field). See also  getMajorParentEdge  and  getMinorParentEdge  source  #  PhyloNetworks.getMinorParentEdge     Function .  getMajorParentEdge(node)\ngetMinorParentEdge(node)  return the parent edge of a given node: the major / minor if hybrid.    warning : assume isChild1 and isMajor attributes are correct  To get all parent  nodes : see  getParents .    source  #  PhyloNetworks.getParent     Method .  getParent(e::Edge)  Return parent node of edge  e  using the  isChild1  attribute of the edge. To get parents of nodes: see  getParents .  source  #  PhyloNetworks.getParents     Method .  getParents(n::Node)  Get vector of all parent nodes of  n , based on  isChild1  field (for edges). To get the parent node of an edge: see  getParent .   To get individual parent edges (rather than all parent  nodes ): see  getMajorParentEdge  and  getMinorParentEdge .  source  #  PhyloNetworks.getPartner     Method .  getPartner(edge::Edge)\ngetPartner(edge::Edge, node::Node)  Return hybrid partner of edge, that is, hybrid edge pointing to the same child as  edge . Assumptions (not checked):   correct  isChild1  field for  edge  and for hybrid edges  no in-coming polytomy: a node has 0, 1 or 2 parents, no more   When  node  is given, it is assumed to be the child of  edge  (the first form calls the second).  source  #  PhyloNetworks.getTipSubmatrix     Method .  getTipSubmatrix(M, net; indexation=:both)  Extract submatrix of M, with rows and/or columns corresponding to tips in the network, ordered like in  net.leaf . In M, rows and/or columns are assumed ordered as in  net.nodes_changed .  indexation: one of  :rows ,  :cols  or  :both : are nodes numbers indexed in the matrix by rows, by columns, or both? Subsetting is taken accordingly.  source  #  PhyloNetworks.hybridEdges     Method .  hybridEdges(node::Node, e::Edge)  Return the 2 edges connected to  node  other than  e , in the same order as  node.edge , except that  e  absent from the list.  Despite what the name suggest,  node  need not be a hybrid node!  node  is assumed to have 3 edges, though.  source  #  PhyloNetworks.hybridEdges     Method .  hybridEdges(node::Node)  Return the 3 edges attached to  node  in a specific order [e1,e2,e3].  Warning : assume a level-1 network with node field  hasHybEdge  and edge field  inCycle  up-to-date.  If  node  is a hybrid node:   e1 is the major hybrid parent edge of  node  e2 is the minor hybrid parent edge  e3 is the tree edge, child of  node .   If  node  is a tree node parent of one child edge:   e1 is the hybrid edge, child of  node  e2 is the tree edge that belongs to the cycle created by e1  e3 is the other tree edge attached to  node  (not in a cycle)   Otherwise:   e3 is an external edge from  node  to a leaf, if one exists.   source  #  PhyloNetworks.inheritanceWeight     Method .  inheritanceWeight(tree::HybridNetwork)  Return the  log  inheritance weight of a network or tree (as provided by  displayedTrees  with  keepNodes  = true for instance). For a tree displayed in a network, its inheritance weight is the log of the product of \u03b3's of all edges retained in the tree. To avoid underflow, the log is calculated: i.e. sum of log(\u03b3) across retained edges.  If any edge has a negative \u03b3, it is assumed to mean that its \u03b3 is missing, and the function returns  missing .  Example  julia   net   =   readTopology ( (((A,(B)#H1:::0.9),(C,#H1:::0.1)),D); );  julia   trees   =   displayedTrees ( net , 0 . 0 ;   keepNodes = true );  julia   PhyloNetworks . inheritanceWeight .( trees )  2-element   Array { Float64,1 } : \n  -0 . 105361 \n  -2 . 30259    source  #  PhyloNetworks.initializeWeightsFromLeaves!     Method .  initializeWeightsFromLeaves!(w, net, tips, stateset, criterion)  Modify weight in w: to Inf for w[n, i] if the \"tips\" data has a state different from the lineage state of index i at node number n. Assumes that w was initialized to 0 for the leaves.  criterion: should be one of  :softwired ,  :parental  or  :hardwired .   softwired parsimony: lineage states are in this order: \u2205,{1},{2},{3},...,{nstates}   source  #  PhyloNetworks.initializeWeightsFromLeavesSoftwired!     Method .  initializeWeightsFromLeavesSoftwired!(w, net, tips, charset)  Modify weight in w: to Inf for w[n, s] if the \"tips\" data has a state different from s at node number n. Assumes that w was initialized to 0 for the leaves.  source  #  PhyloNetworks.majoredgelength     Method .  majoredgelength(net::HybridNetwork)  Generate vector of edge lengths of major  net  edges organized in the same order as the  edge  matrix created via  majoredgematrix . Considers values of  -1.0  as missing values, recognized as NA in  R . Output: vector allowing for missing values.  Assume  nodes_changed  was updated, to list nodes in pre-order.  Examples  julia   net   =   readTopology ( (((A:3.1,(B:0.2)#H1:0.3::0.9),(C,#H1:0.3::0.1):1.1),D:0.7); );  julia   directEdges !( net );   preorder !( net );  julia   PhyloNetworks . majoredgelength ( net )  8-element   Array { Union{Float64,   Missings.Missing } , 1 } : \n   missing \n  0 . 7      \n   missing \n  1 . 1      \n   missing \n  3 . 1      \n  0 . 3      \n  0 . 2        source  #  PhyloNetworks.majoredgematrix     Method .  majoredgematrix(net::HybridNetwork)  Matrix of major edges from  net  where edge[i,1] is the number of the parent node of edge i and edge[i,2] is the number of the child node of edge i. Assume  nodes_changed  was updated, to list nodes in pre-order.  Examples  julia  net = readTopology( (A,(B,(C,D))); );\n\njulia  PhyloNetworks.resetNodeNumbers!(net);\n\njulia  PhyloNetworks.majoredgematrix(net)\n6\u00d72 Array{Int64,2}:\n 5  1\n 5  6\n 6  2\n 6  7\n 7  3\n 7  4  source  #  PhyloNetworks.makemissing!     Method .  makemissing!(x::AbstractVector)  Turn to  missing  any element of  x  exactly equal to -1.0. Used for branch lengths and \u03b3s.  x  needs to accept missing values. If not, this can be done with  allowmissing(x) .  source  #  PhyloNetworks.mapAllelesCFtable!     Method .  mapAllelesCFtable!(quartet CF DataFrame, mapping DataFrame, columns, write?, filename)  Modify (and return) the quartet concordance factor (CF) DataFrame: replace each allele name by the species name that the allele maps onto based on the mapping data frame. This mapping data frame should have columns named \"allele\" and \"species\" (see  rename!  to change column names if need be).  If  write?  is  true , the modified data frame is written to a file named \"filename\".  Warning:  mapAllelesCFtable  takes the quartet data file as its second argument, while  mapAllelesCFtable!  takes the quartet data (which it modifies) as its first argument.  source  #  PhyloNetworks.maxParsimonyNetRun1     Function .  Road map for various functions behind maxParsimonyNet  maxParsimonyNet\nmaxParsimonyNetRun1\nmaxParsimonyNetRun1!  All return their optimized network. Only maxParsimonyNet returns a rooted network (though all functions guarantee that the returned networks agree with the outgroup).   maxParsimonyNet calls maxParsimonyNetRun1 per run, after a read(write(.)) of the starting network (to ensure level-1 and semi-directedness).  maxParsimonyNetRun1 will make a copy of the topology, and will call findStartingTopology! to modify the topology according to random NNI/move origin/move target moves. It then calls maxParsimonyNetRun1! on the modified network  maxParsimonyNetRun1! proposes new network with various moves (same moves as snaq), and stops when it finds the most parsimonious network, using  parsimonyGF .   None of these functions allow for multiple alleles yet.  Note that the search algorithm keeps two HybridNetworks at a time: currT (current topology) and newT (proposed topology). Both are kept unrooted (semi-directed), otherwise the moves in proposedTop! function fail. We only root the topologies to calculate the parsimony, so we create a rooted copy (currTr, newTr) to compute parsimony score in this copied topology. We do not root and calculate parsimony score in the original HybridNetworks objects (currT,newT) because the computation of the parsimony score overwrites the inCycle attribute of the Nodes, which messes with the search moves.  Extensions:   other criteria: hardwired, parental (only softwired implemented now)   remove level-1 restriction: this will involve changing the proposedTop! function to use rSPR or rNNI moves (instead of the level-1 moves coded for snaq!). We need:   functions for rSPR and rNNI moves  create new proposedTop! function (proposedRootedTop?) to choose from the rSPR/rNNI/other moves  have the search in maxParsimonuNetRun1! to have rooted currT and rooted newT, instead of keeping semi-directed objects (currT, newT), only to root for the parsimony score (currTr, newTr)  outgroup is currently String or Node number, but it would be good if it allowed Edge number as an option too. Not sure best way to distinguish between Node number and Edge number, which is why left as Node number for now.     source  #  PhyloNetworks.maxParsimonyNetRun1!     Function .  Road map for various functions behind maxParsimonyNet  maxParsimonyNet\nmaxParsimonyNetRun1\nmaxParsimonyNetRun1!  All return their optimized network. Only maxParsimonyNet returns a rooted network (though all functions guarantee that the returned networks agree with the outgroup).   maxParsimonyNet calls maxParsimonyNetRun1 per run, after a read(write(.)) of the starting network (to ensure level-1 and semi-directedness).  maxParsimonyNetRun1 will make a copy of the topology, and will call findStartingTopology! to modify the topology according to random NNI/move origin/move target moves. It then calls maxParsimonyNetRun1! on the modified network  maxParsimonyNetRun1! proposes new network with various moves (same moves as snaq), and stops when it finds the most parsimonious network, using  parsimonyGF .   None of these functions allow for multiple alleles yet.  Note that the search algorithm keeps two HybridNetworks at a time: currT (current topology) and newT (proposed topology). Both are kept unrooted (semi-directed), otherwise the moves in proposedTop! function fail. We only root the topologies to calculate the parsimony, so we create a rooted copy (currTr, newTr) to compute parsimony score in this copied topology. We do not root and calculate parsimony score in the original HybridNetworks objects (currT,newT) because the computation of the parsimony score overwrites the inCycle attribute of the Nodes, which messes with the search moves.  Extensions:   other criteria: hardwired, parental (only softwired implemented now)   remove level-1 restriction: this will involve changing the proposedTop! function to use rSPR or rNNI moves (instead of the level-1 moves coded for snaq!). We need:   functions for rSPR and rNNI moves  create new proposedTop! function (proposedRootedTop?) to choose from the rSPR/rNNI/other moves  have the search in maxParsimonuNetRun1! to have rooted currT and rooted newT, instead of keeping semi-directed objects (currT, newT), only to root for the parsimony score (currTr, newTr)  outgroup is currently String or Node number, but it would be good if it allowed Edge number as an option too. Not sure best way to distinguish between Node number and Edge number, which is why left as Node number for now.     source  #  PhyloNetworks.minorreticulationgamma     Method .  minorreticulationgamma(net::HybridNetwork)  Vector of minor edge gammas (inheritance probabilities) organized in the same order as in the matrix created via  minorreticulationmatrix . Considers values of  -1.0  as missing values, recognized as NA in  R . Output: vector allowing for missing values.  Examples  julia   net   =   readTopology ( (((A,(B)#H1:::0.9),(C,#H1:::0.1)),D); );  julia   PhyloNetworks . minorreticulationgamma ( net )  1-element   Array { Union{Float64,   Missings.Missing } , 1 } : \n  0 . 1    source  #  PhyloNetworks.minorreticulationlength     Method .  minorreticulationlength(net::HybridNetwork)  Vector of lengths for the minor hybrid edges, organized in the same order as in the matrix created via  minorreticulationmatrix . Replace values of  -1.0  with missing values recognized by  R . Output: vector allowing for missing values.  Examples  julia   net   =   readTopology ( (((A:3.1,(B:0.2)#H1:0.4::0.9),(C,#H1:0.3::0.1):1.1),D:0.7); );  julia   PhyloNetworks . minorreticulationlength ( net )  1-element   Array { Union{Float64,   Missings.Missing } , 1 } : \n  0 . 3   source  #  PhyloNetworks.minorreticulationmatrix     Method .  minorreticulationmatrix(net::HybridNetwork)  Matrix of integers, representing the minor hybrid edges in  net . edge[i,1] is the number of the parent node of the ith minor hybrid edge, and edge[i,2] is the number of its child node. Node numbers may be negative, unless they were modified by  resetNodeNumbers! . Assumes correct  isChild1  fields.  Examples  julia   net   =   readTopology ( (((A,(B)#H1:::0.9),(C,#H1:::0.1)),D); );  julia   PhyloNetworks . minorreticulationmatrix ( net )  1 \u00d7 2   Array { Int64,2 } : \n  -6    3   source  #  PhyloNetworks.moveHybrid!     Method .  moveHybrid  road map  Function that tries to fix a gamma zero problem ( h==0,1; t==0; hz==0,1 ) after changing direction of hybrid edge failed. This function is called in  gammaZero .  Arguments:   closeN=true  will try move origin/target on all neighbors (first choose minor/major edge at random, then make list of all neighbor edges and tries to put the hybrid node in all the neighbors until successful move); if false, will delete and add hybrid until successful move up to N times (this is never tested)   Returns true if change was successful (not testing  optBL  again), and false if we could not move anything  source  #  PhyloNetworks.nparams     Method .  nparams(model)  Number of parameters for a given trait evolution model (length of field  model.rate ).  source  #  PhyloNetworks.optBL!     Method .  optBL  road map  Function that optimizes the numerical parameters (branch lengths and inheritance probabilities) for a given network. This function is called multiple times inside  optTopLevel! .   Input: network  net , data  d  Numerical tolerances:  ftolAbs, ftolRel, xtolAbs, xtolRel  Function based on  MixedModels   fit  function  The function assumes  net  has all the right attributes, and cannot check this inside because it would be inefficient   Procedure:   ht = parameters!(net)  extracts the vector of parameters to estimate  (h,t,gammaz) , and sets as  net.ht ; identifies a bad diamond I, sets  net.numht  (vector of hybrid node numbers for h, edge numbers for t, hybrid node numbers for gammaz), and  net.index  to keep track of the vector of parameters to estimate   extractQuartet!(net,d)  does the following for all quartets in  d.quartet :   Extract quartet by deleting all leaves not in q -  create  QuartetNetwork  object saved in  q.qnet  This network is ugly and does not have edges collapsed. This is done to keep a one-to-one correspondence between the edges in  q.qnet  and the edges in  net  (if we remove nodes with only two edges, we will lose this correspondence)  Calculate expected CF with  calculateExpCFAll  for a copy of  q.qnet . We do this copy because we want to keep  q.qnet  as it is (without collapsed edges into one). The function will then save the  expCF  in  q.qnet.expCF   calculateExpCFAll!(qnet)  will    identify the type of quartet as type 1 (equivalent to a tree) or type 2 (minor CF different). Here the code will first clean up any hybrid node by removing nodes with only two edges before identifying the  qnet  (because identification depends on neighbor nodes to hybrid node); later, set  qnet.which  (1 or 2),  node.prev  (neighbor node to hybrid node), updates  node.k  (number of nodes in hybridization cycle, this can change after deleting the nodes with only two edges),  node.typeHyb  (1,2,3,4,5 depending on the number of nodes in the hybridization cycle and the origin/target of the minor hybrid edge; this attribute is never used).   eliminate hybridization: this will remove type 1 hybridizations first. If  qnet.which=1 , then the  qnet  is similar to a tree quartet, so it will calculate the internal length of the tree quartet:  qnet.t1 .  update split for  qnet.which=1 , to determine which taxa are together. For example, for the quartet 12|34, the split is  1,1,2,2 , that is, taxon 1 and 2 are on the same side of the split. This will update  qnet.split  update formula for  qnet.which=1  to know the order of minorCF and majorCF in the vector  qnet.expCF . That is, if the quartet is 1342 (order in  qnet.quartet.taxon ), then the expected CF should match the observed CF in 13|42, 14|32, 12|34 and the  qnet  is 12|34 (given by  qnet.split ),  qnet.formula  will be [2,2,1] minor, minor, major  calculateExpCF!(qnet)  for  qnet.which=1 , it will do  1-2/3exp(-qnet.t1)  if  qnet.formula[i]==1 , and  1/3exp(qnet.t1)  if  qnet.formula[i]==2 . For  qnet.which=2 , we need to make sure that there is only one hybrid node, and compute the major, minor1,minor2 expected CF in the order 12|34, 13|24, 14|23 of the taxa in  qnet.quartet.taxon     Then we create a  NLopt  object with algorithm BOBYQA and k parameters (length of ht). We define upper and lower bounds and define the objective function that should only depend on  x=(h,t,gz)  and g (gradient, which we do not have, but still need to put as argument).  The objective function  obj(x,g)  calls    calculateExpCFAll!(d,x,net)  needs to be run after  extractQuartet(net,d)  that will update  q.qnet  for all quartet.  Assumes that  qnet.indexht  is updated already: we only need to do this at the beginning of  optBL!  because the topology is fixed at this point)   First it will update the edge lengths according to x  If the  q.qnet.changed=true  (that is, any of  qnet  branches changed value), we need to call  calculateExpCFAll!(qnet)  on a copy of  q.qnet  (again because we want to leave  q.qnet  with the edge correspondence to  net )  update!(net,x)  simply saves the new x in  net.ht     Finally, we call  NLopt.optimize , and we update the  net.loglik  and  net.ht  at the end. After  optBL , we want to call  afterOptBLAll  (or  afterOptBLAllMultipleAlleles ) to check if there are  h==0,1 ;  t==0 ;  hz==0,1 .  source  #  PhyloNetworks.optTopLevel!     Method .  optTopLevel  road map  Function that does most of the heavy-lifting of  snaq . It optimizes the pseudolikelihood for a given starting topology, and returns the best network. Assumes that the starting topology is level-1 network, and has all the attributes correctly updated.  Input parameters:   Starting topology  currT , input data  DataCF   d , maximum number of hybridizations  hmax  Numerical optimization parameters:  liktolAbs, Nfail, ftolRel, ftolAbs, xtolRel, xtolAbs  Print parameters:  verbose, sout, logfile, writelog  Parameters to tune the search in space of networks:  closeN=true  only propose move origin/target to neighbor edges (coded, but not tested with  closeN=false ),  Nmov0  vector with maximum number of trials allowed per type of move  (add, mvorigin, mvtarget, chdir, delete, nni) , by default computed inside with coupon\u2019s collector formulas   The optimization procedure keeps track of   movescount : count of proposed moves,  movesgamma : count of proposed moves to fix a gamma zero situation (see below for definition of this situation),  movesfail : count of failed moves by violation of level-1 network ( inCycle  attribute) or worse pseudolikelihood than current,  failures : number of failed proposals that had a worse pseudolikelihood   Optimization procedure:  While the difference between current loglik and proposed loglik is greater than  liktolAbs , or  failures Nfail , or  stillmoves=true :   Nmov  is updated based on  newT . The type of move proposed will depend on  newT  (which is the same as  currT  at this point). For example, if  currT  is a tree, we cannot propose move origin/target.  move = whichMove  selects randomly a type of move, depending on  Nmov,movesfail,hmax,newT  with weights 1/5 by default for all, and 0 for delete. These weights are adjusted depending on  newT.numHybrids  and  hmax . If  newT.numHybrids  is far from  hmax , we give higher probability to adding a new hybrid (we want to reach the  hmax  sooner, maybe not the best strategy, easy to change).  Later, we adjust the weights by  movesfail  (first, give weight of 0 if  movesfail[i] Nmov[i] , that is, if we reached the maximum possible number of moves allowed for a certain type) and then increase the probability of the other moves.  So, unless one move has  w=0 , nothing changes. This could be improved by using the outlier quartets to guide the proposal of moves.  whichMove  will choose a move randomly from the weights, it will return  none  if no more moves allowed, in which case, the optimization ends   flag=proposedTop!(move, newT)  will modify  newT  based on  move . The function  proposedTop  will return  flag=true  if the move was successful (the move succeeded by  inCycle ,  containRoot , available edge to make the move (more details in  proposedTop )). If  flag=false , then  newT  is cleaned, except for the case of multiple alleles. The function  proposedTop  keeps count of  movescount  (successful move),  movesfail  (unsuccessful move),  Options:  random=true : moves major/minor hybrid edge with prob h,1-h, respectively  N=10 : number of trials for NNI edge.\n  * if(flag) Optimize branch lengths with  optBL  If  newT.loglik  is better than  currT.loglik  by  liktolAbs , jump to  newT  ( accepted=true ) and fix  gamma=0, t=0  problems (more info on  afterOptBL )  If(accepted)    failures=0 ,  movesfail=zeros ,  movescount  for successful move +1    end while  After choosing the best network  newT , we do one last more thorough optimization of branch lengths with  optBL , we change non identifiable branch lengths to -1 and return  newT  source  #  PhyloNetworks.optTopRun1!     Method .  optTopRun1  roadmap  The function will run 1 run by modifying the starting topology and calling  optTopLevel .   probST  (default in snaq is 0.3) is the probability of starting one run in the same starting tree. So, with probability  1-probST , we will change the topology by a NNI move on a tree edge without neighbor hybrid.   If the starting topology is a network, then with probability  1-probST  it will modify one randomly chosen hybrid edge: with prob 0.5, the function will move origin, with prob 0.5 will do move target  If there are multiple alleles ( d.repSpecies  not empty), then the function has to check that the starting topology does not violate the multiple alleles condition.  After modifying the starting topology with NNI and/or move origin/target, the function calls  optTopLevel .  source  #  PhyloNetworks.optTopRuns!     Method .  Road map for various functions behind snaq!  snaq!\noptTopRuns!\noptTopRun1!\noptTopLevel!\noptBL!\nsnaqDebug  All return their optimized network.   snaq! calls optTopRuns! once, after a deep copy of the starting network. If the data contain multiple alleles from a given species,  snaq!  first expands the leaf for that species into 2 separate leaves, and merges them back into a single leaf after calling  optTopRuns! .  optTopRuns! calls optTopRun1! several (nrun) times. assumes level-1 network with  0 branch lengths. assumes same tips in network as in data: i.e. 2 separate tips per species                                          that has multiple alleles. each call to optTopRun1! gets the same starting network.  optTopRun1! calls optTopLevel! once, after deep copying + changing the starting network slightly.  optTopLevel! calls optBL! various times and proposes new network with various moves.  snaqDebug calls optTopRun1! once   Functions that are no longer used, and not tested as much:  optTop! : optimizes at h=0, then h=1 etc.  source  #  PhyloNetworks.pairwiseTaxonDistanceGrad     Method .  pairwiseTaxonDistanceGrad(net; checkEdgeNumber=true, nodeAges=[])  3-dim array: gradient of pairwise distances between all nodes. (internal and leaves); gradient with respect to edge lengths if  nodeAges  is empty; with respect to node ages otherwise. Assume correct  net.nodes_changed  (preorder).   This gradient depends on the network's topology and \u03b3's only, not on branch lengths or node ages (distances are linear in either).  WARNING: edge numbers need to range between 1 and #edges.  source  #  PhyloNetworks.parseEdgeData!     Method .  parseEdgeData!(s::IO, edge, node, numberOfLeftParentheses::Array{Int,1})  Helper function for readSubtree!, fixes a bug from using setGamma Modifies  e  according to the specified edge length and gamma values in the tree topology. Advances the stream  s  past any existing edge data. Edges in a topology may optionally be followed by \":edgeLen:bootstrap:gamma\" where edgeLen, bootstrap, and gamma are decimal values.  source  #  PhyloNetworks.parseHybridNode!     Method .  parseHybridNode!(node, parentNode, hybridName, net, hybrids)  Helper function for  readSubtree! . Create the parent edge for  node . Return this edge, and the hybrid node retained ( node  or its clone in the newick string). Insert new edge and appropriate node into  net  and  hybrids  accordingly. Handles any type of given hybrid node. Called after a  #  has been found in a tree topology.  source  #  PhyloNetworks.parseRemainingSubtree!     Method .  parseRemainingSubtree!(s::IO, numLeft, net, hybrids)  Create internal node. Helper for  readSubtree! , which creates the parent edge of the node created by  parseRemainingSubtree! :  readSubtree!  calls  parseRemainingSubtree! , and vice versa. Called once a  (  has been read in a tree topology and reads until the corresponding  )  has been found. This function performs the recursive step for  readSubtree! . Advances  s  past the subtree, adds discovered nodes and edges to  net , and  hybrids .  Does  not  read the node name and the edge information of the subtree root: this is done by  readSubtree!  source  #  PhyloNetworks.parseTreeNode!     Method .  parseTreeNode!(node, parentNode, net)  Helper function for  readSubtree! . Insert the input tree node and associated edge (created here) into  net .  source  #  PhyloNetworks.parsimonyBottomUpFitch!     Method .  parsimonyBottomUpFitch!(node, states, score)  Bottom-up phase (from tips to root) of the Fitch algorithm: assign sets of character states to internal nodes based on character states at tips. Polytomies okay. Assumes a  tree  (no reticulation) and correct isChild1 attribute.  output: dictionary with state sets and most parsimonious score  source  #  PhyloNetworks.parsimonyBottomUpGF!     Method .  `parsimonyBottomUpGF!(node, blobroot, nchar, w, scores,\n    costmatrix1, costmatrix2)`  Compute the MP scores (one for each assignment of the blob root state) given the descendants of a blob, conditional on the states at predefined parents of hybrids in the blobs (one parent per hybrid) as described in  Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).  Assumes a set of state  guesses , ie correct initialization of  w  for predefined hybrid parents, and correct  fromBadDiamondI  field for the children edges of these predefined parents.  fromBadDiamondI  is true for edges that are cut.  The field  isExtBadTriangle  is used to know which nodes are at the root of a blob. The field  isChild1  is used (and assumed correct). Field  inCycle  is assumed to store the # of detached parents (with guessed states)   nchar : number of characters considered at internal lineages. For softwired parsimony, this is # states + 1, because characters at internal nodes are \u2205, {1}, {2}, etc. For parental parsimony, this is 2^#states -1, because characters are all sets on {1,2,...} except for the empty set \u2205.  costmatrix1 [i,j] and  costmatrix2 [k][i,j]: 2d array and vector of 2d arrays containing the cost of going to character j starting from character i when the end node has a single parent, or the cost of a child node having character j when its parents have characters k and i. These cost matrices are pre-computed depending on the parsimony criterion (softwired, hardwired, parental etc.)   used by  parsimonyGF .  source  #  PhyloNetworks.parsimonyBottomUpSoftwired!     Method .  parsimonyBottomUpSoftwired!(node, blobroot, states, w, scores)  Computing the MP scores (one for each assignment of the root state) of a swicthing as described in Algorithm 1 in the following paper:  Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.  Assumes a  switching  (ie correct  fromBadDiamondI  field) and correct isChild1 field. The field  isExtBadTriangle  is used to know which nodes are at the root of a blob.  source  #  PhyloNetworks.parsimonyDiscreteFitch     Method .  parsimonyDiscreteFitch(net, tipdata)  Calculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network. Tip data can be given in a data frame, in which case the taxon names are to appear in column 1 or in a column named \"taxon\" or \"species\", and trait values are to appear in column 2 or in a column named \"trait\". Alternatively, tip data can be given as a dictionary taxon =  trait.  also return the union of all optimized character states at each internal node as obtained by Fitch algorithm, where the union is taken over displayed trees with the MP score.  source  #  PhyloNetworks.parsimonySummaryFitch     Method .  parsimonySummaryFitch(tree, nodestates)  summarize character states at nodes, assuming a  tree  source  #  PhyloNetworks.parsimonyTopDownFitch!     Method .  parsimonyTopDownFitch!(node, states)  Top-down phase (root to tips) of the Fitch algorithm: constrains character states at internal nodes based on the state of the root. Assumes a  tree : no reticulation.  output: dictionary with state sets  source  #  PhyloNetworks.proposedTop!     Method .  proposedTop!(move,newT,random,count,N,movescount,movesfail,multall)  road map  Function to change the current network  newT  by a given  move , and checks that the move was successful (correct attributes). If not successful,  newT  is changed back to its original state, except for the case of multiple alleles.  Note  that the update of attributes by each move is not done in all the network, but only in the local edges that were changed by the move. This is efficient (and makes a move easy to undo), but makes the code of each move function very clunky.  Arguments:   move chosen from  whichMove  as described in  optTopLevel  newT  is the topology that will be modified inside with the move  random=true : chooses minor hybrid edge with prob 1-h, and major edge with prob h, if false, always chooses minor hybrid edge  count : simply which likelihood step we are in in the optimization at  optTopLevel  movescount  and  movesfail : vector of counts of number of moves proposed  multall=true  if multiple alleles case: we need to check if the move did not violate the multiple alleles condition (sister alleles together and no gene flow into the alleles). This is inefficient because we are proposing moves that we can reject later, instead of being smart about the moves we propose: for example, move origin/target could rule out some neighbors that move gene flow into the alleles, the same for add hybridization; nni move can check if it is trying to separate the alleles)   Moves:   addHybridizationUpdate(newT,N) :   will choose a partition first (to avoid choosing edges that will create a non level-1 network) will choose two edges from this partition randomly, will not allow two edges in a cherry (non-identifiable), or sister edges that are not identifiable (the blacklist was a way to keep track of \"bad edges\" were we should not waste time trying to put hybridizations, it has never been used nor tested). Also choose gamma from U(0,0.5). The \"Update\" in the function name means that it creates the new hybrid, and also updates all the attributes of  newT   node = chooseHybrid(newT)  choose a hybrid randomly for the next moves:  moveOriginUpdateRepeat!(newT,node,random)   will choose randomly the minor/major hybrid edge to move (if  random=true ); will get the list of all neighbor edges where to move the origin, will move the origin and update all the attributes and check if the move was successful (not conflicting attributes); if not, will undo the move, and try with a different neighbor until it runs out of neighbors. Return true if the move was successful.   moveTargetUpdateRepeat!(newT,node,random)   same as move origin but moving the target   changeDirectionUpdate!(newT,node,random)   chooses minor/major hybrid edge at random (if `random=true), and changes the direction, and updates all the attributes. Checks if the move was successful (returns true), or undoes the change and returns false.   deleteHybridizationUpdate!(newT,node)   removes the hybrid node, updates the attributes, no need to check any attributes, always successful move   NNIRepeat!(newT,N)   choose an edge for nni that does not have a neighbor hybrid. It will try to find such an edge N times, and if it fails, it will return false (unsuccessful move). N=10 by default. If N=1, it rarely finds such an edge if the network is small or complex. The function cannot choose an external edge. it will update locally the attributes.   Important:   All the moves undo what they did if the move was not successful, so at the end you either have a  newT  with a new move and with all good attributes, or the same  newT  that started. This is important to avoid having to do deepcopy of the network before doing the move. Also, after each move, when we update the attributes, we do not update the attributes of the whole network, we only update the attributes of the edges that were affected by the move. This saves time, but makes the code quite clunky. Only the case of multiple alleles the moves does not undo what it did, because it finds out that it failed after the function is over, so just need to treat this case special.  source  #  PhyloNetworks.readCSVtoArray     Method .  readCSVtoArray(dat::DataFrame)\nreadCSVtoArray(filename::String)  Read a CSV table containing both species names and data, create two separate arrays: one for the species names, a second for the data, in a format that  parsimonyGF  needs.  Warning:   it will try to find a column 'taxon' or 'species' for the taxon names. If none found, it will assume the taxon names are in column 1.  will use all other columns as characters   source  #  PhyloNetworks.readStartTop     Method .  readStartTop(treefile,d::DataCF)  function to read a tree in parenthetical format from text file treefile and a DataCF object to update the branch lengths according to the average observed CF for any given edge.  source  #  PhyloNetworks.readSubtree!     Method .  readSubtree!(s::IO, parentNode, numLeft, net, hybrids)  Recursive helper method for  readTopology : read a subtree from an extended Newick topology. input  s : IOStream/IOBuffer.  Reads additional info formatted as:  :length:bootstrap:gamma . Allows for name of internal nodes without # after closing parenthesis: (1,2)A. Warning if hybrid edge without \u03b3, or if \u03b3 (ignored) without hybrid edge  source  #  PhyloNetworks.recursionPostOrder     Method .  recursionPostOrder(nodes, init_function, tip_function, node_function,\n                   parameters)\nupdatePostOrder(index, nodes, updated_matrix, tip_function, node_function,\n                parameters)  Generic tool to apply a post-order (or topological ordering) algorithm. Used by  descendenceMatrix .  source  #  PhyloNetworks.recursionPreOrder!     Function .  recursionPreOrder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters)\nrecursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,\n                   hybrid_node_function, parameters)\nupdatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,\n               hybrid_node_function, parameters)  Generic tool to apply a pre-order (or topological ordering) algorithm. Used by  sharedPathMatrix  and by  pairwiseTaxonDistanceMatrix .  source  #  PhyloNetworks.recursionPreOrder     Method .  recursionPreOrder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters)\nrecursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,\n                   hybrid_node_function, parameters)\nupdatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,\n               hybrid_node_function, parameters)  Generic tool to apply a pre-order (or topological ordering) algorithm. Used by  sharedPathMatrix  and by  pairwiseTaxonDistanceMatrix .  source  #  PhyloNetworks.removeHybrid!     Method .  removeHybrid!(net::Network, n::Node)  Delete a hybrid node  n  from  net.hybrid , and update  net.numHybrid . The actual node  n  is not deleted. It is kept in the full list  net.node .  source  #  PhyloNetworks.resetEdgeNumbers!     Method .  resetEdgeNumbers !( net :: HybridNetwork ;   checkPreorder = true ,   ape = true )   Check that edge numbers of  net  are consecutive numbers from 1 to the total number of edges. If not, reset the edge numbers to be so.  source  #  PhyloNetworks.resetNodeNumbers!     Method .  resetNodeNumbers !( net :: HybridNetwork ;   checkPreorder = true ,   ape = true )   Change internal node numbers of  net  to consecutive numbers from 1 to the total number of nodes.  keyword arguments:   ape : if true, the new numbers satisfy the conditions assumed by the  ape  R package: leaves are 1 to n, the root is n+1, and internal nodes are higher consecutive integers. If false, nodes are numbered in post-order, with leaves from 1 to n (and the root last).  checkPreorder : if false, the  isChild1  edge field and the  net.nodes_changed  network field are supposed to be correct (to get nodes in preorder)   Examples  julia  net = readTopology( (A,(B,(C,D))); );\njulia  PhyloNetworks.resetNodeNumbers!(net)\njulia  printNodes(net)\nNode    In Cycle        isHybrid        hasHybEdge      Node label      isLeaf  Edges numbers\n1       -1              false           false           A               true    1\n2       -1              false           false           B               true    2\n3       -1              false           false           C               true    3\n4       -1              false           false           D               true    4\n7       -1              false           false                           false   3       4       5\n6       -1              false           false                           false   2       5       6\n5       -1              false           false                           false   1       6  source  #  PhyloNetworks.sameTaxa     Method .  sameTaxa(Quartet, HybridNetwork)  Return  true  if all taxa in the quartet are represented in the network,  false  if one or more taxa in the quartet does not appear in the network.  warning: the name can cause confusion. A more appropriate name might be \"in\", or \"taxain\", or \"taxonsubset\", or etc.  source  #  PhyloNetworks.sampleBootstrapTrees     Method .  sampleBootstrapTrees(vector of tree lists; seed=0::Integer, generesampling=false, row=0)\nsampleBootstrapTrees!(tree list, vector of tree lists; seed=0::Integer, generesampling=false, row=0)  Sample bootstrap gene trees, 1 tree per gene. Set the seed with keyword argument  seed , which is 0 by default. When  seed=0 , the actual seed is set using the clock. Assumes a vector of vectors of networks (see  readBootstrapTrees ), each one of length 1 or more (error if one vector is empty, tested in  bootsnaq ).   site resampling: always, from sampling one bootstrap tree from each given list. This tree is sampled at  random  unless  row 0  (see below).  gene resampling: if  generesampling=true  (default is false), genes (i.e. lists) are sampled with replacement.  row=i : samples the ith bootstrap tree for each gene.  row  is turned back to 0 if gene resampling is true.   output: one vector of trees. the modifying function (!) modifies the input tree list and returns it.  source  #  PhyloNetworks.sampleCFfromCI     Function .  sampleCFfromCI(data frame, seed=0)\nsampleCFfromCI!(data frame, seed=0)  Read a data frame containing CFs and their credibility intervals, and sample new obsCF uniformly within the CIs. These CFs are then rescaled to sum up to 1 for each 4-taxon sets. Return a data frame with taxon labels in first 4 columns, sampled obs CFs in columns 5-7 and credibility intervals in columns 8-13.   The non-modifying function creates a new data frame (with re-ordered columns) and returns it. If  seed=-1 , the new df is a deep copy of the input df, with no call to the random number generator. Otherwise,  seed  is passed to the modifying function.  The modifying function overwrites the input data frame with the sampled CFs and returns it. If  seed=0 , the random generator is seeded from the clock. Otherwise the random generator is seeded using  seed .   Warning: the modifying version does  not  check the data frame: assumes correct columns.  optional argument:  delim=','  by default: how columns are delimited.  source  #  PhyloNetworks.setBLGammaParsimony!     Method .  setBLGammaParsimony!(net::HybridNetwork)  Maximum parsimony function does not provide estimates for branch lengths, or gamma. But since the  maxParsimonyNet  function is using snaq move functions, branch lengths and gamma values are set randomly (to initialize optimization). We need to remove these random values before returning the maximum parsimony network.  source  #  PhyloNetworks.setBranchLength!     Method .  setBranchLength!(Edge,new length)  sets the length of an Edge object. The new length needs to be non-negative, or -1.0 to be interpreted as missing. Example: if net is a HybridNetwork object, do printEdges(net) to see the list of all edges with their lengths. The length of the 3rd edge can be changed to 1.2 with setBranchLength!(net.edge[3],1.2). It can also be set to missing with setBranchLength!(net.edge[3],-1.0)  source  #  PhyloNetworks.setGammaBLfromGammaz!     Method .  setGammaBLfromGammaz!(node, network)  Update the \u03b3 values of the two sister hybrid edges in a bad diamond I, given the  gammaz  values of their parent nodes, and updates the branch lengths t1 and t2 of their parent edges (those across from the hybrid nodes), in such a way that t1=t2 and that these branch lengths and \u03b3 values are consistent with the  gammaz  values in the network.  source  #  PhyloNetworks.setGammas!     Method .  setGammas!(net, \u03b3 vector)  Set inheritance \u03b3's of hybrid edges, using input vector for  major  edges. Assume pre-order calculated already, with up-to-date field  nodes_changed . See  getGammas .  Very different from  setGamma! , which focuses on a single hybrid event, updates the field  isMajor  according to the new \u03b3, and is not used here.  May assume a tree-child network.  source  #  PhyloNetworks.setNonIdBL!     Method .  setNonIdBL!(net)  Set non-identifiable edge branch lengths to -1.0 (i.e. missing) for a level-1 network  net , except for edges in   a good triangle: the edge below the hybrid is constrained to 0.  a bad diamond II: the edge below the hybrid is constrained to 0  a bad diamond I: the edges across from the hybrid node have non identifiable lengths but are kept, because the two \u03b3*(1-exp(-t)) values are identifiable.   will break if  inCycle  attributes are not initialized (at -1) or giving a correct node number.  source  #  PhyloNetworks.showQ     Method .  showQ(IO, model)  Print the Q matrix to the screen, with trait states as labels on rows and columns. adapted from prettyprint function by mcreel, found 2017/10 at https://discourse.julialang.org/t/display-of-arrays-with-row-and-column-names/1961/6  source  #  PhyloNetworks.sortUnionTaxa!     Method .  sortUnionTaxa!(taxa)  Take a vector of strings  taxa , sort it numerically if elements can be parsed as an integer, alphabetically otherwise.  source  #  PhyloNetworks.symmetricNet     Function .  symmetricNet(n, h, gamma)  Create a string with a symmetric net with 2^n tips, numbered from 1 to 2^n The total height of the network is set to 1. Hybrids are added from level h to h-1 symmetrically.  source  #  PhyloNetworks.symmetricNet     Method .  symmetricNet(n, i, j, gamma)  Create a string with a symmetric net with 2^n tips, numbered from 1 to 2^n All the branch length are set equal to 1. One hybrid branch, going from level i to level j is added, with weigth gamma. The tree can be created with function readTopology.  source  #  PhyloNetworks.symmetricTree     Function .  symmetricTree(n, i=1)  Create a string with a symmetric tree with 2^n tips, numbered from i to i+2^n-1. All the branch length are set equal to 1. The tree can be created with function readTopology.  source  #  PhyloNetworks.synchronizePartnersData!     Method .  synchronizePartnersData!(e::Edge, n::Node)  Synchronize \u03b3 and isMajor for edges  e  and its partner, both hybrid edges with the same child  n :   if one \u03b3 is missing and the other is not: set the missing \u03b3 to 1 - the other  \u03b3's should sum up to 1.0  update  isMajor  to match the \u03b3 information: the major edge is the one with \u03b3   0.5.   Warnings : does not check that  e  is a hybrid edge, nor that  n  is the child of  e .  source  #  PhyloNetworks.taxadiff     Method .  taxadiff(Vector{Quartet}, network; multiplealleles=true)\ntaxadiff(DataCF, network; multiplealleles=true)  Return 2 vectors:   taxa in at least 1 of the quartets but not in the network, and  taxa in the network but in none of the quartets.   When  multiplealleles  is true, the taxon names that end with \"__2\" are ignored in the quartets: they are not expected to appear in the networks that users give as input, or get as output.  source  #  PhyloNetworks.ticr_optimalpha     Method .  ticr_optimalpha(D::DataCF)  Find the concentration parameter \u03b1 by maximizing the pseudo-log-likelihood of observed quartet concordance factors. The model assumes a Dirichlet distribution with mean equal to the expected concordance factors calculated from a phylogenetic network (under ILS and reticulation). These expected CFs are assumed to be already calculated, and stored in D.  When calculating the pseudo-log-likelihood, this function will check the observed concordance factors for any values equal to zero: they cause a problem because the Dirichlet density is 0 at 0 (for concentrations   1). Those 0.0 observed CF values are re-set to the minimum of:   the minimum of all expected concordance factors, and  the minimum of all nonzero observed concordance factors.   output:   maximized pseudo-loglikelihood  value of \u03b1 where the pseudo-loglikelihood is maximized  return code of the optimization   The optimization uses NLOpt, with the  :LN_BOBYQA  method. Optional arguments can tune the optimization differently:  NLoptMethod ,  xtol_rel  (1e-6 by default), starting \u03b1 value  x_start  (1.0 by default).  source  #  PhyloNetworks.traitlabels2indices     Method .  traitlabels2indices(data, model::TraitSubstitutionModel)  Check that the character states in  data  are compatible with (i.e. subset of) the trait labels in  model . All columns are used.  data  can be a DataFrame or a Matrix (multiple traits), or a Vector (one trait).  Return a vector of vectors (one per species) with integer entries, where each state (label) is replaced by its index in  model .  source  #  PhyloNetworks.traverseContainRoot!     Method .  updateContainRoot!(HybridNetwork, Node)\ntraverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})  The input  node  to  updateContainRoot!  must be a hybrid node (can come from searchHybridNode).  updateContainRoot!  starts at the input node and calls  traverseContainRoot! , which traverses the network recursively. By default, containRoot attributes of edges are true. Changes containRoot to false for all the visited edges: those below the input node, but not beyond any other hybrid node.  updateContainRoot!  Returns a  flag  and an array of edges whose containRoot has been changed from true to false.  flag  is false if the set of edges to place the root is empty  In  traverseContainRoot! ,  rightDir  turns false if hybridizations have incompatible directions (vector of length 1, to be modified).  Warning:   does  not  update containRoot of minor hybrid edges.  assumes correct isMajor attributes: to stop the recursion at minor hybrid edges.  assumes correct hybrid attributes of both nodes   edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).   source  #  PhyloNetworks.updatePostOrder!     Function .  recursionPostOrder(nodes, init_function, tip_function, node_function,\n                   parameters)\nupdatePostOrder(index, nodes, updated_matrix, tip_function, node_function,\n                parameters)  Generic tool to apply a post-order (or topological ordering) algorithm. Used by  descendenceMatrix .  source  #  PhyloNetworks.updatePreOrder!     Function .  recursionPreOrder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters)\nrecursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,\n                   hybrid_node_function, parameters)\nupdatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,\n               hybrid_node_function, parameters)  Generic tool to apply a pre-order (or topological ordering) algorithm. Used by  sharedPathMatrix  and by  pairwiseTaxonDistanceMatrix .  source  #  PhyloNetworks.writeTopologyLevel1     Method .  writeTopologyLevel1(net::HybridNetwork)  Write the extended Newick parenthetical format of a level-1 network object with many optional arguments (see below). Makes a deep copy of net: does  not  modify  net .   di=true: write in format for Dendroscope (default false)  names=false: write the leaf nodes numbers instead of taxon names (default true)  outgroup (string): name of outgroup to root the tree/network. if \"none\" is given, the root is placed wherever possible.  printID=true, only print branch lengths for identifiable egdes according to the snaq estimation procedure (default false) (true inside of  snaq! .)  round: rounds branch lengths and heritabilities \u03b3 (default: true)  digits: digits after the decimal place for rounding (defult: 3)  string: if true (default), returns a string, otherwise returns an IOBuffer object.  multall: (default false). set to true when there are multiple alleles per population.   The topology may be written using a root different than net.root, if net.root is incompatible with one of more hybrid node. Missing hybrid names are written as \"#Hi\" where \"i\" is the hybrid node number if possible.  source  #  StatsBase.fit     Method .  fit(StatisticalSubstitutionModel, net, model, traits; kwargs...)\nfit!(StatisticalSubstitutionModel; kwargs...)  Internal function called by  fitDiscrete : with same key word arguments  kwargs . But dangerous:  traits  should be a vector of vectors as for  fitDiscrete   but  here  traits  need to contain the  indices  of trait values corresponding to the indices in  model.label , and species should appear in  traits  in the order corresponding to the node numbers in  net . See  traitlabels2indices  to convert trait labels to trait indices.  Warning : does  not  perform checks.  fitDiscrete  calls this function after doing checks, preordering nodes in the network, making sure nodes have consecutive numbers, species are matched between data and network etc.  source", 
            "title": "functions"
        }
    ]
}