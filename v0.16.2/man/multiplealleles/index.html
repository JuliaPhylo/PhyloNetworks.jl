<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multiple Alleles · PhyloNetworks.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PhyloNetworks.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PhyloNetworks.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../netmanipulation/">Network manipulation</a></li><li><a class="tocitem" href="../inputdata/">Input Data for SNaQ</a></li><li><a class="tocitem" href="../ticr_howtogetQuartetCFs/">TICR pipeline</a></li><li><a class="tocitem" href="../snaq_plot/">Network estimation and display</a></li><li><a class="tocitem" href="../dist_reroot/">Network comparison and manipulation</a></li><li><a class="tocitem" href="../fixednetworkoptim/">Candidate Networks</a></li><li><a class="tocitem" href="../expectedCFs/">Extract Expected CFs</a></li><li><a class="tocitem" href="../bootstrap/">Bootstrap</a></li><li class="is-active"><a class="tocitem" href>Multiple Alleles</a><ul class="internal"><li><a class="tocitem" href="#between-species-4-taxon-sets"><span>between-species 4-taxon sets</span></a></li><li><a class="tocitem" href="#within-species-4-taxon-sets"><span>within-species 4-taxon sets</span></a></li></ul></li><li><a class="tocitem" href="../trait_tree/">Continuous Trait Evolution</a></li><li><a class="tocitem" href="../parsimony/">Parsimony on networks</a></li><li><a class="tocitem" href="../fitDiscrete/">Discrete Trait Evolution</a></li><li><a class="tocitem" href="../nj/">Neighbour Joining</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Multiple Alleles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multiple Alleles</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/crsl4/PhyloNetworks.jl/blob/master/docs/src/man/multiplealleles.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Multiple-alleles-per-species"><a class="docs-heading-anchor" href="#Multiple-alleles-per-species">Multiple alleles per species</a><a id="Multiple-alleles-per-species-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-alleles-per-species" title="Permalink"></a></h1><h2 id="between-species-4-taxon-sets"><a class="docs-heading-anchor" href="#between-species-4-taxon-sets">between-species 4-taxon sets</a><a id="between-species-4-taxon-sets-1"></a><a class="docs-heading-anchor-permalink" href="#between-species-4-taxon-sets" title="Permalink"></a></h2><p>The default setting for SNaQ considers that each allele in a gene tree corresponds to a taxon (a tip) in the network. If instead each allele/individual can be mapped confidently to a species, and if only the species-level network needs to be estimated, then the following functions can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using CSV, DataFrames</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mappingfile = joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;,&quot;examples&quot;,&quot;mappingIndividuals.csv&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tm = CSV.read(mappingfile, DataFrame) # taxon map as a data frame</code><code class="nohighlight hljs ansi" style="display:block;">3×2 DataFrame
 Row │ species  individual
     │ String3  String3
─────┼─────────────────────
   1 │ S1       S1A
   2 │ S1       S1B
   3 │ S1       S1C</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; taxonmap = Dict(row[:individual] =&gt; row[:species] for row in eachrow(tm)) # taxon map as a dictionary</code><code class="nohighlight hljs ansi" style="display:block;">Dict{InlineStrings.String3, InlineStrings.String3} with 3 entries:
  &quot;S1A&quot; =&gt; &quot;S1&quot;
  &quot;S1B&quot; =&gt; &quot;S1&quot;
  &quot;S1C&quot; =&gt; &quot;S1&quot;</code></pre><p>The <a href="https://github.com/crsl4/PhyloNetworks/blob/master/examples/mappingIndividuals.csv">mapping file</a> can be a text (or <code>csv</code>) file with two columns (at least): one for the individuals, named <code>allele</code> or <code>individual</code>, and one column containing the species names, named <code>species</code>. Each row should map an allele name to a species name. Next, read in the <a href="https://github.com/crsl4/PhyloNetworks/blob/master/examples/genetrees_alleletips.tre">gene trees</a> and calculate the quartet CFs at the species level:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; genetreefile = joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;,&quot;examples&quot;,&quot;genetrees_alleletips.tre&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; genetrees = readMultiTopology(genetreefile);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sort(tipLabels(genetrees[1])) # multiple tips in species S1</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{String}:
 &quot;S1A&quot;
 &quot;S1B&quot;
 &quot;S1C&quot;
 &quot;S2&quot;
 &quot;S3&quot;
 &quot;S4&quot;
 &quot;S5&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_sp = writeTableCF(countquartetsintrees(genetrees, taxonmap, showprogressbar=false)...)</code><code class="nohighlight hljs ansi" style="display:block;">5×9 DataFrame
 Row │ qind   t1         t2         t3         t4         CF12_34    CF13_24   ⋯
     │ Int64  Abstract…  Abstract…  Abstract…  Abstract…  Float64    Float64   ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │     1  S1         S2         S3         S4         0.0833333  0.854167  ⋯
   2 │     2  S1         S2         S3         S5         0.0833333  0.854167
   3 │     3  S1         S2         S4         S5         0.875      0.0625
   4 │     4  S1         S3         S4         S5         1.0        0.0
   5 │     5  S2         S3         S4         S5         0.875      0.0625    ⋯
                                                               2 columns omitted</code></pre><p>Now <code>df_sp</code> is a data frame containing the quartet concordance factors at the species level only, that is, considering sets made of 4 distinct species, even if the gene trees may have multiple alleles from the same species. For 4 distinct species <code>A,B,C,D</code>, all alleles from each species (<code>A</code> etc.) will be used to calculate the quartet CF. If a given gene tree has <code>n_a</code> alleles from <code>a</code>, <code>n_b</code> alleles from <code>b</code> etc., then each set of 4 alleles is given a weight of <code>1/(n_a n_b n_c n_d)</code> to calculated of the CF for <code>A,B,C,D</code> (such that the total weight from this particular gene trees is 1). It is safe to save this data frame, then use it for <code>snaq!</code> like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; CSV.write(&quot;tableCF_species.csv&quot;, df_sp);   # to save the data frame to a file</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d_sp = readTableCF(&quot;tableCF_species.csv&quot;); # to get a &quot;DataCF&quot; object for use in snaq!</code><code class="nohighlight hljs ansi" style="display:block;">between 16.0 and 16.00000000000001 gene trees per 4-taxon set</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; summarizeDataCF(d_sp)</code><code class="nohighlight hljs ansi" style="display:block;">data consists of 5 4-taxon subsets
Taxa: [&quot;S1&quot;, &quot;S2&quot;, &quot;S3&quot;, &quot;S4&quot;, &quot;S5&quot;]
Number of Taxa: 5
Maximum number of 4-taxon subsets: 5. Thus, 100.0 percent of 4-taxon subsets sampled</code></pre><h2 id="within-species-4-taxon-sets"><a class="docs-heading-anchor" href="#within-species-4-taxon-sets">within-species 4-taxon sets</a><a id="within-species-4-taxon-sets-1"></a><a class="docs-heading-anchor-permalink" href="#within-species-4-taxon-sets" title="Permalink"></a></h2><p>Four-taxon sets involving 2 individuals per species can provide more information about the underlying network, including external branch length in coalescent units. However, <code>snaq!</code> runs more slowly when using this extra information. To get quartet CFs from sets of 4 individuals in which 2 individuals are from the same species, the following functions should be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_ind = writeTableCF(countquartetsintrees(genetrees, showprogressbar=false)...); # no mapping: CFs across individuals</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; first(df_ind, 4) # to see the first 4 rows</code><code class="nohighlight hljs ansi" style="display:block;">4×9 DataFrame
 Row │ qind   t1      t2      t3      t4      CF12_34  CF13_24  CF14_23  ngene ⋯
     │ Int64  String  String  String  String  Float64  Float64  Float64  Float ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │     1  S1A     S1B     S1C     S2       0.375    0.25      0.375     16 ⋯
   2 │     2  S1A     S1B     S1C     S3       0.375    0.25      0.375     16
   3 │     3  S1A     S1B     S2      S3       0.8125   0.0625    0.125     16
   4 │     4  S1A     S1C     S2      S3       0.75     0.125     0.125     16
                                                                1 column omitted</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; CSV.write(&quot;tableCF_individuals.csv&quot;, df_ind);  # to save to a file</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_sp = mapAllelesCFtable(mappingfile, &quot;tableCF_individuals.csv&quot;);</code><code class="nohighlight hljs ansi" style="display:block;">┌ Warning: not all alleles were mapped
│ alleles not mapped to a species name: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 S2 S3 S4
└ @ PhyloNetworks ~/work/PhyloNetworks.jl/PhyloNetworks.jl/src/multipleAlleles.jl:212</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d_sp = readTableCF!(df_sp, mergerows=true);</code><code class="nohighlight hljs ansi" style="display:block;">found 4 4-taxon sets uninformative about between-species relationships, out of 35.
These 4-taxon sets will be deleted from the data frame. 31 informative 4-taxon sets will be used.
11 unique 4-taxon sets were found. CF values of repeated 4-taxon sets will be averaged (ngenes too).
16.0 gene trees per 4-taxon set</code></pre><p>where the mapping file can be a text (or <code>csv</code>) file with two columns named <code>allele</code> (or <code>individual</code>) and <code>species</code>, mapping each allele name to a species name. The data in <code>df_ind</code> is the table of concordance factors at the level of individuals. In other words, it lists CFs using one row for each set of 4 alleles/individuals.</p><p><code>mapAllelesCFtable</code> creates a new data frame <code>df_sp</code> of quartet concordance factors at the species level: with the allele names replaced by the appropriate species names.</p><p><strong>Warnings</strong>:</p><ul><li>This procedure requires that all alleles from the same individual are given the same name (the individual&#39;s &#39;name&#39;) across all genes for which that individual was sequenced.</li><li>For a four-taxon set <code>A,B,C,D</code>, all the individuals from <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code> are considered, say <code>(a1,b1,c1,d1)</code>, <code>(a2,b1,c1,d1)</code>, <code>(a1,b2,c1,d1)</code>, <code>(a2,b2,c1,d1)</code> and so on. The CFs of these 4-taxon sets are averaged together to obtain the CFs at the species level. This procedures gives more weight to genes that have many alleles (because they contribute to more sets of 4 individuals) and less weight to genes that have few alleles.</li></ul><p>The last command modifies this data frame <code>df_sp</code> by deleting rows that are uninformative about between-species relationships, such as rows corresponding to 4 individuals from the same species. The output <code>d_sp</code> of this second command is an object of type <code>DataCF</code> at the species level, which can be used as input for networks estimation with <code>snaq!</code>. But before, it is safe to save the concordance factor of quartets of species, which can be calculated by averaging the CFs of quartets of individuals from the associated species:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_sp = writeTableCF(d_sp) # data frame, quartet CFs averaged across individuals of same species</code><code class="nohighlight hljs ansi" style="display:block;">11×8 DataFrame
 Row │ t1      t2      t3      t4      CF12_34    CF13_24   CF14_23   ngenes   ⋯
     │ String  String  String  String  Float64    Float64   Float64   Float64? ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │ S1      S1__2   S2      S3      0.791667   0.104167  0.104167      16.0 ⋯
   2 │ S1      S1__2   S2      S4      0.875      0.0625    0.0625        16.0
   3 │ S1      S1__2   S3      S4      0.791667   0.104167  0.104167      16.0
   4 │ S1      S2      S3      S4      0.0833333  0.854167  0.0625        16.0
   5 │ S1      S1__2   S2      S5      0.875      0.0625    0.0625        16.0 ⋯
   6 │ S1      S1__2   S3      S5      0.791667   0.104167  0.104167      16.0
   7 │ S1      S2      S3      S5      0.0833333  0.854167  0.0625        16.0
   8 │ S1      S1__2   S4      S5      1.0        0.0       0.0           16.0
   9 │ S1      S2      S4      S5      0.875      0.0625    0.0625        16.0 ⋯
  10 │ S1      S3      S4      S5      1.0        0.0       0.0           16.0
  11 │ S2      S3      S4      S5      0.875      0.0625    0.0625        16.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; CSV.write(&quot;CFtable_species.csv&quot;, df_sp); # save to file</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Some quartets have the same species repeated twice, representing cases when 2 of the 4 individuals came from the same species. These quartets, with repeated species, are informative about the population size of extant populations, i.e. about the lengths of external branches in coalescent units.</p><p>The main difference between this section compared to the previous section (&quot;between-species 4-taxon sets&quot;) is that quartets with 2 individuals from the same species are included here, such as <code>a1,a2,b1,c1</code>. Also, the weighting of quartets is different. Here, genes with more alleles are given more weight.</p><p>now we can run snaq:</p><pre><code class="language-julia hljs">net = snaq!(T_sp, d_sp);</code></pre><p>where <code>T_sp</code> should be a starting topology with one tip per species, labelled with the same species names as the names used in the mapping file.</p><p>If <code>snaq!</code> takes too long that way, we can try a less ambitious estimation that does not estimate the external branch lengths, that is, <em>without</em> using quartets that have 2 individuals from the same species. To do so, we can use the quartet concordance factors at the species level, but filter out the quartets with one (or more) species repeated. This can be done as in the first section (&quot;between-species 4-taxon sets&quot;) to give equal weight to all genes, or as shown below to give more weight to genes that have more alleles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; first(df_sp, 3) # some quartets have the same species twice</code><code class="nohighlight hljs ansi" style="display:block;">3×8 DataFrame
 Row │ t1      t2      t3      t4      CF12_34   CF13_24   CF14_23   ngenes
     │ String  String  String  String  Float64   Float64   Float64   Float64?
─────┼────────────────────────────────────────────────────────────────────────
   1 │ S1      S1__2   S2      S3      0.791667  0.104167  0.104167      16.0
   2 │ S1      S1__2   S2      S4      0.875     0.0625    0.0625        16.0
   3 │ S1      S1__2   S3      S4      0.791667  0.104167  0.104167      16.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function hasrep(row) # see if a row (4-taxon set) has a species name ending with &quot;__2&quot;: repeated species
           occursin(r&quot;__2$&quot;, row[:t1]) || occursin(r&quot;__2$&quot;, row[:t2]) || # replace :t1 :t2 etc. by appropriate column names in your data,
           occursin(r&quot;__2$&quot;, row[:t3]) || occursin(r&quot;__2$&quot;, row[:t4])    # e.g. by :taxon1 :taxon2 etc.
       end</code><code class="nohighlight hljs ansi" style="display:block;">hasrep (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_sp_reduced = filter(!hasrep, df_sp) # removes rows with repeated species</code><code class="nohighlight hljs ansi" style="display:block;">5×8 DataFrame
 Row │ t1      t2      t3      t4      CF12_34    CF13_24   CF14_23  ngenes
     │ String  String  String  String  Float64    Float64   Float64  Float64?
─────┼────────────────────────────────────────────────────────────────────────
   1 │ S1      S2      S3      S4      0.0833333  0.854167   0.0625      16.0
   2 │ S1      S2      S3      S5      0.0833333  0.854167   0.0625      16.0
   3 │ S1      S2      S4      S5      0.875      0.0625     0.0625      16.0
   4 │ S1      S3      S4      S5      1.0        0.0        0.0         16.0
   5 │ S2      S3      S4      S5      0.875      0.0625     0.0625      16.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; CSV.write(&quot;CFtable_species_norep.csv&quot;, df_sp_reduced); # to save to file</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d_sp_reduced = readTableCF(df_sp_reduced) # DataCF object, for input to snaq!</code><code class="nohighlight hljs ansi" style="display:block;">16.0 gene trees per 4-taxon set
Object DataCF
number of quartets: 5</code></pre><p>and now we can run <code>snaq!</code> on the reduced set of quartets without repeats, which should be faster:</p><pre><code class="language-julia hljs">net = snaq!(T_sp, d_sp_reduced);</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bootstrap/">« Bootstrap</a><a class="docs-footer-nextpage" href="../trait_tree/">Continuous Trait Evolution »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 11 May 2023 12:31">Thursday 11 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
