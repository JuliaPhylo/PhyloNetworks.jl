{
    "docs": [
        {
            "location": "/", 
            "text": "PhyloNetworks.jl\n\n\nPhyloNetworks is a Julia package for the manipulation, visualization and inference of phylogenetic networks.  SNaQ implements the statistical inference method in \nSol\ns-Lemus and An\n 2016\n. The procedure involves a numerical optimization of branch lengths and inheritance probabilities and a heuristic search in the space of phylogenetic networks.\n\n\n\n\nHow to get help\n\n\n\n\nthe package \nwiki\n has a step-by-step tutorial, done for the Evolution 2016 conference, with background on networks and explanations.\n\n\nthe \ngoogle group\n has answers to common questions.\n\n\nthe Manual below has a quick tutorial on SNaQ and PhyloNetworks.\n\n\nthe \nIndex\n further below has the full list of documented functions.\n\n\n\n\n\n\nManual Outline\n\n\n\n\nInstallation\n\n\nInstallation of Julia\n\n\nInstallation of the package PhyloNetworks\n\n\nTest example\n\n\nJulia types\n\n\n\n\n\n\nInput for SNaQ\n\n\nTutorial data: gene trees\n\n\nTutorial data: quartet CFs\n\n\n\n\n\n\nTICR pipeline\n\n\nTo run MrBayes: You already have alignments\n\n\nTo run BUCKy: You already have MrBayes output\n\n\n\n\n\n\nGetting a Network\n\n\nNetwork Estimation\n\n\nNetwork Visualization\n\n\nRe-rooting networks\n\n\nCandidate Network Evaluation\n\n\n\n\n\n\nFixed Network\n\n\nOptimizing branch lengths and inheritance probabilities for a given network\n\n\nNetwork Score with no optimization\n\n\n\n\n\n\nExtract Expected CFs\n\n\nBootstrap\n\n\nRunning a bootstrap analysis\n\n\nSummarizing bootstrap on the main tree\n\n\nSummarizing bootstrap on reticulations\n\n\n\n\n\n\nMultiple alleles per species\n\n\nTrait Evolution\n\n\nSimulation\n\n\nPhylogenetic Regression\n\n\nAncestral State Reconstruction\n\n\nData Imputation\n\n\nPhylogenetic ANOVA\n\n\nPagel's Lambda\n\n\n\n\n\n\n\n\n\n\nLibrary Outline\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nTypes\n\n\nUtilities\n\n\nData and Topology read/write\n\n\nNetwork inference\n\n\nNetwork Comparisons\n\n\nTrait Evolution\n\n\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\nTypes\n\n\nFunctions and methods\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nFunctions\n\n\n\n\nBase.getindex\n\n\nGadfly.plot\n\n\nPhyloNetworks.ancestralStateReconstruction\n\n\nPhyloNetworks.bootsnaq\n\n\nPhyloNetworks.cladewiseorder!\n\n\nPhyloNetworks.deleteHybridThreshold!\n\n\nPhyloNetworks.deleteleaf!\n\n\nPhyloNetworks.directEdges!\n\n\nPhyloNetworks.displayedNetworkAt!\n\n\nPhyloNetworks.displayedTrees\n\n\nPhyloNetworks.expectations\n\n\nPhyloNetworks.expectationsPlot\n\n\nPhyloNetworks.fittedQuartetCF\n\n\nPhyloNetworks.hardwiredCluster\n\n\nPhyloNetworks.hardwiredClusterDistance\n\n\nPhyloNetworks.hardwiredClusters\n\n\nPhyloNetworks.hybridBootstrapSupport\n\n\nPhyloNetworks.hybridatnode!\n\n\nPhyloNetworks.lambda_estim\n\n\nPhyloNetworks.majorTree\n\n\nPhyloNetworks.mapAllelesCFtable\n\n\nPhyloNetworks.minorTreeAt\n\n\nPhyloNetworks.mu_estim\n\n\nPhyloNetworks.phyloNetworklm\n\n\nPhyloNetworks.predint\n\n\nPhyloNetworks.predintPlot\n\n\nPhyloNetworks.preorder!\n\n\nPhyloNetworks.printEdges\n\n\nPhyloNetworks.printNodes\n\n\nPhyloNetworks.readBootstrapTrees\n\n\nPhyloNetworks.readInputTrees\n\n\nPhyloNetworks.readMultiTopology\n\n\nPhyloNetworks.readSnaqNetwork\n\n\nPhyloNetworks.readTableCF\n\n\nPhyloNetworks.readTableCF!\n\n\nPhyloNetworks.readTopology\n\n\nPhyloNetworks.readTopologyLevel1\n\n\nPhyloNetworks.readTrees2CF\n\n\nPhyloNetworks.rootatnode!\n\n\nPhyloNetworks.rootonedge!\n\n\nPhyloNetworks.rotate!\n\n\nPhyloNetworks.setGamma!\n\n\nPhyloNetworks.setLength!\n\n\nPhyloNetworks.sigma2_estim\n\n\nPhyloNetworks.simulate\n\n\nPhyloNetworks.snaq!\n\n\nPhyloNetworks.snaqDebug\n\n\nPhyloNetworks.sorttaxa!\n\n\nPhyloNetworks.summarizeDataCF\n\n\nPhyloNetworks.tipLabels\n\n\nPhyloNetworks.topologyMaxQPseudolik!\n\n\nPhyloNetworks.topologyQPseudolik!\n\n\nPhyloNetworks.treeEdgesBootstrap\n\n\nPhyloNetworks.writeMultiTopology\n\n\nPhyloNetworks.writeTopology\n\n\nBase.getindex\n\n\nPhyloNetworks.assignhybridnames!\n\n\nPhyloNetworks.deleteNode!\n\n\nPhyloNetworks.sampleBootstrapTrees\n\n\nPhyloNetworks.sampleCFfromCI\n\n\nPhyloNetworks.setNonIdBL!\n\n\nPhyloNetworks.sharedPathMatrix\n\n\n\n\n\n\nTypes\n\n\n\n\nPhyloNetworks.DataCF\n\n\nPhyloNetworks.HybridNetwork\n\n\nPhyloNetworks.ParamsBM\n\n\nPhyloNetworks.PhyloNetworkLinearModel\n\n\nPhyloNetworks.Quartet\n\n\nPhyloNetworks.ReconstructedStates\n\n\nPhyloNetworks.TraitSimulation\n\n\nPhyloNetworks.ANode\n\n\nPhyloNetworks.MatrixTopologicalOrder", 
            "title": "Home"
        }, 
        {
            "location": "/#phylonetworksjl", 
            "text": "PhyloNetworks is a Julia package for the manipulation, visualization and inference of phylogenetic networks.  SNaQ implements the statistical inference method in  Sol s-Lemus and An  2016 . The procedure involves a numerical optimization of branch lengths and inheritance probabilities and a heuristic search in the space of phylogenetic networks.", 
            "title": "PhyloNetworks.jl"
        }, 
        {
            "location": "/#how-to-get-help", 
            "text": "the package  wiki  has a step-by-step tutorial, done for the Evolution 2016 conference, with background on networks and explanations.  the  google group  has answers to common questions.  the Manual below has a quick tutorial on SNaQ and PhyloNetworks.  the  Index  further below has the full list of documented functions.", 
            "title": "How to get help"
        }, 
        {
            "location": "/#manual-outline", 
            "text": "Installation  Installation of Julia  Installation of the package PhyloNetworks  Test example  Julia types    Input for SNaQ  Tutorial data: gene trees  Tutorial data: quartet CFs    TICR pipeline  To run MrBayes: You already have alignments  To run BUCKy: You already have MrBayes output    Getting a Network  Network Estimation  Network Visualization  Re-rooting networks  Candidate Network Evaluation    Fixed Network  Optimizing branch lengths and inheritance probabilities for a given network  Network Score with no optimization    Extract Expected CFs  Bootstrap  Running a bootstrap analysis  Summarizing bootstrap on the main tree  Summarizing bootstrap on reticulations    Multiple alleles per species  Trait Evolution  Simulation  Phylogenetic Regression  Ancestral State Reconstruction  Data Imputation  Phylogenetic ANOVA  Pagel's Lambda", 
            "title": "Manual Outline"
        }, 
        {
            "location": "/#library-outline", 
            "text": "Public Documentation  Contents  Index  Types  Utilities  Data and Topology read/write  Network inference  Network Comparisons  Trait Evolution    Internal Documentation  Contents  Index  Types  Functions and methods", 
            "title": "Library Outline"
        }, 
        {
            "location": "/#index", 
            "text": "", 
            "title": "Index"
        }, 
        {
            "location": "/#functions", 
            "text": "Base.getindex  Gadfly.plot  PhyloNetworks.ancestralStateReconstruction  PhyloNetworks.bootsnaq  PhyloNetworks.cladewiseorder!  PhyloNetworks.deleteHybridThreshold!  PhyloNetworks.deleteleaf!  PhyloNetworks.directEdges!  PhyloNetworks.displayedNetworkAt!  PhyloNetworks.displayedTrees  PhyloNetworks.expectations  PhyloNetworks.expectationsPlot  PhyloNetworks.fittedQuartetCF  PhyloNetworks.hardwiredCluster  PhyloNetworks.hardwiredClusterDistance  PhyloNetworks.hardwiredClusters  PhyloNetworks.hybridBootstrapSupport  PhyloNetworks.hybridatnode!  PhyloNetworks.lambda_estim  PhyloNetworks.majorTree  PhyloNetworks.mapAllelesCFtable  PhyloNetworks.minorTreeAt  PhyloNetworks.mu_estim  PhyloNetworks.phyloNetworklm  PhyloNetworks.predint  PhyloNetworks.predintPlot  PhyloNetworks.preorder!  PhyloNetworks.printEdges  PhyloNetworks.printNodes  PhyloNetworks.readBootstrapTrees  PhyloNetworks.readInputTrees  PhyloNetworks.readMultiTopology  PhyloNetworks.readSnaqNetwork  PhyloNetworks.readTableCF  PhyloNetworks.readTableCF!  PhyloNetworks.readTopology  PhyloNetworks.readTopologyLevel1  PhyloNetworks.readTrees2CF  PhyloNetworks.rootatnode!  PhyloNetworks.rootonedge!  PhyloNetworks.rotate!  PhyloNetworks.setGamma!  PhyloNetworks.setLength!  PhyloNetworks.sigma2_estim  PhyloNetworks.simulate  PhyloNetworks.snaq!  PhyloNetworks.snaqDebug  PhyloNetworks.sorttaxa!  PhyloNetworks.summarizeDataCF  PhyloNetworks.tipLabels  PhyloNetworks.topologyMaxQPseudolik!  PhyloNetworks.topologyQPseudolik!  PhyloNetworks.treeEdgesBootstrap  PhyloNetworks.writeMultiTopology  PhyloNetworks.writeTopology  Base.getindex  PhyloNetworks.assignhybridnames!  PhyloNetworks.deleteNode!  PhyloNetworks.sampleBootstrapTrees  PhyloNetworks.sampleCFfromCI  PhyloNetworks.setNonIdBL!  PhyloNetworks.sharedPathMatrix", 
            "title": "Functions"
        }, 
        {
            "location": "/#types", 
            "text": "PhyloNetworks.DataCF  PhyloNetworks.HybridNetwork  PhyloNetworks.ParamsBM  PhyloNetworks.PhyloNetworkLinearModel  PhyloNetworks.Quartet  PhyloNetworks.ReconstructedStates  PhyloNetworks.TraitSimulation  PhyloNetworks.ANode  PhyloNetworks.MatrixTopologicalOrder", 
            "title": "Types"
        }, 
        {
            "location": "/man/installation/", 
            "text": "Installation\n\n\n\n\nInstallation of Julia\n\n\nJulia is a high-level and interactive programming language (like R or Matlab), but it is also high-performance (like C). To install Julia, go to http://julialang.org/downloads/ For a basic tutorial on Julia, see http://learnxinyminutes.com/docs/julia/\n\n\nIMPORTANT: Julia code is just-in-time compiled. This means that the first time you run a function, it will be compiled at that moment. So, please be patient! Future calls to the function will be much much faster. Trying out toy examples for the first calls is a good idea.\n\n\nUsers should have Julia 0.4 or above.\n\n\n\n\nInstallation of the package PhyloNetworks\n\n\nTo install the package, type inside Julia:\n\n\nPkg.add(\nPhyloNetworks\n)\n\n\n\n\nThe first step can take a few minutes, be patient. If you already installed the package and want the latest registered version, just do this (which will update all of your packages):\n\n\nPkg.update()\n\n\n\n\nWARNING: It is important to update the package regularly as it is undergoing constant development. Join the google group for updates \nhere\n.\n\n\nPkg.update()\n will install the latest registered version, but there could be other improvements in the \nmaster\n branch of the repository. If you want to update to the latest unregistered version of the package, you can do \nPkg.checkout(\"PhyloNetworks\")\n just beware that the latest changes could be not as robust. If you want to go back to the registered package, you can do \nPkg.free(\"PhyloNetworks\")\n.\n\n\nSimilarly, you can pin a version of the package \nPkg.pin(\"PhyloNetworks\")\n so that \nPkg.update()\n will not modify it. You can always free a pinned package with \nPkg.free(\"PhyloNetworks\")\n. More on checked and pinned packages \nhere\n.\n\n\n\n\n\nThe PhyloNetworks package has dependencies like NLopt and Gadfly (see the REQUIRE file for the full list), but everything is installed automatically.\n\n\n\n\nTest example\n\n\nTo check that your installation worked, type this in Julia to load the package. This is something to type every time you start a Julia session:\n\n\nusing PhyloNetworks;\n\n\n\n\nThis step can also take a while, if Julia needs to pre-compile the code (after a package update for instance). Here is a very small test for the installation of PhyloNetworks.\n\n\nnet = readTopology(\n(A,(B,(C,D)));\n);\ntipLabels(net)\n\n\n\n\n4-element Array{String,1}:\n \nA\n\n \nB\n\n \nC\n\n \nD\n\n\n\n\n\nYou can see a list of all the functions with\n\n\nwhos(PhyloNetworks)\n\n\n\n\nand press \n?\n inside Julia to switch to help mode, followed by the name of a function (or type) to get more details about it.\n\n\n\n\nJulia types\n\n\nObjects in Julia are called \ntypes\n. We show here small example on how to get more info on an object, what's its type, and how to manipulate objects. For example, let's take an object \nd\n created from reading in some data (see \nInput for SNaQ\n):\n\n\nd=readTrees2CF(\ntableCF.txt\n);\n\n\n\n\nTyping the following command will provide a list of objects saved in memory, including \nd\n that we just created:\n\n\nwhos()\n\n\n\n\nIf we want to know the type of a particular object, we do:\n\n\ntypeof(d)\n\n\n\n\nwhich shows us that \nd\n if of type \nDataCF\n. If we want to know about the attributes the object has, we can type \n?\n in Julia, followed by \nDataCF\n for a description. We can also ask for a list of all its attributes with\n\n\nfieldnames(d)\n\n\n\n\nFor example, we see that one attribute is \nnumQuartets\n: its the number of 4-taxon subsets in the data. To see what this number is:\n\n\nd.numQuartets\n\n\n\n\nWe also noticed an attribute \nquartet\n. It is a vector of Quartet objects inside \nd\n, so\n\n\nd.quartet[1].taxon\n\n\n\n\nwill provide the list of taxon names for the first 4-taxon subset in the data. We can corroborate this is the firs 4-taxon subset by checking the file \ntableCF.txt\n.\n\n\nTo see the observed CF, we can type\n\n\nd.quartet[1].obsCF\n\n\n\n\nWe can verify the type with\n\n\ntypeof(d.quartet[1])\n\n\n\n\nYou can also read a simple network in Julia and print the list of edges\n\n\nstr = \n(A,((B,#H1),(C,(D)#H1)));\n;\nnet = readTopology(str)\nprintEdges(net)\n\n\n\n\nYou see that the edges do not have branch lengths, and the hybrid edges do not have gamma values, you can set them with\n\n\nsetLength!(net.edge[1],1.9)\nsetGamma!(net.edge[3],0.8)\nprintEdges(net)\n\n\n\n\nwhere 1 and 3 correspond to the position of the given edge to modify in the list of edges. You can only change the gamma value of hybrid edges. Such an attempt below will cause an error with a message to explain that the edge was a tree edge:\n\n\nsetGamma!(net.edge[4],0.7)\n# should return this:\n# ERROR: cannot change gamma in a tree edge", 
            "title": "Installation"
        }, 
        {
            "location": "/man/installation/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/man/installation/#installation-of-julia", 
            "text": "Julia is a high-level and interactive programming language (like R or Matlab), but it is also high-performance (like C). To install Julia, go to http://julialang.org/downloads/ For a basic tutorial on Julia, see http://learnxinyminutes.com/docs/julia/  IMPORTANT: Julia code is just-in-time compiled. This means that the first time you run a function, it will be compiled at that moment. So, please be patient! Future calls to the function will be much much faster. Trying out toy examples for the first calls is a good idea.  Users should have Julia 0.4 or above.", 
            "title": "Installation of Julia"
        }, 
        {
            "location": "/man/installation/#installation-of-the-package-phylonetworks", 
            "text": "To install the package, type inside Julia:  Pkg.add( PhyloNetworks )  The first step can take a few minutes, be patient. If you already installed the package and want the latest registered version, just do this (which will update all of your packages):  Pkg.update()  WARNING: It is important to update the package regularly as it is undergoing constant development. Join the google group for updates  here .  Pkg.update()  will install the latest registered version, but there could be other improvements in the  master  branch of the repository. If you want to update to the latest unregistered version of the package, you can do  Pkg.checkout(\"PhyloNetworks\")  just beware that the latest changes could be not as robust. If you want to go back to the registered package, you can do  Pkg.free(\"PhyloNetworks\") .  Similarly, you can pin a version of the package  Pkg.pin(\"PhyloNetworks\")  so that  Pkg.update()  will not modify it. You can always free a pinned package with  Pkg.free(\"PhyloNetworks\") . More on checked and pinned packages  here .   The PhyloNetworks package has dependencies like NLopt and Gadfly (see the REQUIRE file for the full list), but everything is installed automatically.", 
            "title": "Installation of the package PhyloNetworks"
        }, 
        {
            "location": "/man/installation/#test-example", 
            "text": "To check that your installation worked, type this in Julia to load the package. This is something to type every time you start a Julia session:  using PhyloNetworks;  This step can also take a while, if Julia needs to pre-compile the code (after a package update for instance). Here is a very small test for the installation of PhyloNetworks.  net = readTopology( (A,(B,(C,D))); );\ntipLabels(net)  4-element Array{String,1}:\n  A \n  B \n  C \n  D   You can see a list of all the functions with  whos(PhyloNetworks)  and press  ?  inside Julia to switch to help mode, followed by the name of a function (or type) to get more details about it.", 
            "title": "Test example"
        }, 
        {
            "location": "/man/installation/#julia-types", 
            "text": "Objects in Julia are called  types . We show here small example on how to get more info on an object, what's its type, and how to manipulate objects. For example, let's take an object  d  created from reading in some data (see  Input for SNaQ ):  d=readTrees2CF( tableCF.txt );  Typing the following command will provide a list of objects saved in memory, including  d  that we just created:  whos()  If we want to know the type of a particular object, we do:  typeof(d)  which shows us that  d  if of type  DataCF . If we want to know about the attributes the object has, we can type  ?  in Julia, followed by  DataCF  for a description. We can also ask for a list of all its attributes with  fieldnames(d)  For example, we see that one attribute is  numQuartets : its the number of 4-taxon subsets in the data. To see what this number is:  d.numQuartets  We also noticed an attribute  quartet . It is a vector of Quartet objects inside  d , so  d.quartet[1].taxon  will provide the list of taxon names for the first 4-taxon subset in the data. We can corroborate this is the firs 4-taxon subset by checking the file  tableCF.txt .  To see the observed CF, we can type  d.quartet[1].obsCF  We can verify the type with  typeof(d.quartet[1])  You can also read a simple network in Julia and print the list of edges  str =  (A,((B,#H1),(C,(D)#H1))); ;\nnet = readTopology(str)\nprintEdges(net)  You see that the edges do not have branch lengths, and the hybrid edges do not have gamma values, you can set them with  setLength!(net.edge[1],1.9)\nsetGamma!(net.edge[3],0.8)\nprintEdges(net)  where 1 and 3 correspond to the position of the given edge to modify in the list of edges. You can only change the gamma value of hybrid edges. Such an attempt below will cause an error with a message to explain that the edge was a tree edge:  setGamma!(net.edge[4],0.7)\n# should return this:\n# ERROR: cannot change gamma in a tree edge", 
            "title": "Julia types"
        }, 
        {
            "location": "/man/inputdata/", 
            "text": "Input for SNaQ\n\n\nSNaQ is a method implemented in the package to estimate a phylogenetic network from multiple molecular sequence alignments. There are two alternatives for the input data:\n\n\n\n\nA list of estimated gene trees for each locus, which can be obtained using\n\n\n\n\nMrBayes\n or \nRAxML\n. Or:\n\n\n\n\nA table of concordance factors (CF) for each 4-taxon subset which can be\n\n\n\n\nobtained from \nBUCKy\n,   to account for gene tree uncertainty\n\n\nThis \npipeline\n can be used to obtain the table of  quartet CF needed as input for SNaQ. The pipeline starts from the sequence alignments, runs MrBayes and then BUCKy (both parallelized), producing the table of estimated CFs and their credibility intervals. Additional details on this \nTICR pipeline\n describe how to insert data at various stages (e.g. after running MrBayes on each locus).\n\n\n\n\nTutorial data: gene trees\n\n\n We suggest that you create a special directory for running these examples, where input files can be downloaded and where output files will be created (with estimated networks for instance). Enter this directory and run Julia from there.\n\n\nSuppose you have a file with a list of gene trees in parenthetical format called \ntreefile.txt\n. You can access the example file of input trees \nhere\n or \nhere\n for easier download.\n\n\nDo not copy-paste into a \"smart\" text-editor. Instead, save the file directly into your working directory using \"save link as\" or \"download linked file as\". This file contains 10 trees, each in parenthetical format on 6 taxa like this:\n\n\n(6:2.728,((3:0.655,5:0.655):1.202,(1:0.881,(2:0.783,4:0.783):0.098):0.976):0.871);\n\n\nIf 'treefile.txt' is in your working directory, you can view its content within Julia:\n\n\nless(\ntreefile.txt\n)\n\n\n\n\nJust type \nq\n to quit viewing this file. You could read in these 10 trees and visualize the third one (say) like this:\n\n\ntentrees = readMultiTopology(\ntreefile.txt\n)\ntentrees[3]\nplot(tentrees[3])\n\n\n\n\nTo read in all gene trees and directly summarize them by a list of quartet CFs (proportion of input trees with a given quartet):\n\n\nd=readTrees2CF(\ntreefile.txt\n, CFfile=\ntableCFall.txt\n)\nless(\ntableCFall.txt\n)\n\n\n\n\nless(\"tableCFall.txt\")\n lets you see the content of the newly created file \"tableCFall.txt\", within Julia. Again, type \nq\n to quit viewing this file.\n\n\nIf instead of all the 4-taxon subsets, you just want to use a random sample of 10 4-taxon subsets:\n\n\nd=readTrees2CF(\ntreefile.txt\n, whichQ=\nrand\n, numQ=10, CFfile=\ntableCF10.txt\n)\n\n\n\n\nBe careful to use a numQ value smaller than the total number of possible 4-taxon subsets, which is \nn choose 4\n on \nn\n taxa (e.g. 15 on 6 taxa). To get a predictable random sample, you may set the seed with \nsrand(12321)\n (for instance) prior to sampling the quartets as above.\n\n\n\n\nTutorial data: quartet CFs\n\n\nIf you already have a table of quartet concordance factor (CF) values in a file \ntableCF.txt\n in this format\n\n\n\n\n\n\n\n\nTaxon1\n\n\nTaxon2\n\n\nTaxon3\n\n\nTaxon4\n\n\nCF12_34\n\n\nCF13_24\n\n\nCF14_23\n\n\n\n\n\n\n\n\n\n\nA\n\n\nB\n\n\nE\n\n\nD\n\n\n0.4\n\n\n0.6\n\n\n0.0\n\n\n\n\n\n\n\n\nyou would read it like this:\n\n\nd=readTableCF(\ntableCF.txt\n) # one step only: read file and convert to 'DataCF' object\n# or in 2 steps:\nusing DataFrames\ndat = readtable(\ntableCF.txt\n) # read file into a 'DataFrame' object\nd = readTableCF(dat)           # convert DataFrame into DataCF\n\n\n\n\nYou can access this example file \nhere\n or \nhere\n.\n\n\nColumns need to be in the right order. If you have the information on the number of genes used for each 4-taxon subset, you can add this information in a column named \"ngenes\".\n\n\nIf you have a tree \nstartTree.txt\n in parenthetical format to use as starting point for the optimization, you can read it with\n\n\nT=readTopology(\nstartTree.txt\n)\n\n\n\n\nYou can access this example file \nhere\n (raw file \nhere\n).\n\n\nIf the topology \nT\n is to be used as a starting tree for SNaQ, it needs to be of level 1. To make sure that it is, you may read it in with \nreadTopologyLevel1\n (which may also unroot the tree, resolve polytomies, replace missing branch lengths by 1 for starting values etc.):\n\n\nT=readTopologyLevel1(\nstartTree.txt\n)\n\n\n\n\nNote that all trees and all networks with 1 hybridization are of level 1.\n\n\nNext: \nGetting a Network", 
            "title": "Input Data for SNaQ"
        }, 
        {
            "location": "/man/inputdata/#input-for-snaq", 
            "text": "SNaQ is a method implemented in the package to estimate a phylogenetic network from multiple molecular sequence alignments. There are two alternatives for the input data:   A list of estimated gene trees for each locus, which can be obtained using   MrBayes  or  RAxML . Or:   A table of concordance factors (CF) for each 4-taxon subset which can be   obtained from  BUCKy ,   to account for gene tree uncertainty  This  pipeline  can be used to obtain the table of  quartet CF needed as input for SNaQ. The pipeline starts from the sequence alignments, runs MrBayes and then BUCKy (both parallelized), producing the table of estimated CFs and their credibility intervals. Additional details on this  TICR pipeline  describe how to insert data at various stages (e.g. after running MrBayes on each locus).", 
            "title": "Input for SNaQ"
        }, 
        {
            "location": "/man/inputdata/#tutorial-data-gene-trees", 
            "text": "We suggest that you create a special directory for running these examples, where input files can be downloaded and where output files will be created (with estimated networks for instance). Enter this directory and run Julia from there. Suppose you have a file with a list of gene trees in parenthetical format called  treefile.txt . You can access the example file of input trees  here  or  here  for easier download.  Do not copy-paste into a \"smart\" text-editor. Instead, save the file directly into your working directory using \"save link as\" or \"download linked file as\". This file contains 10 trees, each in parenthetical format on 6 taxa like this:  (6:2.728,((3:0.655,5:0.655):1.202,(1:0.881,(2:0.783,4:0.783):0.098):0.976):0.871);  If 'treefile.txt' is in your working directory, you can view its content within Julia:  less( treefile.txt )  Just type  q  to quit viewing this file. You could read in these 10 trees and visualize the third one (say) like this:  tentrees = readMultiTopology( treefile.txt )\ntentrees[3]\nplot(tentrees[3])  To read in all gene trees and directly summarize them by a list of quartet CFs (proportion of input trees with a given quartet):  d=readTrees2CF( treefile.txt , CFfile= tableCFall.txt )\nless( tableCFall.txt )  less(\"tableCFall.txt\")  lets you see the content of the newly created file \"tableCFall.txt\", within Julia. Again, type  q  to quit viewing this file.  If instead of all the 4-taxon subsets, you just want to use a random sample of 10 4-taxon subsets:  d=readTrees2CF( treefile.txt , whichQ= rand , numQ=10, CFfile= tableCF10.txt )  Be careful to use a numQ value smaller than the total number of possible 4-taxon subsets, which is  n choose 4  on  n  taxa (e.g. 15 on 6 taxa). To get a predictable random sample, you may set the seed with  srand(12321)  (for instance) prior to sampling the quartets as above.", 
            "title": "Tutorial data: gene trees"
        }, 
        {
            "location": "/man/inputdata/#tutorial-data-quartet-cfs", 
            "text": "If you already have a table of quartet concordance factor (CF) values in a file  tableCF.txt  in this format     Taxon1  Taxon2  Taxon3  Taxon4  CF12_34  CF13_24  CF14_23      A  B  E  D  0.4  0.6  0.0     you would read it like this:  d=readTableCF( tableCF.txt ) # one step only: read file and convert to 'DataCF' object\n# or in 2 steps:\nusing DataFrames\ndat = readtable( tableCF.txt ) # read file into a 'DataFrame' object\nd = readTableCF(dat)           # convert DataFrame into DataCF  You can access this example file  here  or  here .  Columns need to be in the right order. If you have the information on the number of genes used for each 4-taxon subset, you can add this information in a column named \"ngenes\".  If you have a tree  startTree.txt  in parenthetical format to use as starting point for the optimization, you can read it with  T=readTopology( startTree.txt )  You can access this example file  here  (raw file  here ).  If the topology  T  is to be used as a starting tree for SNaQ, it needs to be of level 1. To make sure that it is, you may read it in with  readTopologyLevel1  (which may also unroot the tree, resolve polytomies, replace missing branch lengths by 1 for starting values etc.):  T=readTopologyLevel1( startTree.txt )  Note that all trees and all networks with 1 hybridization are of level 1.  Next:  Getting a Network", 
            "title": "Tutorial data: quartet CFs"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/", 
            "text": "TICR pipeline\n\n\nThis page provides details to insert data into the TICR pipeline at various stages. Full information and code for this pipeline is \nhere\n.\n\n\n\n\nTo run MrBayes: You already have alignments\n\n\nIf you don't need to run mdl.pl because you already have aligned gene sequences which you would like to run through MrBayes, you can simply create a tarball of the Nexus files (fasta won't work at this stage) you wish to use. This command assumes that you want to use all the files ending with \".nex\" in the current directory, one file per locus:\n\n\ntar czf my-genes.tar.gz *.nex\n\n\nOnce the tarball has been successfully generated, you can then specify this file as input for \nmb.pl\n assuming you have a a valid MrBayes block located in the file \"bayes.txt\":\n\n\nmb.pl my-genes.tar.gz -m bayes.txt -o my-genes-mb\n\n\nIf you get an error message like \nmb.pl: Command not found\n, it might be because \nmb.pl\n has no execute permission or your current directory is not in your path. An easy fix is to run this command instead:\n\n\nperl mb.pl my-genes.tar.gz -m bayes.txt -o my-genes-mb\n\n\nThe resulting output tarball would now be located in my-genes-mb/my-genes.mb.tar, and can be used normally with \nbucky.pl\n, that is, like this:\n\n\nbucky.pl my-genes-mb/my-genes.mb.tar -o mygenes-bucky\n\n\nThe output, with the table of concordance factors for all sets of 4 taxa, will be in a file named \nmy-genes.CFs.csv\n inside a directory named \nmygenes-bucky\n. That's the file containing the quartet concordance factors to give to SNaQ as input.\n\n\n\n\nTo run BUCKy: You already have MrBayes output\n\n\n\n\nTo run mbsum on the output of MrBayes for each gene\n\n\nYou must now run \nmbsum\n separately on each gene's MrBayes output. For a gene with output tree files named gene1.run1.t gene1.run2.t gene1.run3.t, and a desired burnin of 1000 trees per tree file:\n\n\nmbsum -n 1000 -o gene1.in gene1.run1.t gene1.run2.t gene1.run3.t\n\n\nThis \nmbsum\n command will need to be executed for each gene. Now continue to the next section.\n\n\n\n\nTo run bucky on all 4-taxon sets: you already have the mbsum output\n\n\nIf you have already run mbsum on each individual gene's MrBayes output, you can simply create a tarball containing all the mbsum output files. So if you had mbsum output in files named gene1.in, gene2.in, ... , gene100.in, you would want to run something similar to the following command:\n\n\ntar czf my-genes-mbsum.tar.gz gene*.in\n\n\nYou can now use this tarball along with the -s option in \nbucky.pl\n like this:\n\n\nbucky.pl my-genes-mbsum.tar.gz -s -o mygenes-bucky\n\n\nAgain, if you get an error like \nbucky.pl: Command not found\n, run instead\n\n\nbucky.pl my-genes-mbsum.tar.gz -s -o mygenes-bucky\n\n\nThe output, with the table of concordance factors for all sets of 4 taxa, will be in a file named \nmy-genes.CFs.csv\n inside directory \nmygenes-bucky\n. That's the file containing the quartet concordance factors to give to SNaQ as input.", 
            "title": "TICR pipeline"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#ticr-pipeline", 
            "text": "This page provides details to insert data into the TICR pipeline at various stages. Full information and code for this pipeline is  here .", 
            "title": "TICR pipeline"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#to-run-mrbayes-you-already-have-alignments", 
            "text": "If you don't need to run mdl.pl because you already have aligned gene sequences which you would like to run through MrBayes, you can simply create a tarball of the Nexus files (fasta won't work at this stage) you wish to use. This command assumes that you want to use all the files ending with \".nex\" in the current directory, one file per locus:  tar czf my-genes.tar.gz *.nex  Once the tarball has been successfully generated, you can then specify this file as input for  mb.pl  assuming you have a a valid MrBayes block located in the file \"bayes.txt\":  mb.pl my-genes.tar.gz -m bayes.txt -o my-genes-mb  If you get an error message like  mb.pl: Command not found , it might be because  mb.pl  has no execute permission or your current directory is not in your path. An easy fix is to run this command instead:  perl mb.pl my-genes.tar.gz -m bayes.txt -o my-genes-mb  The resulting output tarball would now be located in my-genes-mb/my-genes.mb.tar, and can be used normally with  bucky.pl , that is, like this:  bucky.pl my-genes-mb/my-genes.mb.tar -o mygenes-bucky  The output, with the table of concordance factors for all sets of 4 taxa, will be in a file named  my-genes.CFs.csv  inside a directory named  mygenes-bucky . That's the file containing the quartet concordance factors to give to SNaQ as input.", 
            "title": "To run MrBayes: You already have alignments"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#to-run-bucky-you-already-have-mrbayes-output", 
            "text": "", 
            "title": "To run BUCKy: You already have MrBayes output"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#to-run-mbsum-on-the-output-of-mrbayes-for-each-gene", 
            "text": "You must now run  mbsum  separately on each gene's MrBayes output. For a gene with output tree files named gene1.run1.t gene1.run2.t gene1.run3.t, and a desired burnin of 1000 trees per tree file:  mbsum -n 1000 -o gene1.in gene1.run1.t gene1.run2.t gene1.run3.t  This  mbsum  command will need to be executed for each gene. Now continue to the next section.", 
            "title": "To run mbsum on the output of MrBayes for each gene"
        }, 
        {
            "location": "/man/ticr_howtogetQuartetCFs/#to-run-bucky-on-all-4-taxon-sets-you-already-have-the-mbsum-output", 
            "text": "If you have already run mbsum on each individual gene's MrBayes output, you can simply create a tarball containing all the mbsum output files. So if you had mbsum output in files named gene1.in, gene2.in, ... , gene100.in, you would want to run something similar to the following command:  tar czf my-genes-mbsum.tar.gz gene*.in  You can now use this tarball along with the -s option in  bucky.pl  like this:  bucky.pl my-genes-mbsum.tar.gz -s -o mygenes-bucky  Again, if you get an error like  bucky.pl: Command not found , run instead  bucky.pl my-genes-mbsum.tar.gz -s -o mygenes-bucky  The output, with the table of concordance factors for all sets of 4 taxa, will be in a file named  my-genes.CFs.csv  inside directory  mygenes-bucky . That's the file containing the quartet concordance factors to give to SNaQ as input.", 
            "title": "To run bucky on all 4-taxon sets: you already have the mbsum output"
        }, 
        {
            "location": "/man/snaq_plot/", 
            "text": "Getting a Network\n\n\n\n\nNetwork Estimation\n\n\nAfter \nInput for SNaQ\n, we can estimate the network using the input data \nd\n and starting from tree (or network) \nT\n:\n\n\nnet1=snaq!(T,d,filename=\nnet1_snaq\n);\nless(\nnet1_snaq.err\n)\nless(\nnet1_snaq.out\n)\nless(\nnet1_snaq.networks\n)\nnet2=snaq!(T,d,hmax=2, filename=\nnet2_snaq\n);\n\n\n\n\nwhen viewing the result files \"net1_snaq.err\" and \"net1_snaq.out\" with \nless\n within Julia, use arrows to scroll down and type \nq\n to quit viewing the files. The \"net1_snaq.networks\" file contains a list of networks obtained from moving the placement of the hybrid node to another node inside the cycle, along with its pseudolikelihood score.\n\n\nThe option \nhmax\n corresponds to the maximum number of hybridizations allowed, 1 by default. The function name \nsnaq!\n ends with ! because it modifies the argument \nd\n by including the expected CF. Type \n?\n then \nsnaq!\n to get help on that function.\n\n\nThe estimation function creates a \n.out\n file (\nsnaq.out\n by default) with the estimated network in parenthetical format, which you can also print directly to the screen like this:\n\n\nnet1\nwriteTopology(net1)                   # topology to screen, full precision for branch lengths and \u03b3\nwriteTopology(net1,di=true)           # \u03b3 omitted: for dendroscope\nwriteTopology(net1, \nbestnet_h1.tre\n) # topology to file 'bestnet_h1.tre': creates or overwrites file\nless(\nbestnet_h1.tre\n)                # just view the file\n\n\n\n\nThe option \ndi=true\n is for the parenthetical format used by \nDendroscope\n (without reticulation heritabilities). Copy this parenthetical description and paste it into Dendroscope, or use the plotting function described below.\n\n\n\n\nSNaQ error\n\n\nPlease report any bugs and errors to \nclaudia@stat.wisc.edu\n, so we can debug it. The easiest way to do it is by checking the \n.err\n file which will show the number of runs that failed by a bug and the corresponding seed to replicate the run. This is an example of what the \n.err\n file looks like: \nTotal errors: 1 in seeds [4545]\n. You need to run the following function with the same settings that caused the error:\n\n\nsnaqDebug(T,d,hmax=2,seed=4545)\n\n\n\n\nThis will create two files: \nsnaqDebug.log\n and \ndebug.log\n which you can then send to \nclaudia@stat.wisc.edu\n with subject \"SNaQ bug found\" or something similar. I will not have access to any part of your data, the files simply print out the steps to retrace the bug, and hopefully fix it.\n\n\n\n\nNetwork Visualization\n\n\nTo visualize the network:\n\n\np = plot(net1, showGamma=true)\n\n\n\n\nThis function will open a browser where the plot will appear. To get a pdf version of the plot:\n\n\nusing Gadfly\ndraw(PDF(\nbestnet_h1.pdf\n, 4inch, 4inch),p)\n\n\n\n\nThe plot function has many options. Type \n?\n to switch to the help mode of Julia, then type the name of the function, here \nplot\n. Edge colors can be modified, for instance.\n\n\n# using Gadfly # if not done earlier\nplot(net1, showEdgeLength=true, minorHybridEdgeColor=colorant\ntan\n)\n\n\n\n\n\n\nRe-rooting networks\n\n\nSNaQ infers an unrooted semi-directed network, in the sense that the direction of tree edges cannot be inferred, but the direction of hybrid edges can be inferred. To obtain a representative visualization, it is best to root the network first, using one or more outgroup. If there is a single outgroup, the network can be rooted with this outgroup, if compatible, like this:\n\n\nrootatnode!(net1, \n4\n)\nplot(net1, showGamma=true)\n\n\n\n\nHere we used taxon \"4\" as outgroup. More options are available, to root the network either at a give node or along a given edge. Use the help mode (type \n?\n) to get help on the functions \nrootatnode!\n and \nrootonedge!\n to get more info.\n\n\nIf the network is plotted with crossing edges, you may identify ways to rotate the children edges at some nodes to untangle some crossing edges. This can be done using the function \nrotate!\n. Type \n?\n then \nrotate!\n to get help and examples.\n\n\n\n\nCandidate Network Evaluation\n\n\nFrom a set of candidate networks, one might simply need to score of each network to pick the best. Here, the score is the negative log pseudo-likelihood, and the lower the better. See the section to get the score of a \nFixed Network\n.\n\n\nElse: go next to \nExtract Expected CFs\n to see how your network fits your data, or go for a \nBootstrap\n analysis to quantify support for tree edges and hybrid edges.", 
            "title": "Network estimation and display"
        }, 
        {
            "location": "/man/snaq_plot/#getting-a-network", 
            "text": "", 
            "title": "Getting a Network"
        }, 
        {
            "location": "/man/snaq_plot/#network-estimation", 
            "text": "After  Input for SNaQ , we can estimate the network using the input data  d  and starting from tree (or network)  T :  net1=snaq!(T,d,filename= net1_snaq );\nless( net1_snaq.err )\nless( net1_snaq.out )\nless( net1_snaq.networks )\nnet2=snaq!(T,d,hmax=2, filename= net2_snaq );  when viewing the result files \"net1_snaq.err\" and \"net1_snaq.out\" with  less  within Julia, use arrows to scroll down and type  q  to quit viewing the files. The \"net1_snaq.networks\" file contains a list of networks obtained from moving the placement of the hybrid node to another node inside the cycle, along with its pseudolikelihood score.  The option  hmax  corresponds to the maximum number of hybridizations allowed, 1 by default. The function name  snaq!  ends with ! because it modifies the argument  d  by including the expected CF. Type  ?  then  snaq!  to get help on that function.  The estimation function creates a  .out  file ( snaq.out  by default) with the estimated network in parenthetical format, which you can also print directly to the screen like this:  net1\nwriteTopology(net1)                   # topology to screen, full precision for branch lengths and \u03b3\nwriteTopology(net1,di=true)           # \u03b3 omitted: for dendroscope\nwriteTopology(net1,  bestnet_h1.tre ) # topology to file 'bestnet_h1.tre': creates or overwrites file\nless( bestnet_h1.tre )                # just view the file  The option  di=true  is for the parenthetical format used by  Dendroscope  (without reticulation heritabilities). Copy this parenthetical description and paste it into Dendroscope, or use the plotting function described below.", 
            "title": "Network Estimation"
        }, 
        {
            "location": "/man/snaq_plot/#snaq-error", 
            "text": "Please report any bugs and errors to  claudia@stat.wisc.edu , so we can debug it. The easiest way to do it is by checking the  .err  file which will show the number of runs that failed by a bug and the corresponding seed to replicate the run. This is an example of what the  .err  file looks like:  Total errors: 1 in seeds [4545] . You need to run the following function with the same settings that caused the error:  snaqDebug(T,d,hmax=2,seed=4545)  This will create two files:  snaqDebug.log  and  debug.log  which you can then send to  claudia@stat.wisc.edu  with subject \"SNaQ bug found\" or something similar. I will not have access to any part of your data, the files simply print out the steps to retrace the bug, and hopefully fix it.", 
            "title": "SNaQ error"
        }, 
        {
            "location": "/man/snaq_plot/#network-visualization", 
            "text": "To visualize the network:  p = plot(net1, showGamma=true)  This function will open a browser where the plot will appear. To get a pdf version of the plot:  using Gadfly\ndraw(PDF( bestnet_h1.pdf , 4inch, 4inch),p)  The plot function has many options. Type  ?  to switch to the help mode of Julia, then type the name of the function, here  plot . Edge colors can be modified, for instance.  # using Gadfly # if not done earlier\nplot(net1, showEdgeLength=true, minorHybridEdgeColor=colorant tan )", 
            "title": "Network Visualization"
        }, 
        {
            "location": "/man/snaq_plot/#re-rooting-networks", 
            "text": "SNaQ infers an unrooted semi-directed network, in the sense that the direction of tree edges cannot be inferred, but the direction of hybrid edges can be inferred. To obtain a representative visualization, it is best to root the network first, using one or more outgroup. If there is a single outgroup, the network can be rooted with this outgroup, if compatible, like this:  rootatnode!(net1,  4 )\nplot(net1, showGamma=true)  Here we used taxon \"4\" as outgroup. More options are available, to root the network either at a give node or along a given edge. Use the help mode (type  ? ) to get help on the functions  rootatnode!  and  rootonedge!  to get more info.  If the network is plotted with crossing edges, you may identify ways to rotate the children edges at some nodes to untangle some crossing edges. This can be done using the function  rotate! . Type  ?  then  rotate!  to get help and examples.", 
            "title": "Re-rooting networks"
        }, 
        {
            "location": "/man/snaq_plot/#candidate-network-evaluation", 
            "text": "From a set of candidate networks, one might simply need to score of each network to pick the best. Here, the score is the negative log pseudo-likelihood, and the lower the better. See the section to get the score of a  Fixed Network .  Else: go next to  Extract Expected CFs  to see how your network fits your data, or go for a  Bootstrap  analysis to quantify support for tree edges and hybrid edges.", 
            "title": "Candidate Network Evaluation"
        }, 
        {
            "location": "/man/fixednetworkoptim/", 
            "text": "Fixed Network\n\n\n\n\nOptimizing branch lengths and inheritance probabilities for a given network\n\n\nFor a given network topology, we can optimize the branch lengths and inheritance probabilities (\u03b3) with the pseudolikelihood. This is useful if we have a few candidate networks to compare. Each network can be optimized individually, and the network with the best pseudolikelihood can be chosen.\n\n\nThe score being optimized is the pseudo-deviance, i.e. the negative log pseudo-likelihood up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0 (the lower the better).\n\n\nnet1topo = readTopology(\n(2,(4,(3,(5,(6,#H1)))),(1)#H1);\n);\nnet1par = topologyMaxQPseudolik!(net1topo,d)\nnet1par.loglik # pseudo deviance, actually\n\n\n\n\nFor a more thorough optimization, we may increase the requirements before the search stops:\n\n\nnet1par = topologyMaxQPseudolik!(net1topo,d, xtolRel=1e-10, xtolAbs=1e-10)\nnet1par.loglik\n\n\n\n\n\n\nNetwork Score with no optimization\n\n\nFor a network with given branch lengths and \u03b3 heritabilies, we can compute the pseudolikelihood with:\n\n\nnet1withBL = readTopology(\n(2,(4,(3,(5,(6,#H6:1.0::0.3):5.006):0.518):0.491):1.533,(1)#H6:1.0::0.7);\n);\ntopologyQPseudolik!(net1withBL,d)\nnet1withBL.loglik\n\n\n\n\nThis function is not maximizing the pseudolikelihood, it is simply computing the pseudolikelihood (or deviance) for the given branch lengths and probabilities of inheritance. At the moment, both of these functions require that the given network is of level 1 (cycles don't overlap).", 
            "title": "Fixed Network"
        }, 
        {
            "location": "/man/fixednetworkoptim/#fixed-network", 
            "text": "", 
            "title": "Fixed Network"
        }, 
        {
            "location": "/man/fixednetworkoptim/#optimizing-branch-lengths-and-inheritance-probabilities-for-a-given-network", 
            "text": "For a given network topology, we can optimize the branch lengths and inheritance probabilities (\u03b3) with the pseudolikelihood. This is useful if we have a few candidate networks to compare. Each network can be optimized individually, and the network with the best pseudolikelihood can be chosen.  The score being optimized is the pseudo-deviance, i.e. the negative log pseudo-likelihood up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0 (the lower the better).  net1topo = readTopology( (2,(4,(3,(5,(6,#H1)))),(1)#H1); );\nnet1par = topologyMaxQPseudolik!(net1topo,d)\nnet1par.loglik # pseudo deviance, actually  For a more thorough optimization, we may increase the requirements before the search stops:  net1par = topologyMaxQPseudolik!(net1topo,d, xtolRel=1e-10, xtolAbs=1e-10)\nnet1par.loglik", 
            "title": "Optimizing branch lengths and inheritance probabilities for a given network"
        }, 
        {
            "location": "/man/fixednetworkoptim/#network-score-with-no-optimization", 
            "text": "For a network with given branch lengths and \u03b3 heritabilies, we can compute the pseudolikelihood with:  net1withBL = readTopology( (2,(4,(3,(5,(6,#H6:1.0::0.3):5.006):0.518):0.491):1.533,(1)#H6:1.0::0.7); );\ntopologyQPseudolik!(net1withBL,d)\nnet1withBL.loglik  This function is not maximizing the pseudolikelihood, it is simply computing the pseudolikelihood (or deviance) for the given branch lengths and probabilities of inheritance. At the moment, both of these functions require that the given network is of level 1 (cycles don't overlap).", 
            "title": "Network Score with no optimization"
        }, 
        {
            "location": "/man/expectedCFs/", 
            "text": "Extract Expected CFs\n\n\nA good way to visualize the \"goodness-of-fit\" of a given estimated network to the data is to plot the observed CF versus the expected CF. If the network is a good fit, then the dots in the plot will be close to the diagonal (x=y line). The following function will create a dataframe with the observed and expected CFs, which are all saved in the DataCF object after running snaq:\n\n\ndf_wide = fittedQuartetCF(d) # same as fittedQuartetCF(d, :wide)\ndf_long = fittedQuartetCF(d, :long)\n\n\n\n\nIt is important to have run \nsnaq!\n, \ntopologyQPseudolik!\n or \ntopologyMaxQPseudolik!\n before making this plot, or the result would be meaningless. These functions update the fitted concordance factors (those expected under the network) inside the dataCF object \nd\n.\n\n\nNow, we can plot them with any of the Julia packages for plotting. For example:\n\n\nusing Gadfly\np = plot(layer(df_long, x=\nobsCF\n, y=\nexpCF\n, Geom.point, Stat.x_jitter(range=0.4)),\n         layer(x=0:1,y=0:1, Geom.line))\n\n\n\n\nThis will pop up a browser window with the plot. The plot can be saved as PDF (or many other formats, see \nGadfly tutorial\n) with\n\n\ndraw(PDF(\nplot.pdf\n, 4inch, 3inch), p)\n\n\n\n\nTo highlight quartets that include taxon \"6\", say, if we suspect that it is an unrecognized hybrid, one may do this.\n\n\nusing DataFramesMeta # install this package with Pkg.add(\nDataFramesMeta\n) if not done before\nmycolor = @with(df_long, (:tx1 .== \n6\n) | (:tx2 .== \n6\n) | (:tx3 .== \n6\n) | (:tx4 .== \n6\n));\n# 'mycolor' is true for quartets having taxon \n6\n, false for others\np = plot(layer(df_long, x=\nobsCF\n, y=\nexpCF\n, color=mycolor, Geom.point),\n         layer(x=0:1,y=0:1, Geom.line),\n         Guide.colorkey(\nhas taxon 6?\n))\n\n\n\n\nTo export this table and explore the fit of the network with other tools:\n\n\nwritetable(\nfittedCF_net1_long.csv\n, df_long)", 
            "title": "Extract Expected CFs"
        }, 
        {
            "location": "/man/expectedCFs/#extract-expected-cfs", 
            "text": "A good way to visualize the \"goodness-of-fit\" of a given estimated network to the data is to plot the observed CF versus the expected CF. If the network is a good fit, then the dots in the plot will be close to the diagonal (x=y line). The following function will create a dataframe with the observed and expected CFs, which are all saved in the DataCF object after running snaq:  df_wide = fittedQuartetCF(d) # same as fittedQuartetCF(d, :wide)\ndf_long = fittedQuartetCF(d, :long)  It is important to have run  snaq! ,  topologyQPseudolik!  or  topologyMaxQPseudolik!  before making this plot, or the result would be meaningless. These functions update the fitted concordance factors (those expected under the network) inside the dataCF object  d .  Now, we can plot them with any of the Julia packages for plotting. For example:  using Gadfly\np = plot(layer(df_long, x= obsCF , y= expCF , Geom.point, Stat.x_jitter(range=0.4)),\n         layer(x=0:1,y=0:1, Geom.line))  This will pop up a browser window with the plot. The plot can be saved as PDF (or many other formats, see  Gadfly tutorial ) with  draw(PDF( plot.pdf , 4inch, 3inch), p)  To highlight quartets that include taxon \"6\", say, if we suspect that it is an unrecognized hybrid, one may do this.  using DataFramesMeta # install this package with Pkg.add( DataFramesMeta ) if not done before\nmycolor = @with(df_long, (:tx1 .==  6 ) | (:tx2 .==  6 ) | (:tx3 .==  6 ) | (:tx4 .==  6 ));\n# 'mycolor' is true for quartets having taxon  6 , false for others\np = plot(layer(df_long, x= obsCF , y= expCF , color=mycolor, Geom.point),\n         layer(x=0:1,y=0:1, Geom.line),\n         Guide.colorkey( has taxon 6? ))  To export this table and explore the fit of the network with other tools:  writetable( fittedCF_net1_long.csv , df_long)", 
            "title": "Extract Expected CFs"
        }, 
        {
            "location": "/man/bootstrap/", 
            "text": "Bootstrap\n\n\n\n\nRunning a bootstrap analysis\n\n\nWe can run a bootstrap analysis if we estimated quartet concordance factors (CFs) with credibility intervals, such as if we used the \nTICR pipeline\n. This pipeline provides a CF table with extra columns for credibility intervals.\n\n\nusing DataFrames\ndf = readtable(\ntableCFCI.csv\n)\nbootnet = bootsnaq(T, df, hmax=1, nrep=10, runs=3, filename=\nbootstrap\n)\n\n\n\n\nThis example file can be accessed \nhere\n or \nhere\n. Make sure that your downloaded file has the name \ntableCFCI.csv\n (to match the name in the Julia command), with no an extra extension \n.txt\n. Rename the file after download if necessary.\n\n\nThis example uses a number of replicates (10) that is definitely too small, to make the example run faster. You might also increase the number of optimization runs (\nruns\n) done for each bootstrap replicate.\n\n\nThe bootstrap networks are saved in the \nboostrap.out\n file, so they can be read in a new session with \nbootnet = readMultiTopology(\"boostrap.out\")\n. To save the bootstrap networks to a different file (perhaps after having re-rooted them with an outgroup), you can do this:\n\n\nwriteMultiTopology(bootnet, \nbootstrapNets_h1.tre\n)\nlength(bootnet) # 10 networks in the array 'bootnet'\nless(\nbootstrapNets_h1.tre\n)\n\n\n\n\nIf you close your session and re-open it later, you can re-read the bootstrap networks back in memory like this:\n\n\nbootnet = readMultiTopology(\nbootstrapNets_h1.tre\n);\n\n\n\n\nWe can run bootstrap analysis from gene trees also. We need a text file with a list of files containg the bootstrap trees (one file per gene). This is the same format used by ASTRAL (see the wiki page for more details.).\n\n\nbootTrees = readBootstrapTrees(\nBSlistfiles\n)\nbootnet = bootsnaq(T, bootTrees, hmax=1, nrep=100, filename=\nbootsnaq1_raxmlboot\n)\n\n\n\n\nIf you used a specified list of quartets on the original data, you should use that same list for the bootstrap analysis through the option \nquartetfile\n.\n\n\n\n\nSummarizing bootstrap on the main tree\n\n\nThe \nbootsnaq\n function, as used before, returned a list of 10 networks (\nnrep=10\n). Before summarizing them on the best network, it is best to re-read this network to get a reproducible internal numbering of its nodes and edges, used later for mapping bootstrap support to edges. We can then summarize bootstrap networks:\n\n\nnet1 = readTopology(\nnet1_snaq.out\n) # reading from output file of snaq\nBStable, tree1 = treeEdgesBootstrap(bootnet,net1)\n\n\n\n\nThis will calculate the major tree \ntree1\n displayed in \nnet1\n, that is, the tree obtained by following the major parent (\u03b3\n0.5) of each hybrid node. This tree can be visualized like this, with edge numbers shown for later use.\n\n\nrootatnode!(net1, \n4\n)\nrootatnode!(tree1, \n4\n)\nplot(tree1, showEdgeNumber=true)\n\n\n\n\nNext, we can look at bootstrap table \nBStable\n, which has one row for each tree edge in \nnet1\n. One column contains the edge number (same as shown in the plot) and another column contains the edge bootstrap support: the proportion of bootstrap replicates in which this edge was found in the major tree of the inferred network. We can see the full bootstrap table and see which tree edges have bootstrap support lower than 100% with\n\n\nshowall(BStable)\nBStable[BStable[:proportion] .\n 1.0, :]\n\n\n\n\nFinally, we can map the bootstrap proportions onto the network or its main tree by passing the bootstrap table to the \nedgeLabel\n option of \nplot\n:\n\n\nplot(tree1, edgeLabel=BStable)\nplot(net1,  edgeLabel=BStable)\n\n\n\n\n(Here, it is important that the numbers assigned to edges when building the boostrap table \u2013those in \nnet1\n at the time\u2013 correspond to the current edge numbers in \ntree1\n and \nnet1\n. That was the purpose of reading the network from the output file of snaq! earlier, for consistency across different Julia sessions.)\n\n\nIf we wanted to plot only certain bootstrap values, like those below 100% (1.0), we could do this:\n\n\nplot(net1, edgeLabel=BStable[BStable[:proportion] .\n 1.0, :])\n\n\n\n\n\n\nSummarizing bootstrap on reticulations\n\n\nSummarizing the placement of hybridization edges is not standard. The function \nhybridBootstrapSupport\n attempts to do so. The descendants of a given hybrid node form the \"recipient\" or \"hybrid\" clade, and is obtained after removing all other reticulations. If reticulation is due to gene flow or introgression, the minor hybrid edge (with \u03b3\n0.5) represents this event. The descendants of the lineage from which gene flow originated is then a second \"sister\" of the hybrid clade. Because of the reticulation event, the hybrid clade has 2 sister clades, not 1: the major sister (through the major hybrid edge with \u03b3\n0.5) and the minor sister (through the minor hybrid edge with \u03b3\n0.5). Note that the network says \nnothing\n about the process: its shows the \nrelationships\n only. We can calculate the frequency that each clade is a hybrid clade, or a major or minor sister for some other hybrid, in the bootstrap networks:\n\n\nBSn, BSe, BSc, BSgam, BSedgenum = hybridBootstrapSupport(bootnet, net1);\n\n\n\n\nLet's look at the results. We can list all the clades and the percentage of bootstrap networks (bootstrap support) in which each clade is a hybrid or sister to a hybrid:\n\n\nBSn\n\n\n\n\nIf a clade contains a single taxon, it is listed with its taxon name. The clade found in the best network is listed with its tag, starting with H (e.g. \"H7\"). The name of other clades start with \"c_\" followed by their number in the best network, if they do appear in the best network. The node numbers, as used internally in the best network, are listed in a separate column. They can be used later to display the bootstrap support values onto the network. Various columns give the bootstrap support that each clade is a hybrid, or a (major/minor) sister to a hybrid. The last column gives the bootstrap support for the full relationship in the best network: same hybrid with same two sisters. These bootstrap values are associated with nodes (or possibly, their parent edges).\n\n\nTo see what is the clade named \"H7\", for instance:\n\n\nBSc # this might be too big\nshowall(BSc)\nBSc[:taxa][BSc[:H7]]\n\n\n\n\nWe can also get bootstrap values associated with edges, to describe the support that a given hybrid clade has a given sister clade.\n\n\nBSe\n\n\n\n\nHere, each row describes a pair of 2 clades: one being the hybrid, the other being its sister, connected by a hybrid edge. The first rows corresponds to hybrid edges in the best network. Other rows correspond to edges seen in bootstrap networks but not in the best network.\n\n\nBSedgenum\n\n\n\n\nlists all the hybrid edges in the best network, two for each hybrid node: the major parent edge and then the minor parent edge. In our case, there is only one reticulation, so only 2 hybrid edges.\n\n\nWe can plot the bootstrap values of the 2 hybrid edges in the best network:\n\n\nplot(net1, edgeLabel=BSe[[:edge,:BS_hybrid_edge]])\n\n\n\n\nThis is showing the bootstrap support each hybrid edge: percentage of bootstrap trees with an edge from the same sister clade to the same hybrid clade. Alternatively, we could show the bootstrap support for the full reticulation relationships in the network, one at each hybrid node (support for same hybrid with same sister clades):\n\n\nplot(net1, nodeLabel=BSn[[:hybridnode,:BS_hybrid_samesisters]])\n\n\n\n\nOn a different plot, we can show the bootstrap support for hybrid clades, shown on the parent edge of each node with positive hybrid support:\n\n\nplot(net1, edgeLabel=BSn[BSn[:BS_hybrid].\n0, [:edge,:BS_hybrid]])\n\n\n\n\nor plot the support for minor sister clades (shown along parent edge, and filtered to those with sister support \n 5%):\n\n\nplot(net1, edgeLabel=BSn[BSn[:BS_minor_sister].\n5, [:edge,:BS_minor_sister]])\n\n\n\n\nTo plot the same values next to the associated nodes, rather than edges, we use the option \nnodeLabel\n and we select the column \nnode\n or \nhybridnode\n:\n\n\nplot(net1, nodeLabel=BSn[BSn[:BS_hybrid].\n0, [:hybridnode,:BS_hybrid]])\nplot(net1, nodeLabel=BSn[BSn[:BS_minor_sister].\n5, [:node,:BS_minor_sister]])\nplot(net1, nodeLabel=BSn[BSn[:BS_major_sister].\n5, [:node,:BS_major_sister]])\n\n\n\n\nThe estimated heritability \u03b3 on hybrid edges in the reference network, when present in a bootstrap network, was also extracted:\n\n\nBSgam\n\n\n\n\n\u03b3=0 values are for bootstrap replicates that did not have the edge in their network. Basic summaries on \u03b3 values for a given edge, say the minor parent, could be obtained like this:\n\n\nminimum(BSgam[:,2])\nmaximum(BSgam[:,2])\nmean(BSgam[:,2])\nstd(BSgam[:,2])", 
            "title": "Bootstrap"
        }, 
        {
            "location": "/man/bootstrap/#bootstrap", 
            "text": "", 
            "title": "Bootstrap"
        }, 
        {
            "location": "/man/bootstrap/#running-a-bootstrap-analysis", 
            "text": "We can run a bootstrap analysis if we estimated quartet concordance factors (CFs) with credibility intervals, such as if we used the  TICR pipeline . This pipeline provides a CF table with extra columns for credibility intervals.  using DataFrames\ndf = readtable( tableCFCI.csv )\nbootnet = bootsnaq(T, df, hmax=1, nrep=10, runs=3, filename= bootstrap )  This example file can be accessed  here  or  here . Make sure that your downloaded file has the name  tableCFCI.csv  (to match the name in the Julia command), with no an extra extension  .txt . Rename the file after download if necessary.  This example uses a number of replicates (10) that is definitely too small, to make the example run faster. You might also increase the number of optimization runs ( runs ) done for each bootstrap replicate.  The bootstrap networks are saved in the  boostrap.out  file, so they can be read in a new session with  bootnet = readMultiTopology(\"boostrap.out\") . To save the bootstrap networks to a different file (perhaps after having re-rooted them with an outgroup), you can do this:  writeMultiTopology(bootnet,  bootstrapNets_h1.tre )\nlength(bootnet) # 10 networks in the array 'bootnet'\nless( bootstrapNets_h1.tre )  If you close your session and re-open it later, you can re-read the bootstrap networks back in memory like this:  bootnet = readMultiTopology( bootstrapNets_h1.tre );  We can run bootstrap analysis from gene trees also. We need a text file with a list of files containg the bootstrap trees (one file per gene). This is the same format used by ASTRAL (see the wiki page for more details.).  bootTrees = readBootstrapTrees( BSlistfiles )\nbootnet = bootsnaq(T, bootTrees, hmax=1, nrep=100, filename= bootsnaq1_raxmlboot )  If you used a specified list of quartets on the original data, you should use that same list for the bootstrap analysis through the option  quartetfile .", 
            "title": "Running a bootstrap analysis"
        }, 
        {
            "location": "/man/bootstrap/#summarizing-bootstrap-on-the-main-tree", 
            "text": "The  bootsnaq  function, as used before, returned a list of 10 networks ( nrep=10 ). Before summarizing them on the best network, it is best to re-read this network to get a reproducible internal numbering of its nodes and edges, used later for mapping bootstrap support to edges. We can then summarize bootstrap networks:  net1 = readTopology( net1_snaq.out ) # reading from output file of snaq\nBStable, tree1 = treeEdgesBootstrap(bootnet,net1)  This will calculate the major tree  tree1  displayed in  net1 , that is, the tree obtained by following the major parent (\u03b3 0.5) of each hybrid node. This tree can be visualized like this, with edge numbers shown for later use.  rootatnode!(net1,  4 )\nrootatnode!(tree1,  4 )\nplot(tree1, showEdgeNumber=true)  Next, we can look at bootstrap table  BStable , which has one row for each tree edge in  net1 . One column contains the edge number (same as shown in the plot) and another column contains the edge bootstrap support: the proportion of bootstrap replicates in which this edge was found in the major tree of the inferred network. We can see the full bootstrap table and see which tree edges have bootstrap support lower than 100% with  showall(BStable)\nBStable[BStable[:proportion] .  1.0, :]  Finally, we can map the bootstrap proportions onto the network or its main tree by passing the bootstrap table to the  edgeLabel  option of  plot :  plot(tree1, edgeLabel=BStable)\nplot(net1,  edgeLabel=BStable)  (Here, it is important that the numbers assigned to edges when building the boostrap table \u2013those in  net1  at the time\u2013 correspond to the current edge numbers in  tree1  and  net1 . That was the purpose of reading the network from the output file of snaq! earlier, for consistency across different Julia sessions.)  If we wanted to plot only certain bootstrap values, like those below 100% (1.0), we could do this:  plot(net1, edgeLabel=BStable[BStable[:proportion] .  1.0, :])", 
            "title": "Summarizing bootstrap on the main tree"
        }, 
        {
            "location": "/man/bootstrap/#summarizing-bootstrap-on-reticulations", 
            "text": "Summarizing the placement of hybridization edges is not standard. The function  hybridBootstrapSupport  attempts to do so. The descendants of a given hybrid node form the \"recipient\" or \"hybrid\" clade, and is obtained after removing all other reticulations. If reticulation is due to gene flow or introgression, the minor hybrid edge (with \u03b3 0.5) represents this event. The descendants of the lineage from which gene flow originated is then a second \"sister\" of the hybrid clade. Because of the reticulation event, the hybrid clade has 2 sister clades, not 1: the major sister (through the major hybrid edge with \u03b3 0.5) and the minor sister (through the minor hybrid edge with \u03b3 0.5). Note that the network says  nothing  about the process: its shows the  relationships  only. We can calculate the frequency that each clade is a hybrid clade, or a major or minor sister for some other hybrid, in the bootstrap networks:  BSn, BSe, BSc, BSgam, BSedgenum = hybridBootstrapSupport(bootnet, net1);  Let's look at the results. We can list all the clades and the percentage of bootstrap networks (bootstrap support) in which each clade is a hybrid or sister to a hybrid:  BSn  If a clade contains a single taxon, it is listed with its taxon name. The clade found in the best network is listed with its tag, starting with H (e.g. \"H7\"). The name of other clades start with \"c_\" followed by their number in the best network, if they do appear in the best network. The node numbers, as used internally in the best network, are listed in a separate column. They can be used later to display the bootstrap support values onto the network. Various columns give the bootstrap support that each clade is a hybrid, or a (major/minor) sister to a hybrid. The last column gives the bootstrap support for the full relationship in the best network: same hybrid with same two sisters. These bootstrap values are associated with nodes (or possibly, their parent edges).  To see what is the clade named \"H7\", for instance:  BSc # this might be too big\nshowall(BSc)\nBSc[:taxa][BSc[:H7]]  We can also get bootstrap values associated with edges, to describe the support that a given hybrid clade has a given sister clade.  BSe  Here, each row describes a pair of 2 clades: one being the hybrid, the other being its sister, connected by a hybrid edge. The first rows corresponds to hybrid edges in the best network. Other rows correspond to edges seen in bootstrap networks but not in the best network.  BSedgenum  lists all the hybrid edges in the best network, two for each hybrid node: the major parent edge and then the minor parent edge. In our case, there is only one reticulation, so only 2 hybrid edges.  We can plot the bootstrap values of the 2 hybrid edges in the best network:  plot(net1, edgeLabel=BSe[[:edge,:BS_hybrid_edge]])  This is showing the bootstrap support each hybrid edge: percentage of bootstrap trees with an edge from the same sister clade to the same hybrid clade. Alternatively, we could show the bootstrap support for the full reticulation relationships in the network, one at each hybrid node (support for same hybrid with same sister clades):  plot(net1, nodeLabel=BSn[[:hybridnode,:BS_hybrid_samesisters]])  On a different plot, we can show the bootstrap support for hybrid clades, shown on the parent edge of each node with positive hybrid support:  plot(net1, edgeLabel=BSn[BSn[:BS_hybrid]. 0, [:edge,:BS_hybrid]])  or plot the support for minor sister clades (shown along parent edge, and filtered to those with sister support   5%):  plot(net1, edgeLabel=BSn[BSn[:BS_minor_sister]. 5, [:edge,:BS_minor_sister]])  To plot the same values next to the associated nodes, rather than edges, we use the option  nodeLabel  and we select the column  node  or  hybridnode :  plot(net1, nodeLabel=BSn[BSn[:BS_hybrid]. 0, [:hybridnode,:BS_hybrid]])\nplot(net1, nodeLabel=BSn[BSn[:BS_minor_sister]. 5, [:node,:BS_minor_sister]])\nplot(net1, nodeLabel=BSn[BSn[:BS_major_sister]. 5, [:node,:BS_major_sister]])  The estimated heritability \u03b3 on hybrid edges in the reference network, when present in a bootstrap network, was also extracted:  BSgam  \u03b3=0 values are for bootstrap replicates that did not have the edge in their network. Basic summaries on \u03b3 values for a given edge, say the minor parent, could be obtained like this:  minimum(BSgam[:,2])\nmaximum(BSgam[:,2])\nmean(BSgam[:,2])\nstd(BSgam[:,2])", 
            "title": "Summarizing bootstrap on reticulations"
        }, 
        {
            "location": "/man/multiplealleles/", 
            "text": "Multiple alleles per species\n\n\nThe default setting for SNaQ considers that each allele in a gene tree corresponds to a taxon (a tip) in the network. If instead each allele/individual can be mapped confidently to a species, and if only the species-level network needs to be estimated, then the following functions should be used:\n\n\ndf_sp = mapAllelesCFtable(mappingFile, CFtable_ind);\nd_sp = readTableCF!(df_sp);\n\n\n\n\nwhere the mapping file can be a text (or \ncsv\n) file with two columns named \nallele\n and \nspecies\n, mapping each allele name to a species name. The CF table \nCFtable_ind\n should be a table of concordance factors at the level of individuals. In other words, it should list CFs using one row for each set of 4 alleles/individuals. The first command creates a new data frame \ndf_sp\n of quartet concordance factors at the species level: with the allele names replaced by the appropriate species names.\n\n\nThe second command modifies this data frame \ndf_sp\n by deleting rows that are uninformative about between-species relationships, such as rows corresponding to 4 individuals from the same species. The output \nd_sp\n of this second command is an object of type \nDataCF\n at the species level, which can be used as input for networks estimation with \nsnaq!\n:\n\n\nnet = snaq!(T_sp, d_sp);\n\n\n\n\nwhere \nT_sp\n should be a starting topology with one tip per species, labelled with the same species names as the names used in the mapping file.\n\n\nWarnings:\n\n\n\n\nThis feature has not been fully tested\n\n\nThis procedure is slow and should be made faster, when working with gene trees as input.\n\n\n\n\nIf input data are gene trees, the CF table at the individual level should be created first, like this:\n\n\njulia\nCFtable_ind = readTrees2CF(gene tree file);\n\n\nbefore applying the two commands above. At this time, however, this procedure requires that all alleles from the same individual are given the same name (the individual's 'name') across all genes for which that individual was sequenced.", 
            "title": "Multiple Alleles"
        }, 
        {
            "location": "/man/multiplealleles/#multiple-alleles-per-species", 
            "text": "The default setting for SNaQ considers that each allele in a gene tree corresponds to a taxon (a tip) in the network. If instead each allele/individual can be mapped confidently to a species, and if only the species-level network needs to be estimated, then the following functions should be used:  df_sp = mapAllelesCFtable(mappingFile, CFtable_ind);\nd_sp = readTableCF!(df_sp);  where the mapping file can be a text (or  csv ) file with two columns named  allele  and  species , mapping each allele name to a species name. The CF table  CFtable_ind  should be a table of concordance factors at the level of individuals. In other words, it should list CFs using one row for each set of 4 alleles/individuals. The first command creates a new data frame  df_sp  of quartet concordance factors at the species level: with the allele names replaced by the appropriate species names.  The second command modifies this data frame  df_sp  by deleting rows that are uninformative about between-species relationships, such as rows corresponding to 4 individuals from the same species. The output  d_sp  of this second command is an object of type  DataCF  at the species level, which can be used as input for networks estimation with  snaq! :  net = snaq!(T_sp, d_sp);  where  T_sp  should be a starting topology with one tip per species, labelled with the same species names as the names used in the mapping file.  Warnings:   This feature has not been fully tested  This procedure is slow and should be made faster, when working with gene trees as input.   If input data are gene trees, the CF table at the individual level should be created first, like this:  julia\nCFtable_ind = readTrees2CF(gene tree file);  before applying the two commands above. At this time, however, this procedure requires that all alleles from the same individual are given the same name (the individual's 'name') across all genes for which that individual was sequenced.", 
            "title": "Multiple alleles per species"
        }, 
        {
            "location": "/man/trait_tree/", 
            "text": "Trait Evolution\n\n\nOnce the network is inferred, we can use it for downstream analysis, including for Phylogenetic Comparative Methods (PCM).\n\n\nThe following examples show how to use functions to analyze trait evolution, in the special case when the evolutionary network is in fact a phylogenetic tree. This tree is assumed to be rooted, fixed, and with branch lengths.\n\n\nThe examples below use a dataset described in Mahler et al. (2013)\n1\n, available on Dryad \n2\n. We can read it in from file \nexamples/lizard_tree.txt\n \n(here)\n in Newick format:\n\n\nphy = readTopology(joinpath(Pkg.dir(\nPhyloNetworks\n), \nexamples\n, \nlizard_tree.txt\n));\n\n\n\n\n\n\nSimulation\n\n\nTools are available to simulate trait data on a given phylogenetic tree. For now, only simulations according to a simple Brownian Motion (BM) are implemented.\n\n\nWe first need to create an object of class \nParamsBM\n:ParamsProcess\n:\n\n\nparams_simu = ParamsBM(2, 0.5) # BM with mean 2 and variance 0.5\n\n\n\n\nWe can then simulate according to these parameters on the phylogeny, using function \nsimulate\n.\n\n\nsim = simulate(phy, params_simu) # simulate a BM on phy\n\n\n\n\nThis creates an object of class \nTraitSimulation\n, from which we can extract  the data at the tips, thanks to the method \ngetindex(::TraitSimulation, ::Symbol)\n:\n\n\npred = sim[:Tips]\n\n\n\n\nWe can also extract the simulated values at the internal nodes of the phylogeny:\n\n\npredNodes = sim[:InternalNodes]\n\n\n\n\nBoth extractors create an \nArray\n with one column, and as many lines as the number of tips (respectively, internal nodes) there are in the phylogeny.  It is sorted in the same order as the tips (respectively, internal nodes) of the phylogeny used to simulate it.\n\n\n\n\nPhylogenetic Regression\n\n\nThe main function that can be used to do phylogenetic regression is the function \nphyloNetworklm\n. It is based on function \nlm\n from package \nGLM\n, and inherits from a lot of its features.\n\n\nIn this example, we simulate data for later analysis. We use the predictor simulated above to create a new trait that depends linearly on the predictor, with a noise that has a phylogenetic structure:\n\n\nnoise = simulate(phy, ParamsBM(0, 0.1)) # Phylogenetic residuals\ntrait = 10 + 2 * pred + noise[:Tips] # Trait to study\n\n\n\n\nBelow, we create a data frame that contains the trait, the predictor, and the tip names.  In order to avoid confusion, it is important that the data frame contains an extra column specifying the tip names, labeled \ntipNames\n.\n\n\nusing DataFrames\ndat = DataFrame(trait = trait, pred = pred, tipNames = tipLabels(sim))\n\n\n\n\nPhylogenetic regression / ANOVA can then be done like with the \nGLM\n package, using formulas. We just need to specify the phylogeny we are using:\n\n\nfitTrait = phyloNetworklm(trait ~ pred, dat, phy)\n\n\n\n\nThis returns an object of type \nPhyloNetworkLinearModel\n:LinPredModel\n. It is dominated by the GLM type \nLinPredModel\n, which means that all base functions from Julia \nStatsBase\n can be applied to it. See the documentation for this type for a list of all functions that can be used. Some functions allow the user to retrieve directly the estimated parameters of the BM, and are specific to this object.\n\n\n@doc PhyloNetworkLinearModel # list all base functions\nsigma2_estim(fitTrait) # estimated variance of the BM\nmu_estim(fitTrait) # estimated root value of the BM\n\n\n\n\n\n\nAncestral State Reconstruction\n\n\nWhen we know the model of evolution that the traits followed, we can do ancestral state reconstruction, finding the Best Linear Unbiased Predictor (BLUP) and their prediction intervals, for the trait values at internal nodes.\n\n\n\n\nFrom known parameters\n\n\nHere, we simulated the predictor trait ourselves, so we know the exact model of evolution that generated the data. In this favorable case, an ancestral state reconstruction can be obtained using function \nancestralStateReconstruction\n:\n\n\nancPred = ancestralStateReconstruction(phy, pred, params_simu)\n\n\n\n\nThe object created has type \nReconstructedStates\n. Several extractors can be applied to it:\n\n\nexpectations(ancPred) # The predictors\nstderr(ancPred) # The standard errors associated\npredint(ancPred) # The prediction interval (default to 95%)\n\n\n\n\nThe \nPhyloNetworks\n plot function can be used to plot the ancestral states or prediction intervals on the tree, using the \nnodeLabel\n argument, and the \nexpectationsPlot\n or \npredintPlot\n utility function:\n\n\nancExpe = expectationsPlot(ancPred) # Format the expected ancestral states for the plot\nplot(phy, nodeLabel = ancExpe)\n\nancInt = predintPlot(ancPred) # Format the prediction intervals for the plot\nplot(phy, nodeLabel = ancInt)\n\n\n\n\nAs we know the true ancestral states here, we can compare them to our estimation. In particular, we can count the number of times the true value lies in the prediction interval. This should be true about 95% of the times.\n\n\nsum((predNodes .\n predint(ancPred)[1:99, 2]) \n (predNodes .\n predint(ancPred)[1:99, 1]))\n\n\n\n\n\n\nFrom estimated parameters\n\n\nIn real applications though, we do not have access to the true parameters of the process that generated the data. If we make an assumption on process (like a BM for the residuals here), we can estimate it using the previous function. To fit a regular BM, we just need to do a regression of the trait against a simple intercept:\n\n\nfitPred = phyloNetworklm(pred ~ 1, dat, phy)\n\n\n\n\nWe can then apply the \nancestralStateReconstruction\n function directly to the fitted object:\n\n\nancPredApprox = ancestralStateReconstruction(fitPred)\n\n\n\n\nThe prediction intervals ignore the fact that we estimated the process parameters, so they are less accurate and the function throws a warning. The output is an object of the same \nReconstructedStates\n type as earlier, and the same extractors can be applied to it:\n\n\nplot(phy, ancPredApprox)\n\n\n\n\nFor convenience, the two steps described above (fitting against the intercept, and then do ancestral state reconstruction) can be done all at once with a single call of the function \nancestralStateReconstruction\n on a DataFrame with the trait to reconstruct, and the tip labels:\n\n\ndatPred = DataFrame(pred = pred, tipNames = tipLabels(sim))\nancPredApprox = ancestralStateReconstruction(datPred, phy)\nplot(phy, ancPredApprox)\n\n\n\n\nThis produces the exact same results.\n\n\n\n\nWith known predictors\n\n\nAt this point, it might be tempting to apply this function to the trait we simulated earlier as a linear combination of the predictor and a phylogenetic noise.  However, this cannot be done directly:\n\n\nancTrait = ancestralStateReconstruction(fitTrait) # Throws an error !\n\n\n\n\nThis is because the model we used to fit the trait (a regression with one predictor and an intercept) is not compatible with the simple model of Brownian evolution that we assumed for the ancestral state reconstruction. As the predictor used is not known for ancestral states, it is not possible to reconstruct the trait for this particular model.\n\n\nThe only option we have is to provide the function with the predictor's ancestral states, if they are known. They are known indeed in this toy example that we generated ourselves, so we can reconstruct our trait doing the following:\n\n\nancTrait = ancestralStateReconstruction(fitTrait, [ones(99, 1) predNodes])\nplot(phy, ancTrait)\n\n\n\n\nwhere we provided the ancestral predictors as a matrix, containing the intercept, and the known predictor at the nodes. The user must be very careful with this function, as no check is done for the order of the predictors, that must be in the same order as the internal nodes of the phylogeny. As ancestral predictors are often unknown, the use of this functionality is discouraged.\n\n\n\n\nData Imputation\n\n\nThere is no theoretical difference between an internal node, for which we could not measure the value of the trait, and a missing value at a tip of the phylogeny. Consequently, the previous \nancestralStateReconstruction\n function can be used to do data imputation. To see this, let's add some missing values in the \npred\n array we used earlier:\n\n\ndatPred[[2, 6, 15, 38, 54, 89], :pred] = NA;\nancPredApprox = ancestralStateReconstruction(datPred, phy)\nplot(phy, ancPredApprox)\n\n\n\n\nIn the plotting function, a prediction interval is shown for the missing values.\n\n\n\n\nPhylogenetic ANOVA\n\n\nAs mentioned above, the \nphyloNetworklm\nfunction is based on the \nlm\n function from \nGLM\n. This means that it inherits from most of its features, and in particular, it can handle formulas with factors or interactions. To see this, let's load a subset of the lizard dataset \n1\n we already used:\n\n\ndat = readtable(joinpath(Pkg.dir(\nPhyloNetworks\n), \nexamples\n, \nlizard_trait.txt\n));\n\n\n\n\nThis example file can be accessed \nhere\n. This DataFrame has four columns: \ntipNames\n contains the tips names of the species, matching the one on the phylogeny we already loaded earlier; \nAVG_SVL\n is the average body size (\"Snout to Vent Length\"); \nAVG_ltoe_IV\n and \nAVG_lfing_IV\n are the average length of the fourth toe and finger; and \nregion\n is a factor with 4 levels coding for the region where each species is found. See the description of the dataset on Dryad\n2\n for further information, and other measured traits.\n\n\nFor the sake of this example, let's assume that we want to do a regression of the SVL length against the toe and finger lengths, taking the region into account, and with an interaction between the finger length and the region. (This model has no biological basis. It is just meant to show the possibilities of the function). First, we need to make sure that the region information is indeed considered as a factor. This is done by transforming the region column into a \nPooledDataArray\n:\n\n\ndat[:region] = PooledDataArray(dat[:region]); # Pool by region\n\n\n\n\nThen, we just need to apply \nphyloNetworklm\n with the right formula:\n\n\nfitAnova = phyloNetworklm(AVG_SVL ~ AVG_ltoe_IV + AVG_lfing_IV * region, dat, phy)\n\n\n\n\nAs before, a summary is shown by default, and all the functions that can be applied to a \nlm\n result still apply here.\n\n\n\n\nPagel's Lambda\n\n\nOne classical question about trait evolution is the amount of \"phylogenetic signal\" in a dataset, that is, the importance of the tree structure to explain variation in the observed traits. One way of doing measuring that is to use Pagel's lambda\n3\n transformation of the branch lengths. This model assumes a BM on a tree where the internal branches are multiplied by a factor $\\lambda$, while the external branches are modified so that the total hight of the tree is constant. Hence, $\\lambda$ varies between $0$ (the tree has no influence on the data) and $1$ (the tree is unchanged).\n\n\nWe can illustrate this with the predictor trait we used earlier. We use the same function as before, only indicating the model we want to use:\n\n\nfitPagel = phyloNetworklm(pred ~ 1, datPred, phy, model = \nlambda\n)\n\n\n\n\nAs it is indeed generated according to a plain BM on the phylogeny, the estimated $\\lambda$ should be close to $1$. It can be extracted with function \nlambda_estim\n:\n\n\nlambda_estim(fitPagel)\n\n\n\n\nNote that we took a version of the dataset with missing values, that can be readily handed by the function \nphyloNetworklm\n.\n\n\n\n\n\n\n\n\n\n\nMahler DL, Ingram T, Revell LJ, Losos JB (2013). Exceptional      convergence on the macroevolutionary landscape in island lizard radiations.     Science 341(6143): 292-295. http://dx.doi.org/10.1126/science.1232392\n\n\n\n\n\n\nMahler DL, Ingram T, Revell LJ, Losos JB (2013). Data from: Exceptional     convergence on the macroevolutionary landscape in island lizard radiations.     Dryad Digital Repository. http://dx.doi.org/10.5061/dryad.9g182\n\n\n\n\n\n\nPagel M (1999). Inferring the historical patterns of biological     evolution. Nature. 401: 877\u2013884. doi:10.1038/44766", 
            "title": "Trait Evolution"
        }, 
        {
            "location": "/man/trait_tree/#trait-evolution", 
            "text": "Once the network is inferred, we can use it for downstream analysis, including for Phylogenetic Comparative Methods (PCM).  The following examples show how to use functions to analyze trait evolution, in the special case when the evolutionary network is in fact a phylogenetic tree. This tree is assumed to be rooted, fixed, and with branch lengths.  The examples below use a dataset described in Mahler et al. (2013) 1 , available on Dryad  2 . We can read it in from file  examples/lizard_tree.txt   (here)  in Newick format:  phy = readTopology(joinpath(Pkg.dir( PhyloNetworks ),  examples ,  lizard_tree.txt ));", 
            "title": "Trait Evolution"
        }, 
        {
            "location": "/man/trait_tree/#simulation", 
            "text": "Tools are available to simulate trait data on a given phylogenetic tree. For now, only simulations according to a simple Brownian Motion (BM) are implemented.  We first need to create an object of class  ParamsBM :ParamsProcess :  params_simu = ParamsBM(2, 0.5) # BM with mean 2 and variance 0.5  We can then simulate according to these parameters on the phylogeny, using function  simulate .  sim = simulate(phy, params_simu) # simulate a BM on phy  This creates an object of class  TraitSimulation , from which we can extract  the data at the tips, thanks to the method  getindex(::TraitSimulation, ::Symbol) :  pred = sim[:Tips]  We can also extract the simulated values at the internal nodes of the phylogeny:  predNodes = sim[:InternalNodes]  Both extractors create an  Array  with one column, and as many lines as the number of tips (respectively, internal nodes) there are in the phylogeny.  It is sorted in the same order as the tips (respectively, internal nodes) of the phylogeny used to simulate it.", 
            "title": "Simulation"
        }, 
        {
            "location": "/man/trait_tree/#phylogenetic-regression", 
            "text": "The main function that can be used to do phylogenetic regression is the function  phyloNetworklm . It is based on function  lm  from package  GLM , and inherits from a lot of its features.  In this example, we simulate data for later analysis. We use the predictor simulated above to create a new trait that depends linearly on the predictor, with a noise that has a phylogenetic structure:  noise = simulate(phy, ParamsBM(0, 0.1)) # Phylogenetic residuals\ntrait = 10 + 2 * pred + noise[:Tips] # Trait to study  Below, we create a data frame that contains the trait, the predictor, and the tip names.  In order to avoid confusion, it is important that the data frame contains an extra column specifying the tip names, labeled  tipNames .  using DataFrames\ndat = DataFrame(trait = trait, pred = pred, tipNames = tipLabels(sim))  Phylogenetic regression / ANOVA can then be done like with the  GLM  package, using formulas. We just need to specify the phylogeny we are using:  fitTrait = phyloNetworklm(trait ~ pred, dat, phy)  This returns an object of type  PhyloNetworkLinearModel :LinPredModel . It is dominated by the GLM type  LinPredModel , which means that all base functions from Julia  StatsBase  can be applied to it. See the documentation for this type for a list of all functions that can be used. Some functions allow the user to retrieve directly the estimated parameters of the BM, and are specific to this object.  @doc PhyloNetworkLinearModel # list all base functions\nsigma2_estim(fitTrait) # estimated variance of the BM\nmu_estim(fitTrait) # estimated root value of the BM", 
            "title": "Phylogenetic Regression"
        }, 
        {
            "location": "/man/trait_tree/#ancestral-state-reconstruction", 
            "text": "When we know the model of evolution that the traits followed, we can do ancestral state reconstruction, finding the Best Linear Unbiased Predictor (BLUP) and their prediction intervals, for the trait values at internal nodes.", 
            "title": "Ancestral State Reconstruction"
        }, 
        {
            "location": "/man/trait_tree/#from-known-parameters", 
            "text": "Here, we simulated the predictor trait ourselves, so we know the exact model of evolution that generated the data. In this favorable case, an ancestral state reconstruction can be obtained using function  ancestralStateReconstruction :  ancPred = ancestralStateReconstruction(phy, pred, params_simu)  The object created has type  ReconstructedStates . Several extractors can be applied to it:  expectations(ancPred) # The predictors\nstderr(ancPred) # The standard errors associated\npredint(ancPred) # The prediction interval (default to 95%)  The  PhyloNetworks  plot function can be used to plot the ancestral states or prediction intervals on the tree, using the  nodeLabel  argument, and the  expectationsPlot  or  predintPlot  utility function:  ancExpe = expectationsPlot(ancPred) # Format the expected ancestral states for the plot\nplot(phy, nodeLabel = ancExpe)\n\nancInt = predintPlot(ancPred) # Format the prediction intervals for the plot\nplot(phy, nodeLabel = ancInt)  As we know the true ancestral states here, we can compare them to our estimation. In particular, we can count the number of times the true value lies in the prediction interval. This should be true about 95% of the times.  sum((predNodes .  predint(ancPred)[1:99, 2])   (predNodes .  predint(ancPred)[1:99, 1]))", 
            "title": "From known parameters"
        }, 
        {
            "location": "/man/trait_tree/#from-estimated-parameters", 
            "text": "In real applications though, we do not have access to the true parameters of the process that generated the data. If we make an assumption on process (like a BM for the residuals here), we can estimate it using the previous function. To fit a regular BM, we just need to do a regression of the trait against a simple intercept:  fitPred = phyloNetworklm(pred ~ 1, dat, phy)  We can then apply the  ancestralStateReconstruction  function directly to the fitted object:  ancPredApprox = ancestralStateReconstruction(fitPred)  The prediction intervals ignore the fact that we estimated the process parameters, so they are less accurate and the function throws a warning. The output is an object of the same  ReconstructedStates  type as earlier, and the same extractors can be applied to it:  plot(phy, ancPredApprox)  For convenience, the two steps described above (fitting against the intercept, and then do ancestral state reconstruction) can be done all at once with a single call of the function  ancestralStateReconstruction  on a DataFrame with the trait to reconstruct, and the tip labels:  datPred = DataFrame(pred = pred, tipNames = tipLabels(sim))\nancPredApprox = ancestralStateReconstruction(datPred, phy)\nplot(phy, ancPredApprox)  This produces the exact same results.", 
            "title": "From estimated parameters"
        }, 
        {
            "location": "/man/trait_tree/#with-known-predictors", 
            "text": "At this point, it might be tempting to apply this function to the trait we simulated earlier as a linear combination of the predictor and a phylogenetic noise.  However, this cannot be done directly:  ancTrait = ancestralStateReconstruction(fitTrait) # Throws an error !  This is because the model we used to fit the trait (a regression with one predictor and an intercept) is not compatible with the simple model of Brownian evolution that we assumed for the ancestral state reconstruction. As the predictor used is not known for ancestral states, it is not possible to reconstruct the trait for this particular model.  The only option we have is to provide the function with the predictor's ancestral states, if they are known. They are known indeed in this toy example that we generated ourselves, so we can reconstruct our trait doing the following:  ancTrait = ancestralStateReconstruction(fitTrait, [ones(99, 1) predNodes])\nplot(phy, ancTrait)  where we provided the ancestral predictors as a matrix, containing the intercept, and the known predictor at the nodes. The user must be very careful with this function, as no check is done for the order of the predictors, that must be in the same order as the internal nodes of the phylogeny. As ancestral predictors are often unknown, the use of this functionality is discouraged.", 
            "title": "With known predictors"
        }, 
        {
            "location": "/man/trait_tree/#data-imputation", 
            "text": "There is no theoretical difference between an internal node, for which we could not measure the value of the trait, and a missing value at a tip of the phylogeny. Consequently, the previous  ancestralStateReconstruction  function can be used to do data imputation. To see this, let's add some missing values in the  pred  array we used earlier:  datPred[[2, 6, 15, 38, 54, 89], :pred] = NA;\nancPredApprox = ancestralStateReconstruction(datPred, phy)\nplot(phy, ancPredApprox)  In the plotting function, a prediction interval is shown for the missing values.", 
            "title": "Data Imputation"
        }, 
        {
            "location": "/man/trait_tree/#phylogenetic-anova", 
            "text": "As mentioned above, the  phyloNetworklm function is based on the  lm  function from  GLM . This means that it inherits from most of its features, and in particular, it can handle formulas with factors or interactions. To see this, let's load a subset of the lizard dataset  1  we already used:  dat = readtable(joinpath(Pkg.dir( PhyloNetworks ),  examples ,  lizard_trait.txt ));  This example file can be accessed  here . This DataFrame has four columns:  tipNames  contains the tips names of the species, matching the one on the phylogeny we already loaded earlier;  AVG_SVL  is the average body size (\"Snout to Vent Length\");  AVG_ltoe_IV  and  AVG_lfing_IV  are the average length of the fourth toe and finger; and  region  is a factor with 4 levels coding for the region where each species is found. See the description of the dataset on Dryad 2  for further information, and other measured traits.  For the sake of this example, let's assume that we want to do a regression of the SVL length against the toe and finger lengths, taking the region into account, and with an interaction between the finger length and the region. (This model has no biological basis. It is just meant to show the possibilities of the function). First, we need to make sure that the region information is indeed considered as a factor. This is done by transforming the region column into a  PooledDataArray :  dat[:region] = PooledDataArray(dat[:region]); # Pool by region  Then, we just need to apply  phyloNetworklm  with the right formula:  fitAnova = phyloNetworklm(AVG_SVL ~ AVG_ltoe_IV + AVG_lfing_IV * region, dat, phy)  As before, a summary is shown by default, and all the functions that can be applied to a  lm  result still apply here.", 
            "title": "Phylogenetic ANOVA"
        }, 
        {
            "location": "/man/trait_tree/#pagels-lambda", 
            "text": "One classical question about trait evolution is the amount of \"phylogenetic signal\" in a dataset, that is, the importance of the tree structure to explain variation in the observed traits. One way of doing measuring that is to use Pagel's lambda 3  transformation of the branch lengths. This model assumes a BM on a tree where the internal branches are multiplied by a factor $\\lambda$, while the external branches are modified so that the total hight of the tree is constant. Hence, $\\lambda$ varies between $0$ (the tree has no influence on the data) and $1$ (the tree is unchanged).  We can illustrate this with the predictor trait we used earlier. We use the same function as before, only indicating the model we want to use:  fitPagel = phyloNetworklm(pred ~ 1, datPred, phy, model =  lambda )  As it is indeed generated according to a plain BM on the phylogeny, the estimated $\\lambda$ should be close to $1$. It can be extracted with function  lambda_estim :  lambda_estim(fitPagel)  Note that we took a version of the dataset with missing values, that can be readily handed by the function  phyloNetworklm .      Mahler DL, Ingram T, Revell LJ, Losos JB (2013). Exceptional      convergence on the macroevolutionary landscape in island lizard radiations.     Science 341(6143): 292-295. http://dx.doi.org/10.1126/science.1232392    Mahler DL, Ingram T, Revell LJ, Losos JB (2013). Data from: Exceptional     convergence on the macroevolutionary landscape in island lizard radiations.     Dryad Digital Repository. http://dx.doi.org/10.5061/dryad.9g182    Pagel M (1999). Inferring the historical patterns of biological     evolution. Nature. 401: 877\u2013884. doi:10.1038/44766", 
            "title": "Pagel's Lambda"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\nDocumentation for \nPhyloNetworks\n's public (exported) interface.\n\n\nSee \nInternal Documentation\n for documentation on internal functions.\n\n\n\n\nContents\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nTypes\n\n\nUtilities\n\n\nData and Topology read/write\n\n\nNetwork inference\n\n\nNetwork Comparisons\n\n\nTrait Evolution\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nPhyloNetworks.DataCF\n\n\nPhyloNetworks.HybridNetwork\n\n\nPhyloNetworks.ParamsBM\n\n\nPhyloNetworks.PhyloNetworkLinearModel\n\n\nPhyloNetworks.Quartet\n\n\nPhyloNetworks.ReconstructedStates\n\n\nPhyloNetworks.TraitSimulation\n\n\nBase.getindex\n\n\nGadfly.plot\n\n\nPhyloNetworks.ancestralStateReconstruction\n\n\nPhyloNetworks.bootsnaq\n\n\nPhyloNetworks.cladewiseorder!\n\n\nPhyloNetworks.deleteHybridThreshold!\n\n\nPhyloNetworks.deleteleaf!\n\n\nPhyloNetworks.directEdges!\n\n\nPhyloNetworks.displayedNetworkAt!\n\n\nPhyloNetworks.displayedTrees\n\n\nPhyloNetworks.expectations\n\n\nPhyloNetworks.expectationsPlot\n\n\nPhyloNetworks.fittedQuartetCF\n\n\nPhyloNetworks.hardwiredCluster\n\n\nPhyloNetworks.hardwiredClusterDistance\n\n\nPhyloNetworks.hardwiredClusters\n\n\nPhyloNetworks.hybridBootstrapSupport\n\n\nPhyloNetworks.hybridatnode!\n\n\nPhyloNetworks.lambda_estim\n\n\nPhyloNetworks.majorTree\n\n\nPhyloNetworks.mapAllelesCFtable\n\n\nPhyloNetworks.minorTreeAt\n\n\nPhyloNetworks.mu_estim\n\n\nPhyloNetworks.phyloNetworklm\n\n\nPhyloNetworks.predint\n\n\nPhyloNetworks.predintPlot\n\n\nPhyloNetworks.preorder!\n\n\nPhyloNetworks.printEdges\n\n\nPhyloNetworks.printNodes\n\n\nPhyloNetworks.readBootstrapTrees\n\n\nPhyloNetworks.readInputTrees\n\n\nPhyloNetworks.readMultiTopology\n\n\nPhyloNetworks.readSnaqNetwork\n\n\nPhyloNetworks.readTableCF\n\n\nPhyloNetworks.readTableCF!\n\n\nPhyloNetworks.readTopology\n\n\nPhyloNetworks.readTopologyLevel1\n\n\nPhyloNetworks.readTrees2CF\n\n\nPhyloNetworks.rootatnode!\n\n\nPhyloNetworks.rootonedge!\n\n\nPhyloNetworks.rotate!\n\n\nPhyloNetworks.setGamma!\n\n\nPhyloNetworks.setLength!\n\n\nPhyloNetworks.sigma2_estim\n\n\nPhyloNetworks.simulate\n\n\nPhyloNetworks.snaq!\n\n\nPhyloNetworks.snaqDebug\n\n\nPhyloNetworks.sorttaxa!\n\n\nPhyloNetworks.summarizeDataCF\n\n\nPhyloNetworks.tipLabels\n\n\nPhyloNetworks.topologyMaxQPseudolik!\n\n\nPhyloNetworks.topologyQPseudolik!\n\n\nPhyloNetworks.treeEdgesBootstrap\n\n\nPhyloNetworks.writeMultiTopology\n\n\nPhyloNetworks.writeTopology\n\n\n\n\n\n\nTypes\n\n\n#\n\n\nPhyloNetworks.HybridNetwork\n \n \nType\n.\n\n\nHybridNetwork type\n Explicit network or tree with the following attributes:\n\n\n\n\nnumTaxa\n\n\nnumNodes (total number of nodes)\n\n\nnumEdges\n\n\nnumHybrids (number of hybrid nodes)\n\n\nedge (array of Edges)\n\n\nnode (array of Nodes)\n\n\nroot (index of root in vector 'node'. May be artificial, for printing and traversal purposes only.)\n\n\nhybrid (array of Nodes: those are are hybrid nodes)\n\n\nleaf (array of Nodes: those that are leaves)\n\n\nloglik (negative log pseudolik after estimation)\n\n\nisRooted (true or false)\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.DataCF\n \n \nType\n.\n\n\nDataCF type\n\n\ntype that contains the following attributes:\n\n\n\n\nquartet (vector of Quartets)\n\n\nnumQuartets\n\n\ntree (vector of trees: empty if a table of CF was input instead of list of trees)\n\n\nnumTrees (-1 if a table CF was input instead of list of trees)\n\n\nrepSpecies (taxon names that were repeated in table of CF or input gene trees: used inside snaq for multiple alleles case)\n\n\n\n\nThe list of Quartet may be accessed with the attribute .quartet. If the input was a list of trees, the HybridNetwork's can be accessed with the attribute .tree. For example, if the DataCF object is named d, d.quartet[1] will show the first quartet and d.tree[1] will print the first input tree.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.Quartet\n \n \nType\n.\n\n\nQuartet type\n\n\ntype that saves the information on a given 4-taxon subset. It contains the following attributes:\n\n\n\n\nnumber\n\n\ntaxon (vector of taxon names)\n\n\nobsCF (vector of observed CF)\n\n\nlogPseudoLik\n\n\nngenes (number of gene trees used to compute the observed CF: -1 if unknown)\n\n\nqnet (internal topological structure that saves the expCF after snaq estimation to emphasize that the expCF depend on a specific network, not the data)\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.ParamsBM\n \n \nType\n.\n\n\nParamsBM \n: ParamsProcess\n\n\nType for a BM process on a network. Fields are \nmu\n (expectation), \nsigma2\n (variance), \nrandomRoot\n (whether the root is random, default to \nfalse\n), and \nvarRoot\n (if the root is random, the variance of the root, defalut to \nNaN\n).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.TraitSimulation\n \n \nType\n.\n\n\nTraitSimulation\n\n\nResult of a trait simulation on an \nHybridNetwork\n with function \nsimulate\n.\n\n\nThe following functions and extractors can be applied to it: \ntipLabels\n, \nobj[:Tips]\n, \nobj[:InternalNodes]\n (see documentation for function \ngetindex(::TraitSimulation, ::Symbol)\n).\n\n\nThe \nTraitSimulation\n object has fields: \nM\n, \nparams\n, \nmodel\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.PhyloNetworkLinearModel\n \n \nType\n.\n\n\nPhyloNetworkLinearModel\n:LinPredModel\n\n\nRegression object for a phylogenetic regression. Result of fitting function \nphyloNetworklm\n. Dominated by the \nLinPredModel\n class, from package \nGLM\n.\n\n\nThe following StatsBase functions can be applied to it: \ncoef\n, \nnobs\n, \nvcov\n, \nstderr\n, \nconfint\n, \ncoeftable\n, \ndof_residual\n, \ndof\n, \ndeviance\n, \nresiduals\n, \nmodel_response\n, \npredict\n, \nloglikelihood\n, \nnulldeviance\n, \nnullloglikelihood\n, \nr2\n, \nadjr2\n, \naic\n, \naicc\n, \nbic\n.\n\n\nThe following DataFrame functions can also be applied to it: \nModelFrame\n, \nModelMatrix\n, \nFormula\n.\n\n\nEstimated variance and mean of the BM process used can be retrieved with  functions \nsigma2_estim\n and \nmu_estim\n.\n\n\nIf a Pagel's lambda model is fitted, the parameter can be retrieved with function  \nlambda_estim\n.\n\n\nAn ancestral state reconstruction can be performed from this fitted object using function: \nancestralStateReconstruction\n.\n\n\nThe \nPhyloNetworkLinearModel\n object has fields: \nlm\n, \nV\n, \nVy\n, \nRL\n, \nY\n, \nX\n, \nlogdetVy\n, \nind\n, \nmsng\n, \nmodel\n, \nlambda\n. Type in \"?PhyloNetworkLinearModel.field\" to get help on a specific field.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.ReconstructedStates\n \n \nType\n.\n\n\nReconstructedStates\n\n\nType containing the inferred information about the law of the ancestral states given the observed tips values. The missing tips are considered as ancestral states.\n\n\nThe following functions can be applied to it: \nexpectations\n (vector of expectations at all nodes), \nstderr\n (the standard error), \npredint\n (the prediction interval).\n\n\nThe \nReconstructedStates\n object has fields: \ntraits_nodes\n, \nvariances_nodes\n, \nNodeNumbers\n, \ntraits_tips\n, \ntipNumbers\n, \nmodel\n. Type in \"?ReconstructedStates.field\" to get help on a specific field.\n\n\nsource\n\n\n\n\nUtilities\n\n\n#\n\n\nPhyloNetworks.tipLabels\n \n \nFunction\n.\n\n\ntipLabels(net::HybridNetwork)\n\n\nreturns a vector of taxon names (at the leaves) from a HybridNetwork object\n\n\nsource\n\n\ntipLabels(obj::TraitSimulation)\n returns a vector of taxon names (at the leaves) for a simulated object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sorttaxa!\n \n \nFunction\n.\n\n\nsorttaxa!(DataFrame, columns)\n\n\n\n\nReorder the 4 taxa and reorders the observed concordance factors accordingly, on each row of the data frame. If \ncolumns\n is committed, taxon names are assumed to be in columns 1-4 and CFs are assumed to be in columns 5-6 with quartets in this order: 12_34, 13_24, 14_23. Does \nnot\n reorder credibility interval values, if present.\n\n\nsorttaxa!(DataCF)\nsorttaxa!(Quartet, permutation_tax, permutation_cf)\n\n\n\n\nReorder the 4 taxa in each element of the DataCF \nquartet\n. For a given Quartet, reorder the 4 taxa in its fields \ntaxon\n and \nqnet.quartetTaxon\n (if non-empty) and reorder the 3 concordance values accordingly, in \nobsCF\n and \nqnet.expCF\n.\n\n\npermutation_tax\n and \npermutation_cf\n should be vectors of short integers (Int8) of length 4 and 3 respectively, whose memory allocation gets reused. Their length is \nnot checked\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.printEdges\n \n \nFunction\n.\n\n\nprintEdges(net::HybridNetwork)\n\n\nprints the information on the edges of net: edge number, node numbers of nodes attached to it, in which cycle it is contained (-1 if no cycle), can it contain root, is it an identifiable edge, length, is it hybrid, gamma value\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.printNodes\n \n \nFunction\n.\n\n\nprintNodes(net::HybridNetwork)\n\n\nprints information on the nodes of net: node number, in which cycle it is contained (-1 if no cycle), is it hybrid, does it has hybrid edges, edges number attached to it\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.summarizeDataCF\n \n \nFunction\n.\n\n\nsummarizeDataCF(d::DataCF)\n\n\nfunction to summarize the information contained in a DataCF object. It has the following optional arguments:\n\n\n\n\nfilename: if provided, the summary will be saved in the filename, not to screen\n\n\npc (number between (0,1)): threshold of percentage of missing genes to identify 4-taxon subsets with fewer genes than the threshold\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.directEdges!\n \n \nFunction\n.\n\n\ndirectEdges!(net::HybridNetwork; checkMajor=true::Bool)\n\n\nUpdates the edges' attribute \nisChild1\n, according to the root placement. Also updates edges' attribute \ncontainRoot\n, for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if checkMajor=true.\n\n\nWarning: Assumes that isChild1 is correct on hybrid edges (to avoid changing the identity of which nodes are hybrids and which are not).\n\n\nReturns the network. Throws a 'RootMismatch' Exception if the root was found to conflict with the direction of any hybrid edge.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.preorder!\n \n \nFunction\n.\n\n\npreorder!(net::HybridNetwork)\n\n\nUpdates attribute net.nodes_changed in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges' direction needs to be correct before calling preorder!, using directEdges!\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.cladewiseorder!\n \n \nFunction\n.\n\n\ncladewiseorder!(net::HybridNetwork)\n\n\nUpdates attribute net.cladewiseorder_nodeIndex. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges' direction needs to be correct before calling cladewiseorder!, using directEdges!\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.rootatnode!\n \n \nFunction\n.\n\n\nrootatnode!(HybridNetwork, nodeNumber::Integer; index=false::Bool)\nrootatnode!(HybridNetwork, Node)\nrootatnode!(HybridNetwork, nodeName::AbstractString)\n\n\n\n\nRoots the network/tree object at the node with name 'nodeName' or number 'nodeNumber' (by default) or with index 'nodeNumber' if index=true. Attributes isChild1 and containRoot are updated along the way. Use \nplot(net, showNodeNumber=true, showEdgeLength=false)\n to visualize and identify a node of interest.\n\n\nReturns the network.\n\n\nWarnings:\n\n\n\n\nIf the node is a leaf, the root will be placed along the edge adjacent to the leaf, with a message. This might add a new node.\n\n\n\n\nIf the desired root placement is incompatible with one or more hybrids, then\n\n\n\n\na RootMismatch error is thrown\n\n\nthe input network will still have some attributes modified.\n\n\n\n\n\n\n\n\nSee also: \nrootonedge!\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.rootonedge!\n \n \nFunction\n.\n\n\nrootonedge!(HybridNetwork, edgeNumber::Integer; index=false::Bool)\nrootonedge!(HybridNetwork, Edge)\n\n\n\n\nRoots the network/tree object along an edge with number 'edgeNumber' (by default) or with index 'edgeNumber if index=true. Attributes isChild1 and containRoot are updated along the way.\n\n\nThis adds a new node and a new edge to the network. Use \nplot(net, showEdgeNumber=true, showEdgeLength=false)\n to visualize and identify an edge of interest.\n\n\nSee also: \nrootatnode!\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hybridatnode!\n \n \nFunction\n.\n\n\nhybridatnode!(net::HybridNetwork, nodeNumber::Integer)\n\n\nChanges the hybrid in a cycle to the node with number \nnodeNumber\n. This node must be in one (and only one) cycle, otherwise an error will be thrown.\n\n\nExample #\"\n\n\njulia\n net = readTopology(\n(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\n);\njulia\n plot(net, showNodeNumber=true)\njulia\n hybridatnode!(net, -4)\njulia\n plot(net)\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.setLength!\n \n \nFunction\n.\n\n\nsetLength!(Edge,new length)\n\n\nset a new length for an object Edge. The new length needs to be positive. For example, if you have a HybridNetwork object net, and do printEdges(net), you can see the list of Edges and their lengths. You can then change the length of the 3rd edge with setLength!(net.edge[3],1.2). If \nnew length\n is above 10, the value 10 will be used, as an upper limit to coalescent units that can be reliably estimated.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.setGamma!\n \n \nFunction\n.\n\n\nsetGamma!(Edge,new gamma)\n\n\nset \u03b3 for an edge, which must be a hybrid edge. The new \u03b3 needs to be in (0,1). The \u03b3 of the sister hybrid edge is changed accordingly, to 1-\u03b3. If \nnet\n is a HybridNetwork object, \nprintEdges(net)\n will show the list of edges and their \u03b3's. The \u03b3 of the third hybrid edge (say) can be changed to 0.2 with \nsetGamma!(net.edge[3],0.2)\n. This will automatically set \u03b3 of the sister hybrid edge to 0.8.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.deleteleaf!\n \n \nFunction\n.\n\n\ndeleteleaf!(HybridNetwork, leafName::AbstractString; simplify=true)\ndeleteleaf!(HybridNetwork, Node; simplify=true)\ndeleteleaf!(HybridNetwork, Integer; index=false, simplify=true)\n\n\n\n\nDeletes a leaf node from the network, possibly from its name, number, or index in the network's array of nodes.\n\n\nsimplify: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.\n\n\nThe first 2 versions require that \nnode\n is a leaf. The 3rd version does \nnot\n require that \nnode\n is a leaf. If \nnode\n has degree 3 or more, nothing happens. If it has degree 1 or 2, it is deleted.\n\n\nWarning: does \nnot\n update attributes related to level-1 networks, such as inCycle, partition, gammaz, etc. Does not require branch lengths, and designed to work on networks of all levels.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.deleteHybridThreshold!\n \n \nFunction\n.\n\n\ndeleteHybridThreshold!(net::HybridNetwork,gamma::Float64)\n\n\nDeletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.\n\n\n\n\nif gamma\n0.5: deletes     minor hybrid edges with gamma value \n  threshold\n\n\nif gamma=0.5: deletes all minor hybrid edges (i.e gamma value \n= threshold)\n\n\n\n\nWarning: assumes correct isMajor attributes.\n\n\nsource\n\n\n#\n\n\nGadfly.plot\n \n \nFunction\n.\n\n\n    function plot(data_source::@compat(Union{AbstractMatrix, AbstractDataFrame}),\n              elements::ElementOrFunctionOrLayers...; mapping...)\n\n\n\n\nCreate a new plot.\n\n\nGrammar of graphics style plotting consists of specifying a dataset, one or more plot elements (scales, coordinates, geometries, etc), and binding of aesthetics to columns or expressions of the dataset.\n\n\nFor example, a simple scatter plot would look something like:\n\n\nplot(my_data, Geom.point, x=\"time\", y=\"price\")\n\n\nWhere \"time\" and \"price\" are the names of columns in my_data.\n\n\nArgs:\n\n\n\n\ndata_source: Data to be bound to aesthetics.\n\n\nelements: Geometries, statistics, etc.\n\n\nmapping: Aesthetics symbols (e.g. :x, :y, :color) mapped to names of columns in the data frame or other expressions.\n\n\n\n\nsource\n\n\nfunction plot(data_source::@compat(Union{(@compat Void), AbstractMatrix, AbstractDataFrame}),\n              mapping::Dict, elements::ElementOrFunctionOrLayers...)\n\n\n\n\nThe old fashioned (pre named arguments) version of plot.\n\n\nThis version takes an explicit mapping dictionary, mapping aesthetics symbols to expressions or columns in the data frame.\n\n\nArgs:\n\n\n\n\ndata_source: Data to be bound to aesthetics.\n\n\nmapping: Dictionary of aesthetics symbols (e.g. :x, :y, :color) to           names of columns in the data frame or other expressions.\n\n\nelements: Geometries, statistics, etc.\n\n\n\n\nReturns:\n\n\nA Plot object.\n\n\nsource\n\n\nplot(net::HybridNetwork; useEdgeLength=false, mainTree=false, showTipLabel=true,\n     showNodeNumber=false, showEdgeLength=false, showGamma=false, edgeColor=colorant\nblack\n,\n     majorHybridEdgeColor=colorant\ndeepskyblue4\n, minorHybridEdgeColor=colorant\ndeepskyblue\n,\n     showEdgeNumber=false, showIntNodeLabel=false, edgeLabel=[], nodeLabel=[])\n\n\n\n\nPlots a network, from left to right.\n\n\n\n\nuseEdgeLength: if true, the tree edges and major hybrid edges are drawn proportionally to their length. Minor hybrid edges are not, however. Note that edge lengths in coalescent units may scale very poorly with time.\n\n\nmainTree: if true, the minor hybrid edges are ommitted.\n\n\nshowTipLabel: if true, taxon labels are shown. You may need to zoom out to see them.\n\n\nshowNodeNumber: if true, nodes are labelled with the number used internally.\n\n\nshowEdgeLength: if true, edges are labelled with their length (above)\n\n\nshowGamma: if true, hybrid edges are labelled with their heritability (below)\n\n\nedgeColor: color for tree edges. black by default.\n\n\nmajorHybridEdgeColor: color for major hybrid edges\n\n\nminorHybridEdgeColor: color for minor hybrid edges\n\n\nshowEdgeNumber: if true, edges are labelled with the number used internally.\n\n\nshowIntNodeLabel: if true, internal nodes are labelled with their names. Useful for hybrid nodes, which do have tags like '#H1'.\n\n\nedgeLabel: dataframe with two columns: the first with edge numbers, the second with labels (like bootstrap values) to annotate edges. empty by default.\n\n\nnodeLabel: dataframe with two columns: the first with node numbers, the second with labels (like bootstrap values for hybrid relationships) to annotate nodes. empty by default.\n\n\n\n\nNote that \nplot\n actually modifies some (minor) attributes of the network, as it calls \ndirectEdges!\n, \npreorder!\n and \ncladewiseorder!\n.\n\n\nIf hybrid edges cross tree and major edges, you may choose to rotate some tree edges to eliminate crossing edges, using \nrotate!\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.rotate!\n \n \nFunction\n.\n\n\nrotate!(net::HybridNetwork, nodeNumber::Integer; orderedEdgeNum::Array{Int,1})\n\n\nRotates the order of the node's children edges. Useful for plotting, to remove crossing edges. If \nnode\n is a tree node with no polytomy, the 2 children edges are switched and the optional argument \norderedEdgeNum\n is ignored.\n\n\nUse plot(net, showNodeNumber=true, showEdgeNumber=false) to map node and edge numbers on the network, as shown in the examples below.\n\n\nWarning: assumes that edges are correctly directed (isChild1 updated). This is done by plot(net). Otherwise run directEdges!(net).\n\n\nExample #\"\n\n\njulia\n net = readTopology(\n(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\n);\njulia\n plot(net, showNodeNumber=true)\njulia\n rotate!(net, -4)\njulia\n plot(net)\njulia\n net=readTopology(\n(4,((1,(2)#H7:::0.864):2.069,(6,5):3.423):0.265,(3,#H7:::0.136):10.0);\n);\njulia\n plot(net, showNodeNumber=true, showEdgeNumber=true)\njulia\n rotate!(net, -1, orderedEdgeNum=[1,12,9])\njulia\n plot(net, showNodeNumber=true, showEdgeNumber=true)\njulia\n rotate!(net, -3)\njulia\n plot(net)\n\n\n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\ngetindex(obj, d)\n\n\nGetting submatrices of an object of type \nTraitSimulation\n.\n\n\nArguments\n\n\n\n\nobj::TraitSimulation\n: the matrix from which to extract.\n\n\n\n\nd::Symbol\n: a symbol precising which sub-matrix to extract. Can be:\n\n\n\n\n:Tips\n columns and/or rows corresponding to the tips\n\n\n:InternalNodes\n columns and/or rows corresponding to the internal nodes\n\n\n\n\n\n\n\n\nsource\n\n\n\n\nData and Topology read/write\n\n\n#\n\n\nPhyloNetworks.readTopology\n \n \nFunction\n.\n\n\nreadTopology(file name)\nreadTopology(parenthetical description)\n\n\n\n\nRead tree or network topology from parenthetical format (extended Newick).\n\n\nInput: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readTopologyLevel1\n \n \nFunction\n.\n\n\nreadTopologyLevel1(filename)\nreadTopologyLevel1(parenthetical format)\n\n\n\n\nsame as readTopology, reads a tree or network from parenthetical format, but this function enforces the necessary conditions for any starting topology in SNaQ: non-intersecting cycles, no polytomies, unrooted. It sets any missing branch length to 1.0.\n\n\nIf the network has a bad diamond II (in which edge lengths are \u03b3's are not identifiable) and if the edge below this diamond has a length \nt\n different from 0, then this length is set back to 0 and the major parent hybrid edge is lengthened by \nt\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readInputTrees\n \n \nFunction\n.\n\n\nreadInputTrees(file)\n\n\nfunction to read a text file with a list of trees in parenthetical format (one tree per line), it returns an array of HybridNetwork object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readMultiTopology\n \n \nFunction\n.\n\n\nreadMultiTopology(file)\n\n\nRead a text file with a list of networks in parenthetical format (one per line). Each network is read with \nreadTopology\n. Crash if a network is broken over several lines. Return an array of HybridNetwork object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readSnaqNetwork\n \n \nFunction\n.\n\n\nreadSnaqNetwork(output file)\n\n\nfunction to read the estimated network from an .out file generated by the snaq function\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readTrees2CF\n \n \nFunction\n.\n\n\nreadTrees2CF(treefile)\nreadTrees2CF(vector of trees)\n\n\n\n\nRead trees in parenthetical format from a file, or take a vector of trees already read, and calculate the proportion of these trees having a given quartet (concordance factor: CF), for all quartets or for a sample of quartets. Optional arguments include:\n\n\n\n\nquartetfile: name of text file with list of 4-taxon subsets to be analyzed. If none is specified, the function will list all possible 4-taxon subsets.\n\n\nwhichQ=\"rand\": to choose a random sample of 4-taxon subsets\n\n\nnumQ: size of random sample (ignored if whichQ is not set to \"rand\")\n\n\nwriteTab=false: does not write the observedCF to a table (default true)\n\n\nCFfile: name of file to save the observedCF (default tableCF.txt)\n\n\nwriteQ=true: save intermediate files with the list of all 4-taxon subsets and chosen random sample (default false).\n\n\nwriteSummary: write descriptive stats of input data (default: true)\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readTableCF\n \n \nFunction\n.\n\n\nreadTableCF(file)\nreadTableCF(data frame)\nreadTableCF!(data frame)\n\n\n\n\nRead a file or DataFrame object containing a table of concordance factors (CF), with one row per 4-taxon set. The first 4 columns are assumed to give the labels of the 4 taxa in each set (tx1, tx2, tx3, tx4). Columns containing the CFs are assumed to be named 'CF12_34', 'CF13_24' and 'CF14_23', or else are assumed to be columns 5,6,7. If present, a column named 'ngenes' will be used to get the number of loci used to estimate the CFs for each 4-taxon set.\n\n\nOptional arguments:\n\n\n\n\nsummaryfile: if specified, a summary file will be created with that name.\n\n\nsep (for the first form only): to specify the type of separator in the file, with single quotes: sep=';'. Default is a \ncsv\n file, i.e. \nsep=','\n.\n\n\n\n\nThe last version modifies the input data frame, if species are represented by multiple alleles for instance (see \nreadTableCF!\n).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readTableCF!\n \n \nFunction\n.\n\n\nreadTableCF!(data frame, columns)\n\n\n\n\nRead in quartet CFs from data frame, assuming information is in columns numbered \ncolumns\n, of length \n7 or 8\n: 4 taxon labels then 3 CFs then ngenes possibly.\n\n\nIf some species appears more than once in the same 4-taxon set (e.g. t1,t1,t2,t3), then the data frame is modified to remove rows (4-taxon sets) that are uninformative about between-species relationships. This situation may occur if multiple individuals are sampled from the same species. A 4-taxon set is uninformative (and its row is removed) if one taxon is repeated 3 or 4 times (like t1,t1,t1,t1 or t1,t2,t2,t2). The list of species appearing twice in some 4-taxon sets is stored in the output DataCF object. For these species, the length of their external edge is identifiable (in coalescent units). If multiple rows correspond to the same 4-taxon set, these rows are merged and their CF values (and number of genes) are averaged.\n\n\nreadTableCF!(DataCF, data frame, columns)\n\n\n\n\nModify the \n.quartet.obsCF\n values in the \nDataCF\n object with those read from the data frame in columns numbered \ncolumns\n. \ncolumns\n should have \n3\n columns numbers for the 3 CFs in this order: 12_34, 13_24 and 14_23. Assume the same 4-taxon sets in \nDataCF\n and in the data frame, and in the same order, but this assumption is \nnot checked\n (for speed, e.g. during bootstrapping).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.readBootstrapTrees\n \n \nFunction\n.\n\n\nreadBootstrapTrees(filename)\n\n\n\n\ninput: name of file containing the path/name to multiple bootstrap files, one per line. Each bootstrap file corresponds to bootstrap trees from a single gene.\n\n\noutput: vector of vectors of trees.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.writeTopology\n \n \nFunction\n.\n\n\nwriteTopology(net)\nwriteTopology(net, filename)\n\n\n\n\nwrite the parenthetical extended Newick format of a HybridNetwork object, as a string or to a file. Optional arguments (default values):\n\n\n\n\ndi (false): write in format for Dendroscope\n\n\nround (false): rounds branch lengths and heritabilities \u03b3\n\n\ndigits (3): digits after the decimal place for rounding\n\n\n\n\nIf the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.writeMultiTopology\n \n \nFunction\n.\n\n\nwriteMultiTopology(nets, file_name; append=false)\nwriteMultiTopology(nets, IO)\n\n\n\n\nWrite an array of networks in parenthetical extended Newick format, one network per line. Use the option append=true to append to the file. Otherwise, the default is to create a new file or overwrite it, if it already existed. Each network is written with \nwriteTopology\n.\n\n\nExamples #\"\n\n\njulia\n net = [readTopology(\n(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10);\n),\n              readTopology(\n(A,(B,C));\n),readTopology(\n(E,F);\n),readTopology(\n(G,H,F);\n)];\n\njulia\n writeMultiTopology(net, \nfournets.net\n) # to (over)write to file \nfournets.net\n\njulia\n writeMultiTopology(net, \nfournets.net\n, append=true) # to append to this file\njulia\n writeMultiTopology(net, STDOUT)         # to write to the screen (standard out)\n(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10.0);\n(A,(B,C));\n(E,F);\n(G,H,F);\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.mapAllelesCFtable\n \n \nFunction\n.\n\n\nmapAllelesCFtable(mapping file, CF file; filename, columns)\n\n\nCreate a new DataFrame containing the same concordance factors as in the input CF file, but with modified taxon names. Each allele name in the input CF table is replaced by the species name that the allele maps onto, based on the mapping file.\n\n\nOptional arguments:\n\n\n\n\nfile name to write/save resulting CF table. If not specified, then the output data frame is not saved to a file.\n\n\ncolumn numbers for the taxon names. 1-4 by default.\n\n\n\n\nsource\n\n\n\n\nNetwork inference\n\n\n#\n\n\nPhyloNetworks.snaq!\n \n \nFunction\n.\n\n\nsnaq!(T::HybridNetwork, d::DataCF)\n\n\nEstimate the network (or tree) to fit observed quartet concordance factors (CFs) stored in a DataCF object, using maximum pseudo-likelihood. A level-1 network is assumed. The search starts from topology \nT\n, which can be a tree or a network with no more than \nhmax\n hybrid nodes. The function name ends with ! because it modifies the CF data \nd\n by updating its attributes \nexpCF\n: CFs expected under the network model. It does \nnot\n modify \nT\n. The quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.\n\n\nOutput:\n\n\n\n\nestimated network in file \n.out\n (also in \n.log\n): best network overall and list of networks from each individual run.\n\n\nthe best network and modifications of it, in file \n.networks\n. All networks in this file have the same undirected topology as the best network, but have different hybrid/gene flow directions. These other networks are reported with their pseudo-likelihood scores, because  non-identifiability issues can cause them to have very similar scores, and because  SNaQ was shown to estimate the undirected topology accurately but not the direction of  hybridization in cases of near non-identifiability.\n\n\nif any error occurred, file \n.err\n provides information (seed) to reproduce the error.\n\n\n\n\nThere are many optional arguments, including\n\n\n\n\nhmax: maximum number of hybridizations allowed (default 1)\n\n\nverbose: if true, print information about the numerical optimization\n\n\nruns: number of independent starting points for the search (default 10)\n\n\noutgroup: outgroup taxon to root the estimated topology at the very end\n\n\nfilename: root name for the output files. Default is \"snaq\". If empty (\"\"), files are \nnot\n created, progress log goes to the screen only (standard out).\n\n\nseed: seed to replicate a given search\n\n\n\n\nThe following optional arguments control when to stop the optimization of branch lengths and \u03b3's on each individual candidate network. Defaults are in parentheses:\n\n\n\n\nftolRel (1e-5) and ftolAbs (1e-6): relative and absolute differences of the network score between the current and proposed parameters,\n\n\nxtolRel (1e-3) and xtolAbs (1e-4): relative and absolute differences between the current and proposed parameters.\n\n\n\n\nGreater values will result in a less thorough but faster search. These parameters are used when evaluating candidate networks only. Branch lengths and \u03b3's are optimized on the last \"best\" network with different and very thorough tolerance parameters (1e-12 for ftolRel and 1e-10 for the others).\n\n\nThe following optional arguments control when to stop proposing new network topologies:\n\n\n\n\nNfail (100): maximum number of times that new topologies are proposed and rejected (in a row).\n\n\nliktolAbs (0.1): the proposed network is accepted if its score is better than the current score by at least liktolAbs.\n\n\n\n\nLower values of Nfail and greater values of liktolAbs and ftolAbs would result in a less thorough but faster search.\n\n\nSee also: \ntopologyMaxQPseudolik!\n to optimize parameters on a fixed topology, and \ntopologyQPseudolik!\n to get the deviance (pseudo log-likelihood up to a constant) of a fixed topology with fixed parameters.\n\n\nReference: Claudia Sol\u00eds-Lemus and C\u00e9cile An\u00e9 (2016). Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting. \nPLoS Genetics\n 12(3):e1005896\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.snaqDebug\n \n \nFunction\n.\n\n\nsnaqDebug(currT::HybridNetwork,d::DataCF)\n\n\nfunction to replicate a given run that produces error according to the .err file generated by snaq. The same settings used in that run should be used in this function, specially the seed. See the readme file online for more details.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.topologyMaxQPseudolik!\n \n \nFunction\n.\n\n\ntopologyMaxQPseudolik!(net::HybridNetwork, d::DataCF)\n\n\nEstimate the branch lengths and inheritance probabilities (\u03b3's) for a given network topology. The network is \nnot\n modified, only the object \nd\n is, with updated expected concordance factors.\n\n\nOuput: new network, with optimized parameters (branch lengths and gammas). The maximized quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0. This is also an attribute of the network, which can be accessed with \nnet.loglik\n.\n\n\nOptional arguments (default value):\n\n\n\n\nverbose (false): if true, information on the numerical optimization is printed to screen\n\n\nftolRel (1e-5), ftolAbs (1e-6), xtolRel (1e-3), xtolAbs (1e-4): absolute and relative tolerance values for the pseudo-deviance function and the parameters\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.topologyQPseudolik!\n \n \nFunction\n.\n\n\ntopologyQPseudolik!(net::HybridNetwork, d::DataCF)\n\n\nCalculate the quartet pseudo-deviance of a given network/tree for DataCF \nd\n. This is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.\n\n\nBe careful if the net object does not have all internal branch lengths specified because then the pseudolikelihood will be meaningless.\n\n\nThe loglik attribute of the network is undated, and \nd\n is updated with the expected concordance factors under the input network.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.fittedQuartetCF\n \n \nFunction\n.\n\n\nfittedQuartetCF(d::DataCF, format::Symbol)\n\n\nreturn a data frame with the observed and expected quartet concordance factors after estimation of a network with snaq(T,d). The format can be :wide (default) or :long.\n\n\n\n\nif wide, the output has one row per 4-taxon set, and each row has 10 columns: 4 columns for the taxon names, 3 columns for the observed CFs and 3 columns for the expected CF.\n\n\nif long, the output has one row per quartet, i.e. 3 rows per 4-taxon sets, and 7 columns: 4 columns for the taxon names, one column to give the quartet resolution, one column for the observed CF and the last column for the expected CF.\n\n\n\n\nsee also: \ntopologyQPseudolik!\n and \ntopologyMaxQPseudolik!\n to update the fitted CF expected under a specific network, inside the DataCF object \nd\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.bootsnaq\n \n \nFunction\n.\n\n\nbootsnaq(T::HybridNetwork, df::DataFrame)\nbootsnaq(T::HybridNetwork, vector of tree lists)\n\n\n\n\nBootstrap analysis for SNaQ. Bootstrap data can be quartet concordance factors (CF), drawn from sampling uniformly in their credibility intervals, as given in the data frame \ndf\n. Alternatively, bootstrap data can be gene trees sampled from a vector of tree lists: one list of bootstrap trees per locus (see \nreadBootstrapTrees\n to generate this, from a file containing a list of bootstrap files: one per locus).\n\n\nFrom each bootstrap replicate, a network is estimated with snaq!, with a search starting from topology \nT\n. Optional arguments include the following, with default values in parentheses:\n\n\n\n\nhmax (1): max number of reticulations in the estimated networks\n\n\nnrep (10): number of bootstrap replicates.\n\n\nruns (10): number of independent optimization runs for each replicate\n\n\nfilename (\"bootsnaq\"): root name for output files. No output files if \"\".\n\n\nseed (0 to get a random seed from the clock): seed for random number generator\n\n\notherNet (empty): another starting topology so that each replicate will start prcnet% runs on otherNet and (1-prcnet)% runs on T\n\n\nprcnet (0): percentage of runs starting on otherNet; error if different than 0.0, and otherNet not specified.\n\n\n\n\nsource\n\n\n\n\nNetwork Comparisons\n\n\n#\n\n\nPhyloNetworks.majorTree\n \n \nFunction\n.\n\n\nmajorTree(net::HybridNetwork)\n\n\nWarning: assumes correct isMajor attributes.\n\n\nExtracts the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node. Returns a HybridNetwork object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.minorTreeAt\n \n \nFunction\n.\n\n\nminorTreeAt(net::HybridNetwork, hybindex::Integer)\n\n\nWarning: assumes correct isMajor attributes.\n\n\nExtracts the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i=hybindex), where the minor hybrid edge is kept instead of the major hybrid edge.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.displayedTrees\n \n \nFunction\n.\n\n\ndisplayedTrees(net::HybridNetwork, gamma::Float64)\n\n\nWarning: assumes correct isMajor attributes.\n\n\nExtracts all trees displayed in a network, following hybrid edges with heritability \n= gamma threshold (or \n0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than gamma. Returns an array of trees, as HybridNetwork objects.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.displayedNetworkAt!\n \n \nFunction\n.\n\n\ndisplayedNetworkAt!(net::HybridNetwork, node::Node)\n\n\nWarning: assumes correct isMajor attributes.\n\n\nDeletes all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hardwiredClusters\n \n \nFunction\n.\n\n\nhardwiredClusters(net::HybridNetwork, S::Union{Vector{String},Vector{Int}})\n\n\nReturns a matrix describing all the hardwired clusters in a network. Warnings: Clusters are rooted, so the root must be correct.           Allows for missing taxa, with entries all 0.\n\n\nEach row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).\n\n\n\n\nfirst column: edge number\n\n\nnext columns: 0/1 values. 1=descendant of edge, 0=not a descendant, or missing taxon.\n\n\nlast column:  10/11 values. 10=tree edge, 11=hybrid edge\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hardwiredCluster\n \n \nFunction\n.\n\n\nhardwiredCluster(edge::Edge,taxa::Union{Vector{String},Vector{Int}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}},\n                  visited::Vector{Int})\n\n\n\n\nCalculate the hardwired cluster of \nnode\n, coded a vector of booleans: true for taxa that are descendent of nodes, false for other taxa (including missing taxa).\n\n\nThe node should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.\n\n\nvisited: vector of node numbers, of all visited nodes.\n\n\nExamples: #\"\n\n\njulia\n net5 = \n(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));\n |\n readTopology |\n directEdges! ;\n\njulia\n taxa = net5 |\n tipLabels # ABC EF D\n6-element Array{String,1}:\n \nA\n\n \nB\n\n \nC\n\n \nE\n\n \nF\n\n \nD\n\n\njulia\n hardwiredCluster(net5.edge[12], taxa) # descendants of 12th edge = CEF\n6-element Array{Bool,1}:\n false\n false\n  true\n  true\n  true\n false\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hardwiredClusterDistance\n \n \nFunction\n.\n\n\nhardwiredClusterDistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)\n\n\nTakes 2 networks and returns their hardwired cluster distance, that is, the number of hardwired clusters found in one network and not in the other. Note that this is not a distance per se on the full space of hybrid networks: there are pairs of different networks for which this measure is 0. But it is a distance on some network subspaces.\n\n\nIf the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, the trees are considered unrooted.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.treeEdgesBootstrap\n \n \nFunction\n.\n\n\ntreeEdgesBootstrap(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork)\n\n\nread a list of bootstrap networks (\nboot_net\n) and a reference network (\nref_net\n), and calculate the bootstrap support of the tree edges in the reference network. All minor hybrid edges (\u03b3\n0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.\n\n\noutput:\n\n\n\n\na data frame with one row per tree edge and two columns: edge number, bootstrap support (as a percentage)\n\n\nthe major tree from the reference network, where minor hybrid edges (with \u03b3\n0.5) have been removed.\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.hybridBootstrapSupport\n \n \nFunction\n.\n\n\nhybridBootstrapSupport(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)\n\n\nMatch hybrid nodes in a reference network with those in an array of networks, like bootstrap networks. All networks must be fully resolved, and on the same taxon set. If \nrooted=true\n, all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).\n\n\nTwo hybrid edges in two networks are said to match if they share the same \"hybrid\" clade (or recipient) and the same \"donor clade\", which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with \u03b3\n0.5) and one is its minor sister (following the major hybrid edge with \u03b3\n0.5).\n\n\nTo calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If \nrooted=false\n, sister clades are considered as bipartitions.\n\n\nOutput:\n\n\n\n\na \"node\" data frame (see below)\n\n\nan \"edge\" data frame (see below)\n\n\na \"clade\" data frame to describe the make up of all clades found as hybrids or sisters,\n\n\n\n\nstarting with a column \ntaxa\n that lists all taxa. All other columns correspond to a given   clade and contain true/false values. \ntrue\n means that a given taxon belongs in a given clade.   For a clade named \nH1\n, for instance, and if the data frame was named \ncla\n, the   list of taxa in this clade can be obtained with \ncla[:taxa][cla[:H1]]\n.\n\n\n\n\nan array of gamma values, with one row for each bootstrap network and two columns (major/minor)\n\n\n\n\nfor each hybrid edge in the reference network. If this hybrid edge was found in the bootstrap network   (i.e. same hybrid and sister clades, after removal of all other hybrid nodes),   its bootstrap gamma value is recorded here. Otherwise, the gamma entry is 0.0.\n\n\n\n\na vector with the number of each hybrid edge in the reference network, in the same order\n\n\n\n\nas for the columns in the array of gamma values above.\n\n\nThe \"node\" data frame has one row per clade and 9 columns giving:\n\n\n\n\nclade\n: the clade's name, like the taxon name (if a hybrid is a single taxon) or the hybrid tag (like 'H1') in the reference network\n\n\nnode\n: the node number in the reference network. NA if the clade is not in this network.\n\n\nhybridnode\n: typically the same node number as above, except for hybrid clades in the reference network. For those, the hybrid node number is listed here.\n\n\nedge\n: number of the parent edge, parent to the node in column 2, if found in the ref network. NA otherwise.\n\n\nBS_hybrid\n: percentage of bootstrap networks in which the clade is found to be a hybrid clade.\n\n\nBS_sister\n: percentage of bootstrap networks in which the clade is found to be sister to some hybrid clade (sum of the next 2 columns)\n\n\nBS_major_sister\n: percentage of bootstrap networks in which the clade is found to be the major sister to some hybrid clade\n\n\nBS_minor_sister\n: same as previous, but minor\n\n\nBS_hybrid_samesisters\n: percentage of bootstrap networks in which the clade is found to be a hybrid and with the same set of sister clades as in the reference network. Applies to hybrid clades found in the reference network only, NA for all other clades.\n\n\n\n\nThe \"edge\" data frame has one row for each pair of clades, and 8 columns:\n\n\n\n\nedge\n: hybrid edge number, if the edge appears in the reference network. NA otherwise.\n\n\nhybrid_clade\n: name of the clade found to be a hybrid, descendent of 'edge'\n\n\nhybrid\n: node number of that clade, if it appears in the reference network. NA otherwise.\n\n\nsister_clade\n: name of the clade that is sister to 'edge', i.e. be sister to a hybrid\n\n\nsister\n: node number of that clade, if in the ref network.\n\n\nBS_hybrid_edge\n: percentage of bootstrap networks in which 'edge' is found to be a hybrid  edge, i.e. when the clade in the 'hybrid' column is found to be a hybrid and the clade in  the 'sister' column is one of its sisters.\n\n\nBS_major\n: percentage of bootstrap networks in which 'edge' is found to be a major hybrid  edge, i.e. when 'hybrid' is found to be a hybrid clade and 'sister' is found to be its  major sister.\n\n\nBS_minor\n: same as previous, but minor\n\n\n\n\nsource\n\n\n\n\nTrait Evolution\n\n\n#\n\n\nPhyloNetworks.simulate\n \n \nFunction\n.\n\n\nsimulate(net::HybridNetwork, params::ParamsProcess, checkPreorder=true::Bool)\n\n\nSimualte some traits on \nnet\n using the parameters \nparams\n. For now, only parameters of type \nParamsBM\n (Brownian Motion) are accepted.\n\n\nAssumes that the network is in the pre-order. If \ncheckPreorder=true\n (default), then it runs function \npreoder\n on the network beforehand.\n\n\nReturns an object of type \nTraitSimulation\n.\n\n\nExamples\n\n\njulia\n phy = readTopology(joinpath(Pkg.dir(\nPhyloNetworks\n), \nexamples\n, \ncarnivores_tree.txt\n));\n\njulia\n par = ParamsBM(1, 0.1) # BM with expectation 1 and variance 0.1.\nPhyloNetworks.ParamsBM:\nParameters of a BM with fixed root:\nmu: 1\nSigma2: 0.1\n\njulia\n srand(17920921); # Seed for reproducibility\n\njulia\n sim = simulate(phy, par) # Simulate on the tree.\nPhyloNetworks.TraitSimulation:\nTrait simulation results on a network with 16 tips, using a BM model, with parameters:\nmu: 1\nSigma2: 0.1\n\njulia\n traits = sim[:Tips] # Extract simulated values at the tips.\n16-element Array{Float64,1}:\n  2.17618 \n  1.03308 \n  3.04898 \n  3.03796 \n  2.1897  \n  4.03159 \n  4.64773 \n -0.877285\n  4.62512 \n -0.511167\n  1.35604 \n -0.103112\n -2.08847 \n  2.63991 \n  2.80512 \n  3.19109\n\n\n\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.phyloNetworklm\n \n \nFunction\n.\n\n\nphyloNetworklm(f, fr, net, model=\nBM\n,\n    fTolRel=1e^-10, fTolAbs=1e^-10, xTolRel=1e^-10, xTolAbs=1e^-10,\n    startingValue=0.5)`\n\n\n\n\nPhylogenetic regression, using the correlation structure induced by the network.\n\n\nReturns an object of class \nPhyloNetworkLinearModel\n. See documentation for this type and example to see all the functions that can be applied to it.\n\n\nArguments\n\n\n\n\nf::Formula\n: formula to use for the regression (see the \nDataFrame\n package)\n\n\nfr::AbstractDataFrame\n: DataFrame containing the data and regressors at the tips. It should have an extra column labelled \"tipNames\", that gives the names of the taxa for each observation.\n\n\nnet::HybridNetwork\n: phylogenetic network to use. Should have labelled tips.\n\n\nmodel::AbstractString=\"BM\"\n: the model to use, \"BM\" being the default and only available model for now. If the entry is a TREE, then \"lambda\" can fit a Pagel's lambda model.\n\n\nno_names::Bool=false\n: if \ntrue\n, force the function to ignore the tips names. The data is then assumed to be in the same order as the tips of the network. Default to false, setting it to true is dangerous, and strongly discouraged.\n\n\n\n\nIf \nmodel=\"lambda\"\n, there are a few more parameters to control the optimization in the parameter:\n\n\n\n\nfTolRel::AbstractFloat=1e-10\n: relative tolerance on the likelihood value for the optimization in lambda.\n\n\nfTolAbs::AbstractFloat=1e-10\n: absolute tolerance on the likelihood value for the optimization in lambda.\n\n\nxTolRel::AbstractFloat=1e-10\n: relative tolerance on the parameter value for the optimization in lambda.\n\n\nxTolAbs::AbstractFloat=1e-10\n: absolute tolerance on the parameter value for the optimization in lambda.\n\n\nstartingValue::Real=0.5\n: the starting value for the parameter in the optimization in lambda.\n\n\n\n\nExamples\n\n\njulia\n using DataFrames # Needed to handle data frames.\n\njulia\n phy = readTopology(joinpath(Pkg.dir(\nPhyloNetworks\n), \nexamples\n, \ncaudata_tree.txt\n));\n\njulia\n dat = readtable(joinpath(Pkg.dir(\nPhyloNetworks\n), \nexamples\n, \ncaudata_trait.txt\n));\n\njulia\n fitBM = phyloNetworklm(trait ~ 1, dat, phy);\n\njulia\n fitBM # Shows a summary\nDataFrames.DataFrameRegressionModel{PhyloNetworks.PhyloNetworkLinearModel,Array{Float64,2}}\n\nFormula: trait ~ +1\n\nParameter(s) Estimates:\nSigma2: 0.00294521\n\nCoefficients:\n             Estimate Std.Error t value Pr(\n|t|)\n(Intercept)     4.679  0.330627 14.1519   \n1e-31\n\nLog Likelihood: -78.9611507833\nAIC: 161.9223015666\n\njulia\n round(sigma2_estim(fitBM), 6) # rounding for jldoctest convenience\n0.002945\n\njulia\n round(mu_estim(fitBM), 4)\n4.679\n\njulia\n round(loglikelihood(fitBM), 10)\n-78.9611507833\n\njulia\n round(aic(fitBM), 10)\n161.9223015666\n\njulia\n round(aicc(fitBM), 10)\n161.9841572367\n\njulia\n round(bic(fitBM), 10)\n168.4887090241\n\njulia\n coef(fitBM)\n1-element Array{Float64,1}:\n 4.679\n\njulia\n confint(fitBM)\n1\u00d72 Array{Float64,2}:\n 4.02696  5.33104\n\njulia\n abs(round(r2(fitBM), 10)) # absolute value for jldoctest convenience\n0.0\n\njulia\n abs(round(adjr2(fitBM), 10))\n0.0\n\njulia\n vcov(fitBM)\n1\u00d71 Array{Float64,2}:\n 0.109314\n\njulia\n residuals(fitBM)\n197-element Array{Float64,1}:\n -0.237648\n -0.357937\n -0.159387\n -0.691868\n -0.323977\n -0.270452\n -0.673486\n -0.584654\n -0.279882\n -0.302175\n  \u22ee       \n -0.777026\n -0.385121\n -0.443444\n -0.327303\n -0.525953\n -0.673486\n -0.603158\n -0.211712\n -0.439833\n\njulia\n model_response(fitBM)\n197-element Array{Float64,1}:\n 4.44135\n 4.32106\n 4.51961\n 3.98713\n 4.35502\n 4.40855\n 4.00551\n 4.09434\n 4.39912\n 4.37682\n \u22ee      \n 3.90197\n 4.29388\n 4.23555\n 4.3517 \n 4.15305\n 4.00551\n 4.07584\n 4.46729\n 4.23917\n\njulia\n predict(fitBM)\n197-element Array{Float64,1}:\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n \u22ee    \n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n\n\n\n\n\nSee also\n\n\nType \nPhyloNetworkLinearModel\n, Function \nancestralStateReconstruction\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sigma2_estim\n \n \nFunction\n.\n\n\nsigma2_estim(m::PhyloNetworkLinearModel)\n Estimated variance for a fitted object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.mu_estim\n \n \nFunction\n.\n\n\nmu_estim(m::PhyloNetworkLinearModel)\n Estimated root value for a fitted object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.lambda_estim\n \n \nFunction\n.\n\n\nlambda_estim(m::PhyloNetworkLinearModel)\n Estimated lambda parameter for a fitted object.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.ancestralStateReconstruction\n \n \nFunction\n.\n\n\nancestralStateReconstruction(net::HybridNetwork, Y::Vector, params::ParamsBM)\n\n\nCompute the conditional expectations and variances of the ancestral (un-observed) traits values at the internal nodes of the phylogenetic network (\nnet\n),  given the values of the traits at the tips of the network (\nY\n) and some known parameters of the process used for trait evolution (\nparams\n, only BM with fixed root works for now).\n\n\nThis function assumes that the parameters of the process are known. For a more general function, see \nancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])\n.\n\n\nsource\n\n\nancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])\n\n\nFunction to find the ancestral traits reconstruction on a network, given an object fitted by function \nphyloNetworklm\n. By default, the function assumes that the regressor is just an intercept. If the value of the regressor for  all the ancestral states is known, it can be entered in X_n, a matrix with as many columns as the number of predictors used, and as many lines as the number of unknown nodes or tips.\n\n\nReturns an object of type \nReconstructedStates\n. See documentation for this type and examples for functions that can be applied to it.\n\n\nExamples\n\n\njulia\n using DataFrames # Needed to use handle data frames\n\njulia\n phy = readTopology(joinpath(Pkg.dir(\nPhyloNetworks\n), \nexamples\n, \ncarnivores_tree.txt\n));\n\njulia\n dat = readtable(joinpath(Pkg.dir(\nPhyloNetworks\n), \nexamples\n, \ncarnivores_trait.txt\n));\n\njulia\n fitBM = phyloNetworklm(trait ~ 1, dat, phy);\n\njulia\n ancStates = ancestralStateReconstruction(fitBM) # Should produce a warning, as variance is unknown.\nWARNING: These prediction intervals show uncertainty in ancestral values,\nassuming that the estimated variance rate of evolution is correct.\nAdditional uncertainty in the estimation of this variance rate is\nignored, so prediction intervals should be larger.\nPhyloNetworks.ReconstructedStates:\n     Node index     Pred.       Min. Max. (95%)\n           -5.0   1.32139  -0.288423     2.9312\n           -8.0   1.03258  -0.539072    2.60423\n           -7.0   1.41575 -0.0934395    2.92495\n           -6.0   1.39417 -0.0643135    2.85265\n           -4.0   1.39961 -0.0603343    2.85955\n           -3.0   1.51341  -0.179626    3.20644\n          -13.0    5.3192    3.96695    6.67145\n          -12.0   4.51176    2.94268    6.08085\n          -16.0   1.50947  0.0290151    2.98992\n          -15.0   1.67425   0.241696    3.10679\n          -14.0   1.80309   0.355568     3.2506\n          -11.0    2.7351    1.21896    4.25123\n          -10.0   2.73217    1.16545    4.29889\n           -9.0   2.41132   0.639075    4.18357\n           -2.0   2.04138 -0.0340955    4.11686\n           14.0   1.64289    1.64289    1.64289\n            8.0   1.67724    1.67724    1.67724\n            5.0  0.331568   0.331568   0.331568\n            2.0   2.27395    2.27395    2.27395\n            4.0  0.275237   0.275237   0.275237\n            6.0   3.39094    3.39094    3.39094\n           13.0  0.355799   0.355799   0.355799\n           15.0  0.542565   0.542565   0.542565\n            7.0  0.773436   0.773436   0.773436\n           10.0   6.94985    6.94985    6.94985\n           11.0   4.78323    4.78323    4.78323\n           12.0   5.33016    5.33016    5.33016\n            1.0 -0.122604  -0.122604  -0.122604\n           16.0   0.73989    0.73989    0.73989\n            9.0   4.84236    4.84236    4.84236\n            3.0    1.0695     1.0695     1.0695\n\njulia\n expectations(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 condExpectation \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502 1.32139         \u2502\n\u2502 2   \u2502 -8         \u2502 1.03258         \u2502\n\u2502 3   \u2502 -7         \u2502 1.41575         \u2502\n\u2502 4   \u2502 -6         \u2502 1.39417         \u2502\n\u2502 5   \u2502 -4         \u2502 1.39961         \u2502\n\u2502 6   \u2502 -3         \u2502 1.51341         \u2502\n\u2502 7   \u2502 -13        \u2502 5.3192          \u2502\n\u2502 8   \u2502 -12        \u2502 4.51176         \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502 0.542565        \u2502\n\u2502 24  \u2502 7          \u2502 0.773436        \u2502\n\u2502 25  \u2502 10         \u2502 6.94985         \u2502\n\u2502 26  \u2502 11         \u2502 4.78323         \u2502\n\u2502 27  \u2502 12         \u2502 5.33016         \u2502\n\u2502 28  \u2502 1          \u2502 -0.122604       \u2502\n\u2502 29  \u2502 16         \u2502 0.73989         \u2502\n\u2502 30  \u2502 9          \u2502 4.84236         \u2502\n\u2502 31  \u2502 3          \u2502 1.0695          \u2502\n\njulia\n predint(ancStates)\n31\u00d72 Array{Float64,2}:\n -0.288423    2.9312  \n -0.539072    2.60423 \n -0.0934395   2.92495 \n -0.0643135   2.85265 \n -0.0603343   2.85955 \n -0.179626    3.20644 \n  3.96695     6.67145 \n  2.94268     6.08085 \n  0.0290151   2.98992 \n  0.241696    3.10679 \n  \u22ee\n  0.542565    0.542565\n  0.773436    0.773436\n  6.94985     6.94985 \n  4.78323     4.78323 \n  5.33016     5.33016 \n -0.122604   -0.122604\n  0.73989     0.73989 \n  4.84236     4.84236 \n  1.0695      1.0695 \n\njulia\n ## Format and plot the ancestral states:\n\njulia\n expectationsPlot(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502 \n1.32\n  \u2502\n\u2502 2   \u2502 -8         \u2502 \n1.03\n  \u2502\n\u2502 3   \u2502 -7         \u2502 \n1.42\n  \u2502\n\u2502 4   \u2502 -6         \u2502 \n1.39\n  \u2502\n\u2502 5   \u2502 -4         \u2502 \n1.4\n   \u2502\n\u2502 6   \u2502 -3         \u2502 \n1.51\n  \u2502\n\u2502 7   \u2502 -13        \u2502 \n5.32\n  \u2502\n\u2502 8   \u2502 -12        \u2502 \n4.51\n  \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502 \n0.54\n  \u2502\n\u2502 24  \u2502 7          \u2502 \n0.77\n  \u2502\n\u2502 25  \u2502 10         \u2502 \n6.95\n  \u2502\n\u2502 26  \u2502 11         \u2502 \n4.78\n  \u2502\n\u2502 27  \u2502 12         \u2502 \n5.33\n  \u2502\n\u2502 28  \u2502 1          \u2502 \n-0.12\n \u2502\n\u2502 29  \u2502 16         \u2502 \n0.74\n  \u2502\n\u2502 30  \u2502 9          \u2502 \n4.84\n  \u2502\n\u2502 31  \u2502 3          \u2502 \n1.07\n  \u2502\n\njulia\n plot(phy, nodeLabel = expectationsPlot(ancStates))\nPlot(...)\n\njulia\n predintPlot(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502 \n[-0.29, 2.93]\n \u2502\n\u2502 2   \u2502 -8         \u2502 \n[-0.54, 2.6]\n  \u2502\n\u2502 3   \u2502 -7         \u2502 \n[-0.09, 2.92]\n \u2502\n\u2502 4   \u2502 -6         \u2502 \n[-0.06, 2.85]\n \u2502\n\u2502 5   \u2502 -4         \u2502 \n[-0.06, 2.86]\n \u2502\n\u2502 6   \u2502 -3         \u2502 \n[-0.18, 3.21]\n \u2502\n\u2502 7   \u2502 -13        \u2502 \n[3.97, 6.67]\n  \u2502\n\u2502 8   \u2502 -12        \u2502 \n[2.94, 6.08]\n  \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502 \n0.54\n          \u2502\n\u2502 24  \u2502 7          \u2502 \n0.77\n          \u2502\n\u2502 25  \u2502 10         \u2502 \n6.95\n          \u2502\n\u2502 26  \u2502 11         \u2502 \n4.78\n          \u2502\n\u2502 27  \u2502 12         \u2502 \n5.33\n          \u2502\n\u2502 28  \u2502 1          \u2502 \n-0.12\n         \u2502\n\u2502 29  \u2502 16         \u2502 \n0.74\n          \u2502\n\u2502 30  \u2502 9          \u2502 \n4.84\n          \u2502\n\u2502 31  \u2502 3          \u2502 \n1.07\n          \u2502\n\njulia\n plot(phy, nodeLabel = predintPlot(ancStates))\nPlot(...)\n\njulia\n ## Some tips may also be missing\n\njulia\n dat[[2, 5], :trait] = NA;\n\njulia\n fitBM = phyloNetworklm(trait ~ 1, dat, phy);\n\njulia\n ancStates = ancestralStateReconstruction(fitBM); \nWARNING: These prediction intervals show uncertainty in ancestral values,\nassuming that the estimated variance rate of evolution is correct.\nAdditional uncertainty in the estimation of this variance rate is\nignored, so prediction intervals should be larger.\n\njulia\n expectations(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 condExpectation \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502 1.42724         \u2502\n\u2502 2   \u2502 -8         \u2502 1.35185         \u2502\n\u2502 3   \u2502 -7         \u2502 1.61993         \u2502\n\u2502 4   \u2502 -6         \u2502 1.54198         \u2502\n\u2502 5   \u2502 -4         \u2502 1.53916         \u2502\n\u2502 6   \u2502 -3         \u2502 1.64984         \u2502\n\u2502 7   \u2502 -13        \u2502 5.33508         \u2502\n\u2502 8   \u2502 -12        \u2502 4.55109         \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502 0.542565        \u2502\n\u2502 24  \u2502 7          \u2502 0.773436        \u2502\n\u2502 25  \u2502 10         \u2502 6.94985         \u2502\n\u2502 26  \u2502 11         \u2502 4.78323         \u2502\n\u2502 27  \u2502 12         \u2502 5.33016         \u2502\n\u2502 28  \u2502 1          \u2502 -0.122604       \u2502\n\u2502 29  \u2502 16         \u2502 0.73989         \u2502\n\u2502 30  \u2502 9          \u2502 4.84236         \u2502\n\u2502 31  \u2502 3          \u2502 1.0695          \u2502\n\njulia\n predint(ancStates)\n31\u00d72 Array{Float64,2}:\n -0.31245     3.16694 \n -0.625798    3.3295  \n -0.110165    3.35002 \n -0.0710391   3.15501 \n -0.0675924   3.14591 \n -0.197236    3.49692 \n  3.89644     6.77373 \n  2.8741      6.22808 \n -0.0358627   3.12834 \n  0.182594    3.2534  \n  \u22ee\n  0.542565    0.542565\n  0.773436    0.773436\n  6.94985     6.94985 \n  4.78323     4.78323 \n  5.33016     5.33016 \n -0.122604   -0.122604\n  0.73989     0.73989 \n  4.84236     4.84236 \n  1.0695      1.0695 \n\njulia\n ## Format and plot the ancestral states:\n\njulia\n expectationsPlot(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502 \n1.43\n  \u2502\n\u2502 2   \u2502 -8         \u2502 \n1.35\n  \u2502\n\u2502 3   \u2502 -7         \u2502 \n1.62\n  \u2502\n\u2502 4   \u2502 -6         \u2502 \n1.54\n  \u2502\n\u2502 5   \u2502 -4         \u2502 \n1.54\n  \u2502\n\u2502 6   \u2502 -3         \u2502 \n1.65\n  \u2502\n\u2502 7   \u2502 -13        \u2502 \n5.34\n  \u2502\n\u2502 8   \u2502 -12        \u2502 \n4.55\n  \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502 \n0.54\n  \u2502\n\u2502 24  \u2502 7          \u2502 \n0.77\n  \u2502\n\u2502 25  \u2502 10         \u2502 \n6.95\n  \u2502\n\u2502 26  \u2502 11         \u2502 \n4.78\n  \u2502\n\u2502 27  \u2502 12         \u2502 \n5.33\n  \u2502\n\u2502 28  \u2502 1          \u2502 \n-0.12\n \u2502\n\u2502 29  \u2502 16         \u2502 \n0.74\n  \u2502\n\u2502 30  \u2502 9          \u2502 \n4.84\n  \u2502\n\u2502 31  \u2502 3          \u2502 \n1.07\n  \u2502\n\njulia\n plot(phy, nodeLabel = expectationsPlot(ancStates))\nPlot(...)\n\njulia\n predintPlot(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502 \n[-0.31, 3.17]\n \u2502\n\u2502 2   \u2502 -8         \u2502 \n[-0.63, 3.33]\n \u2502\n\u2502 3   \u2502 -7         \u2502 \n[-0.11, 3.35]\n \u2502\n\u2502 4   \u2502 -6         \u2502 \n[-0.07, 3.16]\n \u2502\n\u2502 5   \u2502 -4         \u2502 \n[-0.07, 3.15]\n \u2502\n\u2502 6   \u2502 -3         \u2502 \n[-0.2, 3.5]\n   \u2502\n\u2502 7   \u2502 -13        \u2502 \n[3.9, 6.77]\n   \u2502\n\u2502 8   \u2502 -12        \u2502 \n[2.87, 6.23]\n  \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502 \n0.54\n          \u2502\n\u2502 24  \u2502 7          \u2502 \n0.77\n          \u2502\n\u2502 25  \u2502 10         \u2502 \n6.95\n          \u2502\n\u2502 26  \u2502 11         \u2502 \n4.78\n          \u2502\n\u2502 27  \u2502 12         \u2502 \n5.33\n          \u2502\n\u2502 28  \u2502 1          \u2502 \n-0.12\n         \u2502\n\u2502 29  \u2502 16         \u2502 \n0.74\n          \u2502\n\u2502 30  \u2502 9          \u2502 \n4.84\n          \u2502\n\u2502 31  \u2502 3          \u2502 \n1.07\n          \u2502\n\njulia\n plot(phy, nodeLabel = predintPlot(ancStates))\nPlot(...)\n\n\n\n\nsource\n\n\nancestralStateReconstruction(fr::AbstractDataFrame, net::HybridNetwork; kwargs...)\n\n\nFunction to find the ancestral traits reconstruction on a network, given some data at the tips. Uses function \nphyloNetworklm\n to perform a phylogenetic regression of the data against an intercept (amounts to fitting an evolutionary model on the network, BM being the only option  available for now).\n\n\nSee documentation on \nphyloNetworklm\n and \nancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])\n for further details.\n\n\nReturns an object of type \nReconstructedStates\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.expectations\n \n \nFunction\n.\n\n\nexpectations(obj::ReconstructedStates)\n Estimated reconstructed states at the nodes and tips.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.predint\n \n \nFunction\n.\n\n\npredint(obj::ReconstructedStates, level=0.95::Real)\n Prediction intervals with level \nlevel\n for internal nodes and missing tips.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.expectationsPlot\n \n \nFunction\n.\n\n\nexpectationsPlot(obj::ReconstructedStates)\n Compute and format the expected reconstructed states for the plotting function. The resulting dataframe can be readily used as a \nnodeLabel\n argument to \nplot\n.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.predintPlot\n \n \nFunction\n.\n\n\npredintPlot(obj::ReconstructedStates, level=0.95::Real)\n Compute and format the prediction intervals for the plotting function. The resulting dataframe can be readily used as a \nnodeLabel\n argument to \nplot\n.\n\n\nsource", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public-documentation", 
            "text": "Documentation for  PhyloNetworks 's public (exported) interface.  See  Internal Documentation  for documentation on internal functions.", 
            "title": "Public Documentation"
        }, 
        {
            "location": "/lib/public/#contents", 
            "text": "Public Documentation  Contents  Index  Types  Utilities  Data and Topology read/write  Network inference  Network Comparisons  Trait Evolution", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/public/#index", 
            "text": "PhyloNetworks.DataCF  PhyloNetworks.HybridNetwork  PhyloNetworks.ParamsBM  PhyloNetworks.PhyloNetworkLinearModel  PhyloNetworks.Quartet  PhyloNetworks.ReconstructedStates  PhyloNetworks.TraitSimulation  Base.getindex  Gadfly.plot  PhyloNetworks.ancestralStateReconstruction  PhyloNetworks.bootsnaq  PhyloNetworks.cladewiseorder!  PhyloNetworks.deleteHybridThreshold!  PhyloNetworks.deleteleaf!  PhyloNetworks.directEdges!  PhyloNetworks.displayedNetworkAt!  PhyloNetworks.displayedTrees  PhyloNetworks.expectations  PhyloNetworks.expectationsPlot  PhyloNetworks.fittedQuartetCF  PhyloNetworks.hardwiredCluster  PhyloNetworks.hardwiredClusterDistance  PhyloNetworks.hardwiredClusters  PhyloNetworks.hybridBootstrapSupport  PhyloNetworks.hybridatnode!  PhyloNetworks.lambda_estim  PhyloNetworks.majorTree  PhyloNetworks.mapAllelesCFtable  PhyloNetworks.minorTreeAt  PhyloNetworks.mu_estim  PhyloNetworks.phyloNetworklm  PhyloNetworks.predint  PhyloNetworks.predintPlot  PhyloNetworks.preorder!  PhyloNetworks.printEdges  PhyloNetworks.printNodes  PhyloNetworks.readBootstrapTrees  PhyloNetworks.readInputTrees  PhyloNetworks.readMultiTopology  PhyloNetworks.readSnaqNetwork  PhyloNetworks.readTableCF  PhyloNetworks.readTableCF!  PhyloNetworks.readTopology  PhyloNetworks.readTopologyLevel1  PhyloNetworks.readTrees2CF  PhyloNetworks.rootatnode!  PhyloNetworks.rootonedge!  PhyloNetworks.rotate!  PhyloNetworks.setGamma!  PhyloNetworks.setLength!  PhyloNetworks.sigma2_estim  PhyloNetworks.simulate  PhyloNetworks.snaq!  PhyloNetworks.snaqDebug  PhyloNetworks.sorttaxa!  PhyloNetworks.summarizeDataCF  PhyloNetworks.tipLabels  PhyloNetworks.topologyMaxQPseudolik!  PhyloNetworks.topologyQPseudolik!  PhyloNetworks.treeEdgesBootstrap  PhyloNetworks.writeMultiTopology  PhyloNetworks.writeTopology", 
            "title": "Index"
        }, 
        {
            "location": "/lib/public/#types", 
            "text": "#  PhyloNetworks.HybridNetwork     Type .  HybridNetwork type  Explicit network or tree with the following attributes:   numTaxa  numNodes (total number of nodes)  numEdges  numHybrids (number of hybrid nodes)  edge (array of Edges)  node (array of Nodes)  root (index of root in vector 'node'. May be artificial, for printing and traversal purposes only.)  hybrid (array of Nodes: those are are hybrid nodes)  leaf (array of Nodes: those that are leaves)  loglik (negative log pseudolik after estimation)  isRooted (true or false)   source  #  PhyloNetworks.DataCF     Type .  DataCF type  type that contains the following attributes:   quartet (vector of Quartets)  numQuartets  tree (vector of trees: empty if a table of CF was input instead of list of trees)  numTrees (-1 if a table CF was input instead of list of trees)  repSpecies (taxon names that were repeated in table of CF or input gene trees: used inside snaq for multiple alleles case)   The list of Quartet may be accessed with the attribute .quartet. If the input was a list of trees, the HybridNetwork's can be accessed with the attribute .tree. For example, if the DataCF object is named d, d.quartet[1] will show the first quartet and d.tree[1] will print the first input tree.  source  #  PhyloNetworks.Quartet     Type .  Quartet type  type that saves the information on a given 4-taxon subset. It contains the following attributes:   number  taxon (vector of taxon names)  obsCF (vector of observed CF)  logPseudoLik  ngenes (number of gene trees used to compute the observed CF: -1 if unknown)  qnet (internal topological structure that saves the expCF after snaq estimation to emphasize that the expCF depend on a specific network, not the data)   source  #  PhyloNetworks.ParamsBM     Type .  ParamsBM  : ParamsProcess  Type for a BM process on a network. Fields are  mu  (expectation),  sigma2  (variance),  randomRoot  (whether the root is random, default to  false ), and  varRoot  (if the root is random, the variance of the root, defalut to  NaN ).  source  #  PhyloNetworks.TraitSimulation     Type .  TraitSimulation  Result of a trait simulation on an  HybridNetwork  with function  simulate .  The following functions and extractors can be applied to it:  tipLabels ,  obj[:Tips] ,  obj[:InternalNodes]  (see documentation for function  getindex(::TraitSimulation, ::Symbol) ).  The  TraitSimulation  object has fields:  M ,  params ,  model .  source  #  PhyloNetworks.PhyloNetworkLinearModel     Type .  PhyloNetworkLinearModel :LinPredModel  Regression object for a phylogenetic regression. Result of fitting function  phyloNetworklm . Dominated by the  LinPredModel  class, from package  GLM .  The following StatsBase functions can be applied to it:  coef ,  nobs ,  vcov ,  stderr ,  confint ,  coeftable ,  dof_residual ,  dof ,  deviance ,  residuals ,  model_response ,  predict ,  loglikelihood ,  nulldeviance ,  nullloglikelihood ,  r2 ,  adjr2 ,  aic ,  aicc ,  bic .  The following DataFrame functions can also be applied to it:  ModelFrame ,  ModelMatrix ,  Formula .  Estimated variance and mean of the BM process used can be retrieved with  functions  sigma2_estim  and  mu_estim .  If a Pagel's lambda model is fitted, the parameter can be retrieved with function   lambda_estim .  An ancestral state reconstruction can be performed from this fitted object using function:  ancestralStateReconstruction .  The  PhyloNetworkLinearModel  object has fields:  lm ,  V ,  Vy ,  RL ,  Y ,  X ,  logdetVy ,  ind ,  msng ,  model ,  lambda . Type in \"?PhyloNetworkLinearModel.field\" to get help on a specific field.  source  #  PhyloNetworks.ReconstructedStates     Type .  ReconstructedStates  Type containing the inferred information about the law of the ancestral states given the observed tips values. The missing tips are considered as ancestral states.  The following functions can be applied to it:  expectations  (vector of expectations at all nodes),  stderr  (the standard error),  predint  (the prediction interval).  The  ReconstructedStates  object has fields:  traits_nodes ,  variances_nodes ,  NodeNumbers ,  traits_tips ,  tipNumbers ,  model . Type in \"?ReconstructedStates.field\" to get help on a specific field.  source", 
            "title": "Types"
        }, 
        {
            "location": "/lib/public/#utilities", 
            "text": "#  PhyloNetworks.tipLabels     Function .  tipLabels(net::HybridNetwork)  returns a vector of taxon names (at the leaves) from a HybridNetwork object  source  tipLabels(obj::TraitSimulation)  returns a vector of taxon names (at the leaves) for a simulated object.  source  #  PhyloNetworks.sorttaxa!     Function .  sorttaxa!(DataFrame, columns)  Reorder the 4 taxa and reorders the observed concordance factors accordingly, on each row of the data frame. If  columns  is committed, taxon names are assumed to be in columns 1-4 and CFs are assumed to be in columns 5-6 with quartets in this order: 12_34, 13_24, 14_23. Does  not  reorder credibility interval values, if present.  sorttaxa!(DataCF)\nsorttaxa!(Quartet, permutation_tax, permutation_cf)  Reorder the 4 taxa in each element of the DataCF  quartet . For a given Quartet, reorder the 4 taxa in its fields  taxon  and  qnet.quartetTaxon  (if non-empty) and reorder the 3 concordance values accordingly, in  obsCF  and  qnet.expCF .  permutation_tax  and  permutation_cf  should be vectors of short integers (Int8) of length 4 and 3 respectively, whose memory allocation gets reused. Their length is  not checked .  source  #  PhyloNetworks.printEdges     Function .  printEdges(net::HybridNetwork)  prints the information on the edges of net: edge number, node numbers of nodes attached to it, in which cycle it is contained (-1 if no cycle), can it contain root, is it an identifiable edge, length, is it hybrid, gamma value  source  #  PhyloNetworks.printNodes     Function .  printNodes(net::HybridNetwork)  prints information on the nodes of net: node number, in which cycle it is contained (-1 if no cycle), is it hybrid, does it has hybrid edges, edges number attached to it  source  #  PhyloNetworks.summarizeDataCF     Function .  summarizeDataCF(d::DataCF)  function to summarize the information contained in a DataCF object. It has the following optional arguments:   filename: if provided, the summary will be saved in the filename, not to screen  pc (number between (0,1)): threshold of percentage of missing genes to identify 4-taxon subsets with fewer genes than the threshold   source  #  PhyloNetworks.directEdges!     Function .  directEdges!(net::HybridNetwork; checkMajor=true::Bool)  Updates the edges' attribute  isChild1 , according to the root placement. Also updates edges' attribute  containRoot , for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if checkMajor=true.  Warning: Assumes that isChild1 is correct on hybrid edges (to avoid changing the identity of which nodes are hybrids and which are not).  Returns the network. Throws a 'RootMismatch' Exception if the root was found to conflict with the direction of any hybrid edge.  source  #  PhyloNetworks.preorder!     Function .  preorder!(net::HybridNetwork)  Updates attribute net.nodes_changed in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges' direction needs to be correct before calling preorder!, using directEdges!  source  #  PhyloNetworks.cladewiseorder!     Function .  cladewiseorder!(net::HybridNetwork)  Updates attribute net.cladewiseorder_nodeIndex. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges' direction needs to be correct before calling cladewiseorder!, using directEdges!  source  #  PhyloNetworks.rootatnode!     Function .  rootatnode!(HybridNetwork, nodeNumber::Integer; index=false::Bool)\nrootatnode!(HybridNetwork, Node)\nrootatnode!(HybridNetwork, nodeName::AbstractString)  Roots the network/tree object at the node with name 'nodeName' or number 'nodeNumber' (by default) or with index 'nodeNumber' if index=true. Attributes isChild1 and containRoot are updated along the way. Use  plot(net, showNodeNumber=true, showEdgeLength=false)  to visualize and identify a node of interest.  Returns the network.  Warnings:   If the node is a leaf, the root will be placed along the edge adjacent to the leaf, with a message. This might add a new node.   If the desired root placement is incompatible with one or more hybrids, then   a RootMismatch error is thrown  the input network will still have some attributes modified.     See also:  rootonedge! .  source  #  PhyloNetworks.rootonedge!     Function .  rootonedge!(HybridNetwork, edgeNumber::Integer; index=false::Bool)\nrootonedge!(HybridNetwork, Edge)  Roots the network/tree object along an edge with number 'edgeNumber' (by default) or with index 'edgeNumber if index=true. Attributes isChild1 and containRoot are updated along the way.  This adds a new node and a new edge to the network. Use  plot(net, showEdgeNumber=true, showEdgeLength=false)  to visualize and identify an edge of interest.  See also:  rootatnode! .  source  #  PhyloNetworks.hybridatnode!     Function .  hybridatnode!(net::HybridNetwork, nodeNumber::Integer)  Changes the hybrid in a cycle to the node with number  nodeNumber . This node must be in one (and only one) cycle, otherwise an error will be thrown.  Example #\"  julia  net = readTopology( (A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1; );\njulia  plot(net, showNodeNumber=true)\njulia  hybridatnode!(net, -4)\njulia  plot(net)  source  #  PhyloNetworks.setLength!     Function .  setLength!(Edge,new length)  set a new length for an object Edge. The new length needs to be positive. For example, if you have a HybridNetwork object net, and do printEdges(net), you can see the list of Edges and their lengths. You can then change the length of the 3rd edge with setLength!(net.edge[3],1.2). If  new length  is above 10, the value 10 will be used, as an upper limit to coalescent units that can be reliably estimated.  source  #  PhyloNetworks.setGamma!     Function .  setGamma!(Edge,new gamma)  set \u03b3 for an edge, which must be a hybrid edge. The new \u03b3 needs to be in (0,1). The \u03b3 of the sister hybrid edge is changed accordingly, to 1-\u03b3. If  net  is a HybridNetwork object,  printEdges(net)  will show the list of edges and their \u03b3's. The \u03b3 of the third hybrid edge (say) can be changed to 0.2 with  setGamma!(net.edge[3],0.2) . This will automatically set \u03b3 of the sister hybrid edge to 0.8.  source  #  PhyloNetworks.deleteleaf!     Function .  deleteleaf!(HybridNetwork, leafName::AbstractString; simplify=true)\ndeleteleaf!(HybridNetwork, Node; simplify=true)\ndeleteleaf!(HybridNetwork, Integer; index=false, simplify=true)  Deletes a leaf node from the network, possibly from its name, number, or index in the network's array of nodes.  simplify: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.  The first 2 versions require that  node  is a leaf. The 3rd version does  not  require that  node  is a leaf. If  node  has degree 3 or more, nothing happens. If it has degree 1 or 2, it is deleted.  Warning: does  not  update attributes related to level-1 networks, such as inCycle, partition, gammaz, etc. Does not require branch lengths, and designed to work on networks of all levels.  source  #  PhyloNetworks.deleteHybridThreshold!     Function .  deleteHybridThreshold!(net::HybridNetwork,gamma::Float64)  Deletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.   if gamma 0.5: deletes     minor hybrid edges with gamma value    threshold  if gamma=0.5: deletes all minor hybrid edges (i.e gamma value  = threshold)   Warning: assumes correct isMajor attributes.  source  #  Gadfly.plot     Function .      function plot(data_source::@compat(Union{AbstractMatrix, AbstractDataFrame}),\n              elements::ElementOrFunctionOrLayers...; mapping...)  Create a new plot.  Grammar of graphics style plotting consists of specifying a dataset, one or more plot elements (scales, coordinates, geometries, etc), and binding of aesthetics to columns or expressions of the dataset.  For example, a simple scatter plot would look something like:  plot(my_data, Geom.point, x=\"time\", y=\"price\")  Where \"time\" and \"price\" are the names of columns in my_data.  Args:   data_source: Data to be bound to aesthetics.  elements: Geometries, statistics, etc.  mapping: Aesthetics symbols (e.g. :x, :y, :color) mapped to names of columns in the data frame or other expressions.   source  function plot(data_source::@compat(Union{(@compat Void), AbstractMatrix, AbstractDataFrame}),\n              mapping::Dict, elements::ElementOrFunctionOrLayers...)  The old fashioned (pre named arguments) version of plot.  This version takes an explicit mapping dictionary, mapping aesthetics symbols to expressions or columns in the data frame.  Args:   data_source: Data to be bound to aesthetics.  mapping: Dictionary of aesthetics symbols (e.g. :x, :y, :color) to           names of columns in the data frame or other expressions.  elements: Geometries, statistics, etc.   Returns:  A Plot object.  source  plot(net::HybridNetwork; useEdgeLength=false, mainTree=false, showTipLabel=true,\n     showNodeNumber=false, showEdgeLength=false, showGamma=false, edgeColor=colorant black ,\n     majorHybridEdgeColor=colorant deepskyblue4 , minorHybridEdgeColor=colorant deepskyblue ,\n     showEdgeNumber=false, showIntNodeLabel=false, edgeLabel=[], nodeLabel=[])  Plots a network, from left to right.   useEdgeLength: if true, the tree edges and major hybrid edges are drawn proportionally to their length. Minor hybrid edges are not, however. Note that edge lengths in coalescent units may scale very poorly with time.  mainTree: if true, the minor hybrid edges are ommitted.  showTipLabel: if true, taxon labels are shown. You may need to zoom out to see them.  showNodeNumber: if true, nodes are labelled with the number used internally.  showEdgeLength: if true, edges are labelled with their length (above)  showGamma: if true, hybrid edges are labelled with their heritability (below)  edgeColor: color for tree edges. black by default.  majorHybridEdgeColor: color for major hybrid edges  minorHybridEdgeColor: color for minor hybrid edges  showEdgeNumber: if true, edges are labelled with the number used internally.  showIntNodeLabel: if true, internal nodes are labelled with their names. Useful for hybrid nodes, which do have tags like '#H1'.  edgeLabel: dataframe with two columns: the first with edge numbers, the second with labels (like bootstrap values) to annotate edges. empty by default.  nodeLabel: dataframe with two columns: the first with node numbers, the second with labels (like bootstrap values for hybrid relationships) to annotate nodes. empty by default.   Note that  plot  actually modifies some (minor) attributes of the network, as it calls  directEdges! ,  preorder!  and  cladewiseorder! .  If hybrid edges cross tree and major edges, you may choose to rotate some tree edges to eliminate crossing edges, using  rotate! .  source  #  PhyloNetworks.rotate!     Function .  rotate!(net::HybridNetwork, nodeNumber::Integer; orderedEdgeNum::Array{Int,1})  Rotates the order of the node's children edges. Useful for plotting, to remove crossing edges. If  node  is a tree node with no polytomy, the 2 children edges are switched and the optional argument  orderedEdgeNum  is ignored.  Use plot(net, showNodeNumber=true, showEdgeNumber=false) to map node and edge numbers on the network, as shown in the examples below.  Warning: assumes that edges are correctly directed (isChild1 updated). This is done by plot(net). Otherwise run directEdges!(net).  Example #\"  julia  net = readTopology( (A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1; );\njulia  plot(net, showNodeNumber=true)\njulia  rotate!(net, -4)\njulia  plot(net)\njulia  net=readTopology( (4,((1,(2)#H7:::0.864):2.069,(6,5):3.423):0.265,(3,#H7:::0.136):10.0); );\njulia  plot(net, showNodeNumber=true, showEdgeNumber=true)\njulia  rotate!(net, -1, orderedEdgeNum=[1,12,9])\njulia  plot(net, showNodeNumber=true, showEdgeNumber=true)\njulia  rotate!(net, -3)\njulia  plot(net)  source  #  Base.getindex     Method .  getindex(obj, d)  Getting submatrices of an object of type  TraitSimulation .  Arguments   obj::TraitSimulation : the matrix from which to extract.   d::Symbol : a symbol precising which sub-matrix to extract. Can be:   :Tips  columns and/or rows corresponding to the tips  :InternalNodes  columns and/or rows corresponding to the internal nodes     source", 
            "title": "Utilities"
        }, 
        {
            "location": "/lib/public/#data-and-topology-readwrite", 
            "text": "#  PhyloNetworks.readTopology     Function .  readTopology(file name)\nreadTopology(parenthetical description)  Read tree or network topology from parenthetical format (extended Newick).  Input: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description.  source  #  PhyloNetworks.readTopologyLevel1     Function .  readTopologyLevel1(filename)\nreadTopologyLevel1(parenthetical format)  same as readTopology, reads a tree or network from parenthetical format, but this function enforces the necessary conditions for any starting topology in SNaQ: non-intersecting cycles, no polytomies, unrooted. It sets any missing branch length to 1.0.  If the network has a bad diamond II (in which edge lengths are \u03b3's are not identifiable) and if the edge below this diamond has a length  t  different from 0, then this length is set back to 0 and the major parent hybrid edge is lengthened by  t .  source  #  PhyloNetworks.readInputTrees     Function .  readInputTrees(file)  function to read a text file with a list of trees in parenthetical format (one tree per line), it returns an array of HybridNetwork object.  source  #  PhyloNetworks.readMultiTopology     Function .  readMultiTopology(file)  Read a text file with a list of networks in parenthetical format (one per line). Each network is read with  readTopology . Crash if a network is broken over several lines. Return an array of HybridNetwork object.  source  #  PhyloNetworks.readSnaqNetwork     Function .  readSnaqNetwork(output file)  function to read the estimated network from an .out file generated by the snaq function  source  #  PhyloNetworks.readTrees2CF     Function .  readTrees2CF(treefile)\nreadTrees2CF(vector of trees)  Read trees in parenthetical format from a file, or take a vector of trees already read, and calculate the proportion of these trees having a given quartet (concordance factor: CF), for all quartets or for a sample of quartets. Optional arguments include:   quartetfile: name of text file with list of 4-taxon subsets to be analyzed. If none is specified, the function will list all possible 4-taxon subsets.  whichQ=\"rand\": to choose a random sample of 4-taxon subsets  numQ: size of random sample (ignored if whichQ is not set to \"rand\")  writeTab=false: does not write the observedCF to a table (default true)  CFfile: name of file to save the observedCF (default tableCF.txt)  writeQ=true: save intermediate files with the list of all 4-taxon subsets and chosen random sample (default false).  writeSummary: write descriptive stats of input data (default: true)   source  #  PhyloNetworks.readTableCF     Function .  readTableCF(file)\nreadTableCF(data frame)\nreadTableCF!(data frame)  Read a file or DataFrame object containing a table of concordance factors (CF), with one row per 4-taxon set. The first 4 columns are assumed to give the labels of the 4 taxa in each set (tx1, tx2, tx3, tx4). Columns containing the CFs are assumed to be named 'CF12_34', 'CF13_24' and 'CF14_23', or else are assumed to be columns 5,6,7. If present, a column named 'ngenes' will be used to get the number of loci used to estimate the CFs for each 4-taxon set.  Optional arguments:   summaryfile: if specified, a summary file will be created with that name.  sep (for the first form only): to specify the type of separator in the file, with single quotes: sep=';'. Default is a  csv  file, i.e.  sep=',' .   The last version modifies the input data frame, if species are represented by multiple alleles for instance (see  readTableCF! ).  source  #  PhyloNetworks.readTableCF!     Function .  readTableCF!(data frame, columns)  Read in quartet CFs from data frame, assuming information is in columns numbered  columns , of length  7 or 8 : 4 taxon labels then 3 CFs then ngenes possibly.  If some species appears more than once in the same 4-taxon set (e.g. t1,t1,t2,t3), then the data frame is modified to remove rows (4-taxon sets) that are uninformative about between-species relationships. This situation may occur if multiple individuals are sampled from the same species. A 4-taxon set is uninformative (and its row is removed) if one taxon is repeated 3 or 4 times (like t1,t1,t1,t1 or t1,t2,t2,t2). The list of species appearing twice in some 4-taxon sets is stored in the output DataCF object. For these species, the length of their external edge is identifiable (in coalescent units). If multiple rows correspond to the same 4-taxon set, these rows are merged and their CF values (and number of genes) are averaged.  readTableCF!(DataCF, data frame, columns)  Modify the  .quartet.obsCF  values in the  DataCF  object with those read from the data frame in columns numbered  columns .  columns  should have  3  columns numbers for the 3 CFs in this order: 12_34, 13_24 and 14_23. Assume the same 4-taxon sets in  DataCF  and in the data frame, and in the same order, but this assumption is  not checked  (for speed, e.g. during bootstrapping).  source  #  PhyloNetworks.readBootstrapTrees     Function .  readBootstrapTrees(filename)  input: name of file containing the path/name to multiple bootstrap files, one per line. Each bootstrap file corresponds to bootstrap trees from a single gene.  output: vector of vectors of trees.  source  #  PhyloNetworks.writeTopology     Function .  writeTopology(net)\nwriteTopology(net, filename)  write the parenthetical extended Newick format of a HybridNetwork object, as a string or to a file. Optional arguments (default values):   di (false): write in format for Dendroscope  round (false): rounds branch lengths and heritabilities \u03b3  digits (3): digits after the decimal place for rounding   If the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.  source  #  PhyloNetworks.writeMultiTopology     Function .  writeMultiTopology(nets, file_name; append=false)\nwriteMultiTopology(nets, IO)  Write an array of networks in parenthetical extended Newick format, one network per line. Use the option append=true to append to the file. Otherwise, the default is to create a new file or overwrite it, if it already existed. Each network is written with  writeTopology .  Examples #\"  julia  net = [readTopology( (D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10); ),\n              readTopology( (A,(B,C)); ),readTopology( (E,F); ),readTopology( (G,H,F); )];\n\njulia  writeMultiTopology(net,  fournets.net ) # to (over)write to file  fournets.net \njulia  writeMultiTopology(net,  fournets.net , append=true) # to append to this file\njulia  writeMultiTopology(net, STDOUT)         # to write to the screen (standard out)\n(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10.0);\n(A,(B,C));\n(E,F);\n(G,H,F);  source  #  PhyloNetworks.mapAllelesCFtable     Function .  mapAllelesCFtable(mapping file, CF file; filename, columns)  Create a new DataFrame containing the same concordance factors as in the input CF file, but with modified taxon names. Each allele name in the input CF table is replaced by the species name that the allele maps onto, based on the mapping file.  Optional arguments:   file name to write/save resulting CF table. If not specified, then the output data frame is not saved to a file.  column numbers for the taxon names. 1-4 by default.   source", 
            "title": "Data and Topology read/write"
        }, 
        {
            "location": "/lib/public/#network-inference", 
            "text": "#  PhyloNetworks.snaq!     Function .  snaq!(T::HybridNetwork, d::DataCF)  Estimate the network (or tree) to fit observed quartet concordance factors (CFs) stored in a DataCF object, using maximum pseudo-likelihood. A level-1 network is assumed. The search starts from topology  T , which can be a tree or a network with no more than  hmax  hybrid nodes. The function name ends with ! because it modifies the CF data  d  by updating its attributes  expCF : CFs expected under the network model. It does  not  modify  T . The quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.  Output:   estimated network in file  .out  (also in  .log ): best network overall and list of networks from each individual run.  the best network and modifications of it, in file  .networks . All networks in this file have the same undirected topology as the best network, but have different hybrid/gene flow directions. These other networks are reported with their pseudo-likelihood scores, because  non-identifiability issues can cause them to have very similar scores, and because  SNaQ was shown to estimate the undirected topology accurately but not the direction of  hybridization in cases of near non-identifiability.  if any error occurred, file  .err  provides information (seed) to reproduce the error.   There are many optional arguments, including   hmax: maximum number of hybridizations allowed (default 1)  verbose: if true, print information about the numerical optimization  runs: number of independent starting points for the search (default 10)  outgroup: outgroup taxon to root the estimated topology at the very end  filename: root name for the output files. Default is \"snaq\". If empty (\"\"), files are  not  created, progress log goes to the screen only (standard out).  seed: seed to replicate a given search   The following optional arguments control when to stop the optimization of branch lengths and \u03b3's on each individual candidate network. Defaults are in parentheses:   ftolRel (1e-5) and ftolAbs (1e-6): relative and absolute differences of the network score between the current and proposed parameters,  xtolRel (1e-3) and xtolAbs (1e-4): relative and absolute differences between the current and proposed parameters.   Greater values will result in a less thorough but faster search. These parameters are used when evaluating candidate networks only. Branch lengths and \u03b3's are optimized on the last \"best\" network with different and very thorough tolerance parameters (1e-12 for ftolRel and 1e-10 for the others).  The following optional arguments control when to stop proposing new network topologies:   Nfail (100): maximum number of times that new topologies are proposed and rejected (in a row).  liktolAbs (0.1): the proposed network is accepted if its score is better than the current score by at least liktolAbs.   Lower values of Nfail and greater values of liktolAbs and ftolAbs would result in a less thorough but faster search.  See also:  topologyMaxQPseudolik!  to optimize parameters on a fixed topology, and  topologyQPseudolik!  to get the deviance (pseudo log-likelihood up to a constant) of a fixed topology with fixed parameters.  Reference: Claudia Sol\u00eds-Lemus and C\u00e9cile An\u00e9 (2016). Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting.  PLoS Genetics  12(3):e1005896  source  #  PhyloNetworks.snaqDebug     Function .  snaqDebug(currT::HybridNetwork,d::DataCF)  function to replicate a given run that produces error according to the .err file generated by snaq. The same settings used in that run should be used in this function, specially the seed. See the readme file online for more details.  source  #  PhyloNetworks.topologyMaxQPseudolik!     Function .  topologyMaxQPseudolik!(net::HybridNetwork, d::DataCF)  Estimate the branch lengths and inheritance probabilities (\u03b3's) for a given network topology. The network is  not  modified, only the object  d  is, with updated expected concordance factors.  Ouput: new network, with optimized parameters (branch lengths and gammas). The maximized quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0. This is also an attribute of the network, which can be accessed with  net.loglik .  Optional arguments (default value):   verbose (false): if true, information on the numerical optimization is printed to screen  ftolRel (1e-5), ftolAbs (1e-6), xtolRel (1e-3), xtolAbs (1e-4): absolute and relative tolerance values for the pseudo-deviance function and the parameters   source  #  PhyloNetworks.topologyQPseudolik!     Function .  topologyQPseudolik!(net::HybridNetwork, d::DataCF)  Calculate the quartet pseudo-deviance of a given network/tree for DataCF  d . This is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.  Be careful if the net object does not have all internal branch lengths specified because then the pseudolikelihood will be meaningless.  The loglik attribute of the network is undated, and  d  is updated with the expected concordance factors under the input network.  source  #  PhyloNetworks.fittedQuartetCF     Function .  fittedQuartetCF(d::DataCF, format::Symbol)  return a data frame with the observed and expected quartet concordance factors after estimation of a network with snaq(T,d). The format can be :wide (default) or :long.   if wide, the output has one row per 4-taxon set, and each row has 10 columns: 4 columns for the taxon names, 3 columns for the observed CFs and 3 columns for the expected CF.  if long, the output has one row per quartet, i.e. 3 rows per 4-taxon sets, and 7 columns: 4 columns for the taxon names, one column to give the quartet resolution, one column for the observed CF and the last column for the expected CF.   see also:  topologyQPseudolik!  and  topologyMaxQPseudolik!  to update the fitted CF expected under a specific network, inside the DataCF object  d .  source  #  PhyloNetworks.bootsnaq     Function .  bootsnaq(T::HybridNetwork, df::DataFrame)\nbootsnaq(T::HybridNetwork, vector of tree lists)  Bootstrap analysis for SNaQ. Bootstrap data can be quartet concordance factors (CF), drawn from sampling uniformly in their credibility intervals, as given in the data frame  df . Alternatively, bootstrap data can be gene trees sampled from a vector of tree lists: one list of bootstrap trees per locus (see  readBootstrapTrees  to generate this, from a file containing a list of bootstrap files: one per locus).  From each bootstrap replicate, a network is estimated with snaq!, with a search starting from topology  T . Optional arguments include the following, with default values in parentheses:   hmax (1): max number of reticulations in the estimated networks  nrep (10): number of bootstrap replicates.  runs (10): number of independent optimization runs for each replicate  filename (\"bootsnaq\"): root name for output files. No output files if \"\".  seed (0 to get a random seed from the clock): seed for random number generator  otherNet (empty): another starting topology so that each replicate will start prcnet% runs on otherNet and (1-prcnet)% runs on T  prcnet (0): percentage of runs starting on otherNet; error if different than 0.0, and otherNet not specified.   source", 
            "title": "Network inference"
        }, 
        {
            "location": "/lib/public/#network-comparisons", 
            "text": "#  PhyloNetworks.majorTree     Function .  majorTree(net::HybridNetwork)  Warning: assumes correct isMajor attributes.  Extracts the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node. Returns a HybridNetwork object.  source  #  PhyloNetworks.minorTreeAt     Function .  minorTreeAt(net::HybridNetwork, hybindex::Integer)  Warning: assumes correct isMajor attributes.  Extracts the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i=hybindex), where the minor hybrid edge is kept instead of the major hybrid edge.  source  #  PhyloNetworks.displayedTrees     Function .  displayedTrees(net::HybridNetwork, gamma::Float64)  Warning: assumes correct isMajor attributes.  Extracts all trees displayed in a network, following hybrid edges with heritability  = gamma threshold (or  0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than gamma. Returns an array of trees, as HybridNetwork objects.  source  #  PhyloNetworks.displayedNetworkAt!     Function .  displayedNetworkAt!(net::HybridNetwork, node::Node)  Warning: assumes correct isMajor attributes.  Deletes all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before.  source  #  PhyloNetworks.hardwiredClusters     Function .  hardwiredClusters(net::HybridNetwork, S::Union{Vector{String},Vector{Int}})  Returns a matrix describing all the hardwired clusters in a network. Warnings: Clusters are rooted, so the root must be correct.           Allows for missing taxa, with entries all 0.  Each row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).   first column: edge number  next columns: 0/1 values. 1=descendant of edge, 0=not a descendant, or missing taxon.  last column:  10/11 values. 10=tree edge, 11=hybrid edge   source  #  PhyloNetworks.hardwiredCluster     Function .  hardwiredCluster(edge::Edge,taxa::Union{Vector{String},Vector{Int}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}},\n                  visited::Vector{Int})  Calculate the hardwired cluster of  node , coded a vector of booleans: true for taxa that are descendent of nodes, false for other taxa (including missing taxa).  The node should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.  visited: vector of node numbers, of all visited nodes.  Examples: #\"  julia  net5 =  (A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));  |  readTopology |  directEdges! ;\n\njulia  taxa = net5 |  tipLabels # ABC EF D\n6-element Array{String,1}:\n  A \n  B \n  C \n  E \n  F \n  D \n\njulia  hardwiredCluster(net5.edge[12], taxa) # descendants of 12th edge = CEF\n6-element Array{Bool,1}:\n false\n false\n  true\n  true\n  true\n false  source  #  PhyloNetworks.hardwiredClusterDistance     Function .  hardwiredClusterDistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)  Takes 2 networks and returns their hardwired cluster distance, that is, the number of hardwired clusters found in one network and not in the other. Note that this is not a distance per se on the full space of hybrid networks: there are pairs of different networks for which this measure is 0. But it is a distance on some network subspaces.  If the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, the trees are considered unrooted.  source  #  PhyloNetworks.treeEdgesBootstrap     Function .  treeEdgesBootstrap(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork)  read a list of bootstrap networks ( boot_net ) and a reference network ( ref_net ), and calculate the bootstrap support of the tree edges in the reference network. All minor hybrid edges (\u03b3 0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.  output:   a data frame with one row per tree edge and two columns: edge number, bootstrap support (as a percentage)  the major tree from the reference network, where minor hybrid edges (with \u03b3 0.5) have been removed.   source  #  PhyloNetworks.hybridBootstrapSupport     Function .  hybridBootstrapSupport(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)  Match hybrid nodes in a reference network with those in an array of networks, like bootstrap networks. All networks must be fully resolved, and on the same taxon set. If  rooted=true , all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).  Two hybrid edges in two networks are said to match if they share the same \"hybrid\" clade (or recipient) and the same \"donor clade\", which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with \u03b3 0.5) and one is its minor sister (following the major hybrid edge with \u03b3 0.5).  To calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If  rooted=false , sister clades are considered as bipartitions.  Output:   a \"node\" data frame (see below)  an \"edge\" data frame (see below)  a \"clade\" data frame to describe the make up of all clades found as hybrids or sisters,   starting with a column  taxa  that lists all taxa. All other columns correspond to a given   clade and contain true/false values.  true  means that a given taxon belongs in a given clade.   For a clade named  H1 , for instance, and if the data frame was named  cla , the   list of taxa in this clade can be obtained with  cla[:taxa][cla[:H1]] .   an array of gamma values, with one row for each bootstrap network and two columns (major/minor)   for each hybrid edge in the reference network. If this hybrid edge was found in the bootstrap network   (i.e. same hybrid and sister clades, after removal of all other hybrid nodes),   its bootstrap gamma value is recorded here. Otherwise, the gamma entry is 0.0.   a vector with the number of each hybrid edge in the reference network, in the same order   as for the columns in the array of gamma values above.  The \"node\" data frame has one row per clade and 9 columns giving:   clade : the clade's name, like the taxon name (if a hybrid is a single taxon) or the hybrid tag (like 'H1') in the reference network  node : the node number in the reference network. NA if the clade is not in this network.  hybridnode : typically the same node number as above, except for hybrid clades in the reference network. For those, the hybrid node number is listed here.  edge : number of the parent edge, parent to the node in column 2, if found in the ref network. NA otherwise.  BS_hybrid : percentage of bootstrap networks in which the clade is found to be a hybrid clade.  BS_sister : percentage of bootstrap networks in which the clade is found to be sister to some hybrid clade (sum of the next 2 columns)  BS_major_sister : percentage of bootstrap networks in which the clade is found to be the major sister to some hybrid clade  BS_minor_sister : same as previous, but minor  BS_hybrid_samesisters : percentage of bootstrap networks in which the clade is found to be a hybrid and with the same set of sister clades as in the reference network. Applies to hybrid clades found in the reference network only, NA for all other clades.   The \"edge\" data frame has one row for each pair of clades, and 8 columns:   edge : hybrid edge number, if the edge appears in the reference network. NA otherwise.  hybrid_clade : name of the clade found to be a hybrid, descendent of 'edge'  hybrid : node number of that clade, if it appears in the reference network. NA otherwise.  sister_clade : name of the clade that is sister to 'edge', i.e. be sister to a hybrid  sister : node number of that clade, if in the ref network.  BS_hybrid_edge : percentage of bootstrap networks in which 'edge' is found to be a hybrid  edge, i.e. when the clade in the 'hybrid' column is found to be a hybrid and the clade in  the 'sister' column is one of its sisters.  BS_major : percentage of bootstrap networks in which 'edge' is found to be a major hybrid  edge, i.e. when 'hybrid' is found to be a hybrid clade and 'sister' is found to be its  major sister.  BS_minor : same as previous, but minor   source", 
            "title": "Network Comparisons"
        }, 
        {
            "location": "/lib/public/#trait-evolution", 
            "text": "#  PhyloNetworks.simulate     Function .  simulate(net::HybridNetwork, params::ParamsProcess, checkPreorder=true::Bool)  Simualte some traits on  net  using the parameters  params . For now, only parameters of type  ParamsBM  (Brownian Motion) are accepted.  Assumes that the network is in the pre-order. If  checkPreorder=true  (default), then it runs function  preoder  on the network beforehand.  Returns an object of type  TraitSimulation .  Examples  julia  phy = readTopology(joinpath(Pkg.dir( PhyloNetworks ),  examples ,  carnivores_tree.txt ));\n\njulia  par = ParamsBM(1, 0.1) # BM with expectation 1 and variance 0.1.\nPhyloNetworks.ParamsBM:\nParameters of a BM with fixed root:\nmu: 1\nSigma2: 0.1\n\njulia  srand(17920921); # Seed for reproducibility\n\njulia  sim = simulate(phy, par) # Simulate on the tree.\nPhyloNetworks.TraitSimulation:\nTrait simulation results on a network with 16 tips, using a BM model, with parameters:\nmu: 1\nSigma2: 0.1\n\njulia  traits = sim[:Tips] # Extract simulated values at the tips.\n16-element Array{Float64,1}:\n  2.17618 \n  1.03308 \n  3.04898 \n  3.03796 \n  2.1897  \n  4.03159 \n  4.64773 \n -0.877285\n  4.62512 \n -0.511167\n  1.35604 \n -0.103112\n -2.08847 \n  2.63991 \n  2.80512 \n  3.19109  source  #  PhyloNetworks.phyloNetworklm     Function .  phyloNetworklm(f, fr, net, model= BM ,\n    fTolRel=1e^-10, fTolAbs=1e^-10, xTolRel=1e^-10, xTolAbs=1e^-10,\n    startingValue=0.5)`  Phylogenetic regression, using the correlation structure induced by the network.  Returns an object of class  PhyloNetworkLinearModel . See documentation for this type and example to see all the functions that can be applied to it.  Arguments   f::Formula : formula to use for the regression (see the  DataFrame  package)  fr::AbstractDataFrame : DataFrame containing the data and regressors at the tips. It should have an extra column labelled \"tipNames\", that gives the names of the taxa for each observation.  net::HybridNetwork : phylogenetic network to use. Should have labelled tips.  model::AbstractString=\"BM\" : the model to use, \"BM\" being the default and only available model for now. If the entry is a TREE, then \"lambda\" can fit a Pagel's lambda model.  no_names::Bool=false : if  true , force the function to ignore the tips names. The data is then assumed to be in the same order as the tips of the network. Default to false, setting it to true is dangerous, and strongly discouraged.   If  model=\"lambda\" , there are a few more parameters to control the optimization in the parameter:   fTolRel::AbstractFloat=1e-10 : relative tolerance on the likelihood value for the optimization in lambda.  fTolAbs::AbstractFloat=1e-10 : absolute tolerance on the likelihood value for the optimization in lambda.  xTolRel::AbstractFloat=1e-10 : relative tolerance on the parameter value for the optimization in lambda.  xTolAbs::AbstractFloat=1e-10 : absolute tolerance on the parameter value for the optimization in lambda.  startingValue::Real=0.5 : the starting value for the parameter in the optimization in lambda.   Examples  julia  using DataFrames # Needed to handle data frames.\n\njulia  phy = readTopology(joinpath(Pkg.dir( PhyloNetworks ),  examples ,  caudata_tree.txt ));\n\njulia  dat = readtable(joinpath(Pkg.dir( PhyloNetworks ),  examples ,  caudata_trait.txt ));\n\njulia  fitBM = phyloNetworklm(trait ~ 1, dat, phy);\n\njulia  fitBM # Shows a summary\nDataFrames.DataFrameRegressionModel{PhyloNetworks.PhyloNetworkLinearModel,Array{Float64,2}}\n\nFormula: trait ~ +1\n\nParameter(s) Estimates:\nSigma2: 0.00294521\n\nCoefficients:\n             Estimate Std.Error t value Pr( |t|)\n(Intercept)     4.679  0.330627 14.1519    1e-31\n\nLog Likelihood: -78.9611507833\nAIC: 161.9223015666\n\njulia  round(sigma2_estim(fitBM), 6) # rounding for jldoctest convenience\n0.002945\n\njulia  round(mu_estim(fitBM), 4)\n4.679\n\njulia  round(loglikelihood(fitBM), 10)\n-78.9611507833\n\njulia  round(aic(fitBM), 10)\n161.9223015666\n\njulia  round(aicc(fitBM), 10)\n161.9841572367\n\njulia  round(bic(fitBM), 10)\n168.4887090241\n\njulia  coef(fitBM)\n1-element Array{Float64,1}:\n 4.679\n\njulia  confint(fitBM)\n1\u00d72 Array{Float64,2}:\n 4.02696  5.33104\n\njulia  abs(round(r2(fitBM), 10)) # absolute value for jldoctest convenience\n0.0\n\njulia  abs(round(adjr2(fitBM), 10))\n0.0\n\njulia  vcov(fitBM)\n1\u00d71 Array{Float64,2}:\n 0.109314\n\njulia  residuals(fitBM)\n197-element Array{Float64,1}:\n -0.237648\n -0.357937\n -0.159387\n -0.691868\n -0.323977\n -0.270452\n -0.673486\n -0.584654\n -0.279882\n -0.302175\n  \u22ee       \n -0.777026\n -0.385121\n -0.443444\n -0.327303\n -0.525953\n -0.673486\n -0.603158\n -0.211712\n -0.439833\n\njulia  model_response(fitBM)\n197-element Array{Float64,1}:\n 4.44135\n 4.32106\n 4.51961\n 3.98713\n 4.35502\n 4.40855\n 4.00551\n 4.09434\n 4.39912\n 4.37682\n \u22ee      \n 3.90197\n 4.29388\n 4.23555\n 4.3517 \n 4.15305\n 4.00551\n 4.07584\n 4.46729\n 4.23917\n\njulia  predict(fitBM)\n197-element Array{Float64,1}:\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n \u22ee    \n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679  See also  Type  PhyloNetworkLinearModel , Function  ancestralStateReconstruction  source  #  PhyloNetworks.sigma2_estim     Function .  sigma2_estim(m::PhyloNetworkLinearModel)  Estimated variance for a fitted object.  source  #  PhyloNetworks.mu_estim     Function .  mu_estim(m::PhyloNetworkLinearModel)  Estimated root value for a fitted object.  source  #  PhyloNetworks.lambda_estim     Function .  lambda_estim(m::PhyloNetworkLinearModel)  Estimated lambda parameter for a fitted object.  source  #  PhyloNetworks.ancestralStateReconstruction     Function .  ancestralStateReconstruction(net::HybridNetwork, Y::Vector, params::ParamsBM)  Compute the conditional expectations and variances of the ancestral (un-observed) traits values at the internal nodes of the phylogenetic network ( net ),  given the values of the traits at the tips of the network ( Y ) and some known parameters of the process used for trait evolution ( params , only BM with fixed root works for now).  This function assumes that the parameters of the process are known. For a more general function, see  ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix]) .  source  ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])  Function to find the ancestral traits reconstruction on a network, given an object fitted by function  phyloNetworklm . By default, the function assumes that the regressor is just an intercept. If the value of the regressor for  all the ancestral states is known, it can be entered in X_n, a matrix with as many columns as the number of predictors used, and as many lines as the number of unknown nodes or tips.  Returns an object of type  ReconstructedStates . See documentation for this type and examples for functions that can be applied to it.  Examples  julia  using DataFrames # Needed to use handle data frames\n\njulia  phy = readTopology(joinpath(Pkg.dir( PhyloNetworks ),  examples ,  carnivores_tree.txt ));\n\njulia  dat = readtable(joinpath(Pkg.dir( PhyloNetworks ),  examples ,  carnivores_trait.txt ));\n\njulia  fitBM = phyloNetworklm(trait ~ 1, dat, phy);\n\njulia  ancStates = ancestralStateReconstruction(fitBM) # Should produce a warning, as variance is unknown.\nWARNING: These prediction intervals show uncertainty in ancestral values,\nassuming that the estimated variance rate of evolution is correct.\nAdditional uncertainty in the estimation of this variance rate is\nignored, so prediction intervals should be larger.\nPhyloNetworks.ReconstructedStates:\n     Node index     Pred.       Min. Max. (95%)\n           -5.0   1.32139  -0.288423     2.9312\n           -8.0   1.03258  -0.539072    2.60423\n           -7.0   1.41575 -0.0934395    2.92495\n           -6.0   1.39417 -0.0643135    2.85265\n           -4.0   1.39961 -0.0603343    2.85955\n           -3.0   1.51341  -0.179626    3.20644\n          -13.0    5.3192    3.96695    6.67145\n          -12.0   4.51176    2.94268    6.08085\n          -16.0   1.50947  0.0290151    2.98992\n          -15.0   1.67425   0.241696    3.10679\n          -14.0   1.80309   0.355568     3.2506\n          -11.0    2.7351    1.21896    4.25123\n          -10.0   2.73217    1.16545    4.29889\n           -9.0   2.41132   0.639075    4.18357\n           -2.0   2.04138 -0.0340955    4.11686\n           14.0   1.64289    1.64289    1.64289\n            8.0   1.67724    1.67724    1.67724\n            5.0  0.331568   0.331568   0.331568\n            2.0   2.27395    2.27395    2.27395\n            4.0  0.275237   0.275237   0.275237\n            6.0   3.39094    3.39094    3.39094\n           13.0  0.355799   0.355799   0.355799\n           15.0  0.542565   0.542565   0.542565\n            7.0  0.773436   0.773436   0.773436\n           10.0   6.94985    6.94985    6.94985\n           11.0   4.78323    4.78323    4.78323\n           12.0   5.33016    5.33016    5.33016\n            1.0 -0.122604  -0.122604  -0.122604\n           16.0   0.73989    0.73989    0.73989\n            9.0   4.84236    4.84236    4.84236\n            3.0    1.0695     1.0695     1.0695\n\njulia  expectations(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 condExpectation \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502 1.32139         \u2502\n\u2502 2   \u2502 -8         \u2502 1.03258         \u2502\n\u2502 3   \u2502 -7         \u2502 1.41575         \u2502\n\u2502 4   \u2502 -6         \u2502 1.39417         \u2502\n\u2502 5   \u2502 -4         \u2502 1.39961         \u2502\n\u2502 6   \u2502 -3         \u2502 1.51341         \u2502\n\u2502 7   \u2502 -13        \u2502 5.3192          \u2502\n\u2502 8   \u2502 -12        \u2502 4.51176         \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502 0.542565        \u2502\n\u2502 24  \u2502 7          \u2502 0.773436        \u2502\n\u2502 25  \u2502 10         \u2502 6.94985         \u2502\n\u2502 26  \u2502 11         \u2502 4.78323         \u2502\n\u2502 27  \u2502 12         \u2502 5.33016         \u2502\n\u2502 28  \u2502 1          \u2502 -0.122604       \u2502\n\u2502 29  \u2502 16         \u2502 0.73989         \u2502\n\u2502 30  \u2502 9          \u2502 4.84236         \u2502\n\u2502 31  \u2502 3          \u2502 1.0695          \u2502\n\njulia  predint(ancStates)\n31\u00d72 Array{Float64,2}:\n -0.288423    2.9312  \n -0.539072    2.60423 \n -0.0934395   2.92495 \n -0.0643135   2.85265 \n -0.0603343   2.85955 \n -0.179626    3.20644 \n  3.96695     6.67145 \n  2.94268     6.08085 \n  0.0290151   2.98992 \n  0.241696    3.10679 \n  \u22ee\n  0.542565    0.542565\n  0.773436    0.773436\n  6.94985     6.94985 \n  4.78323     4.78323 \n  5.33016     5.33016 \n -0.122604   -0.122604\n  0.73989     0.73989 \n  4.84236     4.84236 \n  1.0695      1.0695 \n\njulia  ## Format and plot the ancestral states:\n\njulia  expectationsPlot(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502  1.32   \u2502\n\u2502 2   \u2502 -8         \u2502  1.03   \u2502\n\u2502 3   \u2502 -7         \u2502  1.42   \u2502\n\u2502 4   \u2502 -6         \u2502  1.39   \u2502\n\u2502 5   \u2502 -4         \u2502  1.4    \u2502\n\u2502 6   \u2502 -3         \u2502  1.51   \u2502\n\u2502 7   \u2502 -13        \u2502  5.32   \u2502\n\u2502 8   \u2502 -12        \u2502  4.51   \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502  0.54   \u2502\n\u2502 24  \u2502 7          \u2502  0.77   \u2502\n\u2502 25  \u2502 10         \u2502  6.95   \u2502\n\u2502 26  \u2502 11         \u2502  4.78   \u2502\n\u2502 27  \u2502 12         \u2502  5.33   \u2502\n\u2502 28  \u2502 1          \u2502  -0.12  \u2502\n\u2502 29  \u2502 16         \u2502  0.74   \u2502\n\u2502 30  \u2502 9          \u2502  4.84   \u2502\n\u2502 31  \u2502 3          \u2502  1.07   \u2502\n\njulia  plot(phy, nodeLabel = expectationsPlot(ancStates))\nPlot(...)\n\njulia  predintPlot(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502  [-0.29, 2.93]  \u2502\n\u2502 2   \u2502 -8         \u2502  [-0.54, 2.6]   \u2502\n\u2502 3   \u2502 -7         \u2502  [-0.09, 2.92]  \u2502\n\u2502 4   \u2502 -6         \u2502  [-0.06, 2.85]  \u2502\n\u2502 5   \u2502 -4         \u2502  [-0.06, 2.86]  \u2502\n\u2502 6   \u2502 -3         \u2502  [-0.18, 3.21]  \u2502\n\u2502 7   \u2502 -13        \u2502  [3.97, 6.67]   \u2502\n\u2502 8   \u2502 -12        \u2502  [2.94, 6.08]   \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502  0.54           \u2502\n\u2502 24  \u2502 7          \u2502  0.77           \u2502\n\u2502 25  \u2502 10         \u2502  6.95           \u2502\n\u2502 26  \u2502 11         \u2502  4.78           \u2502\n\u2502 27  \u2502 12         \u2502  5.33           \u2502\n\u2502 28  \u2502 1          \u2502  -0.12          \u2502\n\u2502 29  \u2502 16         \u2502  0.74           \u2502\n\u2502 30  \u2502 9          \u2502  4.84           \u2502\n\u2502 31  \u2502 3          \u2502  1.07           \u2502\n\njulia  plot(phy, nodeLabel = predintPlot(ancStates))\nPlot(...)\n\njulia  ## Some tips may also be missing\n\njulia  dat[[2, 5], :trait] = NA;\n\njulia  fitBM = phyloNetworklm(trait ~ 1, dat, phy);\n\njulia  ancStates = ancestralStateReconstruction(fitBM); \nWARNING: These prediction intervals show uncertainty in ancestral values,\nassuming that the estimated variance rate of evolution is correct.\nAdditional uncertainty in the estimation of this variance rate is\nignored, so prediction intervals should be larger.\n\njulia  expectations(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 condExpectation \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502 1.42724         \u2502\n\u2502 2   \u2502 -8         \u2502 1.35185         \u2502\n\u2502 3   \u2502 -7         \u2502 1.61993         \u2502\n\u2502 4   \u2502 -6         \u2502 1.54198         \u2502\n\u2502 5   \u2502 -4         \u2502 1.53916         \u2502\n\u2502 6   \u2502 -3         \u2502 1.64984         \u2502\n\u2502 7   \u2502 -13        \u2502 5.33508         \u2502\n\u2502 8   \u2502 -12        \u2502 4.55109         \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502 0.542565        \u2502\n\u2502 24  \u2502 7          \u2502 0.773436        \u2502\n\u2502 25  \u2502 10         \u2502 6.94985         \u2502\n\u2502 26  \u2502 11         \u2502 4.78323         \u2502\n\u2502 27  \u2502 12         \u2502 5.33016         \u2502\n\u2502 28  \u2502 1          \u2502 -0.122604       \u2502\n\u2502 29  \u2502 16         \u2502 0.73989         \u2502\n\u2502 30  \u2502 9          \u2502 4.84236         \u2502\n\u2502 31  \u2502 3          \u2502 1.0695          \u2502\n\njulia  predint(ancStates)\n31\u00d72 Array{Float64,2}:\n -0.31245     3.16694 \n -0.625798    3.3295  \n -0.110165    3.35002 \n -0.0710391   3.15501 \n -0.0675924   3.14591 \n -0.197236    3.49692 \n  3.89644     6.77373 \n  2.8741      6.22808 \n -0.0358627   3.12834 \n  0.182594    3.2534  \n  \u22ee\n  0.542565    0.542565\n  0.773436    0.773436\n  6.94985     6.94985 \n  4.78323     4.78323 \n  5.33016     5.33016 \n -0.122604   -0.122604\n  0.73989     0.73989 \n  4.84236     4.84236 \n  1.0695      1.0695 \n\njulia  ## Format and plot the ancestral states:\n\njulia  expectationsPlot(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502  1.43   \u2502\n\u2502 2   \u2502 -8         \u2502  1.35   \u2502\n\u2502 3   \u2502 -7         \u2502  1.62   \u2502\n\u2502 4   \u2502 -6         \u2502  1.54   \u2502\n\u2502 5   \u2502 -4         \u2502  1.54   \u2502\n\u2502 6   \u2502 -3         \u2502  1.65   \u2502\n\u2502 7   \u2502 -13        \u2502  5.34   \u2502\n\u2502 8   \u2502 -12        \u2502  4.55   \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502  0.54   \u2502\n\u2502 24  \u2502 7          \u2502  0.77   \u2502\n\u2502 25  \u2502 10         \u2502  6.95   \u2502\n\u2502 26  \u2502 11         \u2502  4.78   \u2502\n\u2502 27  \u2502 12         \u2502  5.33   \u2502\n\u2502 28  \u2502 1          \u2502  -0.12  \u2502\n\u2502 29  \u2502 16         \u2502  0.74   \u2502\n\u2502 30  \u2502 9          \u2502  4.84   \u2502\n\u2502 31  \u2502 3          \u2502  1.07   \u2502\n\njulia  plot(phy, nodeLabel = expectationsPlot(ancStates))\nPlot(...)\n\njulia  predintPlot(ancStates)\n31\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 nodeNumber \u2502 PredInt         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 -5         \u2502  [-0.31, 3.17]  \u2502\n\u2502 2   \u2502 -8         \u2502  [-0.63, 3.33]  \u2502\n\u2502 3   \u2502 -7         \u2502  [-0.11, 3.35]  \u2502\n\u2502 4   \u2502 -6         \u2502  [-0.07, 3.16]  \u2502\n\u2502 5   \u2502 -4         \u2502  [-0.07, 3.15]  \u2502\n\u2502 6   \u2502 -3         \u2502  [-0.2, 3.5]    \u2502\n\u2502 7   \u2502 -13        \u2502  [3.9, 6.77]    \u2502\n\u2502 8   \u2502 -12        \u2502  [2.87, 6.23]   \u2502\n\u22ee\n\u2502 23  \u2502 15         \u2502  0.54           \u2502\n\u2502 24  \u2502 7          \u2502  0.77           \u2502\n\u2502 25  \u2502 10         \u2502  6.95           \u2502\n\u2502 26  \u2502 11         \u2502  4.78           \u2502\n\u2502 27  \u2502 12         \u2502  5.33           \u2502\n\u2502 28  \u2502 1          \u2502  -0.12          \u2502\n\u2502 29  \u2502 16         \u2502  0.74           \u2502\n\u2502 30  \u2502 9          \u2502  4.84           \u2502\n\u2502 31  \u2502 3          \u2502  1.07           \u2502\n\njulia  plot(phy, nodeLabel = predintPlot(ancStates))\nPlot(...)  source  ancestralStateReconstruction(fr::AbstractDataFrame, net::HybridNetwork; kwargs...)  Function to find the ancestral traits reconstruction on a network, given some data at the tips. Uses function  phyloNetworklm  to perform a phylogenetic regression of the data against an intercept (amounts to fitting an evolutionary model on the network, BM being the only option  available for now).  See documentation on  phyloNetworklm  and  ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])  for further details.  Returns an object of type  ReconstructedStates .  source  #  PhyloNetworks.expectations     Function .  expectations(obj::ReconstructedStates)  Estimated reconstructed states at the nodes and tips.  source  #  PhyloNetworks.predint     Function .  predint(obj::ReconstructedStates, level=0.95::Real)  Prediction intervals with level  level  for internal nodes and missing tips.  source  #  PhyloNetworks.expectationsPlot     Function .  expectationsPlot(obj::ReconstructedStates)  Compute and format the expected reconstructed states for the plotting function. The resulting dataframe can be readily used as a  nodeLabel  argument to  plot .  source  #  PhyloNetworks.predintPlot     Function .  predintPlot(obj::ReconstructedStates, level=0.95::Real)  Compute and format the prediction intervals for the plotting function. The resulting dataframe can be readily used as a  nodeLabel  argument to  plot .  source", 
            "title": "Trait Evolution"
        }, 
        {
            "location": "/lib/internals/", 
            "text": "Internal Documentation\n\n\n\n\nContents\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\nTypes\n\n\nFunctions and methods\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nPhyloNetworks.ANode\n\n\nPhyloNetworks.MatrixTopologicalOrder\n\n\nBase.getindex\n\n\nPhyloNetworks.assignhybridnames!\n\n\nPhyloNetworks.deleteNode!\n\n\nPhyloNetworks.sampleBootstrapTrees\n\n\nPhyloNetworks.sampleCFfromCI\n\n\nPhyloNetworks.setNonIdBL!\n\n\nPhyloNetworks.sharedPathMatrix\n\n\n\n\n\n\nTypes\n\n\n#\n\n\nPhyloNetworks.ANode\n \n \nType\n.\n\n\nANode\n\n\nAbstract node. An object of type \nEdge\n has a \nnode\n attribute, which is an vector of (2) ANode objects. The object of type \nNode\n is an \nANode\n, and has an \nedge\n attribute, which is vector of \nEdge\n objects.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.MatrixTopologicalOrder\n \n \nType\n.\n\n\nMatrixTopologicalOrder\n\n\nMatrix associated to an \nHybridNetwork\n sorted in topological order.\n\n\nThe following functions and extractors can be applied to it: \ntipLabels\n, \nobj[:Tips]\n, \nobj[:InternalNodes]\n, \nobj[:TipsNodes]\n (see documentation for function \ngetindex(::MatrixTopologicalOrder, ::Symbol)\n).\n\n\nFunctions \nsharedPathMatrix\n and \nsimulate\n return objects of this type.\n\n\nThe \nMatrixTopologicalOrder\n object has fields: \nV\n, \nnodeNumbersTopOrder\n, \ninternalNodeNumbers\n, \ntipNumbers\n, \ntipNames\n, \nindexation\n. Type in \"?MatrixTopologicalOrder.field\" to get documentation on a specific field.\n\n\nsource\n\n\n\n\nFunctions and methods\n\n\n#\n\n\nPhyloNetworks.assignhybridnames!\n \n \nFunction\n.\n\n\nassignhybridnames!(net)\n\n\nAssign names to hybrid nodes in the network \nnet\n. Hybrid nodes with an empty \nname\n field (\"\") are modified with a name that does not conflict with other hybrid names in the network. The preferred name is \"#H3\" if the node number is 3 or -3, but an index other than 3 would be used if \"#H3\" were the name of another hybrid node already.\n\n\nIf two hybrid nodes have non-empty and equal names, the name of one of them is changed and re-assigned as described above (with a warning).\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.deleteNode!\n \n \nFunction\n.\n\n\ndeleteNode!(net::HybridNetwork, n::Node)\n\n\ndeletes a Node from a network, i.e. removes it from net.node, and from net.hybrid or net.leaf as appropriate. Updates attributes numNodes, numTaxa, numHybrids (it does not update net.names though).\n\n\nWarning: if the root is deleted, the new root is arbitrarily set to the first node in the list. This is intentional to save time because this function is used frequently in snaq!, which handles semi-directed (unrooted) networks.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sampleBootstrapTrees\n \n \nFunction\n.\n\n\nsampleBootstrapTrees(vector of tree lists; seed=0::Integer, generesampling=false, row=0)\nsampleBootstrapTrees!(tree list, vector of tree lists; seed=0::Integer, generesampling=false, row=0)\n\n\n\n\nSample bootstrap gene trees, 1 tree per gene. Set the seed with keyword argument \nseed\n, which is 0 by default. When \nseed=0\n, the actual seed is set using the clock. Assumes a vector of vectors of networks (see \nreadBootstrapTrees\n), each one of length 1 or more (error if one vector is empty, tested in \nbootsnaq\n).\n\n\n\n\nsite resampling: always, from sampling one bootstrap tree from each given list. This tree is sampled at \nrandom\n unless \nrow\n0\n (see below).\n\n\ngene resampling: if \ngeneresampling=true\n (default is false), genes (i.e. lists) are sampled with replacement.\n\n\nrow=i\n: samples the ith bootstrap tree for each gene. \nrow\n is turned back to 0 if gene resampling is true.\n\n\n\n\noutput: one vector of trees. the modifying function (!) modifies the input tree list and returns it.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sampleCFfromCI\n \n \nFunction\n.\n\n\nsampleCFfromCI(data frame, seed=0)\nsampleCFfromCI!(data frame, seed=0)\n\n\n\n\nRead a data frame containing CFs and their credibility intervals, and sample new obsCF uniformly within the CIs. These CFs are then rescaled to sum up to 1 for each 4-taxon sets. Return a data frame with taxon labels in first 4 columns, sampled obs CFs in columns 5-7 and credibility intervals in columns 8-13.\n\n\n\n\nThe non-modifying function creates a new data frame (with re-ordered columns) and returns it. If \nseed=-1\n, the new df is a deep copy of the input df, with no call to the random number generator. Otherwise, \nseed\n is passed to the modifying function.\n\n\nThe modifying function overwrites the input data frame with the sampled CFs and returns it. If \nseed=0\n, the random generator is seeded from the clock. Otherwise the random generator is seeded using \nseed\n.\n\n\n\n\nWarning: the modifying version does \nnot\n check the df: assumes correct columns.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.setNonIdBL!\n \n \nFunction\n.\n\n\nsetNonIdBL!(net)\n\n\nSet non-identifiable edge branch lengths to -1.0 (i.e. missing) for a level-1 network \nnet\n, except for edges in\n\n\n\n\na good triangle: the edge below the hybrid is constrained to 0.\n\n\na bad diamond II: the edge below the hybrid is constrained to 0\n\n\na bad diamond I: the edges across from the hybrid node have non identifiable lengths but are kept, because the two \u03b3*(1-exp(-t)) values are identifiable.\n\n\n\n\nwill break if \ninCycle\n attributes are not initialized (at -1) or giving a correct node number.\n\n\nsource\n\n\n#\n\n\nPhyloNetworks.sharedPathMatrix\n \n \nFunction\n.\n\n\nsharedPathMatrix(net::HybridNetwork; checkPreorder=true::Bool)\n\n\nThis function computes the shared path matrix between all the nodes of a network. It assumes that the network is in the pre-order. If checkPreorder is true (default), then it runs function \npreoder\n on the network beforehand.\n\n\nReturns an object of type \nMatrixTopologicalOrder\n.\n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\ngetindex(collection, key...)\n\n\n\n\nRetrieve the value(s) stored at the given key or index within a collection. The syntax \na[i,j,...]\n is converted by the compiler to \ngetindex(a, i, j, ...)\n.\n\n\nsource\n\n\ngetindex(obj, d,[ indTips, msng])\n\n\nGetting submatrices of an object of type \nMatrixTopologicalOrder\n.\n\n\nArguments\n\n\n\n\nobj::MatrixTopologicalOrder\n: the matrix from which to extract.\n\n\n\n\nd::Symbol\n: a symbol precising which sub-matrix to extract. Can be:\n\n\n\n\n:Tips\n columns and/or rows corresponding to the tips\n\n\n:InternalNodes\n columns and/or rows corresponding to the internal nodes\n\n\n:TipsNodes\n columns corresponding to internal nodes, and row to tips (works only is indexation=\"b\")\n\n\nindTips::Vector{Int}\n: optional argument precising a specific order for the tips (internal use).\n\n\nmsng::BitArray{1}\n: optional argument precising the missing tips (internal use).\n\n\n\n\n\n\n\n\nsource", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/internals/#internal-documentation", 
            "text": "", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/lib/internals/#contents", 
            "text": "Internal Documentation  Contents  Index  Types  Functions and methods", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/internals/#index", 
            "text": "PhyloNetworks.ANode  PhyloNetworks.MatrixTopologicalOrder  Base.getindex  PhyloNetworks.assignhybridnames!  PhyloNetworks.deleteNode!  PhyloNetworks.sampleBootstrapTrees  PhyloNetworks.sampleCFfromCI  PhyloNetworks.setNonIdBL!  PhyloNetworks.sharedPathMatrix", 
            "title": "Index"
        }, 
        {
            "location": "/lib/internals/#types", 
            "text": "#  PhyloNetworks.ANode     Type .  ANode  Abstract node. An object of type  Edge  has a  node  attribute, which is an vector of (2) ANode objects. The object of type  Node  is an  ANode , and has an  edge  attribute, which is vector of  Edge  objects.  source  #  PhyloNetworks.MatrixTopologicalOrder     Type .  MatrixTopologicalOrder  Matrix associated to an  HybridNetwork  sorted in topological order.  The following functions and extractors can be applied to it:  tipLabels ,  obj[:Tips] ,  obj[:InternalNodes] ,  obj[:TipsNodes]  (see documentation for function  getindex(::MatrixTopologicalOrder, ::Symbol) ).  Functions  sharedPathMatrix  and  simulate  return objects of this type.  The  MatrixTopologicalOrder  object has fields:  V ,  nodeNumbersTopOrder ,  internalNodeNumbers ,  tipNumbers ,  tipNames ,  indexation . Type in \"?MatrixTopologicalOrder.field\" to get documentation on a specific field.  source", 
            "title": "Types"
        }, 
        {
            "location": "/lib/internals/#functions-and-methods", 
            "text": "#  PhyloNetworks.assignhybridnames!     Function .  assignhybridnames!(net)  Assign names to hybrid nodes in the network  net . Hybrid nodes with an empty  name  field (\"\") are modified with a name that does not conflict with other hybrid names in the network. The preferred name is \"#H3\" if the node number is 3 or -3, but an index other than 3 would be used if \"#H3\" were the name of another hybrid node already.  If two hybrid nodes have non-empty and equal names, the name of one of them is changed and re-assigned as described above (with a warning).  source  #  PhyloNetworks.deleteNode!     Function .  deleteNode!(net::HybridNetwork, n::Node)  deletes a Node from a network, i.e. removes it from net.node, and from net.hybrid or net.leaf as appropriate. Updates attributes numNodes, numTaxa, numHybrids (it does not update net.names though).  Warning: if the root is deleted, the new root is arbitrarily set to the first node in the list. This is intentional to save time because this function is used frequently in snaq!, which handles semi-directed (unrooted) networks.  source  #  PhyloNetworks.sampleBootstrapTrees     Function .  sampleBootstrapTrees(vector of tree lists; seed=0::Integer, generesampling=false, row=0)\nsampleBootstrapTrees!(tree list, vector of tree lists; seed=0::Integer, generesampling=false, row=0)  Sample bootstrap gene trees, 1 tree per gene. Set the seed with keyword argument  seed , which is 0 by default. When  seed=0 , the actual seed is set using the clock. Assumes a vector of vectors of networks (see  readBootstrapTrees ), each one of length 1 or more (error if one vector is empty, tested in  bootsnaq ).   site resampling: always, from sampling one bootstrap tree from each given list. This tree is sampled at  random  unless  row 0  (see below).  gene resampling: if  generesampling=true  (default is false), genes (i.e. lists) are sampled with replacement.  row=i : samples the ith bootstrap tree for each gene.  row  is turned back to 0 if gene resampling is true.   output: one vector of trees. the modifying function (!) modifies the input tree list and returns it.  source  #  PhyloNetworks.sampleCFfromCI     Function .  sampleCFfromCI(data frame, seed=0)\nsampleCFfromCI!(data frame, seed=0)  Read a data frame containing CFs and their credibility intervals, and sample new obsCF uniformly within the CIs. These CFs are then rescaled to sum up to 1 for each 4-taxon sets. Return a data frame with taxon labels in first 4 columns, sampled obs CFs in columns 5-7 and credibility intervals in columns 8-13.   The non-modifying function creates a new data frame (with re-ordered columns) and returns it. If  seed=-1 , the new df is a deep copy of the input df, with no call to the random number generator. Otherwise,  seed  is passed to the modifying function.  The modifying function overwrites the input data frame with the sampled CFs and returns it. If  seed=0 , the random generator is seeded from the clock. Otherwise the random generator is seeded using  seed .   Warning: the modifying version does  not  check the df: assumes correct columns.  source  #  PhyloNetworks.setNonIdBL!     Function .  setNonIdBL!(net)  Set non-identifiable edge branch lengths to -1.0 (i.e. missing) for a level-1 network  net , except for edges in   a good triangle: the edge below the hybrid is constrained to 0.  a bad diamond II: the edge below the hybrid is constrained to 0  a bad diamond I: the edges across from the hybrid node have non identifiable lengths but are kept, because the two \u03b3*(1-exp(-t)) values are identifiable.   will break if  inCycle  attributes are not initialized (at -1) or giving a correct node number.  source  #  PhyloNetworks.sharedPathMatrix     Function .  sharedPathMatrix(net::HybridNetwork; checkPreorder=true::Bool)  This function computes the shared path matrix between all the nodes of a network. It assumes that the network is in the pre-order. If checkPreorder is true (default), then it runs function  preoder  on the network beforehand.  Returns an object of type  MatrixTopologicalOrder .  source  #  Base.getindex     Method .  getindex(collection, key...)  Retrieve the value(s) stored at the given key or index within a collection. The syntax  a[i,j,...]  is converted by the compiler to  getindex(a, i, j, ...) .  source  getindex(obj, d,[ indTips, msng])  Getting submatrices of an object of type  MatrixTopologicalOrder .  Arguments   obj::MatrixTopologicalOrder : the matrix from which to extract.   d::Symbol : a symbol precising which sub-matrix to extract. Can be:   :Tips  columns and/or rows corresponding to the tips  :InternalNodes  columns and/or rows corresponding to the internal nodes  :TipsNodes  columns corresponding to internal nodes, and row to tips (works only is indexation=\"b\")  indTips::Vector{Int} : optional argument precising a specific order for the tips (internal use).  msng::BitArray{1} : optional argument precising the missing tips (internal use).     source", 
            "title": "Functions and methods"
        }
    ]
}