var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#internal-documentation","page":"Internals","title":"internal documentation","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Documentation for PhyloNetworks's internal functions. These functions are not exported and their access (API) should not be considered stable. But they can still be used, like this for example: PhyloNetworks.foo() for a function named foo().","category":"page"},{"location":"lib/internals/#functions-and-types","page":"Internals","title":"functions & types","text":"","category":"section"},{"location":"lib/internals/#PhyloNetworks.ANode","page":"Internals","title":"PhyloNetworks.ANode","text":"ANode\n\nAbstract node. An object of type EdgeT has a node attribute, which is an vector of 2 objects of some subtype of ANode. The concrete type Node is a subtype of ANode, and has an edge attribute, which is vector of Edge objects (where Edge is an alias for EdgeT{Node}).\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.EdgeMuRepresentation","page":"Internals","title":"PhyloNetworks.EdgeMuRepresentation","text":"EdgeMuRepresentation\n\nRepresentation of a semidirected network with one μ-entry for each edge. See Maxfield, Xu & Ané 2025. edge_murepresentation constructs such an object, with μ-entries for internal edges only (not external to a tip).\n\nIf an edge is in the root component, that is, both of its incident nodes can root the network, then its μ-entry is a set of 2 μ-vectors, one corresponding to each direction of the edge. (Each μ-vector would get a tree tag because such edges must be tree edges, so these tags are not stored).\nIf an edge has a fixed direction regardless of where the network is rooted: its μ-entry is 1 tagged μ-vector corresponding to the edge's direction.\nif the edge is not adjacent to the root component, then the tag says whether the edge is a tree edge or a hybrid edge.\nif the edge is adjacent to the root component (one of its incident nodes could be the root), then the root may be placed along the edge. Then its tag indicates so – departing from Maxfield, Xu & Ané (2025). For semidirected induced by a rooted network in the standard way, these edges must be hybrid edges, and there is no information loss.\n\nAll μ-vectors include the number of paths to hybrids, defined for rooted networks by Cardona et al. (2024). See MuVector.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.EdgeT","page":"Internals","title":"PhyloNetworks.EdgeT","text":"EdgeT{node type}\nEdge = EdgeT{Node}\nEdge(number, length=1.0)\n\nData structure for an edge and its various attributes. Most notably:\n\nnumber (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example\nnode: vector of Nodes, normally just 2 of them\nischild1 (boolean): true if node[1] is the child node of the edge, false if node[1] is the parent node of the edge\nlength: branch length\nhybrid (boolean): whether the edge is a tree edge or a hybrid edge (in which case ischild1 is important, even if the network is semi-directed)\ngamma: proportion of genetic material inherited by the child node via the edge; 1.0 for a tree edge\nismajor (boolean): whether the edge is the major path to the child node; true for tree edges, since a tree edge is the only path to its child node; normally true if gamma>0.5.\ncontainroot (boolean): is the interior of this edge a valid rooting position? That is, if we added a node on the edge, could we direct all edges away from this new node to root the semidirected network and get a valid rooted network?\n\nand other fields, used very internally\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.MatrixTopologicalOrder","page":"Internals","title":"PhyloNetworks.MatrixTopologicalOrder","text":"MatrixTopologicalOrder\n\nMatrix associated to a HybridNetwork in which rows and/or columns correspond to nodes in the network. In this matrix, nodes are indexed by their topological order. For example, if rows list nodes in network net, then V[i,:] corresponds to node net.vec_node[i].\n\nThe following functions and extractors can be applied to it: tiplabels, obj[:tips], obj[:internalnodes], obj[:tipsnodes]. See documentation for getindex(::MatrixTopologicalOrder, ::Symbol)).\n\nA MatrixTopologicalOrder object has field V (the matrix of interest) and fields for mapping indices in V to node numbers nodenumbers_toporder, internalnodenumbers, tipnumbers, tipnames, indexation. Type in \"?MatrixTopologicalOrder.field\" to get documentation on a specific field.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.MuVector","page":"Internals","title":"PhyloNetworks.MuVector","text":"MuVector\n\nμ-vector for a single node (see Cardona et al. 2024) separated into\n\nμ0: number of paths starting at the node or edge and ending at any hybrid node\nμ-vector counting the number of paths from that node to each specific leaf.\n\nThis type does not store the leaf labels nor the order in which leaves are positioned in μ-vectors.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.Node","page":"Internals","title":"PhyloNetworks.Node","text":"Node(number, leaf)\nNode(number, leaf, hybrid)\n\nData structure for a node and its various attributes. Most notably:\n\nnumber (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example\nleaf (boolean): whether the node is a leaf (with data typically) or an internal node (no data typically)\nname (string): taxon name for leaves; internal node may or may not have a name\nedge: vector of Edges that the node is attached to; 1 if the node is a leaf, 2 if the node is the root, 3 otherwise, and potentially more if the node has a polytomy\nhybrid (boolean): whether the node is a hybrid node (with 2 or more parents) or a tree node (with a single parent)\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.NodeMuRepresentation","page":"Internals","title":"PhyloNetworks.NodeMuRepresentation","text":"NodeMuRepresentation\n\nRepresentation of a rooted network with one MuVector per node. This entry contains the node's μ-vector: a vector of integers counting the number of paths from that node to each leaf. tiplabels gives the order of leaves in μ-vectors.\n\nnode_murepresentation constructs such an object, with a μ-vector for each non-leaf node only (not for tips), because leaf nodes have trivial μ-vectors (all 0s but one 1) that would match across any network with that leaf.\n\nSee Cardona et al. (2024).\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.Partition","page":"Internals","title":"PhyloNetworks.Partition","text":"Partition\n\nData structure for a collection of edges and (node) numbers. Fields:\n\ncycle: vector of Int\nedges: vector of Edge\n\nprocess_biconnectedcomponents! uses edges to store the edges in a given biconnected component. (blocks = biconnected components partition edges, while blobs = 2-edge connected components partition nodes. They are in 1-to-1 correspondence in binary networks.) cycle is used to store the indices, in net.vec_node, of the block's articulation nodes (or root), with the first one being the entry node (or root) and other being exit articulation nodes. Note that a leaf is not an articulation node: it does not connect the pendent edge to another block.\n\nwarning: `cycle` is a legacy name from SNaQ\nFor level-1 networks, SNaQ uses 1 partition for each maximum tree of cut-edges. edges stores the cut edges in this tree. cycle stores an integer for each cycle that the tree is adjacent to. This integer is the number of the unique hybrid node in this cycle.\n\nSee also entrynode_preindex, number_exitnodes\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.QuartetT","page":"Internals","title":"PhyloNetworks.QuartetT","text":"QuartetT{T}\n\nGeneric type for 4-taxon sets. Fields:\n\nnumber: rank of the 4-taxon set\ntaxonnumber: static vector of 4 integers, assumed to be distinct and sorted\ndata: object of type T\n\nFor easier look-up, a unique mapping is used between the rank (number) of a 4-taxon set and its 4 taxa (see quartetrank and nchoose1234):\n\nrank-1 = (t1-1) choose 1 + (t2-1) choose 2 + (t3-1) choose 3 + (t4-1) choose 4\n\nexamples\n\njulia> nCk = PhyloNetworks.nchoose1234(5)\n6×4 Matrix{Int64}:\n 0   0   0  0\n 1   0   0  0\n 2   1   0  0\n 3   3   1  0\n 4   6   4  1\n 5  10  10  5\n\njulia> PhyloNetworks.QuartetT(1,3,4,6, [.92,.04,.04, 100], nCk)\n4-taxon set number 8; taxon numbers: 1,3,4,6\ndata: [0.92, 0.04, 0.04, 100.0]\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.TopologyConstraint","page":"Internals","title":"PhyloNetworks.TopologyConstraint","text":"Type for various topological constraints, such as:\n\na set of taxa forming a clade in the major tree\na set of individuals belonging to the same species\na set of taxa forming a clade in any one of the displayed trees\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.TopologyConstraint-Tuple{UInt8, Vector{String}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.TopologyConstraint","text":"TopologyConstraint(type::UInt8, taxonnames::Vector{String}, net::HybridNetwork)\n\nCreate a topology constraint from user-given type, taxon names, and network. There are 3 types of constraints:\n\ntype 1: A set of tips that forms a species.\ntype 2: A set of tips that forms a clade in the major tree. Note that the root matters. Constraining a set of species to be an outgroup is equivalent to constraining the ingroup to form a clade.\ntype 3: A set of tips that forms a clade in any one of the displayed trees.\n\nNote: currently, with type-1 constraints, hybridizations are prevented from coming into or going out of a species group.\n\nexamples\n\njulia> net = readnewick(\"(((2a,2b),(((((1a,1b,1c),4),(5)#H1),(#H1,(6,7))))#H2),(#H2,10));\");\n\njulia> c_species1 = PhyloNetworks.TopologyConstraint(0x01, [\"1a\",\"1b\",\"1c\"], net)\nSpecies constraint, on tips: 1a, 1b, 1c\n stem edge number 7\n crown node number -9\n\njulia> c_species2 = PhyloNetworks.TopologyConstraint(0x01, [\"2a\",\"2b\"], net)\nSpecies constraint, on tips: 2a, 2b\n stem edge number 3\n crown node number -4\n\njulia> nni!(net , net.edge[3], true, true, [c_species2]) === nothing # we get nothing: would break species 2\ntrue\n\njulia> # the following gives an error, because 4,5 do not form a clade in \"net\"\n       # PhyloNetworks.TopologyConstraint(0x02, [\"4\",\"5\"], net)\n\njulia> c_clade145 = PhyloNetworks.TopologyConstraint(0x02, [\"1a\",\"1b\",\"1c\",\"4\",\"5\"], net)\nClade constraint, on tips: 1a, 1b, 1c, 4, 5\n stem edge number 12\n crown node number -7\n\njulia> nni!(net , net.edge[12], true, true, [c_species1, c_clade145]) # we get nothing (failed NNI): would break the clade\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.exitnodes_preindex","page":"Internals","title":"PhyloNetworks.exitnodes_preindex","text":"exitnodes_preindex(biconnected_component::Partition)\n\nIterator over the preorder index of articulation exit nodes of a biconnected component, considering the network rooted (see number_exitnodes). Indices are indices in the network's preordering .vec_node.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Base.:==-Tuple{PhyloNetworks.EdgeMuRepresentation, PhyloNetworks.EdgeMuRepresentation}","page":"Internals","title":"Base.:==","text":"==(m1::EdgeMuRepresentation, m2::EdgeMuRepresentation)\n\nEquality of two EdgeMuRepresentation objects, requiring that:\n\nIf m1 has labels that m2 doesn't have, then all corresponding entries for these labels in m1 should be 0 – as if a label is tracked in m1 but absent from the original network, and not tracked in m2. Vice versa: labels in m2 but not in m1 should have 0 entries in m2.\nm1 and m2 should have the same number of μ-entries of the same type (either in the root component, or directed with the same tags).\nAll μ-entries should have the same subvectors corresponding to the labels shared by m1 and m2.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#Base.:==-Tuple{PhyloNetworks.NodeMuRepresentation, PhyloNetworks.NodeMuRepresentation}","page":"Internals","title":"Base.:==","text":"==(m1::NodeMuRepresentation, m2::NodeMuRepresentation)\n\nEquality of two NodeMuRepresentation objects, requiring that:\n\nIf m1 has labels that m2 doesn't have, then all corresponding values for these labels in m1 should be 0 – as if a label is tracked in m1 but absent from the original network, and not tracked in m2. Vice versa: labels in m2 but not in m1 should have 0 values in m2.\nm1 and m2 should have the same number of μ-vectors\nThe μ-vectors should have the same subvectors corresponding to the labels shared by m1 and m2.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#Base.getindex","page":"Internals","title":"Base.getindex","text":"getindex(obj::MatrixTopologicalOrder,\n         d::Symbol,[ indtips, nonmissing])\n\nGet submatrices of a MatrixTopologicalOrder object. In obj.V, row and/column i corresponds to the ith node in topological order. In contrast, in matrix obj[:tips] for example, row and/or column i corresponds to the ith tip when tips are listed in the same order as in the network's original .node vector.\n\nArguments:\n\nobj::MatrixTopologicalOrder: the matrix from which to extract.\nd: symbol specifying which sub-matrix to extract. Can be:\n:tips columns and/or rows corresponding to the tips\n:internalnodes columns and/or rows corresponding to the internal nodes Includes tips not listed in indtips or missing data according to nonmissing.\n:tipsnodes columns corresponding to internal nodes, and row to tips (works only is indexation=\"b\")\n:all nodes, listed in topological order\nindtips::Vector{Int}: optional argument precising a specific order for the tips (internal use).\nnonmissing::BitVector: optional argument saying which tips have data (internal use).  Tips with missing data are treated as internal nodes.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks._getnodeheights","page":"Internals","title":"PhyloNetworks._getnodeheights","text":"_getnodeheights(net::HybridNetwork, fixmissing::Bool,\n                inconsistencyhandler::Function, checkpreorder::Bool=true)\n\nHelper to determine time-consistency and calculate node heights (distance from the root), used by getnodeheights for example.\n\noutput: (isconsistent, nodes_distance_from_root)\n\nArguments:\n\nfixmissing:\nif false, any missing hybrid edge length will cause a warning, the network is not modified, and the best-case is assumed to determine time-consistency (as explained below)\nif true, will attempt to find values for missing lengths of hybrid edges, if any, to make the network time-consistent, placing hybrid nodes as close to the root as possible (as this gives most chances to find a time-consistent assignment of all missing hybrid edge lengths). If there is a time-consistent assignment, then the network is modified (with missing hybrid edge lengths set to time-consistent values). Otherwise, the network is not modified.\nThis option is passed to update_getnodeheights_hybrid! that handles 1 hybrid node at a time.\ninconsistencyhandler: function to check & handle time-consistency as desired as a given hybrid node h, and to decide if the traversal should continue. It should take as input:\na vector of ≥1 candicate heights for h from parent edges with non-missing length, and\na vector of ≥0 heights of parent nodes whose child edge to h has no length\nisconsistent: a boolean that is modified to false if the network is not time-consistent at h (unless an error is thrown anyway!).\nThis handler function decides what to do if the candidate heights are not all equal (the network is time-inconsistent), and if the values to be assigned to missing edge lengths would be negative. Its output should be: (keepgoing_boolean, hybrid_node_height).\nExamples: timeinconsistency_error is conservative and throws an error in both cases. timeinconsistency_average is lenient: only throws warnings, but keeps going and returns γ-weighted average node heights\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork, DataFrames.DataFrame}","page":"Internals","title":"PhyloNetworks.addAlternativeHybridizations!","text":"addAlternativeHybridizations!(net::HybridNetwork, BSe::DataFrame;\n                              cutoff::Number=10, top::Int=3)\n\nModify the network net (the best estimated network) by adding some of the hybridizations present in the bootstrap networks. By default, it will only add hybrid edges with more than 10% bootstrap support (cutoff) and it will only include the top 3 hybridizations (top) sorted by bootstrap support.\n\nThe dataframe BSe is also modified. In the original BSe, supposedly obtained with hybridclades_support, hybrid edges that do not appear in the best network have a missing number. After hybrid edges from bootstrap networks are added, BSe is modified to include the edge numbers of the newly added hybrid edges. To distinguish hybrid edges present in the original network versus new edges, an extra column of true/false values is also added to BSe, named \"alternative\", with true for newly added edges absent from the original network.\n\nThe hybrid edges added to net are added as minor edges, to keep the underlying major tree topology.\n\nexample\n\njulia> bootnet = readmultinewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\", \"bootsnaq.out\")); # vector of 10 networks\n\njulia> bestnet = readnewick(\"((O,(E,#H7:::0.196):0.314):0.332,(((A)#H7:::0.804,B):10.0,(C,D):10.0):0.332);\");\n\njulia> BSn, BSe, BSc, BSgam, BSedgenum = hybridclades_support(bootnet, bestnet);\n\njulia> BSe[1:6,[:edge,:hybrid_clade,:sister_clade,:BS_hybrid_edge]]\n6×4 DataFrame\n Row │ edge     hybrid_clade  sister_clade  BS_hybrid_edge \n     │ Int64?   String        String        Float64        \n─────┼─────────────────────────────────────────────────────\n   1 │       7  H7            B                       33.0\n   2 │       3  H7            E                       32.0\n   3 │ missing  c_minus3      c_minus8                44.0\n   4 │ missing  c_minus3      H7                      44.0\n   5 │ missing  E             O                       12.0\n   6 │ missing  c_minus6      c_minus8                 9.0\n\njulia> PhyloNetworks.addAlternativeHybridizations!(bestnet, BSe)\n\njulia> BSe[1:6,[:edge,:hybrid_clade,:sister_clade,:BS_hybrid_edge,:alternative]]\n6×5 DataFrame\n Row │ edge     hybrid_clade  sister_clade  BS_hybrid_edge  alternative \n     │ Int64?   String        String        Float64         Bool        \n─────┼──────────────────────────────────────────────────────────────────\n   1 │       7  H7            B                       33.0        false\n   2 │       3  H7            E                       32.0        false\n   3 │      16  c_minus3      c_minus8                44.0         true\n   4 │      19  c_minus3      H7                      44.0         true\n   5 │      22  E             O                       12.0         true\n   6 │ missing  c_minus6      c_minus8                 9.0        false\n\njulia> # using PhyloPlots; plot(bestnet, edgelabel=BSe[:,[:edge,:BS_hybrid_edge]]);\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addHybridBetweenClades!-Tuple{HybridNetwork, Number, Number}","page":"Internals","title":"PhyloNetworks.addHybridBetweenClades!","text":"addHybridBetweenClades!(net::HybridNetwork, hybnum::Number, sisnum::Number)\n\nModify net by adding a minor hybrid edge from \"donor\" to \"recipient\", where \"donor\" is the major parent edge e1 of node number hybnum and \"recipient\" is the major parent edge e2 of node number sisnum. The new nodes are currently inserted at the middle of these parent edges.\n\nIf a hybrid edge from e1 to e2 would create a directed cycle in the network, then this hybrid cannot be added. In that case, the donor edge e1 is moved up if its parent is a hybrid node, to ensure that the sister clade to the new hybrid would be a desired (the descendant taxa from e1) and a new attempt is made to create a hybrid edge.\n\nOutput: number of the new hybrid edge, or nothing if the desired hybridization is not possible.\n\nSee also: addhybridedge! (used by this method) and directionalconflict to check that net would still be a DAG.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addhybridedge!","page":"Internals","title":"PhyloNetworks.addhybridedge!","text":"addhybridedge!(\n    net::HybridNetwork,\n    edge1::Edge,\n    edge2::Edge,\n    hybridpartnernew::Bool,\n    edgelength::Float64=-1.0,\n    gamma::Float64=-1.0\n)\n\nAdd hybridization to net coming from edge1 going into edge2. 2 new nodes and 3 new edges are created: edge1 are edge2 are both cut into 2 edges, and a new edge is created linking the 2 new \"middle\" nodes, pointing from edge1 to edge2. The new node in the middle of edge1 is a tree node. The new node in the middle of edge2 is a hybrid node. Its parent edges are the newly created hybrid edge (with γ = gamma, missing by default), and either the newly edge \"above\" edge2 if hybridpartnernew=true, or the old edge2 otherwise (which would reverse the direction of edge2 and others).\n\nShould be called from the other method, which performs a bunch of checks. Updates containroot attributes for edges below the new hybrid node.\n\nOutput: new hybrid node (middle of the old edge2) and new hybrid edge.\n\nexamples\n\njulia> net = readnewick(\"((S8,(((S1,(S5)#H1),(#H1,S6)))#H2),(#H2,S10));\");\n\njulia> hybnode, hybedge = PhyloNetworks.addhybridedge!(net, net.edge[13], net.edge[8], true, 0.0, 0.2)\n(PhyloNetworks.Node:\n number:9\n name:H3\n hybrid node\n attached to 3 edges, numbered: 8 16 17\n, PhyloNetworks.EdgeT{PhyloNetworks.Node}:\n number:17\n length:0.0\n minor hybrid edge with gamma=0.2\n attached to 2 node(s) (parent first): 8 9\n)\n\n\njulia> writenewick(net)\n\"((S8,(((S1,(S5)#H1),((#H1,S6))#H3:::0.8))#H2),(#H2,(S10,#H3:0.0::0.2)));\"\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.addhybridedge!-Tuple{HybridNetwork, Bool, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.addhybridedge!","text":"addhybridedge!(\n    [rng::AbstractRNG,]\n    net::HybridNetwork,\n    nohybridladder::Bool,\n    no3cycle::Bool,\n    constraints::Vector{TopologyConstraint}=TopologyConstraint[];\n    maxattempts::Int=10,\n    fixroot::Bool=false\n)\n\nRandomly choose two edges in net then: add hybrid edge from edge 1 to edge 2 of length 0.01. The two halves of edge 1 (and of edge 2) have equal lengths. The hybrid partner edge (top half of edge 2, if fixroot is true) will point towards the newly-created node on the middle of the original edge 2, and have an inheritance γ randomly uniformly chosen in (0,0.5).\n\nIf the resulting network is a DAG, satisfies the constraint(s), does not contain any 3-cycle (if no3cycle=true), and does not have a hybrid ladder (if nohybridladder=true) then the proposal is successful: net is modified, and the function returns the newly created hybrid node and newly created hybrid edge.\n\nIf the resulting network is not acceptable, then a new set of edges is proposed (using a blacklist) until one is found acceptable, or until a maximum number of attempts have been made (maxattempts). If none of the attempted proposals are successful, nothing is returned (without causing an error).\n\nAfter a pair of edges is picked, the \"top\" half of edge2 is proposed as the partner hybrid edge with probability 0.8 if fixroot is false, (to avoid changing the direction of edge2 with more than 50% chance) and with probability 1.0 if fixroot is true. If this choice does not work and if fixroot is false, the other half of edge2 is proposed as the partner hybrid edge. Note that choosing the \"bottom\" half of edge2 as the partner edge requires to flip the direction of edge 2, and to move the root accordingly (to the original child of edge2).\n\nexamples\n\njulia> net = readnewick(\"((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));\");\n\njulia> using Random\n\njulia> Random.seed!(170);\n\njulia> PhyloNetworks.addhybridedge!(net, true, true)\n(PhyloNetworks.Node:\n number:9\n name:H3\n hybrid node\n attached to 3 edges, numbered: 5 16 17\n, PhyloNetworks.EdgeT{PhyloNetworks.Node}:\n number:17\n length:0.01\n minor hybrid edge with gamma=0.32771460911632916\n attached to 2 node(s) (parent first): 8 9\n)\n\njulia> writenewick(net, round=true, digits=2)\n\"((S1,(((#H1,S4),((S2,(S3)#H1))#H3:::0.67))#H2),((#H2,S5),#H3:0.01::0.33));\"\n\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addindividuals!-Tuple{HybridNetwork, AbstractString, Vector{<:AbstractString}}","page":"Internals","title":"PhyloNetworks.addindividuals!","text":"addindividuals!(net::HybridNetwork, species::AbstractString, individuals::Vector)\n\nAdd individuals to their species leaf as a star, and return the corresponding species constraint. nothing is returned in 2 cases:\n\nif individuals contains only 1 individual, in which case the name of the leaf for that species is replaced by the name of its one individual representative\nif species is not found in the network\n\nSpaces in individuals' names are eliminated, see cleantaxonname.\n\nCalled by mapindividuals.\n\nexamples\n\njulia> net = readnewick(\"(S8,(((S1,S4),(S5)#H1),(#H1,S6)));\");\n\njulia> PhyloNetworks.addindividuals!(net, \"S1\", [\"S1A\", \"S1B\", \"S1C\"])\nSpecies constraint, on tips: S1A, S1B, S1C\n stem edge number 2\n crown node number 2\n\njulia> writenewick(net) # 3 new nodes, S1 now internal: not a tip\n\"(S8,((((S1A,S1B,S1C)S1,S4),(S5)#H1),(#H1,S6)));\"\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addleaf!","page":"Internals","title":"PhyloNetworks.addleaf!","text":"addleaf!(net::HybridNetwork, node::Node, leafname::String, edgelength::Float64=-1.0)\naddleaf!(net::HybridNetwork, edge::Edge, leafname::String, edgelength::Float64=-1.0)\n\nAdd a new external edge between node or between the \"middle\" of edge and a newly-created leaf, of name leafname. By default, the new edge length is missing (-1).\n\noutput: newly created leaf node.\n\nexamples\n\njulia> net = readnewick(\"((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));\");\n\njulia> net.node[6].name # leaf S4\n\"S4\"\n\njulia> PhyloNetworks.addleaf!(net, net.node[6], \"4a\"); # adding leaf to a node\n\njulia> writenewick(net, internallabel=true)\n\"((S1,(((S2,(S3)#H1),(#H1,(4a)S4)))#H2),(#H2,S5));\"\n\njulia> PhyloNetworks.addleaf!(net, net.node[6], \"4b\");\n\njulia> writenewick(net, internallabel=true)\n\"((S1,(((S2,(S3)#H1),(#H1,(4a,4b)S4)))#H2),(#H2,S5));\"\n\njulia> net = readnewick(\"((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));\");\n\njulia> [n.name for n in net.edge[7].node] # external edge to S4\n2-element Vector{String}:\n \"S4\"\n \"\"  \n\njulia> PhyloNetworks.addleaf!(net, net.edge[7], \"4a\"); # adding leaf to an edge\n\njulia> writenewick(net, internallabel=true)\n\"((S1,(((S2,(S3)#H1),(#H1,(S4,4a))))#H2),(#H2,S5));\"\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.adjacentedges-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.adjacentedges","text":"adjacentedges(centeredge::Edge)\n\nVector of all edges that share a node with centeredge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.allowrootbelow!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.allowrootbelow!","text":"allowrootbelow!(net::HybridNetwork)\n\nSet containroot to true for each edge below the root node, then traverses net in preorder to update containroot of all edges (stopping at hybrid nodes): see the other methods. Assumes correct ischild1 edge field.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.allowrootbelow!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.allowrootbelow!","text":"allowrootbelow!(e::Edge)\nallowrootbelow!(n::Node, parent_edge_of_n::Edge)\n\nSet containroot to true for edge e and all edges below, recursively. The traversal stops whenever a hybrid node is encountered: if the child of e is a hybrid node (that is, if e is a hybrid edge) or if n is a hybrid node, then the edges below e or n are not traversed.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.assignhybridnames!","text":"assignhybridnames!(net)\n\nAssign names to hybrid nodes in the network net. Hybrid nodes with an empty name field (\"\") are modified with a name that does not conflict with other hybrid names in the network. The preferred name is \"H3\" if the node number is 3 or -3, but an index other than 3 would be used if \"H3\" were the name of another node already.\n\nIf two hybrid nodes have non-empty and equal names, the name of one of them is changed and re-assigned as described above (with a warning).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.biconnectedcomponent_entrynodes","page":"Internals","title":"PhyloNetworks.biconnectedcomponent_entrynodes","text":"biconnectedcomponent_entrynodes(net, bcc, preorder=true)\n\nArray containing the entry node of the each biconnected component in bcc. bcc is supposed to contain the biconnected components as output by biconnectedcomponents, that is, an array of array of edges.\n\nThese entry nodes depend on the rooting (whereas the BCC only depend on the unrooted graph). They are either the root of the network or cut node (articulation points).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.biconnectedcomponent_exitnodes","page":"Internals","title":"PhyloNetworks.biconnectedcomponent_exitnodes","text":"biconnectedcomponent_exitnodes(net, bcc, preorder=true)\n\nArray containing an array of the exit node(s) of the each biconnected component in bcc. bcc is supposed to contain the biconnected components as output by biconnectedcomponents, that is, an array of array of edges.\n\nThese exit nodes depend on the rooting (whereas the BCC only depend on the unrooted graph). The degree of a blob is the number of exit nodes + 1 if the blob doesn't contain the root (its entry node is a cut node), or + 0 if the blob contains the root (which enters into the blob but isn't a cut node).\n\nWarning (or positive side effect?): the edge .inte1 attribute is modified. It stores the index (in bcc) of the biconnected component that an edge belongs to. If an edge doesn't belong in any (e.g. if trivial blobs are ignored), then its .inte1 is set to -1.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.blobinfo","page":"Internals","title":"PhyloNetworks.blobinfo","text":"blobinfo(network, ignoreTrivial=true)\n\nCalculate the biconnected components (blobs) using function biconnectedcomponents then:\n\nset node field booln4 to true at the root of each non-trivial blob (and at the network root), false otherwise. (a better name for the field would be something like \"isBlobRoot\".)\noutput:\narray of nodes that are the roots of each non-trivial blob, and the network root. If the root of the full network is not part of a non-trivial blob, a corresponding blob is added to the list.\narray of arrays: for each non-trivial blob, array of major hybrid edges in that blob.\narray of arrays: same as #2 but for minor hybrid edges, with hybrids listed in the same order, for each blob.\n\nBlobs are ordered in reverse topological ordering (aka post order). If ignoreTrivial is true, trivial components are ignored.\n\nkeyword argument: checkpreorder, true by default. If false, the ischild1 edge field and the net.vec_node network field are supposed to be correct.\n\nwarning: see biconnectedcomponents for node attributes modified during the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.breakedge!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.breakedge!","text":"breakedge!(edge::Edge, net::HybridNetwork)\n\nBreak an edge into 2 edges, each of length half that of original edge, creating a new node of degree 2. Useful to root network along an edge. Return the new node and the new edge, which is the \"top\" half of the original starting edge. These new node & edge are pushed last in net.node and net.edge.\n\nIf the starting edge was:\n\nn1  --edge-->  n2\n\nthen we get this:\n\nn1  --newedge-->  newnode  --edge-->  n2\n\nischild1 and containroot are updated, but not internal fields (e.g. not those used by SNaQ for level-1 networks).\n\nexamples\n\njulia> net = readnewick(\"(((S8,S9),((((S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\");\n\njulia> length(net.node)\n19\n\njulia> net.edge[4] # edge 4 goes from node -8 to 3\nPhyloNetworks.EdgeT{PhyloNetworks.Node}:\n number:4\n length:-1.0\n attached to 2 node(s) (parent first): -8 3\n\n\njulia> newnode, newedge = PhyloNetworks.breakedge!(net.edge[4], net);\n\njulia> length(net.node) # one more than before\n20\n\njulia> newedge # new edge 21 goes from node -8 and 11 (new)\nPhyloNetworks.EdgeT{PhyloNetworks.Node}:\n number:21\n length:-1.0\n attached to 2 node(s) (parent first): -8 11\n\n\njulia> net.edge[4] # original edge 4 now goes from node 11 (new) to 3\nPhyloNetworks.EdgeT{PhyloNetworks.Node}:\n number:4\n length:-1.0\n attached to 2 node(s) (parent first): 11 3\n\n\njulia> writenewick(net) # note extra pair of parentheses around S1\n\"(((S8,S9),((((S4,(S1)),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\"\n\nSee also: fuseedgesat!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.checkNumHybEdges!","text":"checkNumHybEdges!(net)\n\nCheck for consistency between hybrid-related attributes in the network:\n\nfor each hybrid node: 2 or more hybrid edges\nexception: allows for a leaf to be attached to a single hybrid edge\nexactly 2 incoming parent hybrid edges\n\nRun after storeHybrids!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.check_nonmissing_nonnegative_edgelengths","page":"Internals","title":"PhyloNetworks.check_nonmissing_nonnegative_edgelengths","text":"check_nonmissing_nonnegative_edgelengths(net, str=\"\")\n\nThrow an Exception if net has undefined edge lengths (coded as -1.0) or negative edge lengths. The error message indicates the number of the offending edge(s), followed by str.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.check_valid_gammas","page":"Internals","title":"PhyloNetworks.check_valid_gammas","text":"check_valid_gammas(net, str=\"\")\n\nThrow an Exception if net has any inheritance edge γ that is either undefined (coded as -1.0), or negative, or not 1 for tree edges, or that do not approximately sum up to 1 across hybrid partner edges. The error message indicates the number of the offending edge(s), followed by str.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.checkspeciesnetwork!-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}","page":"Internals","title":"PhyloNetworks.checkspeciesnetwork!","text":"checkspeciesnetwork!(network::HybridNetwork,\n                     constraints::Vector{TopologyConstraint})\n\nCheck that the network satisfies a number of requirements:\n\nno polytomies, other than at species constraints: throws an error otherwise\nno unnecessary nodes: fuse edges at nodes with degree two, including at the root (hence the bang: net may be modified)\ntopology constraints are met.\n\nOutput: true if all is good, false if one or more clades are violated.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.cleantaxonname-Tuple{AbstractString}","page":"Internals","title":"PhyloNetworks.cleantaxonname","text":"cleantaxonname(taxonname::AbstractString)\n\nReturn a String with leading and trailing spaces removed, and interior spaces replaced by underscores: good for using as tip names in a network without causing future error when reading the newick description of the network.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.constraintviolated-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}","page":"Internals","title":"PhyloNetworks.constraintviolated","text":"constraintviolated(network::HybridNetwork,\n                   constraints::Vector{TopologyConstraint})\n\nTrue if network violates one (or more) of the constraints of type 1 (individuals in a species group) or type 2 (must be clades in the major tree). Warning: constraints of type 3 are not implemented. See TopologyConstraint for constraint types.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.deleteEdge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.deleteEdge!","text":"deleteEdge!(net::HybridNetwork,  e::Edge; part=true)\n\nDelete edge e from net.edge and update net.numedges. If part is true, update the network's partition field.\n\nWarning: if part is true (the default), then net is assumed to be of level-1, with valid internal fields e.inte1 (to track which cycle e may be in) and valid net.partition, which then gets updated.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.deleteNode!-Tuple{HybridNetwork, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.deleteNode!","text":"deleteNode!(net::HybridNetwork, n::Node)\n\nDelete node n from a network, i.e. removes it from net.node, and from net.hybrid or net.leaf as appropriate. Update attributes numnodes, numtaxa, numhybrids.\n\nWarning: if the root is deleted, the new root is arbitrarily set to the first node in the list. This is intentional to save time because this function is used frequently in snaq!, which handles semi-directed (unrooted) networks.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.deletehybridedge!","page":"Internals","title":"PhyloNetworks.deletehybridedge!","text":"deletehybridedge!(net::HybridNetwork, edge::Edge,\n                  nofuse=false, unroot=false,\n                  multgammas=false, simplify=true, keeporiginalroot=false)\n\nDelete a hybrid edge from net and return the network. The network does not have to be of level 1 and may contain polytomies, although each hybrid node must have exactly 2 parents. Branch lengths are updated, allowing for missing values.\n\nIf nofuse is false, when edge is removed, its child (hybrid) node is removed and its partner hybrid edge is removed. Its child edge is retained (below the hybrid node), fused with the former partner, with new length: old length + length of edge's old partner. Any 2-cycle is simplified into a single edge, unless simplify is false.\n\nIf nofuse is true, edges with descendant leaves are kept as is, and are not fused. Nodes are retained during edge removal, provided that they have at least one descendant leaf. The hybrid edge that is partner to edge becomes a tree edge, but has its γ value unchanged (it is not set to 1), since it is not merged with its child edge after removal of the reticulation.   Also, 2-cycles are not simplified if nofuse is true. That is, if we get 2 hybrid edges both from the same parent to the same child, these hybrid edges are retained without being fused into a single tree edge.\n\nIf unroot is false and if the root is up for deletion during the process, it will be kept if it's of degree 2 or more. A root node of degree 1 will be deleted unless keeporiginalroot is true.\n\nIf multgammas is true: inheritance weights are kept by multiplying together the inheritance γ's of edges that are merged. For example, if there is a hybrid ladder, the partner hybrid edge remains a hybrid edge (with a new partner), and its γ is the product of the two hybrid edges that have been fused. So it won't add up to 1 with its new partner's γ.\n\nIf keeporiginalroot is true, a root of degree one will not be deleted.\n\nWarnings:\n\ncontainroot is updated, but this requires correct ischild1 fields\nif the parent of edge is the root and if nofuse is false, the root is moved to keep the network unrooted with a root of degree two.\ndoes not update attributes needed for snaq! (like inte1, edge.z, edge.y etc.)\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.descendants","page":"Internals","title":"PhyloNetworks.descendants","text":"descendants(edge::Edge, internal::Bool=false)\n\nReturn the node numbers of the descendants of a given edge: all descendant nodes if internal is true (internal nodes and tips), or descendant tips only otherwise (defaults).\n\nedge should belong in a rooted network for which ischild1 is up-to-date. Run directedges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.\n\nExamples\n\njulia> net5 = \"(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));\" |> readnewick |> directedges! ;\n\njulia> PhyloNetworks.descendants(net5.edge[12], true) # descendants of 12th edge: all of them\n7-element Vector{Int64}:\n -6\n -7\n  4\n  6\n  5\n -9\n  7\n\njulia> PhyloNetworks.descendants(net5.edge[12]) # descendant leaves only\n3-element Vector{Int64}:\n 4\n 5\n 7\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.descendenceweight-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.descendenceweight","text":"descendenceweight(net::HybridNetwork; checkpreorder::Bool=true)\n\nMatrix of weights of all paths starting from an edge and ending to a node, in network net. By default, preorder! is called first, to calculate a pre-ordering of nodes. If checkpreorder is false instead, then this pre-ordering is assumed to have been done already.\n\noutput: object M of type MatrixTopologicalOrder, in which nodes are in rows and edges are in columns, with edge numbers used as indices. In other words, M[i,j] is the sum of weights of all paths from edge number j to node net.vec_node[i].\n\nwarning: net's edge numbers are reset to be consecutive numbers from 1 to the total number of edges. If any edge number needs to be modified for this, a warning is sent, via resetedgenumbers!.\n\nSee also descendencematrix, which returns the matrix of path weights from each node to any other node.\n\nexample\n\njulia> net = readnewick(\"((t4:1.5,((t3:1.27,t1:1.27):1.06,#H8:0.0::0.4):1.18):1.16,(t2:1.32)#H8:1.34::0.6);\");\n\njulia> m = PhyloNetworks.descendenceweight(net);\n\njulia> m[:tips]\n4×9 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  1.0  0.0  1.0  0.0  1.0  1.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  1.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.4  0.4  0.4  1.0  0.6\n\njulia> tiplabels(net) # order of tips along rows\n4-element Vector{String}:\n \"t4\"\n \"t3\"\n \"t1\"\n \"t2\"\n\nThis matrix, which contains information about the network topology and inheritance weights γ, can be combined with the vector of branch lengths to obtain the variance-covariance between tips under a Brownian motion model:\n\njulia> d = Dict(e.number => e.length for e in net.edge);\n\njulia> edgelengths = [d[i] for i in 1:length(net.edge)];\n\njulia> using LinearAlgebra\n\njulia> Ω = m[:tips] * Diagonal(edgelengths) * transpose(m[:tips]) # covariance\n4×4 Matrix{Float64}:\n 2.66   1.16   1.16   0.464\n 1.16   4.67   3.4    0.936\n 1.16   3.4    4.67   0.936\n 0.464  0.936  0.936  2.1768\n\njulia> Matrix(vcv(net)) ≈ Ω # same as from `vcv` function\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.directionalconflict-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool}","page":"Internals","title":"PhyloNetworks.directionalconflict","text":"directionalconflict(parent::Node, edge::Edge, hybridpartnernew::Bool)\n\nCheck if creating a hybrid edge down of parent node into the middle of edge would create a directed cycle in net, i.e. not a DAG. The proposed hybrid would go in the direction of edge down its child node if hybridpartnernew is true. Otherwise, both halves of edge would have their direction reversed, for the hybrid to go towards the original parent node of edge. Does not modify the network.\n\nOutput: true if a conflict would arise (non-DAG), false if no conflict.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.displayednetworks!","page":"Internals","title":"PhyloNetworks.displayednetworks!","text":"displayednetworks!(net::HybridNetwork, node::Node, keepNode=false,\n                   unroot=false, multgammas=false, keeporiginalroot=false)\n\nExtracts the two networks that simplify a given network at a given hybrid node: deleting either one or the other parent hybrid edge. If nofuse is true, the original edges (and nodes) are kept in both networks, provided that they have one or more descendant leaves. If unroot is true, the root will be deleted if it becomes of degree 2. If keeporiginalroot is true, the root is retained even if it is of degree 1.\n\nthe original network is modified: the minor edge removed.\nreturns one HybridNetwork object: the network with the major edge removed\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.distancecorrection_JC!-Tuple{AbstractMatrix, Integer}","page":"Internals","title":"PhyloNetworks.distancecorrection_JC!","text":"distancecorrection_JC!(M::AbstractMatrix, nstates::Integer; scalar=1.01)\n\nJukes-Cantor (JC) corrected distance matrix, to estimate pairwise evolutionary distances from scaled Hamming distances (proportion of sites at which the pair differs). M should contain non-negative values, such as Hamming distances from hammingdistancematrix. The JC correction is defined as: - 0.75 log(1 - M/0.75) if there are 4 states, and more generally - dmax log(1 - M/dmax) where dmax = (n-1/n) on n states.\n\nTheoretically, scaled Hamming distances from the Jukes-Cantor model are < 0.75 on four states, or < (n-1)/n on n states.\n\nIf M has some values ≥ 0.75 (or dmax more generally), then M does not fit the Jukes-Cantor model, and log(1 - M/0.75) would give negative values. To avoid negative corrected distances, and numerical issues if some M values are close to 0.75, the JC correction here applies a following stronger normalization. M is modified in place to contain:\n\nd_JC = - 0.75 log(1 - M/max{0.75, m*1.01})\n\nfor 4 states (replace 0.75 by (n-1)/n for n states), where m is the maximum observed distance in M.\n\nThe scalar=1.01 value above is a keyword argument, to adjust the strength of normalization.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.edge_murepresentation","page":"Internals","title":"PhyloNetworks.edge_murepresentation","text":"edge_murepresentation(net::HybridNetwork,\n    labels::AbstractVector{<:AbstractString}=sort!(tiplabels(net));\n    preorder::Bool=true,\n    suppressroot::Bool=true)\n\nEdgeMuRepresentation object for network net, considered as a semidirected network. This representation maps each internal edge in net to its μ-entry (1 or 2 tagged μ-vectors). A μ-vector contains the number of paths from the edge to each leaf, with leaves ordered as in labels. It also contains the number of paths from the edge to a (any) hybrid node.\n\nExternal edges are edges whose child is a leaf. They are excluded here because they have trivial μ-vectors under the common assumption that leaves are incident to a single edge (that is, leaves must not be hybrid nodes).\n\npreorder: whether to preprocess the network (direct edges away from the root and calculate a pre-ordering of nodes).\nsuppressroot: whether to exclude one internal tree edge incident to the root, in case the root is incident to exactly 2 edges which are not both hybrid edges. In that case, re-rooting the network would suppress that internal tree edge, hence its associated μ-entry. This option does not modify the network.\n\nnet is assumed to have a single root component.\n\nSee node_murepresentation for assumptions about labels and tip labels in net.\n\nUsed by mudistance_semidirected.\n\nexample\n\njulia> net = readnewick(\"(((C,(A)#H1),(#H1,E)),O);\");\n\njulia> # using PhyloPlots; plot(net, showedgenumber=true);\n\njulia> PhyloNetworks.edge_murepresentation(net)\nPhyloNetworks.EdgeMuRepresentation\n4 taxa in μ-vectors: [\"A\", \"C\", \"E\", \"O\"]\nroot μ-vector: μ0=2 μ=[2, 1, 1, 1]\nmaps edge number => μ-entry:\n2 tree edges in the root component\n  4 => μ0=1 μ=[1, 1, 0, 0]; μ0=1 μ=[1, 0, 1, 1]\n  7 => μ0=1 μ=[1, 0, 1, 0]; μ0=1 μ=[1, 1, 0, 1]\n2 edges in the directed part:\n  5 => incident; μ0=1 μ=[1, 0, 0, 0]\n  3 => incident; μ0=1 μ=[1, 0, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.edgerelation-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.edgerelation","text":"edgerelation(e::Edge, node::Node, origin::Edge)\n\nReturn a symbol:\n\n:origin if e is equal to origin, and otherwise:\n:parent if e is a parent of node,\n:child if e is a child of node\n\nusing the ischild1 attribute of edges. Useful when e iterates over all edges adjacent to node and when origin is one of the edges adjacent to node, to known the order in which these edges come.\n\nexample:\n\nlabs = [edgerelation(e, u, uv) for e in u.edge] # assuming u is a node of edge uv\nparentindex = findfirst(isequal(:parent), labs) # could be 'nothing' if no parent\nchildindices = findall( isequal(:child), labs)  # vector. could be empty\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.entrynode_preindex-Tuple{PhyloNetworks.Partition}","page":"Internals","title":"PhyloNetworks.entrynode_preindex","text":"entrynodepreindex(biconnectedcomponent::Partition)\n\nPreorder index of the entry node of a biconnected component, considering the network rooted. It is an articulation node, except if it is the network's root.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.expectedf3matrix-Tuple{HybridNetwork, AbstractString}","page":"Internals","title":"PhyloNetworks.expectedf3matrix","text":"expectedf3matrix(net::HybridNetwork, reftaxon; preorder::Bool=true)\n\nMatrix of f3 statistics using reference taxon reftaxon, expected from net assuming that its branch lengths represent \"f2 distance\". f3-statistics are linear combination of f2-statistics, using o to denote the reference taxon (for \"outgtroup\"):\n\nf3[o|t1,t2] = (f2[o,t1] + f2[o,t2] - f2[o,o] - f2[t1,t2])/2\n\nSee expectedf3matrix and expectedf4table.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.fliphybrid!","page":"Internals","title":"PhyloNetworks.fliphybrid!","text":"fliphybrid!(\n    net::HybridNetwork,\n    hybridnode::Node,\n    minor::Bool=true,\n    nohybridladder::Bool=false,\n    constraints::Vector{TopologyConstraint}=TopologyConstraint[]\n)\n\nFlip the direction of a single hybrid edge: the minor parent edge of hybridnode by default, or the major parent edge if minor is false. The parent node of the hybrid edge becomes the new hybrid node. The former hybrid edge partner is converted to a tree edge (with γ=1), and hybridnode becomes a tree node.\n\nFor the flip to be admissible, the new network must be a semi-directed phylogenetic network: with a root such that the rooted version is a DAG. If nohybridladder is false (default), the flip may create a hybrid ladder If nohybridladder is true and if the flip would create a hybrid ladder, then the flip is not admissible. A hybrid ladder is when a hybrid child of another hybrid.\n\nThe new hybrid partner is an edge adjacent to the new hybrid node, such that the flip is admissible (so it must be a tree edge). The flipped edge retains its original γ. The new hybrid edge is assigned inheritance 1-γ.\n\nOutput: (newhybridnode, flippededge, oldchildedge) if the flip is admissible, nothing otherwise.\n\nThe network is unchanged if the flip is not admissible. If the flip is admissible, the root position may be modified, and the direction of tree edges (via ischild1) is modified accordingly. If the root needs to be modified, then the new root is set to the old hybrid node.\n\nThe index of the new hybrid node in net.hybrid is equal to that of the old hybridnode.\n\nWarning: Undoing this move may not recover the original root if the root position was modified.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.fliphybrid!-Tuple{HybridNetwork, Bool, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.fliphybrid!","text":"fliphybrid!(\n    [rng::AbstractRNG,]\n    net::HybridNetwork,\n    minor::Bool,\n    nohybridladder::Bool=false,\n    constraints::Vector{TopologyConstraint}=TopologyConstraint[]\n)\n\nCycle through hybrid nodes in random order until an admissible flip is found. At this hybrid node, flip the indicated hybrid parent edge (minor or major).\n\nIf an admissible flip is found, return the tuple: newhybridnode, flippededge, oldchildedge. Otherwise, return nothing.\n\nThe flip can be undone with fliphybrid!(net, newhybridnode, minor, constraints), or fliphybrid!(net, newhybridnode, !flippededge.ismajor, constraints) more generally, such as if the flipped edge had its γ modified after the original flip.\n\nWarnings\n\nif the root needed to be reset and if the original root was of degree 2, then a node of degree 2 remains in the modified network.\nundoing the flip may not recover the original root in case the root position was modified during the original flip.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.fuseedgesat!","page":"Internals","title":"PhyloNetworks.fuseedgesat!","text":"fuseedgesat!(i::Integer,net::HybridNetwork, multgammas::Bool=false)\n\nRemoves ith node in net.node, if it is of degree 2. The parent and child edges of this node are fused. If either of the edges is hybrid, the hybrid edge is retained. Otherwise, the edge with the lower edge number is retained.\n\nReverts the action of breakedge!.\n\nreturns the fused edge.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.getTipSubmatrix-Tuple{Matrix, HybridNetwork}","page":"Internals","title":"PhyloNetworks.getTipSubmatrix","text":"getTipSubmatrix(M, net; indexation=:both)\n\nExtract submatrix of M, with rows and/or columns corresponding to tips in the network, ordered like in net.leaf. In M, rows and/or columns are assumed ordered as in net.vec_node.\n\nindexation: one of :rows, :cols or :both: are nodes numbers indexed in the matrix by rows, by columns, or both? Subsetting is taken accordingly.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getconnectingedge-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.getconnectingedge","text":"getconnectingedge(node1::Node, node2::Node)\n\nEdge shared by (or connecting) node1 and node2, that is: edge incident to both nodes. An error is thrown if the 2 nodes are not connected.\n\nSee also isconnected\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getlengths-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}","page":"Internals","title":"PhyloNetworks.getlengths","text":"getlengths(edges::Vector{Edge})\n\nVector of edge lengths for a vector of edges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hammingdistancematrix-Union{Tuple{AbstractArray{Vector{T}, 1}}, Tuple{T}, Tuple{AbstractArray{Vector{T}, 1}, AbstractVector{<:Real}}} where T","page":"Internals","title":"PhyloNetworks.hammingdistancematrix","text":"hammingdistancematrix(\n    trait::AbstractVector{Vector{Union{Missings.Missing,Int}}},\n    traitweight::AbstractVector{<:Real}=ones(length(trait[1]));\n    scaled::Bool=true\n)\n\nMatrix of pairwise Hamming distances between taxa: proportion (or number) of traits at which 2 taxa differ, possibly weighted.\n\nArguments:\n\ntrait: vector of vectors of integers. trait[i] has the data for taxon number i. All vectors trait[i] should be of the same length: same number of traits across taxa. trait[i][j] = k means that taxon i has state index k for trait j.\ntraitweight[k] gives the weight of trait k (default: all 1s)\nscaled: if false, the output distance is the number (or total weight) of traits at which 2 taxa differ. If scaled is true, the output distance is a proportion: the un-scaled distance divided by the number of traits (or sum of trait weights).\n\nMissing data: For each pair, the Hamming distances is calculated ignoring any trait in which one of 2 values is missing. The total number of differences is then divided by the total weight of all sites, ignoring that some of them may have been missing for the pair. This is an inexact rescaling of the Hamming distance, assuming a small proportion of missing values for each pair.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hardwiredclusterdistance_unrooted-Tuple{HybridNetwork, HybridNetwork}","page":"Internals","title":"PhyloNetworks.hardwiredclusterdistance_unrooted","text":"hardwiredclusterdistance_unrooted(net1::HybridNetwork, net2::HybridNetwork)\n\nMiminum hardwired cluster dissimilarity between the two networks, considered as unrooted (or semi-directed). This dissimilarity is defined as the minimum rooted distance, over all root positions that are compatible with the direction of hybrid edges. Called by hardwiredclusterdistance.\n\nTo avoid repeating identical clusters, all degree-2 nodes are deleted before starting the comparison. Since rooting the network at a leaf creates a root node of degree 2 and an extra cluster, leaves are excluded from possible rooting positions.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hybrid3cycle-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.hybrid3cycle","text":"hybrid3cycle(edge1::Edge, edge2::Edge)\n\nCheck if proposed hybrid edge from edge1 into edge2 would create a 3 cycle, that is, if edge1 and edge2 have a node in common. (This move cannot create a 2-cycles because new nodes would be created in the middle of edges 1 and 2.)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.hybridEdges","text":"hybridEdges(node::Node, e::Edge)\n\nReturn the 2 edges connected to node other than e, in the same order as node.edge, except that e absent from the list.\n\nDespite what the name suggest, node need not be a hybrid node! node is assumed to have 3 edges, though.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.hybridEdges","text":"hybridEdges(node::Node)\n\nReturn the 3 edges attached to node in a specific order [e1,e2,e3]. Warning: assume a level-1 network with up-to-date node fields booln1 (tracking whether the node is incident to a hybrid edge and edge) and field intn1 (tracking the number given to the cycle in which the node might be).\n\nIf node is a hybrid node:\n\ne1 is the major hybrid parent edge of node\ne2 is the minor hybrid parent edge\ne3 is the tree edge, child of node.\n\nIf node is a tree node parent of one child hybrid edge:\n\ne1 is the hybrid edge, child of node\ne2 is the tree edge that belongs to the cycle created by e1\ne3 is the other tree edge attached to node (not in a cycle)\n\nOtherwise:\n\ne3 is an external edge from node to a leaf, if one exists.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.indexin_check0μentries-Tuple{PhyloNetworks.MuRepresentation, PhyloNetworks.MuRepresentation}","page":"Internals","title":"PhyloNetworks.indexin_check0μentries","text":"indexin_check0μentries(m1::MuRepresentation, m2::MuRepresentation)\n\nCheck that for any label in m1 that is missing in m2, the corresponding number of paths in m1's entries are all 0 – and vice versa, then return\n\nnothing if the check failed,\notherwise if the check passed: two vectors of indices (o1,o2) such that tiplabels(m1)[o1] == tiplabels(m2)[o2] is the intersection of the label sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.inheritanceweight-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.inheritanceweight","text":"inheritanceweight(tree::HybridNetwork)\n\nReturn the log inheritance weight of a network or tree (as provided by displayedtrees with nofuse = true for instance). For a tree displayed in a network, its inheritance weight is the log of the product of γ's of all edges retained in the tree. To avoid underflow, the log is calculated: i.e. sum of log(γ) across retained edges.\n\nIf any edge has a negative γ, it is assumed to mean that its γ is missing, and the function returns missing.\n\nExample\n\njulia> net = readnewick(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\");\n\njulia> trees = displayedtrees(net,0.0; nofuse=true);\n\njulia> PhyloNetworks.inheritanceweight.(trees)\n2-element Vector{Float64}:\n -0.105361\n -2.30259 \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.initializeweightsfromleaves!-Tuple{AbstractArray, HybridNetwork, Any, Any, Symbol}","page":"Internals","title":"PhyloNetworks.initializeweightsfromleaves!","text":"initializeweightsfromleaves!(w, net, tips, stateset, criterion)\n\nModify weight in w: to Inf for w[n, i] if the \"tips\" data has a state different from the lineage state of index i at node number n. Assumes that w was initialized to 0 for the leaves.\n\ncriterion: should be one of :softwired, :parental or :hardwired.\n\nsoftwired parsimony: lineage states are in this order: ∅,{1},{2},{3},...,{nstates}\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.initializeweightsfromleaves_softwired!-Tuple{AbstractArray, HybridNetwork, Any, Any}","page":"Internals","title":"PhyloNetworks.initializeweightsfromleaves_softwired!","text":"initializeweightsfromleaves_softwired!(w, net, tips, charset)\n\nModify weight in w: to Inf for w[n, s] if the \"tips\" data has a state different from s at node number n. Assumes that w was initialized to 0 for the leaves.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.isconnected-Tuple{Any, Any}","page":"Internals","title":"PhyloNetworks.isconnected","text":"isconnected(node1::Node, node2::Node)\n\nCheck if two nodes are connected by an edge. Return true if connected, false if not connected.\n\nSee also getconnectingedge\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.isdescendant-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.isdescendant","text":"isdescendant(des:Node, anc::Node)\n\nReturn true if des is a strict descendant of anc, using ischild1 fields to determine the direction of edges. See isdescendant_undirected for a version that does not use ischild1.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.isdescendant_undirected-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.isdescendant_undirected","text":"isdescendant_undirected(des:Node, ancestor::Node, parentedge)\n\nReturn true if des is a strict descendant of ancestor when starting from edge parentedge and going towards ancestor onward, regardless of the field ischild1 of tree edges; false otherwise.\n\nThis is useful to know how descendant relationships would change as a result of reverting the direction of a tree edge, without actually modifying the direction (ischild1) of any edge.\n\nparentedge should be connected to ancestor (not checked). The direction of hybrid edges is respected (via ischild1), that is, the traversal does not go from the child to the parent of a hybrid edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.ladderpartition-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.ladderpartition","text":"ladderpartition(tree::HybridNetwork)\n\nFor each node in tree, calculate the clade below each child edge of the node, and each clade moving up the \"ladder\" from the node to the root. The output is a tuple of 2 vectors (node) of vector (clade) of vectors (taxon in clade): below,above. More specifically, for node number n, below[n] is generally of vector of 2 clades: one for the left child and one for the right child of the node (unless the node is of degree 2 or is a polytomy). above[n] contains the grade of clades above node number n.\n\nWarning: assumes that\n\nthe network is a tree (this is checked)\nnode numbers and edge numbers can be used as indices, that is, be all distinct, positive, covering exactly 1:#nodes and 1:#edges (this is checked for nodes).\nedges are corrected directed (ischild1 is up-to-date) and nodes have been pre-ordered already (field vec_node up-to-date).\n\nexamples\n\njulia> tree = readnewick(\"(O,A,((B1,B2),(E,(C,D))));\");\n\njulia> PhyloNetworks.resetnodenumbers!(tree; checkpreorder=true, type=:postorder)\n\njulia> printnodes(tree)\nnode leaf  hybrid name i_cycle edges'numbers\n1    true  false  O    -1      1   \n2    true  false  A    -1      2   \n3    true  false  B1   -1      3   \n4    true  false  B2   -1      4   \n8    false false       -1      3    4    5   \n5    true  false  E    -1      6   \n6    true  false  C    -1      7   \n7    true  false  D    -1      8   \n9    false false       -1      7    8    9   \n10   false false       -1      6    9    10  \n11   false false       -1      5    10   11  \n12   false false       -1      1    2    11  \n\njulia> below, above = PhyloNetworks.ladderpartition(tree);\n\njulia> below\n12-element Vector{Vector{Vector{Int64}}}:\n [[1]]                      \n [[2]]                      \n [[3]]                      \n [[4]]                      \n [[5]]                      \n [[6]]                      \n [[7]]                      \n [[3], [4]]                 \n [[6], [7]]                 \n [[5], [6, 7]]              \n [[3, 4], [5, 6, 7]]        \n [[1], [2], [3, 4, 5, 6, 7]]\n\njulia> for n in 8:12\n         println(\"clades below node \", n, \": \", join(below[n], \" \"))\n       end\nclades below node 8: [3] [4]\nclades below node 9: [6] [7]\nclades below node 10: [5] [6, 7]\nclades below node 11: [3, 4] [5, 6, 7]\nclades below node 12: [1] [2] [3, 4, 5, 6, 7]\n\njulia> above[8:12] # clades sister to and above nodes 8 through 12:\n5-element Vector{Vector{Vector{Int64}}}:\n [[5, 6, 7], [1], [2]]\n [[5], [3, 4], [1], [2]]\n [[3, 4], [1], [2]]     \n [[1], [2]]             \n []                     \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.leaststableancestor","page":"Internals","title":"PhyloNetworks.leaststableancestor","text":"leaststableancestor(net, preorder=true, preprocess=true)\n\nTuple (lsa, lsa_index) where lsa is the least stable ancestor (LSA) node in net, and lsa_index is the index of lsa in net.vec_node. The LSA the lowest node n with the following property: any path between any leaf and the root must go through n. All such nodes with this property are ancestral to the LSA (and therefore must have an index that is lower or equal to lsa_index).\n\nException: if the network has a single leaf, the output lsa is the leaf's parent node, to maintain one external edge between the root and the leaf.\n\nArguments:\n\npreorder to direct edges according to the root and store a pre-ordering of nodes in net.vec_node, if not done earlier on the network (e.g. after a topology modification)\npreprocess to recalculate & store the biconnected components with process_biconnectedcomponents!, assuming the preordering was done\n\nWarning: uses biconnectedcomponents and biconnectedcomponent_exitnodes, therefore share the same caveats regarding the use of field .intn1 and .intn2 for nodes; boole2 and .inte1 for edges. As a positivie side effect, the biconnected components can be recovered via the edges' .inte1 field –including the trivial blobs (cut edges).\n\nSee also: deleteaboveLSA!\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.majoredgelength-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.majoredgelength","text":"majoredgelength(net::HybridNetwork)\n\nGenerate vector of edge lengths of major net edges organized in the same order as the edge matrix created via majoredgematrix. Considers values of -1.0 as missing values, recognized as NA in R. Output: vector allowing for missing values.\n\nAssume vec_node was updated, to list nodes in pre-order.\n\nExamples\n\njulia> net = readnewick(\"(((A:3.1,(B:0.2)#H1:0.3::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);\");\n\njulia> directedges!(net); preorder!(net);\n\njulia> PhyloNetworks.majoredgelength(net)\n8-element Vector{Union{Missing, Float64}}:\n  missing\n 0.7     \n  missing\n 1.1     \n  missing\n 3.1     \n 0.3     \n 0.2     \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.majoredgematrix","text":"majoredgematrix(net::HybridNetwork)\n\nMatrix of major edges from net where edge[i,1] is the number of the parent node of edge i and edge[i,2] is the number of the child node of edge i. Assume vec_node was updated, to list nodes in pre-order.\n\nExamples\n\njulia> net = readnewick(\"(A,(B,(C,D)));\");\n\njulia> PhyloNetworks.resetnodenumbers!(net);\n\njulia> PhyloNetworks.majoredgematrix(net)\n6×2 Matrix{Int64}:\n 5  1\n 5  6\n 6  2\n 6  7\n 7  3\n 7  4\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.makemissing!-Tuple{AbstractVector}","page":"Internals","title":"PhyloNetworks.makemissing!","text":"makemissing!(x::AbstractVector)\n\nTurn to missing any element of x exactly equal to -1.0. Used for branch lengths and γs. x needs to accept missing values. If not, this can be done with allowmissing(x).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.mapindividuals-Tuple{HybridNetwork, String}","page":"Internals","title":"PhyloNetworks.mapindividuals","text":"mapindividuals(net::HybridNetwork, mappingFile::String)\n\nReturn a network expanded from net, where species listed in the mapping file are replaced by individuals mapped to that species. If a species has only 1 individual, the name of the leaf for that species is replaced by the name of its one individual representative. If a species has 2 or more individuals, the leaf for that species is expanded into a \"star\" (polytomy if 3 or more individuals) with a tip for each individual. If a species is in the network but not listed in the mapping file, the tip for that species is left as is. Species listed in the mapping file but not present in the network are ignored.\n\nThe mapping file should be readable by CSV.File and contain two columns: one for the species names and one for the individual (or allele) names. fixit: make this function more flexible by accepting column names\n\nOutput: individual-level network and vector of species constraint(s).\n\nexamples\n\njulia> species_net = readnewick(\"(((S8,S9),((((S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\");\n\njulia> filename = joinpath(dirname(Base.find_package(\"PhyloNetworks\")), \"..\", \"examples\", \"mappingIndividuals.csv\");\n\njulia> filename |> read |> String |> print # to see what the mapping file contains\nspecies,individual\nS1,S1A\nS1,S1B\nS1,S1C\n\njulia> individual_net, species_constraints = PhyloNetworks.mapindividuals(species_net, filename);\n\njulia> writenewick(individual_net, internallabel=true)\n\"(((S8,S9),(((((S1A,S1B,S1C)S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\"\n\njulia> species_constraints\n1-element Vector{PhyloNetworks.TopologyConstraint}:\n Species constraint, on tips: S1A, S1B, S1C\n stem edge number 4\n crown node number 3\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.maxParsimonyNet-Tuple{HybridNetwork, DataFrames.DataFrame}","page":"Internals","title":"PhyloNetworks.maxParsimonyNet","text":"maxParsimonyNet(T::HybridNetwork, df::DataFrame)\n\nwarning: feature to be re-implemented\nThis function has been disabled. It will be re-implemented, without the level-1 restriction. Please use version 0.16 of PhyloNetworks to access this older functionality, until a better one is made available.\n\nSearch for the most parsimonious network (or tree). A level-1 network is assumed. df should be a data frame containing the species names in column 1, or in a column named species or taxon. Trait data are assumed to be in all other columns. The search starts from topology T, which can be a tree or a network with no more than hmax hybrid nodes (see optional arguments below for hmax).\n\nOutput:\n\nestimated network in file .out (also in .log): best network overall and list of networks from each individual run.\nif any error occurred, file .err provides information (seed) to reproduce the error.\n\nOptional arguments include\n\nhmax: maximum number of hybridizations allowed (default 1)\nruns: number of starting points for the search (default 10); each starting point is T with probability probST=0.3 or a modification of T otherwise (using a NNI move, or a hybrid edge direction change)\nNfail: number of failures (proposed networks with equal or worse score) before the search is aborted. 75 by default: this is quite small, which is okay for a first trial. Larger values are recommended.\noutgroup: outgroup taxon.           It can be a taxon name (String) or Node number (Integer).           If none provided, or if the outgroup conflicts the starting           topology, the function returns an error\nfilename: root name for the output files. Default is \"mp\". If empty (\"\"), files are not created, progress log goes to the screen only (standard out).\nseed: seed to replicate a given search\ncriterion: parsimony score could be hardwired, softwired (default) or parental. Currently,            only softwired is implemented\n\nReferences\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.minorreticulationgamma","text":"minorreticulationgamma(net::HybridNetwork)\n\nVector of minor edge gammas (inheritance probabilities) organized in the same order as in the matrix created via minorreticulationmatrix. Considers values of -1.0 as missing values, recognized as NA in R. Output: vector allowing for missing values.\n\nExamples\n\njulia> net = readnewick(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\");\n\njulia> PhyloNetworks.minorreticulationgamma(net)\n1-element Vector{Union{Float64, Missings.Missing}}:\n 0.1\n\n\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.minorreticulationlength","text":"minorreticulationlength(net::HybridNetwork)\n\nVector of lengths for the minor hybrid edges, organized in the same order as in the matrix created via minorreticulationmatrix. Replace values of -1.0 with missing values recognized by R. Output: vector allowing for missing values.\n\nExamples\n\njulia> net = readnewick(\"(((A:3.1,(B:0.2)#H1:0.4::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);\");\n\njulia> PhyloNetworks.minorreticulationlength(net)\n1-element Vector{Union{Missing, Float64}}:\n 0.3\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.minorreticulationmatrix","text":"minorreticulationmatrix(net::HybridNetwork)\n\nMatrix of integers, representing the minor hybrid edges in net. edge[i,1] is the number of the parent node of the ith minor hybrid edge, and edge[i,2] is the number of its child node. Node numbers may be negative, unless they were modified by resetnodenumbers!. Assumes correct ischild1 fields.\n\nExamples\n\njulia> net = readnewick(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\");\njulia> PhyloNetworks.minorreticulationmatrix(net)\n1×2 Matrix{Int64}:\n -6  3\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.moveroot!-Tuple{HybridNetwork, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.moveroot!","text":"moveroot!(\n    [rng::AbstractRNG,]\n    net::HybridNetwork,\n    constraints::Vector{TopologyConstraint}=TopologyConstraint[]\n)\n\nMove the root to a randomly chosen non-leaf node that is different from the current root, and not within a constraint clade or species. Output: true if successul, nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.mudistance-Tuple{PhyloNetworks.EdgeMuRepresentation, PhyloNetworks.EdgeMuRepresentation, Bool}","page":"Internals","title":"PhyloNetworks.mudistance","text":"mudistance(m1::EdgeMuRepresentation, m2::EdgeMuRepresentation,\n           userootμ::Bool)\n\nDistance between two edge-based μ-representations: number of μ-entries, considered with their multiplicities, in one but not in the other. userootμ controls whether the root μ-vector in included in the set of μ-entries being compared. It is ignored by default, because different root μ-vectors for networks with a single root would cause all μ-entries in their root components to be different.\n\nWarning: this method assumes, without checking, that m1 and m2 have the same labels (and in the same order), for efficiency.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.mudistance-Tuple{PhyloNetworks.NodeMuRepresentation, PhyloNetworks.NodeMuRepresentation}","page":"Internals","title":"PhyloNetworks.mudistance","text":"mudistance(m1::NodeMuRepresentation, m2::NodeMuRepresentation)\n\nDistance between two node-based μ-representations: number of μ-vectors, considered with their multiplicity, in one but not in the other.\n\nWarning: this method assumes, without checking, that m1 and m2 have the same labels (and in the same order), for efficiency.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.nchoose1234-Tuple{Int64}","page":"Internals","title":"PhyloNetworks.nchoose1234","text":"nchoose1234(nmax)\n\nnmax+1 x 4 matrix containing the binomial coefficient \"n choose k\" in row n+1 and column k. In other words, M[i,k] gives \"i-1 choose k\". It is useful to store these values and look them up to rank (a large number of) 4-taxon sets: see quartetrank.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.nj!","page":"Internals","title":"PhyloNetworks.nj!","text":"nj!(D::Matrix{Float64}, names::AbstractVector{<:AbstractString}=String[];\n    force_nonnegative_edges::Bool=false)\n\nConstruct a phylogenetic tree from the input distance matrix and vector of names (as strings), using the Neighbour-Joinging algorithm (Satou & Nei 1987). The order of the names argument should match that of the row (and column) of the matrix D. With force_nonnegative_edges being true, any negative edge length is changed to 0.0 (with a message).\n\nWarning: D is modified.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.nnimax-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.nnimax","text":"nnimax(e::Edge)\n\nReturn the number of NNI moves around edge e, assuming that the network is semi-directed. Return 0 if e is not internal, and more generally if either node attached to e does not have 3 edges.\n\nOutput: UInt8 (e.g. 0x02)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.node_murepresentation","page":"Internals","title":"PhyloNetworks.node_murepresentation","text":"node_murepresentation(net::HybridNetwork,\n    labels::AbstractVector{<:AbstractString}=sort!(tiplabels(net));\n    preorder::Bool=true)\n\nNodeMuRepresentation object for network net considered as rooted, including a mapping from each non-leaf node in net to its μ-vector: vector integers representing the number of paths from the node to each leaf, with leaves ordered as in labels.\n\nnet is assumed to have a single root.\n\npreorder: whether to preprocess the network with directedges! and preorder!.\n\nAssumptions about tip labels:\n\ntechnical: labels should be sorted alphabetically\nlabels should have no repeats, otherwise an error is thrown\nnet should have unique tip labels, otherwise an error is thrown\ntip labels in net should all appear in labels, otherwise a warning is sent and μ-vectors will be missing the entry for the tips not listed in labels\nif label[i] is not a tip in net, then all μ-vector will have a count of 0 at index i, with no warning.\n\nUsed by mudistance_rooted, and edge_murepresentation.\n\nexample\n\njulia> net = readnewick(\"(((C,(A)#H1),(#H1,E)),O);\");\n\njulia> # using PhyloPlots; plot(net, shownodenumber=true);\n\njulia> PhyloNetworks.node_murepresentation(net)\nPhyloNetworks.NodeMuRepresentation\n4 taxa in μ-vectors: [\"A\", \"C\", \"E\", \"O\"]\n5 nodes, map node number => μ0 to hybrids and μ-vector to taxa:\n  -3 => μ0=2 μ=[2, 1, 1, 0]\n  -6 => μ0=1 μ=[1, 0, 1, 0]\n  -4 => μ0=1 μ=[1, 1, 0, 0]\n  -2 => μ0=2 μ=[2, 1, 1, 1]\n  3 => μ0=1 μ=[1, 0, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.norootbelow!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.norootbelow!","text":"norootbelow!(e::Edge)\n\nSet containroot to false for edge e and all edges below, recursively. The traversal stops if e.containroot is already false, assuming that containroot is already false all the way below down that edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.number_exitnodes-Tuple{PhyloNetworks.Partition}","page":"Internals","title":"PhyloNetworks.number_exitnodes","text":"number_exitnodes(biconnected_component::Partition)\n\nNumber of articulation exit nodes of a biconnected component, considering the network rooted. An articulation node is such that if removed, the network is disconnected. An articulation exit node is a node in the block that is incident to a different block below.\n\nNote that leaves are not considered articulation exit nodes because they are not articulation nodes. So external (pendent) edges are trivial blobs with 0 (non-internal) exit nodes. If the network is rooted at a leaf, there may be some pathological behaviors depending on the downstream task (e.g. this is checked for by [leaststableancestor])(@ref)).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.pairwisetaxondistance_gradient-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.pairwisetaxondistance_gradient","text":"pairwisetaxondistance_gradient(net; checkEdgeNumber=true, nodeAges=[])\n\n3-dim array: gradient of pairwise distances between all nodes. (internal and leaves); gradient with respect to edge lengths if nodeAges is empty; with respect to node ages otherwise. Assume correct net.vec_node (preorder).   This gradient depends on the network's topology and γ's only, not on branch lengths or node ages (distances are linear in either).\n\nWARNING: edge numbers need to range between 1 and #edges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsenewick_edgedata!-Tuple{IO, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.parsenewick_edgedata!","text":"parsenewick_edgedata!(s::IO, edge, numberOfLeftParentheses::Array{Int,1})\n\nHelper function for readnewick_subtree!. Modifies e according to the specified edge length and gamma values in the tree topology. Advances the stream s past any existing edge data. Edges in a topology may optionally be followed by \":edgeLen:bootstrap:gamma\" where edgeLen, bootstrap, and gamma are decimal values. Nexus-style comments [&...], if any, are ignored.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsenewick_getfloat!-Tuple{IO, Int64, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.parsenewick_getfloat!","text":"parsenewick_getfloat!(s::IO, int, numLeft::Array{Int,1})\n\nHelper function for parsenewick_edgedata!. Read a single floating point edge data value in a tree topology. Ignore (and skip) nexus-style comments before & after the value (see readnexus_comment).\n\nReturn -1.0 if no value exists before the next colon, return the value as a float otherwise. Modifies s by advancing past the next colon character. Only call this function to read a value when you know a numerical value exists!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsenewick_hybridnode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, String, HybridNetwork, Vector{String}}","page":"Internals","title":"PhyloNetworks.parsenewick_hybridnode!","text":"parsenewick_hybridnode!(node, parentNode, hybridName, net, hybrids)\n\nHelper function for readnewick_subtree!. Create the parent edge for node. Return this edge, and the hybrid node retained (node or its clone in the newick string). Insert new edge and appropriate node into net and hybrids accordingly. Handles any type of given hybrid node. Called after a # has been found in a tree topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsenewick_remainingsubtree!-Tuple{IO, Vector{Int64}, HybridNetwork, Vector{String}}","page":"Internals","title":"PhyloNetworks.parsenewick_remainingsubtree!","text":"parsenewick_remainingsubtree!(s::IO, numLeft, net, hybrids)\n\nCreate internal node. Helper for readnewick_subtree!, which creates the parent edge of the node created by parsenewick_remainingsubtree!: readnewick_subtree! calls parsenewick_remainingsubtree!, and vice versa. Called once a ( has been read in a tree topology and reads until the corresponding ) has been found. This function performs the recursive step for readnewick_subtree!. Advances s past the subtree, adds discovered nodes and edges to net, and hybrids.\n\nDoes not read the node name and the edge information of the subtree root: this is done by readnewick_subtree!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsenewick_treenode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, HybridNetwork}","page":"Internals","title":"PhyloNetworks.parsenewick_treenode!","text":"parsenewick_treenode!(node, parentNode, net)\n\nHelper function for readnewick_subtree!. Insert the input tree node and associated edge (created here) into net.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyGF_bottomup!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, Vararg{AbstractArray, 4}}","page":"Internals","title":"PhyloNetworks.parsimonyGF_bottomup!","text":"parsimonyGF_bottomup!(node, blobroot, nchar, w, scores,\n                     costmatrix1, costmatrix2)\n\nCompute the MP scores (one for each assignment of the blob root state) given the descendants of a blob, conditional on the states at predefined parents of hybrids in the blobs (one parent per hybrid) as described in\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\n\nAssumes a set of state guesses, ie correct initialization of w for predefined hybrid parents, and correct boole2 field for the children edges of these predefined parents. boole2 is true for edges that are cut.\n\nThe field booln4 is used to know which nodes are at the root of a blob. The field ischild1 is used (and assumed correct). Field intn1 is assumed to store the # of detached parents (with guessed states)\n\nnchar: number of characters considered at internal lineages. For softwired parsimony, this is # states + 1, because characters at internal nodes are ∅, {1}, {2}, etc. For parental parsimony, this is 2^#states -1, because characters are all sets on {1,2,...} except for the empty set ∅.\ncostmatrix1[i,j] and costmatrix2[k][i,j]: 2d array and vector of 2d arrays containing the cost of going to character j starting from character i when the end node has a single parent, or the cost of a child node having character j when its parents have characters k and i. These cost matrices are pre-computed depending on the parsimony criterion (softwired, hardwired, parental etc.)\n\nused by parsimonyGF.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyfitch-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T","page":"Internals","title":"PhyloNetworks.parsimonyfitch","text":"parsimonyfitch(net, tipdata)\n\nCalculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network. Tip data can be given in a data frame, in which case the taxon names are to appear in column 1 or in a column named \"taxon\" or \"species\", and trait values are to appear in column 2 or in a column named \"trait\". Alternatively, tip data can be given as a dictionary taxon => trait.\n\nalso return the union of all optimized character states at each internal node as obtained by Fitch algorithm, where the union is taken over displayed trees with the MP score.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyfitch_bottomup!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}, Vector{Int64}}} where T","page":"Internals","title":"PhyloNetworks.parsimonyfitch_bottomup!","text":"parsimonyfitch_bottomup!(node, states, score)\n\nBottom-up phase (from tips to root) of the Fitch algorithm: assign sets of character states to internal nodes based on character states at tips. Polytomies okay. Assumes a tree (no reticulation) and correct ischild1 attribute.\n\noutput: dictionary with state sets and most parsimonious score\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyfitch_summary-Union{Tuple{T}, Tuple{HybridNetwork, Dict{Int64, Set{T}}}} where T","page":"Internals","title":"PhyloNetworks.parsimonyfitch_summary","text":"parsimonyfitch_summary(tree, nodestates)\n\nsummarize character states at nodes, assuming a tree\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyfitch_topdown!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}}} where T","page":"Internals","title":"PhyloNetworks.parsimonyfitch_topdown!","text":"parsimonyfitch_topdown!(node, states)\n\nTop-down phase (root to tips) of the Fitch algorithm: constrains character states at internal nodes based on the state of the root. Assumes a tree: no reticulation.\n\noutput: dictionary with state sets\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonysoftwired_bottomup!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, AbstractArray, AbstractArray}","page":"Internals","title":"PhyloNetworks.parsimonysoftwired_bottomup!","text":"parsimonysoftwired_bottomup!(node, blobroot, states, w, scores)\n\nComputing the MP scores (one for each assignment of the root state) of a swicthing as described in Algorithm 1 in the following paper:\n\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\nAssumes a switching (ie correct boole2 field) and correct ischild1 field. The field booln4 is used to know which nodes are at the root of a blob.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.postorder_nodeupdate!","page":"Internals","title":"PhyloNetworks.postorder_nodeupdate!","text":"traversal_postorder(nodes, init_function,\n    tip_function, internalnode_function, parameters...)\npostorder_nodeupdate!(node_index, nodes, output_array,\n    tip_function, internalnode_function, parameters...)\n\nGeneric tool to apply a post-order (or reverse topological ordering) algorithm, acting on a matrix where rows & columns correspond to nodes. Used by descendencematrix.\n\noutput: matrix output_array.\n\narguments:\n\nnodes: array of nodes in the network, pre-ordered, typically the internal net.vec_node after applying preorder!(net). This array is traversed in reverse order.\noutput_array: output object, of type Matrix, named V below\ninit_function: to initialize the output array, taking (nodes, parameters...) as arguments\ntip_function: to do whatever needs to be done to V at a leaf node, using (V, tip_index, parameters...) as arguments\ninternalnode_function: to do whatever needs to be done to V at an internal node, using arguments (V, node_index, childnodes_index_vector, childedges_vector, parameters...)\n\nThe last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.\n\nSee also traversal_preorder, and traversalupdate_default! for a default function that does nothing to V and returns true, with an adequate signature to be used here.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.preorder_nodeupdate!","page":"Internals","title":"PhyloNetworks.preorder_nodeupdate!","text":"traversal_preorder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters...)\ntraversal_preorder!(nodes, output_array, root_function, tree_node_function,\n                   hybrid_node_function, parameters...)\npreorder_nodeupdate!(node_index, nodes, output_array, root_function, tree_node_function,\n               hybrid_node_function, parameters...)\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by sharedpathmatrix and by pairwisetaxondistancematrix, for example. preorder_nodeupdate! is a helper that calls the root / tree node / hybrid node function as appropriate.\n\noutput: array object output_array.\n\narguments:\n\nnodes: array of nodes in the network, pre-ordered, typically the internal net.vec_node after applying preorder!(net)\noutput_array: output object, of type AbstractArray, named V below\ninit_function: to initialize the output array, taking (nodes, parameters...) as arguments\nroot_function: to do whatever needs to be done to V at the root, using (V, rootnode_index, parameters...) as arguments\ntree_node_function: to do whatever needs to be done to V at a tree node, using (V, treenode_index, parentnode_index, parentedge, parameters...) as arguments\nhybrid_node_function: to do whatever needs to be done to V at a hybrid node, using arguments (V, hybnode_index, parentnodes_index_vector, parentedges_vector, parameters...)\n\nThe last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.\n\nSee also traversal_postorder, and traversalupdate_default! for a default function that does nothing to V and returns true, with an adequate signature to be used here.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.problem4cycle-NTuple{4, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.problem4cycle","text":"problem4cycle(β::Node, δ::Node, α::Node, γ::Node)\n\nCheck if the focus edge uv has a 4 cycle that could lead to a 3 cycle after an chosen NNI. Return true if there is a problem 4 cycle, false if none.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.process_biconnectedcomponents!","page":"Internals","title":"PhyloNetworks.process_biconnectedcomponents!","text":"process_biconnectedcomponents!(net, preorder=true)\n\nCalculate biconnected components (aka \"blobs\" in binary networks, \"blocks\" more generally) and save them in net for re-use later. The field net.partition is reset to store the biconnected components, by storing them in preorder (a block comes before any of its descendents). Each one is stored as a Partition object, which stores a list of edges in the biconnected component (which partition edges).\n\nTrivial blocks are formed by one cut-edge and its 2 adjacent nodes. They are stored.\n\nThe edge field .inte1 is used to store the biconnected component that the edge belongs to, that is, an edge belongs in net.partition[edge.inte1]. This is an internal coding that could break in the future, and that could be modified by other functions.\n\nwarning: Warning\nThis preprocessing and net.partition become obsolete and incorrect if the network's topology is later modified, such as after a semidirected NNI, the deletion/addition of a hybrid edge / a leaf. Functions that modify a network are not required to update the blob decomposition (to save time for analyses that don't need the blob decomposition).After a re-rooting with rootatnode!, the blobs remain the same with the same set of edges, but their entry & exit nodes may become incorrect. After rootonedge!, the number of blobs remains correct but one edge was subdivided into 2 edges (and the old root node might have been suppressed), so the edge list in some blobs becomes obsolete.\n\nexamples\n\nThe network below is binary, so each blocks and blobs are the same. It has 2 non-trivial blobs: one with 1 hybrid and the other with 2 hybrids. We first get the blobs, then look at the 2-hybrid blob in more detail.\n\njulia> net = readnewick(\"(((D,#H2),((((E)#H2,C),#H1),((B)#H1,A))),((H,#H3),((F)#H3,G)));\");\n\njulia> # using PhyloPlots; plot(net, showedgenumber=true, shownodenumber=true);\n\njulia> PhyloNetworks.process_biconnectedcomponents!(net);\n\njulia> length(net.partition) # number of biconnected components\n12\n\njulia> findall(!PhyloNetworks.istrivial(blob) for blob in net.partition)\n2-element Vector{Int64}:\n 3\n 7\n\njulia> blob = net.partition[7]; getlevel(blob)\n2\n\njulia> [e.number for e in blob.edges]\n9-element Vector{Int64}:\n 14\n  9\n 13\n 11\n  8\n  7\n  5\n  2\n  3\n\njulia> i = PhyloNetworks.entrynode_preindex(blob); net.vec_node[i] # entry to the blob\nPhyloNetworks.Node:\n number:-3\n attached to 3 edges, numbered: 3 14 15\n\njulia> PhyloNetworks.number_exitnodes(blob) # 5 exit nodes connecting to other blobs below\n5\n\njulia> [net.vec_node[i].number for i in PhyloNetworks.exitnodes_preindex(blob)]\n5-element Vector{Int64}:\n -9\n  5\n -7\n  2\n -4\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.quartetdata_columnnames-Union{Tuple{T}, Tuple{S}, Tuple{Type{T}, Any, Any}} where {S, T<:StaticArraysCore.StaticArray{Tuple{3}, S, 1}}","page":"Internals","title":"PhyloNetworks.quartetdata_columnnames","text":"quartetdata_columnnames(T, prefix, basenames) where T <: StaticArray\n\nVector of column names to hold the quartet data of type T in a table. If T is a length-3 vector type, they are \"prefix1\",\"prefix2\",\"prefix3\" if basenames=[\"1\",\"2\",\"3\"], say, the default used in tablequartetdata to build a table from a vector of QuartetT objects.\n\nFor example, tablequartetCF uses prefix \"CF\" and base names \"1234\",\"1324\",\"1423\", so the first 3 column names are: \"CF1234\",\"CF1324\",\"CF1423\". tablequartetf4 uses different base names.\n\nIf T is a length-4 vector type, the 4th name is \"ngenes\".\n\nIf T is a 3×n matrix type, the output vector contains 3×n names. Each group of 3 is as desribed above, with prefix prefix for the first 3, and prefixes \"V2\", \"V3\", ... \"Vn_\" the following 3(n-1) names.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.quartetrank-Tuple{AbstractVector, Matrix}","page":"Internals","title":"PhyloNetworks.quartetrank","text":"quartetrank(t1,t2,t3,t4, nCk::Matrix)\nquartetrank([t1,t2,t3,t4], nCk)\n\nReturn the rank of a four-taxon set with taxon numbers t1,t2,t3,t4, assuming that tis are positive integers such that t1<t2, t2<t3 and t3<t4 (assumptions not checked!). nCk should be a matrix of \"n choose k\" binomial coefficients: see nchoose1234.\n\nexamples\n\njulia> nCk = PhyloNetworks.nchoose1234(5)\n6×4 Matrix{Int64}:\n 0   0   0  0\n 1   0   0  0\n 2   1   0  0\n 3   3   1  0\n 4   6   4  1\n 5  10  10  5\n\njulia> PhyloNetworks.quartetrank([1,2,3,4], nCk)\n1\n\njulia> PhyloNetworks.quartetrank([3,4,5,6], nCk)\n15\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readcsvtoarray-Tuple{DataFrames.DataFrame}","page":"Internals","title":"PhyloNetworks.readcsvtoarray","text":"readcsvtoarray(dat::DataFrame)\nreadcsvtoarray(filename::String)\n\nRead a CSV table containing both species names and data, create two separate arrays: one for the species names, a second for the data, in a format that parsimonyGF needs.\n\nWarning:\n\nit will try to find a column 'taxon' or 'species' for the taxon names. If none found, it will assume the taxon names are in column 1.\nwill use all other columns as characters\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readfastatoarray","page":"Internals","title":"PhyloNetworks.readfastatoarray","text":"readfastatoarray(filename::AbstractString, sequencetype=BioSequences.LongDNA{4})\n\nRead a fasta-formatted file. Return a tuple species, sequences where species is a vector of Strings with identifier names, and sequences is a vector of BioSequences, each of type sequencetype (DNA by default).\n\nWarnings:\n\nassumes a semi-sequential format, not interleaved. More specifically, each taxon name should appear only once. For this one time, the corresponding sequence may be broken across several lines though.\nfails if all sequences aren't of the same length\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.readnewick_nodename-Tuple{IO, Char, HybridNetwork, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.readnewick_nodename","text":"readnewick_nodename(s::IO, c::Char, net, numLeft)\n\nAuxiliary function to read a taxon name during newick parsing. output: tuple (number, name, pound_boolean)\n\nNames may have numbers: numbers are treated as strings. Accepts # as part of the name (but excludes it from the name), in which case pound_boolean is true. # is used in extended newick to flag hybrid nodes.\n\nNexus-style comments following the node name, if any, are read and ignored.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readnewick_subtree!-Tuple{IO, PhyloNetworks.Node, Vector{Int64}, HybridNetwork, Vector{String}}","page":"Internals","title":"PhyloNetworks.readnewick_subtree!","text":"readnewick_subtree!(s::IO, parentNode, numLeft, net, hybrids)\n\nRecursive helper method for readnewick: read a subtree from an extended Newick topology. input s: IOStream/IOBuffer.\n\nReads additional info formatted as: :length:bootstrap:gamma. Allows for name of internal nodes without # after closing parenthesis: (1,2)A. Warning if hybrid edge without γ, or if γ (ignored) without hybrid edge\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readnexus_assigngammas!-Tuple{HybridNetwork, Dict}","page":"Internals","title":"PhyloNetworks.readnexus_assigngammas!","text":"readnexus_assigngammas!(net, d::Dict)\n\nAssign d[i] as the .gamma value of the minor parent edge of hybrid \"Hi\", if this hybrid node name is found, and if its minor parent doesn't already have a non-missing γ. See readnexus_extractgamma\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readnexus_comment-Tuple{IO, Char}","page":"Internals","title":"PhyloNetworks.readnexus_comment","text":"readnexus_comment(s::IO, c::Char)\n\nRead (and do nothing with) nexus-style comments: [& ... ]   Assumption: 'c' is the next character to be read from s.   Output: nothing.\n\nComments can appear after (or instead of) a node or leaf name, before or after an edge length, and after another comment.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readnexus_extractgamma-Tuple{Any}","page":"Internals","title":"PhyloNetworks.readnexus_extractgamma","text":"readnexus_extractgamma(nexus_string)\n\nExtract γ from comments and return a dictionary hybrid number ID => γ, from one single phylogeny given as a string. The output from BEAST2 uses this format for reticulations at minor edges, as output by bacter (Vaughan et al. 2017):\n\n#11[&conv=0, relSize=0.08, ...\n\nor as output by SpeciesNetwork (Zhang et al. 2018):\n\n#H11[&gamma=0.08]\n\nThe function below assumes that the \"H\" was already added back if not present already (from bacter), like this:\n\n#H11[&conv=0, relSize=0.19, ...\n\nThe bacter format is tried first. If this format doesn't give any match, then the SpeciesNetwork format is tried next.   See readnexus_assigngammas!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readnexus_translatetable-Tuple{Any}","page":"Internals","title":"PhyloNetworks.readnexus_translatetable","text":"readnexus_translatetable(io)\n\nRead translate table from IO object io, whose first non-empty line should contain \"translate\". Then each line should have \"number name\" and the end of the table is indicated by a ;. Output tuple:\n\nline that was last read, and is not part of the translate table, taken from io\ntranslate: boolean, whether a table was successfully read\nid2name: dictionary mapping number to name.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.removeHybrid!","text":"removeHybrid!(net::Network, n::Node)\n\nDelete a hybrid node n from net.hybrid, and update net.numHybrid. The actual node n is not deleted. It is kept in the full list net.node. Very internal function, used by deletehybridedge! and others.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.remove_edgelengthsgammas!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.remove_edgelengthsgammas!","text":"remove_edgelengthsgammas!(net::HybridNetwork)\n\nReset all edge lengths and all hybrid edge γs to be missing (coded as -1.0).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.resetedgenumbers!","page":"Internals","title":"PhyloNetworks.resetedgenumbers!","text":"resetedgenumbers!(net::HybridNetwork, verbose=true)\n\nCheck that edge numbers of net are consecutive numbers from 1 to the total number of edges. If not, reset the edge numbers to be so.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.resetnodenumbers!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.resetnodenumbers!","text":"resetnodenumbers!(net::HybridNetwork; checkpreorder=true, type=:ape)\n\nChange internal node numbers of net to consecutive numbers from 1 to the total number of nodes.\n\nkeyword arguments:\n\ntype: default is :ape, to get numbers that satisfy the conditions assumed by the ape R package: leaves are 1 to n, the root is n+1, and internal nodes are higher consecutive integers. If :postorder, nodes are numbered in post-order, with leaves from 1 to n (and the root last). If :internalonly, leaves are unchanged. Only internal nodes are modified, to take consecutive numbers from (max leaf number)+1 and up. With this last option, the post-ordering of nodes is by-passed.\ncheckpreorder: if false, the ischild1 edge field and the net.vec_node network field are supposed to be correct (to get nodes in preorder). This is not needed when type=:internalonly.\n\nExamples\n\njulia> net = readnewick(\"(A,(B,(C,D)));\");\n\njulia> PhyloNetworks.resetnodenumbers!(net)\n\njulia> printnodes(net) # first column \"node\": root is 5\nnode leaf  hybrid name i_cycle edges'numbers\n1    true  false  A    -1      1   \n2    true  false  B    -1      2   \n3    true  false  C    -1      3   \n4    true  false  D    -1      4   \n7    false false       -1      3    4    5   \n6    false false       -1      2    5    6   \n5    false false       -1      1    6   \n\njulia> net = readnewick(\"(A,(B,(C,D)));\");\n\njulia> PhyloNetworks.resetnodenumbers!(net; type=:postorder)\n\njulia> printnodes(net) # first column \"node\": root is 7\nnode leaf  hybrid name i_cycle edges'numbers\n1    true  false  A    -1      1   \n2    true  false  B    -1      2   \n3    true  false  C    -1      3   \n4    true  false  D    -1      4   \n5    false false       -1      3    4    5   \n6    false false       -1      2    5    6   \n7    false false       -1      1    6   \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.resolvetreepolytomy!","page":"Internals","title":"PhyloNetworks.resolvetreepolytomy!","text":"resolvetreepolytomy!(net::HybridNetwork, n::Node, e1::Edge, e2::Edge)\n\nCreate new node v and new edge n --> v, detach edges e1 and e2 from n to connect them to v instead. Return the new edge, whose child is v.\n\nWarning: assumes that n is incident to both e1 and e2. It is best if these edges are originally children of n because the new edge is directed from n to the newly created node.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.resolvetreepolytomy!-Tuple{HybridNetwork, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.resolvetreepolytomy!","text":"resolvetreepolytomy!(net::HybridNetwork, n::Node)\n\nCreate new nodes and edges from a tree node n, until it has degree 3. It is best if the network's tree edges are correctly directed beforehand.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.rezip_canonical!-Tuple{Vector{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}","page":"Internals","title":"PhyloNetworks.rezip_canonical!","text":"rezip_canonical!(hybridnodes::Vector{Node}, childedges::Vector{Edge},\n                 originallengths::Vector{Float64})\n\nUndo unzip_canonical!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.samplebootstrap_multiloci-Tuple{Vector{Vector{HybridNetwork}}}","page":"Internals","title":"PhyloNetworks.samplebootstrap_multiloci","text":"samplebootstrap_multiloci(vector of tree lists; seed=0, generesampling=false, row=0)\nsamplebootstrap_multiloci!(tree list, vector of tree lists; seed=0, generesampling=false, row=0)\n\nSample bootstrap gene trees, 1 tree per gene. Set the seed with keyword argument seed, which is 0 by default. When seed=0, the actual seed is set using the clock. Assumes a vector of vectors of networks (see readmultinewick_files), each one of length 1 or more (error if one vector is empty, tested in bootsnaq).\n\nsite resampling: always, from sampling one bootstrap tree from each given list. This tree is sampled at random unless row>0 (see below).\ngene resampling: if generesampling=true (default is false), genes (i.e. lists) are sampled with replacement.\nrow=i: samples the ith bootstrap tree for each gene. row is turned back to 0 if gene resampling is true.\n\noutput: one vector of trees. the modifying function (!) modifies the input tree list and returns it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setmultiplegammas!-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}","page":"Internals","title":"PhyloNetworks.setmultiplegammas!","text":"setmultiplegammas!(edges::Vector{Edge}, γs::Vector{Float64})\n\nSet the inheritance of the ith edge to the ith γ value, calling setgamma!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.shrink2cycleat!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool}","page":"Internals","title":"PhyloNetworks.shrink2cycleat!","text":"shrink2cycleat!(net::HybridNetwork, minor::Edge, major::Edge, unroot::Bool)\n\nRemove minor edge then update the branch length of the remaining major edge. Called by shrink2cycles!\n\nAssumption: minor and major do form a 2-cycle. That is, they start and end at the same node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.shrink3cycleat!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.Node, Bool}","page":"Internals","title":"PhyloNetworks.shrink3cycleat!","text":"shrink3cycleat!(net::HybridNetwork, hybrid::Node, edge1::Edge, edge2::Edge,\n                node1::Node, node2::Node, unroot::Bool)\n\nReplace a 3-cycle at a given hybrid node by a single node, if any. Assumption: edge1 (node1) and edge2 (node2) are the parent edges (nodes) of hybrid. Return true if a 3-cycle is found and removed, false otherwise. There is a 3-cycle if nodes 1 & 2 are connected, by an edge called e3 below.\n\nThere are two cases, with differing effects on the γ inheritance values and branch lengths.\n\nHybrid case: the 3-cycle is shrunk to a hybrid node, which occurs if either node 1 or 2 is a hybrid node (that is, e3 is hybrid). If e3 goes from node 1 to node 2, the 3-cycle (left) is shrunk as on the right:\n\n\\eA      /eB           \\eA  /eB\n 1--e3->2       γ1+γ2γ3 \\  / γ2(1-γ3)\n  \\    /               hybrid\n γ1\\  /γ2\n  hybrid\n\nwith new branch lengths: new tA = tA + (γ1.t1 + γ2γ3.(t2+t3))/(γ1+γ2γ3), new tB = tB + t2, provided that γ1, γ2=1-γ1, and γ3 are not missing. If one of them is missing then γ1 and γ2 remain as is, and e3 is deleted naively, such that new tA = tA + t1 and new tB = tB + t2. If γ's are not missing but one of t1,t2,t3 is missing, then the γ's are updated to γ1+γ2γ3 and γ2(1-γ3), but t's are update naively.\n\nTree case: the 3-cycle is shrunk to a tree node, which occurs if node 1 & 2 are both tree nodes (that is, e3 is a tree edge). If eC is the child edge of hybrid, the 3-cycle (left) is shrunk as on the right:\n\n\\eA                  \\eA\n 1--e3--2--eB--       \\\n  \\    /               n--eB--\n γ1\\  /γ2              |\n  hybrid               |eC\n    |\n    |eC\n\nwith new branch lengths: new tA = tA + γ2.t3, new tB = tB + γ1.t3, new tC = tC + γ1.t1 + γ2.t2, provided that γ1, γ2=1-γ1, t1, t2 and t3 are not missing. If one is missing, then e1 is deleted naively such that tB is unchanged, new tC = tC + t2 and new tA = tA + t3.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.shrinkedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.shrinkedge!","text":"shrinkedge!(net::HybridNetwork, edge::Edge)\n\nDelete edge from net, provided that it is a non-external tree edge. Specifically: delete its child node (as determined by ischild1) and connect all edges formerly incident to this child node to the parent node of edge, thus creating a new polytomy, unless the child was of degree 2.\n\nWarning: it's best for ischild1 to be in sync with the root for this. If not, the shrinking may fail (if edge is a tree edge but its \"child\" is a hybrid) or the root may change arbitrarily (if the child of edge is the root).\n\nOutput: true if the remaining node (parent of edge) becomes a hybrid node with more than 1 child after the shrinking; false otherwise (e.g. no polytomy was created, or the new polytomy is below a tree node)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.sort_stringasinteger!-Tuple{Any}","page":"Internals","title":"PhyloNetworks.sort_stringasinteger!","text":"sort_stringasinteger!(taxa)\n\nSort a vector of strings taxa, numerically if elements can be parsed as an integer, alphabetically otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.startingBL!","page":"Internals","title":"PhyloNetworks.startingBL!","text":"startingBL!(net::HybridNetwork,\n            trait::AbstractVector{Vector{Union{Missings.Missing,Int}}},\n            siteweight::AbstractVector{<:Real}=ones(length(trait[1])))\n\nCalibrate branch lengths in net by minimizing the mean squared error between the JC-adjusted pairwise distance between taxa, and network-predicted pairwise distances, using calibratefrompairwisedistances!. The network is not forced to be time-consistent nor ultrametric. To avoid one source of non-identifiability, the network is \"zipped\" by forcing minor hybrid edges to have length 0. Finally, any edge length smaller than 1.0e-10 is reset to 0.0001, to avoid the 0 boundary.\n\nTraits and weights:\n\ntrait[i] is for leaf with node.number = i in net, and trait[i][j] = k means that leaf number i has state index k for trait j. These indices are those used in a substitution model by PhyloTraits: kth value of PhyloTraits.getlabels(model).\nsiteweight[k] gives the weight of site (or site pattern) k (default: all 1s).\n\nSee hammingdistancematrix for how missing data are treated to calculate the Hamming distance.   See distancecorrection_JC! for the Jukes-Cantor correction. For this correction, the number of traits is taken as the maximum trait state index (denoted k above).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.startree_newick","page":"Internals","title":"PhyloNetworks.startree_newick","text":"startree_newick(n, l)\n\nString for the Newick parenthetical description of the star tree with n tips, and all branch lengths equal to l.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.symmetricdistance_sorted-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T","page":"Internals","title":"PhyloNetworks.symmetricdistance_sorted","text":"Symmetric distance between two vectors, assumed sorted in ascending order: number of elements in one vector but not in the order, each element considered as many times as it appears (with multiplicity). The vectors are not mutated.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.symmetricnet_newick","page":"Internals","title":"PhyloNetworks.symmetricnet_newick","text":"symmetricnet_newick(n::Int, h::Int, γ::Real)\n\nCreate a string for a symmetric network with 2^n tips, numbered from 1 to 2^n, with a symmetric major tree, whose branch lengths are all equal. 2^(n-h) hybrids are added from level h to h-1 \"symmetrically\". The network is time-consistent and ultrametric, with a total height of 1.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.symmetricnet_newick-Tuple{Int64, Int64, Int64, Real, Real}","page":"Internals","title":"PhyloNetworks.symmetricnet_newick","text":"symmetricnet_newick(n::Int, i::Int, j::Int, γ::Real, l::Real)\n\nNewick string for a network with a symmetric major tree with 2^n tips, numbered from 1 to 2^n. All the branch lengths of the major tree are set to l. One hybrid branch, going from level i to level j is added, cutting in half each initial edge in the tree. The new edge has length l and inheritance γ.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.symmetrictree_newick","page":"Internals","title":"PhyloNetworks.symmetrictree_newick","text":"symmetrictree_newick(n::Int, ell::Real, i=1)\n\nString for the Newick parenthetical description of a symmetric tree with 2^n tips, numbered from i to i+2^n-1. All branch lengths are set equal to ell. The tree can be created later by reading the string with readnewick.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.synchronizepartnersdata!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.synchronizepartnersdata!","text":"synchronizepartnersdata!(e::Edge, n::Node)\n\nSynchronize γ and ismajor for edges e and its partner, both hybrid edges with the same child n:\n\nif one γ is missing and the other is not: set the missing γ to 1 - the other\nγ's should sum up to 1.0\nupdate ismajor to match the γ information: the major edge is the one with γ > 0.5.\n\nWarnings: does not check that e is a hybrid edge, nor that n is the child of e.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.tablequartetdata-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{<:AbstractString}}} where T<:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}","page":"Internals","title":"PhyloNetworks.tablequartetdata","text":"tablequartetdata(quartetlist::Vector{QuartetT} [, taxonnames];\n                 keepQwithoutgenes=true,\n                 prefix=\"X\", basenames=[\"1\",\"2\",\"3\"], colnames=nothing)\n\nConvert a vector of QuartetT objects to a table with 1 row for each four-taxon set in the list. Each four-taxon set contains quartet data of some type T, which determines the number of columns in the table. This data type T should be a vector of length 3 or 4, or a 3×n matrix. The output is a NamedTuple, to which we can apply common table operations as a Table.jl-compatible source. It can easily be converted to other table formats (e.g. these packages integrate with Tables.jl) such as a DataFrame.\n\nIn the output table, the columns are, in this order:\n\nqind: contains the quartet's number\nt1, t2, t3, t4: contain the quartet's taxonnumbers if no taxonnames are given, or the taxon names otherwise. The name of taxon number i is taken to be taxonnames[i].\n3 or more columns for the quartet's data: see quartetdata_columnnames.\n\nIn short, the first 3 columns of data are named \"X1\", \"X2\", \"X3\" by default. If a prefix and/or basenames is provided, this prefix and/or base names are used for these first 3 column names, for example: \"CF1234\", \"CF1324\", \"CF1423\" if prefix=\"CF\" and `basename=[\"1234\",\"1324\",\"1423\"]`.\n\nIf quartets have 4 data entries, then the 4th column is named ngenes, and a quartet with a value ngenes of 0 is skipped (excluded) from the table, unless keepQwithoutgenes=true (which is the default: 4-taxon sets are kept by default even without any informative genes).\n\nIf quartets have a data matrix with 3 rows and d columns, then the columns 4,5,6 in the table are named V2_1, V2_2, V2_3 and contain the data in the second column of the quartet's data matrix. And so on.\n\nFor the table to have non-default column names, provide the desired 3, 4, or 3×d names as a vector via the optional argument colnames. This argument takes precedence over prefix, that is, a prefix is ignored if the full list of column names is given.\n\nUsed by tablequartetCF and tablequartetf4. See countquartetsintrees for examples.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.timeinconsistency_average-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Ref{Bool}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}} where T<:Real","page":"Internals","title":"PhyloNetworks.timeinconsistency_average","text":"timeinconsistency_average(\n    candidate_nodeheights,\n    missingparent_heights,\n    isconsistent::Ref{Bool},\n    parent_edges,\n    nonmissingparent_j;\n    atol::Real=1e-8, rtol::Real=√eps(Float64))\n\nCalculate the γ-weighted average node height of a given hybrid node h, based on the candidate node heights from its parents with non-missing edge lengths.\n\nIf some of these parent edges have a missing γ, then equal weights are used and a warning is issued.\nIf the hybrid node's average height (calculate from non-missing lengths) turns out to be lower than one of the parent's height with a missing length (such that this parent edge would need to be assigned a negative value) then a warning is issued.\n\nOutcome:\n\nupdate isconsistent to false if the candidate node heights are not all equal or if some missing edge length would have to be assigned a negative value to make the network time-consistent\nreturns (true, nodeheight)\n\nAssumption: candidate_nodeheight is not empty, that is, the node has at least one parent edge with a non-missing length.\n\nSee also _getnodeheights and getnodeheights_average\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.timeinconsistency_check","page":"Internals","title":"PhyloNetworks.timeinconsistency_check","text":"timeinconsistency_error(\n    candidate_nodeheights,\n    missingparent_heights,\n    args...;\n    atol::Real=1e-8, rtol::Real=√eps(Float64))\ntimeinconsistency_check\n\nCheck that all candidate node heights are approximately equal to one another, and that this shared value nodeheight is higher (farther from the root) than the height of parents connected by edge of missing length missingparent_heights to ensure that these edge lengths would be assigned non-negative values.\n\nIf any of these conditions is not met, timeinconsistency_error throws an error. Otherwise, it returns (true, nodeheight) where true means that the network is (or could be) time-consistent at the node being considered. timeinconsistency_check returns (is_timeconsistent, nodeheight) but does not throw an error the is_timeconsistent if false (for either reason).\n\nAssumption: candidate_nodeheight is not empty, that is, the node has at least one parent edge with a non-missing length.\n\nSee also _getnodeheights\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.timeinconsistency_error-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Vararg{Any}}} where T<:Real","page":"Internals","title":"PhyloNetworks.timeinconsistency_error","text":"timeinconsistency_error(\n    candidate_nodeheights,\n    missingparent_heights,\n    args...;\n    atol::Real=1e-8, rtol::Real=√eps(Float64))\ntimeinconsistency_check\n\nCheck that all candidate node heights are approximately equal to one another, and that this shared value nodeheight is higher (farther from the root) than the height of parents connected by edge of missing length missingparent_heights to ensure that these edge lengths would be assigned non-negative values.\n\nIf any of these conditions is not met, timeinconsistency_error throws an error. Otherwise, it returns (true, nodeheight) where true means that the network is (or could be) time-consistent at the node being considered. timeinconsistency_check returns (is_timeconsistent, nodeheight) but does not throw an error the is_timeconsistent if false (for either reason).\n\nAssumption: candidate_nodeheight is not empty, that is, the node has at least one parent edge with a non-missing length.\n\nSee also _getnodeheights\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.timeinconsistency_majortree-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Ref{Bool}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}} where T<:Real","page":"Internals","title":"PhyloNetworks.timeinconsistency_majortree","text":"timeinconsistency_majortree(\n    candidate_nodeheights,\n    missingparent_heights,\n    isconsistent::Ref{Bool},\n    parent_edges,\n    nonmissingparent_j;\n    atol::Real=1e-8, rtol::Real=√eps(Float64))\n\nCalculate node height of a given hybrid node h, based on the its major parent node height, if its major parent edge has a non-missing length. If missing, then the non-missing edge length with the largest γ is used and a warning is issued. If all parent edges have missing γ values then an error is thrown.\n\nOutcome:\n\nupdate isconsistent to false if the candidate node heights are not all equal or if some missing edge length would have to be assigned a negative value to make the network time-consistent\nreturns (true, nodeheight)\n\nAssumption: candidate_nodeheight is not empty, that is, the node has at least one parent edge with a non-missing length.\n\nSee also _getnodeheights and getnodeheights_average\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.traversal_postorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.traversal_postorder","text":"traversal_postorder(nodes, init_function,\n    tip_function, internalnode_function, parameters...)\npostorder_nodeupdate!(node_index, nodes, output_array,\n    tip_function, internalnode_function, parameters...)\n\nGeneric tool to apply a post-order (or reverse topological ordering) algorithm, acting on a matrix where rows & columns correspond to nodes. Used by descendencematrix.\n\noutput: matrix output_array.\n\narguments:\n\nnodes: array of nodes in the network, pre-ordered, typically the internal net.vec_node after applying preorder!(net). This array is traversed in reverse order.\noutput_array: output object, of type Matrix, named V below\ninit_function: to initialize the output array, taking (nodes, parameters...) as arguments\ntip_function: to do whatever needs to be done to V at a leaf node, using (V, tip_index, parameters...) as arguments\ninternalnode_function: to do whatever needs to be done to V at an internal node, using arguments (V, node_index, childnodes_index_vector, childedges_vector, parameters...)\n\nThe last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.\n\nSee also traversal_preorder, and traversalupdate_default! for a default function that does nothing to V and returns true, with an adequate signature to be used here.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.traversal_preorder!","page":"Internals","title":"PhyloNetworks.traversal_preorder!","text":"traversal_preorder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters...)\ntraversal_preorder!(nodes, output_array, root_function, tree_node_function,\n                   hybrid_node_function, parameters...)\npreorder_nodeupdate!(node_index, nodes, output_array, root_function, tree_node_function,\n               hybrid_node_function, parameters...)\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by sharedpathmatrix and by pairwisetaxondistancematrix, for example. preorder_nodeupdate! is a helper that calls the root / tree node / hybrid node function as appropriate.\n\noutput: array object output_array.\n\narguments:\n\nnodes: array of nodes in the network, pre-ordered, typically the internal net.vec_node after applying preorder!(net)\noutput_array: output object, of type AbstractArray, named V below\ninit_function: to initialize the output array, taking (nodes, parameters...) as arguments\nroot_function: to do whatever needs to be done to V at the root, using (V, rootnode_index, parameters...) as arguments\ntree_node_function: to do whatever needs to be done to V at a tree node, using (V, treenode_index, parentnode_index, parentedge, parameters...) as arguments\nhybrid_node_function: to do whatever needs to be done to V at a hybrid node, using arguments (V, hybnode_index, parentnodes_index_vector, parentedges_vector, parameters...)\n\nThe last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.\n\nSee also traversal_postorder, and traversalupdate_default! for a default function that does nothing to V and returns true, with an adequate signature to be used here.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.traversal_preorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Function, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.traversal_preorder","text":"traversal_preorder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters...)\ntraversal_preorder!(nodes, output_array, root_function, tree_node_function,\n                   hybrid_node_function, parameters...)\npreorder_nodeupdate!(node_index, nodes, output_array, root_function, tree_node_function,\n               hybrid_node_function, parameters...)\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by sharedpathmatrix and by pairwisetaxondistancematrix, for example. preorder_nodeupdate! is a helper that calls the root / tree node / hybrid node function as appropriate.\n\noutput: array object output_array.\n\narguments:\n\nnodes: array of nodes in the network, pre-ordered, typically the internal net.vec_node after applying preorder!(net)\noutput_array: output object, of type AbstractArray, named V below\ninit_function: to initialize the output array, taking (nodes, parameters...) as arguments\nroot_function: to do whatever needs to be done to V at the root, using (V, rootnode_index, parameters...) as arguments\ntree_node_function: to do whatever needs to be done to V at a tree node, using (V, treenode_index, parentnode_index, parentedge, parameters...) as arguments\nhybrid_node_function: to do whatever needs to be done to V at a hybrid node, using arguments (V, hybnode_index, parentnodes_index_vector, parentedges_vector, parameters...)\n\nThe last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.\n\nSee also traversal_postorder, and traversalupdate_default! for a default function that does nothing to V and returns true, with an adequate signature to be used here.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.traversalupdate_default!-Tuple{AbstractArray, Int64, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.traversalupdate_default!","text":"traversalupdate_default!(::AbstractArray, ::Int, args...)\n\nReturns true. With its signature, this function can be used as a default update function at any node (root/tree/hybrid) in traversal_preorder or traversal_postorder, if we need a function that does nothing and keeps the traversal going.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.unzip_canonical!","text":"unzip_canonical!(net::HybridNetwork)\n\nUnzip all reticulations: set the length of child edge to 0, and increase the length of both parent edges by the original child edge's length, to obtain the canonical version of the network according to Pardi & Scornavacca (2015).\n\nOutput: vector of hybrid node in postorder, vector of child edges whose length is constrained to be 0, and vector of their original branch lengths to re-zip if needed using rezip_canonical!.\n\nAssumption: net.hybrid is correct, but a preordering of all nodes is not assumed.\n\nNote: This unzipping is not as straightforward as it might seem, because of \"nested\" zippers: when the child of a hybrid node is itself a hybrid node. The unzipping is propagated all the way through.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.unzipat_canonical!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.unzipat_canonical!","text":"unzipat_canonical!(hyb::Node, childedge::Edge)\n\nUnzip the reticulation a node hyb. See unzip_canonical!. Warning: no check that hyb has a single child.\n\nOutput: constrained edge (child of hyb) and its original length.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.updateconstraintfields!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.updateconstraintfields!","text":"updateconstraintfields!(constraints::Vector{TopologyConstraint}, net::HybridNetwork)\n\nUpdate fields stem edge and crown node to match the given net.\n\nAssumes that the constraints are still met in net, and that nodes & edges are numbered identically in net as in the network used to create all constraints.\n\nfixit: remove the assumption that constraints are still met, since an NNI near the crown of a constrained clade might change the crown node and / or the stem edge (u and v exchange).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.updateconstraints!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.updateconstraints!","text":"updateconstraints!(constraints::Vector{TopologyConstraint}, net::HybridNetwork)\n\nUpdate the set taxonnum in each constraint, assuming that the stem edge and the crown node are still correct, and that their descendants are still correct. May be needed if the node and edge numbers were modified by resetnodenumbers! or resetedgenumbers!.\n\nWarning: does not check that the names of leaves with numbers in taxonnum are taxonnames.\n\njulia> net = readnewick(\"(((2a,2b),(((((1a,1b,1c),4),(5)#H1),(#H1,(6,7))))#H2),(#H2,10));\");\n\njulia> c_species1 = PhyloNetworks.TopologyConstraint(0x01, [\"1a\",\"1b\",\"1c\"], net)\nSpecies constraint, on tips: 1a, 1b, 1c\n stem edge number 7\n crown node number -9\n\njulia> c_species1.taxonnums\nSet{Int64} with 3 elements:\n  5\n  4\n  3\n\njulia> c_clade145 = PhyloNetworks.TopologyConstraint(0x02, [\"1a\",\"1b\",\"1c\",\"4\",\"5\"], net)\nClade constraint, on tips: 1a, 1b, 1c, 4, 5\n stem edge number 12\n crown node number -7\n\njulia> PhyloNetworks.resetnodenumbers!(net)\n\njulia> net.node[4].number = 111;\n\njulia> PhyloNetworks.updateconstraints!([c_species1, c_clade145], net)\n\njulia> c_species1\nSpecies constraint, on tips: 1a, 1b, 1c\n stem edge number 7\n crown node number 21\n\njulia> c_species1.taxonnums\nSet{Int64} with 3 elements:\n  5\n  4\n  111\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#index","page":"Internals","title":"index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"man/netmanipulation/#Network-manipulation","page":"Network manipulation","title":"Network manipulation","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"The package contains many utilities to extract information about phylogenetic networks, and to modify networks. Functions that are not exported are more likely to experience breaking changes in future versions, but can be used by prefixing their name with PhyloNetworks. .","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"Below is a list of the most useful functions. They typically assume a bicombining network, that is, a network in which each hybrid node has exactly 2 parents (never more).","category":"page"},{"location":"man/netmanipulation/#Getting-information-on-a-network","page":"Network manipulation","title":"Getting information on a network","text":"","category":"section"},{"location":"man/netmanipulation/#overall-network-information","page":"Network manipulation","title":"overall network information","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"tiplabels for taxon labels\ngetroot gives the root node\npairwisetaxondistancematrix for average distances\nvcv for the variance-covariance matrix between taxa under a Brownian Motion model along the network, and sharedpathmatrix for the variance-covariance between all nodes (not just leaves)\nistimeconsistent: true or false, to know if for all nodes, the various paths from the root to that node have the same length (as expected if length was proportional to time)\ngetnodeages assuming the network is time-consistent and ultrametric\ndisplayedtrees or majortree to get the displayed trees or major tree, respectively\nhardwiredclusters to get all clusters of taxa on a network\ncheckroot! to check that the graph is a valid semidirected network with a root node in a admissible rooting position","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"on the network complexity:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"istreechild\nhashybridladder – a hybrid ladder is also called a \"stack\": one hybrid parent of another\nisgalled in the sense of a galled network\ngetlevel\nbiconnectedcomponents and PhyloNetworks.process_biconnectedcomponents! to calculate (and store) the blobs in a network; also PhyloNetworks.biconnectedcomponent_entrynodes, PhyloNetworks.biconnectedcomponent_exitnodes, and blobdecomposition\ntreeedgecomponents are the components after removing hybrid edges","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"The following functions all compute distances from the root to each node. Their differ in how they handle time inconsistency: when the distance from the root to a node varies across multiple paths from the root to that node.","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"getnodeheights\ngetnodeheights_average\ngetnodeheights_majortree","category":"page"},{"location":"man/netmanipulation/#node-information","page":"Network manipulation","title":"node information","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To learn about nodes and how some might be related or connected, one can use:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"PhyloNetworks.isdescendant and PhyloNetworks.isconnected  can be used to learn about the relationship between two nodes\nhassinglechild\ngetparent or getparents if the node is a hybrid\ngetparentminor\ngetchild or getchildren if the node has more than one child\nisrootof","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To learn about the edges connected to a given node, one can use:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"getchildedge\nPhyloNetworks.getconnectingedge\ngetparentedge\ngetparentedgeminor for a hybrid node","category":"page"},{"location":"man/netmanipulation/#edge-information","page":"Network manipulation","title":"edge information","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To learn about the nodes related connected to a given edge, one can use the following functions: ","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"PhyloNetworks.descendants for the clade (\"hardwired cluster\") below an edge\ngetparent\ngetchild\ngetpartneredge gives the hybrid partner of an edge, if it is the parent edge of a hybrid node.\nisparentof, ischildof can inform whether an edge and node are connected\nhardwiredcluster to get the cluster of taxa below a particular edge","category":"page"},{"location":"man/netmanipulation/#Modifying-a-network","page":"Network manipulation","title":"Modifying a network","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To modify some of the core components of a network:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"rootonedge!, rootatnode!: very useful to root with an outgroup, and rotate! to improve plots\nnni! to perform a semidirected nearest neighbor interchange\nPhyloNetworks.fliphybrid! to flip the direction of a hybrid edge\nPhyloNetworks.unzip_canonical! to \"unzip\" (or zip down) all reticulations, or PhyloNetworks.rezip_canonical! to undo.\nsetlength! and setlengths! to change the length of one or more edges, and setgamma! to change a hybrid edge inheritance γ","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To remove components from a network:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"deleteleaf!\ndeleteaboveLSA!: the \"least stable ancestor\" may be different from the root\ndeletehybridthreshold! to simplify a network by deleting edges with small γ's\nPhyloNetworks.shrinkedge! to contract an edge\nremovedegree2nodes! to suppress degree-2 nodes\nshrink3cycles! and shrink2cycles! to contract \"cycles\" of 2 or 3 edges, which deletes 1 reticulation\nPhyloNetworks.deletehybridedge! to remove one hybrid edge\ntreeofblobs to shrink blobs and get the strict tree-like part of the network","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To add components to a network:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"PhyloNetworks.addleaf!\nPhyloNetworks.addhybridedge!","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To modify some internal attributes, that don't affect the network topology or edge parameters:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"nameinternalnodes!\nPhyloNetworks.resetnodenumbers! and PhyloNetworks.resetedgenumbers!","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To calibrate a network (modify its edge lengths):","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"calibratefrompairwisedistances!. This documentation has little about calibration so far, but see this tutorial","category":"page"},{"location":"man/netmanipulation/#Comparing-networks","page":"Network manipulation","title":"Comparing networks","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"hardwiredclusterdistance: extends the Robinson-Foulds distance. It's a dissimilarity measure on networks: a dissimilarity of 0 does not guarantee that the 2 networks have the same topology in general. But it does if the networks are in some classes (e.g. trees, level-1, tree-child, and others).\nμ-distances mudistance_rooted and mudistance_semidirected: they also extend the Robinson-Foulds distance on trees. They are dissimilarities on general networks, but distances on some classes (including tree-child).","category":"page"},{"location":"man/netmanipulation/#Comparing-taxa","page":"Network manipulation","title":"Comparing taxa","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"average pairwise distances on a network: pairwisetaxondistancematrix,   and from data: `PhyloNetworks.hammingdistancematrix, that can be followed by PhyloNetworks.distancecorrection_JC!\nf2-distances expected from a network: expectedf2matrix which can be used to get expected f3 and expected f4 statistics: PhyloNetworks.expectedf3matrix and expectedf4table.","category":"page"},{"location":"lib/public/#public-documentation","page":"Public","title":"public documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for PhyloNetworks's public (exported) interface.","category":"page"},{"location":"lib/public/#functions-and-types","page":"Public","title":"functions & types","text":"","category":"section"},{"location":"lib/public/#PhyloNetworks.biconnectedcomponents","page":"Public","title":"PhyloNetworks.biconnectedcomponents","text":"biconnectedcomponents(network, ignoreTrivial=false)\n\nCalculate biconnected components (aka \"blobs\") using Tarjan's algorithm.\n\nOutput: array of arrays of edges.\n\nthe length of the array is the number of blobs\neach element is an array of all the edges inside a given blob.\n\nThese blobs are returned in post-order, but within a blob, edges are not necessarily sorted in topological order. If ignoreTrivial is true, trivial components (of a single edge) are not returned. The network is assumed to be connected.\n\nWarnings: for nodes, fields intn2 and intn1 are modified during the algorithm. They are used to store the node's \"index\" (time of visitation), \"lowpoint\", and the node's \"parent\", as defined by the order in which nodes are visited. For edges, field boole2 is modified, to store whether the edge has been already been visited or not.\n\nReferences:\n\np. 153 of Tarjan (1972). Depth first search and linear graph algorithms, SIAM Journal on Computing, 1(2):146-160\non geeksforgeeks, there is an error (as of 2018-01-30): elif v != parent[u] and low[u] > disc[v]: (python version) should be replaced by elif v != parent[u] and disc[u] > disc[v]:\nnice explanation at this url\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.biconnectedcomponents-NTuple{5, Any}","page":"Public","title":"PhyloNetworks.biconnectedcomponents","text":"biconnectedcomponents(node, index, S, blobs, ignoreTrivial)\n\nHelper recursive function starting at a node (not a network). index is an array containing a single integer, thus mutable: order in which nodes are visited.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.blobdecomposition-Tuple{Any}","page":"Public","title":"PhyloNetworks.blobdecomposition","text":"blobdecomposition!(network)\nblobdecomposition(network)\n\nFind blobs using biconnectedcomponents; find their roots using blobinfo; create a forest in the form of a disconnected network (for efficiency), by deconnecting the root of each non-trivial blob from its parent. The root of each blob corresponds to a new leaf (in another tree of the forest): the number of the blob's root is given to the newly created leaf.\n\nThe first (bang) version modifies the network and returns the array of blob roots. The second version copies the network then returns a tuple: the forest and the array of blob roots.\n\nWarnings:\n\nthe forest is represented by a single HybridNetwork object, on which most functions don't work (like writenewick, plotting etc.) because the network is disconnected (to make the forest). Revert back to low-level functions, e.g. printedges and printnodes.\nsee biconnectedcomponents for node attributes modified during the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.calibratefrompairwisedistances!-Tuple{HybridNetwork, Matrix{Float64}, Vector{<:AbstractString}}","page":"Public","title":"PhyloNetworks.calibratefrompairwisedistances!","text":"calibratefrompairwisedistances!(net, distances::Matrix{Float64},\n    taxon_names::Vector{<:AbstractString})\n\nCalibrate the network to match (as best as possible) input pairwise distances between taxa, such as observed from sequence data. taxon_names should provide the list of taxa, in the same order in which they they are considered in the distances matrix. The optimization criterion is the sum of squares between the observed distances, and the distances from the network (weighted average of tree distances, weighted by γ's). The network's edge lengths are modified.\n\nWarning: for many networks, mutiple calibrations can fit the pairwise distance data equally well (lack of identifiability). This function will output one of these equally good calibrations.\n\noptional arguments (default):\n\ncheckpreorder (true)\nforceMinorLength0 (false) to force minor hybrid edges to have a length of 0\nultrametric (true) to force the network to be\ntime-consistent: all paths from the root to a given node must have the same length, so the age of this node is well-defined, and\nultrametric: all tips are at the same distance from the root, so have the same age.\nNLoptMethod (:LD_MMA) for the optimization algorithm. Other options include :LN_COBYLA (derivative-free); see NLopt package.\ntolerance values to control when the optimization is stopped: ftolRel (1e-12), ftolAbs (1e-10) on the criterion, and xtolRel (1e-10), xtolAbs (1e-10) on branch lengths / divergence times.\nverbose (false)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.checkroot!-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.checkroot!","text":"checkroot!(net)\ncheckroot!(net::HybridNetwork, membership::Dict{Node, Int})\n\nSet the root of net to an appropriate node and update the edges containroot field appropriately, using the membership output by treeedgecomponents. A node is appropriate to serve as root if it belongs in the root tree-edge component, that is, the root of the tree-edge component graph.\n\nIf the current root is appropriate, it is left as is. The direction of edges (via ischild1) is also left as is, assuming it was in synch with the existing root.\nOtherwise, the root is set to the first appropriate node in net.node, that is not a leaf. Then edges are directed away from this root.\n\nA RootMismatch error is thrown if net is not a valid semidirected phylogenetic network (i.e. it is not possible to root the network in a way compatible with the given hybrid edges).\n\nOutput: the membership ID of the root component. The full set of nodes in the root component can be obtained as shown below. Warning: only use the output component ID after calling the second version checkroot!(net, membership).\n\njulia> net = readnewick(\"(#H1:::0.1,#H2:::0.2,(((b)#H1)#H2,a));\");\n\njulia> membership = treeedgecomponents(net);\n\njulia> rootcompID = checkroot!(net, membership);\n\njulia> rootcomp = keys(filter(p -> p.second == rootcompID, membership));\n\njulia> sort([n.number for n in rootcomp]) # number of nodes in the root component\n3-element Vector{Int64}:\n -3\n -2\n  4\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.cladewiseorder!-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.cladewiseorder!","text":"cladewiseorder!(net::HybridNetwork)\n\nUpdate the internal attribute net.vec_int1. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges' direction needs to be correct before calling cladewiseorder!, using directedges!\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.countquartetsintrees","page":"Public","title":"PhyloNetworks.countquartetsintrees","text":"countquartetsintrees(trees [, taxonmap]; which=:all, weight_byallele=true)\n\nCalculate the quartet concordance factors (CF) observed in the trees vector. If present, taxonmap should be a dictionary that maps each allele name to it's species name. To save to a file, first convert to a data frame using tablequartetCF. When which=:all, quartet CFs are calculated for all 4-taxon sets. (Other options are not implemented yet.)\n\nThe algorithm runs in O(mn⁴) where m is the number of trees and n is the number of tips in the trees.\n\nCFs are calculated at the species level only, that is, considering 4-taxon sets made of 4 distinct species, even if the gene trees may have multiple alleles from the same species. For 4 distinct species a,b,c,d, all alleles from each species (a etc.) will be considered to calculate the quartet CF.\n\nBy default, each gene has a weight of 1. So if there are n_a alleles from a, n_b alleles from b etc. in a given gene, then each set of 4 alleles has a weight of 1/(n_a n_b b_c n_c) in the calculation of the CF for a,b,c,d. With option weight_byallele=true, then each set of 4 alleles is given a weight of 1 instead. This inflates the total number of sets used to calculate the quartet CFs (to something larger than the number of genes). This may also affect the CF values if the number of alleles varies across genes: genes with more alleles will be given more weight.\n\nexamples\n\njulia> tree1 = readnewick(\"(E,(A,B),(C,D),O);\"); tree2 = readnewick(\"(((A,B),(C,D)),E);\");\n\njulia> q,t = countquartetsintrees([tree1, tree2]);\nReading in trees, looking at 15 quartets in each...\n0+--+100%\n  **\n\njulia> t # taxon order: t[i] = name of taxon number i\n6-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n \"D\"\n \"E\"\n \"O\"\n\njulia> length(q) # 15 four-taxon sets on 6 taxa\n15\n\njulia> q[1] # both trees agree on AB|CD: resolution 1\n4-taxon set number 1; taxon numbers: 1,2,3,4\ndata: [1.0, 0.0, 0.0, 2.0]\n\njulia> q[8] # tree 2 is missing O (taxon 6), tree 1 wants resolution 3: AO|CD\n4-taxon set number 8; taxon numbers: 1,3,4,6\ndata: [0.0, 0.0, 1.0, 1.0]\n\njulia> q[11] # tree 1 has ACEO unresolved, and tree 2 is missing O: no data for this quartet\n4-taxon set number 11; taxon numbers: 1,3,5,6\ndata: [0.0, 0.0, 0.0, 0.0]\n\nIn the next example, each tree has 2 individuals from population A.\n\njulia> tree1 = readnewick(\"(E,(a1,B),(a2,D),O);\"); tree2 = readnewick(\"(((a1,a2),(B,D)),E);\");\n\njulia> q,t = countquartetsintrees([tree1, tree2], Dict(\"a1\"=>\"A\", \"a2\"=>\"A\"); showprogressbar=false);\n\njulia> t\n5-element Vector{String}:\n \"A\"\n \"B\"\n \"D\"\n \"E\"\n \"O\"\n\njulia> q[1] # tree 1 has discordance: a1B|DE and a2D|BE. tree 2 has AE|BD for both alleles of A\n4-taxon set number 1; taxon numbers: 1,2,3,4\ndata: [0.25, 0.25, 0.5, 2.0]\n\njulia> q[3] # tree 2 is missing O (taxon 5), and a2 is unresolved in tree 1. There's only a1B|EO\n4-taxon set number 3; taxon numbers: 1,2,4,5\ndata: [1.0, 0.0, 0.0, 0.5]\n\nNext we show how to convert these objects to a table using tablequartetCF. The output is a NamedTuple. It can be saved later to a DataFrame for example, using option copycols=false to avoid copying the columns (which can be very large if there are many 4-taxon sets). Data frames are easier to visualize, filter etc., but performance can be better on named tuples.\n\njulia> nt = tablequartetCF(q,t); # named tuple\n\njulia> using DataFrames\n\njulia> df = DataFrame(nt, copycols=false); # convert to a data frame, without copying the column data\n\njulia> show(df, allcols=true) # data frames are displayed much more nicely than named tuples\n5×9 DataFrame\n Row │ qind   t1      t2      t3      t4      CF12_34  CF13_24  CF14_23  ngenes  \n     │ Int64  String  String  String  String  Float64  Float64  Float64  Float64 \n─────┼───────────────────────────────────────────────────────────────────────────\n   1 │     1  A       B       D       E          0.25     0.25      0.5      2.0\n   2 │     2  A       B       D       O          0.5      0.5       0.0      1.0\n   3 │     3  A       B       E       O          1.0      0.0       0.0      0.5\n   4 │     4  A       D       E       O          1.0      0.0       0.0      0.5\n   5 │     5  B       D       E       O          0.0      0.0       0.0      0.0\n\njulia> # using CSV; CSV.write(nt, \"filename.csv\");\n\nNote that CSV.write can take a data frame or a named tuple as input, to write the table to a file.\n\nFinally, the example below shows the effect of using weight_byallele=true when caculating quartet concordance factors from gene trees with multiple alleles per population, and of filtering out 4-taxon sets with no informative genes with keepQwithoutgenes=false when converting to a table.\n\njulia> tree2 = readnewick(\"((A,(B,D)),E);\");\n\njulia> q,t = countquartetsintrees([tree1, tree2], Dict(\"a1\"=>\"A\", \"a2\"=>\"A\"); weight_byallele=true);\nReading in trees, looking at 5 quartets in each...\n0+--+100%\n  **\n\njulia> nt = tablequartetCF(q,t; keepQwithoutgenes=false); # qind=5 excluded: 0 genes\n\njulia> show(DataFrame(nt, copycols=false), allcols=true)\n4×9 DataFrame\n Row │ qind   t1      t2      t3      t4      CF12_34   CF13_24   CF14_23   ngenes  \n     │ Int64  String  String  String  String  Float64   Float64   Float64   Float64 \n─────┼──────────────────────────────────────────────────────────────────────────────\n   1 │     1  A       B       D       E       0.333333  0.333333  0.333333      3.0\n   2 │     2  A       B       D       O       0.5       0.5       0.0           2.0\n   3 │     3  A       B       E       O       1.0       0.0       0.0           1.0\n   4 │     4  A       D       E       O       1.0       0.0       0.0           1.0\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.deleteaboveLSA!","page":"Public","title":"PhyloNetworks.deleteaboveLSA!","text":"deleteaboveLSA!(net, preorder=true)\n\nDelete edges and nodes above (ancestral to) the least stable ancestor (LSA) of the leaves in net. See leaststableancestor for the definition of the LSA. Output: modified network net.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.deletehybridthreshold!","page":"Public","title":"PhyloNetworks.deletehybridthreshold!","text":"deletehybridthreshold!(net::HybridNetwork, threshold::Float64,\n                       nofuse=false, unroot=false, multgammas=false,\n                       keeporiginalroot=false)\n\nDeletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.\n\nif threshold<0.5: delete minor hybrid edges with γ < threshold (or with a missing γ, for any threshold > -1.0)\nif threshold=0.5: delete all minor hybrid edges (i.e normally with γ < 0.5, if γ non-missing)\nnofuse: if true, do not fuse edges and keep original nodes.\nunroot: if false, the root will not be deleted if it becomes of degree 2.\nmultgammas: if true, the modified edges have γ values equal to the proportion of genes that the extracted subnetwork represents. For an edge e in the modified network, the inheritance γ for e is the product of γs of all edges in the original network that have been merged into e.\n\n-keeporiginalroot: if true, the root will be retained even if of degree 1.\n\nWarnings:\n\nby default, nofuse is false, partner hybrid edges are fused with their child edge and have their γ changed to 1.0. If nofuse is true: the γ's of partner hybrid edges are unchanged.\nassumes correct ismajor fields, and correct ischild1 fields to update containroot.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.deleteleaf!-Tuple{HybridNetwork, PhyloNetworks.Node}","page":"Public","title":"PhyloNetworks.deleteleaf!","text":"deleteleaf!(HybridNetwork, leafName::AbstractString; ...)\ndeleteleaf!(HybridNetwork, Node; ...)\ndeleteleaf!(HybridNetwork, Integer; index=false, ...)\n\nDelete a node from the network, possibly from its name, number, or index in the network's array of nodes. The first two versions require that the node is a leaf. The third version does not require that the node is a leaf: If it has degree 3 or more, nothing happens. If it has degree 1 or 2, then it is deleted.\n\nkeyword arguments\n\nsimplify: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.\n\nunroot: if true, a root of degree 1 or 2 is deleted. If false, the root is deleted if it is of degree 1 (no root edge is left), but is kept if it is of degree 2. Deleting all leaves in an outgroup clade or grade will leave the ingroup rooted (that is, the new root will be of degree 2).\n\nnofuse: if true, keep nodes (and edges) provided that they have at least one descendant leaf, even if they are of degree 2. This will keep two-cycles (forcing simplify to false). Nodes without any descendant leaves are deleted. If nofuse is false, edges adjacent to degree-2 nodes are fused.\n\nmultgammas: if true, the fused edge has γ equal to the product of the hybrid edges that have been fused together, which may result in tree edges with γ<1, or with reticulations in which the two parent γ don't add up to 1.\n\nkeeporiginalroot: if true, keep the root even if it is of degree one (forcing unroot to be false).\n\nWarning: does not update edges' containroot nor internal attributes (e.g. those used by SNaQ for level-1 networks). Does not require branch lengths, and designed to work on networks of all levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.descendencematrix-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.descendencematrix","text":"descendencematrix(net::HybridNetwork; checkpreorder::Bool=true)\n\nDescendence matrix between all the nodes of a network: object D of type MatrixTopologicalOrder in which D[i,j] is the proportion of genetic material in node i that can be traced back to node j. If D[i,j]>0 then i is a descendent of j (and j is an ancestor of i). The network is assumed to be pre-ordered if checkpreorder is false. If checkpreorder is true (default), preorder! is run on the network beforehand.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.directedges!-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.directedges!","text":"directedges!(net::HybridNetwork; checkMajor::Bool=true)\n\nUpdates the edges' attribute ischild1, according to the root placement. Also updates edges' attribute containroot, for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if checkMajor is true.\n\nWarnings:\n\nAssumes that ischild1 is correct on hybrid edges (to avoid changing the identity of which nodes are hybrids and which are not).\nDoes not check for cycles (to maintain a network's DAG status)\n\nReturns the network. Throws a 'RootMismatch' Exception if the root was found to conflict with the direction of any hybrid edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.displayednetworkat!","page":"Public","title":"PhyloNetworks.displayednetworkat!","text":"displayednetworkat!(net::HybridNetwork, node::Node, nofuse=false,\n                    unroot=false, multgammas=false)\n\nDelete all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before. If nofuse is true, edges are not fused (degree-2 nodes are kept).\n\nWarning: assume correct ismajor fields.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.displayedtrees-Tuple{HybridNetwork, Float64}","page":"Public","title":"PhyloNetworks.displayedtrees","text":"displayedtrees(net::HybridNetwork, gamma::Float64; nofuse::Bool=false,\n               unroot::Bool=false, multgammas::Bool=false,\n               keeporiginalroot::Bool=false)\n\nExtracts all trees displayed in a network, following hybrid edges with heritability >= γ threshold (or >0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than γ. Returns an array of trees, as HybridNetwork objects.\n\nnofuse: if true, do not fuse edges (keep degree-2 nodes) during hybrid edge removal.   unroot: if false, the root will not be deleted if it becomes of degree 2 unless   keeporiginalroot is true.   multgammas: if true, the edges in the displayed trees have γ values   equal to the proportion of genes that the edge represents, even though all   these edges are tree edges. The product of all the γ values across all edges   is the proportion of genes that the tree represents. More specifically,   edge e in a given displayed tree has γ equal to the product of γs   of all edges in the original network that have been merged into e.   keeporiginalroot: if true, keep root even if of degree 1.\n\nWarnings:\n\nif nofuse is true: the retained partner hybrid edges have their γ values unchanged, but their ismajor is changed to true\nassume correct ismajor attributes.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.expectedf2matrix-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.expectedf2matrix","text":"expectedf2matrix(net::HybridNetwork; preorder::Bool=true)\n\nMatrix of f2 statistics expected from net, assuming that branch lengths in net represent \"f2 distance\". When data are based on allele frequencies, edge lengths measure drift units scaled by a variance factor p(1-p) depending on the allele frequency p at the root.\n\nThe rows and columns correspond to the taxa in the network, in the same order as listed by tiplabels(net).\n\nFor background on f-statistics, see for example Patterson et al. 2012 or Lipson 2020.\n\nexample\n\njulia> net2 = readnewick(\"(O:5.5,(((E:1.5)#H1:2.5::0.7,((#H1:0,D:1.5):1.5,((C:1,B:1):1)#H2:1::0.6):1.0):1.0,(#H2:0,A:2):3):0.5);\");\n\njulia> f2 = expectedf2matrix(net2)\n6×6 Matrix{Float64}:\n  0.0   9.95  11.0   9.56  9.56  11.0\n  9.95  0.0    5.45  5.95  5.95   8.95\n 11.0   5.45   0.0   6.16  6.16  10.0\n  9.56  5.95   6.16  0.0   2.0    6.16\n  9.56  5.95   6.16  2.0   0.0    6.16\n 11.0   8.95  10.0   6.16  6.16   0.0\n\njulia> tiplabels(net2) # order of taxa in rows and columns of f2 matrix above\n6-element Vector{String}:\n \"O\"\n \"E\"\n \"D\"\n \"C\"\n \"B\"\n \"A\"\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.expectedf4table-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.expectedf4table","text":"expectedf4table(net::HybridNetwork;\n                showprogressbar::Bool=true,\n                preorder::Bool=true)\n\nCalculate the f4 statistics expected from net, assuming that branch lengths in net represent \"f2 distance\". Output: (q,t) where t is a list of taxa and q is a list of 4-taxon set objects of type PhyloNetworks.QuartetT{datatype}. In each element of q, taxonnumber gives the indices in taxa of the 4 taxa of interest; and data contains the 3 primary expected f4-statistics, for the following 3 ordering of the 4 taxa:\n\nt1,t2|t3,t4   t1,t3|t4,t2   t1,t4|t2,t3.\n\nThis output is similar to that of countquartetsintrees, with 4-taxon sets listed in the same alphabetical order (same output t, then same order of 4-taxon sets in q).\n\nFor background on f-statistics, see for example Patterson et al. 2012 and Lipson 2020.\n\nf4-statistics are linear combination of f2-statistics:\n\nf4[t1,t2|t3,t4] = (f2[t1,t4] + f2[t2,t3] - f2[t1,t3] - f2[t2,t4])/2\n\nGiven a set of 4 taxa, there are 12 ways to order them, but there are only 2 \"degrees of freedom\" in the associated 12 f4-statistics, thanks to symmetries:\n\nf4[t2,t1|t3,t4] = - f4[t1,t2|t3,t4]\nf4[t3,t4|t1,t2] =   f4[t1,t2|t3,t4]\nf4[t1,t2|t3,t4] + f4[t1,t3|t4,t2] + f4[t1,t4|t2,t3] = 0\n\nexample\n\nThe first example is a tree: on which some f4 values are expected to be 0.\n\njulia> net0 = readnewick(\"((D:0.6,((a1:.1,a2:.1):0.1,B:0.2):0.3),C:0.4);\");\n\njulia> # using PhyloPlots; plot(net0, showedgelength=true);\n\njulia> f4,t = expectedf4table(net0);\nCalculation of expected f4 for 5 4-taxon sets...\n0+-----+100%\n  *****\n\njulia> show(t)\n[\"B\", \"C\", \"D\", \"a1\", \"a2\"]\njulia> show(f4[1].taxonnumber) # taxa numbered 1-4 are: B,C,D,a1\n[1, 2, 3, 4]\njulia> for q in f4\n         println(join(t[q.taxonnumber],\",\") * \": \" * string(round.(q.data, digits=3)))\n       end\nB,C,D,a1: [-0.3, 0.3, 0.0]\nB,C,D,a2: [-0.3, 0.3, 0.0]\nB,C,a1,a2: [0.0, -0.1, 0.1]\nB,D,a1,a2: [0.0, -0.1, 0.1]\nC,D,a1,a2: [0.0, -0.4, 0.4]\n\nThe zeros correspond to splits in the tree: Ba1|CD, Ba2|CD, BC|a1a2, BD|a1a2, CD|a1a2. The other values correspond to the internal path length for each split.\n\nNext, we use a network with 2 reticulations, each time between sister species (resulting in 3-cycle blobs).\n\njulia> net = readnewick(\"(D:1,((C:1,#H25:0):0.1,\n        ((((B1:10,B2:1):1.5,#H1:0):10.8,\n        ((A1:1,A2:1):0.001)#H1:0::0.5):0.5)#H25:0::0.501):1);\");\n\njulia> # plot(net, showedgelength=true);\n\njulia> f4,t = expectedf4table(net, showprogressbar=false);\n\njulia> using DataFrames\n\njulia> df = tablequartetf4(f4, t) |> DataFrame\n15×8 DataFrame\n Row │ qind   t1      t2      t3      t4      f4_12_34  f4_13_42  f4_14_23 \n     │ Int64  String  String  String  String  Float64   Float64   Float64  \n─────┼─────────────────────────────────────────────────────────────────────\n   1 │     1  A1      A2      B1      B2           0.0    -4.201     4.201\n   2 │     2  A1      A2      B1      C            0.0     2.699    -2.699\n   3 │     3  A1      A2      B2      C            0.0     2.699    -2.699\n   4 │     4  A1      B1      B2      C           -6.9     6.9       0.0\n   5 │     5  A2      B1      B2      C           -6.9     6.9       0.0\n   6 │     6  A1      A2      B1      D            0.0     2.699    -2.699\n   7 │     7  A1      A2      B2      D            0.0     2.699    -2.699\n   8 │     8  A1      B1      B2      D           -6.9     6.9       0.0\n   9 │     9  A2      B1      B2      D           -6.9     6.9       0.0\n  10 │    10  A1      A2      C       D            0.0    -3.176     3.176\n  11 │    11  A1      B1      C       D            0.0    -5.875     5.875\n  12 │    12  A2      B1      C       D            0.0    -5.875     5.875\n  13 │    13  A1      B2      C       D            0.0    -5.875     5.875\n  14 │    14  A2      B2      C       D            0.0    -5.875     5.875\n  15 │    15  B1      B2      C       D            0.0   -12.775    12.775\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Public","title":"PhyloNetworks.getchild","text":"getchild(edge)\ngetchild(node)\ngetchildren(node)\n\nGet child(ren) node(s).\n\ngetchild: single child node of edge, or of node after checking that node has a single child.\ngetchildren: vector of all children nodes of node.\n\ngetchildedge(node)\n\nSingle child edge of node. Checks that it's a single child.\n\nWarning: these functions rely on correct edge direction, via their ischild1 field.\n\nSee also: getparent, getpartneredge, isparentof, hassinglechild.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.getchildedge","page":"Public","title":"PhyloNetworks.getchildedge","text":"getchild(edge)\ngetchild(node)\ngetchildren(node)\n\nGet child(ren) node(s).\n\ngetchild: single child node of edge, or of node after checking that node has a single child.\ngetchildren: vector of all children nodes of node.\n\ngetchildedge(node)\n\nSingle child edge of node. Checks that it's a single child.\n\nWarning: these functions rely on correct edge direction, via their ischild1 field.\n\nSee also: getparent, getpartneredge, isparentof, hassinglechild.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getchildren","page":"Public","title":"PhyloNetworks.getchildren","text":"getchild(edge)\ngetchild(node)\ngetchildren(node)\n\nGet child(ren) node(s).\n\ngetchild: single child node of edge, or of node after checking that node has a single child.\ngetchildren: vector of all children nodes of node.\n\ngetchildedge(node)\n\nSingle child edge of node. Checks that it's a single child.\n\nWarning: these functions rely on correct edge direction, via their ischild1 field.\n\nSee also: getparent, getpartneredge, isparentof, hassinglechild.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getlevel","page":"Public","title":"PhyloNetworks.getlevel","text":"getlevel(net, preorder=true, preprocess=false)\n\nLevel of net: maximum number of edges to delete within a biconnected component to make it a tree. If the network is bicombining (each hybrid has 2 parents), then the level is the maximum number of hybrid nodes within a biconnected component. Arguments:\n\npreorder to direct edges according to the root and store a pre-ordering of nodes in net.vec_node, if not done earlier on the network (e.g. after a topology modification)\npreprocess to recalculate & store the biconnected components with process_biconnectedcomponents!, assuming the preordering was done\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getnodeages-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.getnodeages","text":"getnodeages(net)\n\nvector of node ages in pre-order, as in vec_node.\n\nWarnings: net is assumed to\n\nhave been preordered before (to calculate vec_node)\nbe time-consistent (all paths to the root to a given hybrid have the same length)\nbe ultrametric (all leaves have the same age: 0)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.getnodeheights","page":"Public","title":"PhyloNetworks.getnodeheights","text":"getnodeheights(net, checkpreorder::Bool=true)\ngetnodeheights!(net, checkpreorder::Bool=true)\n\nVector of node heights, that is: the distance of each node to the root. An error is thrown if the network is not time-consistent. A network is time-consistent if, for any node v, all paths from the root to v have the same length. (It is sufficient to check this condition at hybrid nodes). Ultrametricity is not assumed: tips need not all be at the same distance from the root. If checkpreorder=false, assumes the network has already been preordered with preorder!.\n\nIf a tree edge has a missing length (coded as -1), both functions throw an error. In general, there may be an exponential number of ways to assign tree edge lengths that make the network time-consistent.\n\ngetnodeheights sends a warning upon finding a missing hybrid edge length, otherwises proceeds as getnodeheights! but without modifying the network. getnodeheights! will attempt to assign values to missing lengths, for hybrid edges only, so as to make the network time-consistent.\n\nIf a hybrid edge e has a missing length, getnodeheights! proceeds as follows at its child hybrid node h:\n\nIf all of h's parent edges lack a length: the shortest non-negative lengths are assigned to make the network time-consistent at h. In particular, one of the partner edges is assigned length 0, and h is made as old as possible, that is, as close to the root as possible: the reticulation is \"zipped-up\".\nOtherwise: the length of e is set to the unique value that makes the network time-consistent at h, based on the partner edge's length. If this value is negative, then an error is thrown.\n\nOutput: vector of node heights, one per node, in the same order as in net.vec_node.\n\nSee also: istimeconsistent and getnodeheights_average.\n\nExamples:\n\njulia> net = readnewick(\"(((C:1,(A:1)#H1:1.5::0.7):1,(#H1:0.3::0.3,E:2.0):2.2):1.0,O:5.2)root;\");\n\njulia> # using PhyloPlots; plot(net, useedgelength=true, showedgelength=true, shownodenumber=true); # to see\n\njulia> nodeheight = getnodeheights(net)\n9-element Vector{Float64}:\n 0.0\n 5.2\n 1.0\n 3.2\n 5.2\n 2.0\n 3.5\n 4.5\n 3.0\n\njulia> [node.number => (height, node.name) for (height,node) in zip(nodeheight, net.vec_node)]\n9-element Vector{Pair{Int64, Tuple{Float64, String}}}:\n -2 => (0.0, \"root\")\n  5 => (5.2, \"O\")\n -3 => (1.0, \"\")\n -6 => (3.2, \"\")\n  4 => (5.2, \"E\")\n -4 => (2.0, \"\")\n  3 => (3.5, \"H1\")\n  2 => (4.5, \"A\")\n  1 => (3.0, \"C\")\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getnodeheights!","page":"Public","title":"PhyloNetworks.getnodeheights!","text":"getnodeheights(net, checkpreorder::Bool=true)\ngetnodeheights!(net, checkpreorder::Bool=true)\n\nVector of node heights, that is: the distance of each node to the root. An error is thrown if the network is not time-consistent. A network is time-consistent if, for any node v, all paths from the root to v have the same length. (It is sufficient to check this condition at hybrid nodes). Ultrametricity is not assumed: tips need not all be at the same distance from the root. If checkpreorder=false, assumes the network has already been preordered with preorder!.\n\nIf a tree edge has a missing length (coded as -1), both functions throw an error. In general, there may be an exponential number of ways to assign tree edge lengths that make the network time-consistent.\n\ngetnodeheights sends a warning upon finding a missing hybrid edge length, otherwises proceeds as getnodeheights! but without modifying the network. getnodeheights! will attempt to assign values to missing lengths, for hybrid edges only, so as to make the network time-consistent.\n\nIf a hybrid edge e has a missing length, getnodeheights! proceeds as follows at its child hybrid node h:\n\nIf all of h's parent edges lack a length: the shortest non-negative lengths are assigned to make the network time-consistent at h. In particular, one of the partner edges is assigned length 0, and h is made as old as possible, that is, as close to the root as possible: the reticulation is \"zipped-up\".\nOtherwise: the length of e is set to the unique value that makes the network time-consistent at h, based on the partner edge's length. If this value is negative, then an error is thrown.\n\nOutput: vector of node heights, one per node, in the same order as in net.vec_node.\n\nSee also: istimeconsistent and getnodeheights_average.\n\nExamples:\n\njulia> net = readnewick(\"(((C:1,(A:1)#H1:1.5::0.7):1,(#H1:0.3::0.3,E:2.0):2.2):1.0,O:5.2)root;\");\n\njulia> # using PhyloPlots; plot(net, useedgelength=true, showedgelength=true, shownodenumber=true); # to see\n\njulia> nodeheight = getnodeheights(net)\n9-element Vector{Float64}:\n 0.0\n 5.2\n 1.0\n 3.2\n 5.2\n 2.0\n 3.5\n 4.5\n 3.0\n\njulia> [node.number => (height, node.name) for (height,node) in zip(nodeheight, net.vec_node)]\n9-element Vector{Pair{Int64, Tuple{Float64, String}}}:\n -2 => (0.0, \"root\")\n  5 => (5.2, \"O\")\n -3 => (1.0, \"\")\n -6 => (3.2, \"\")\n  4 => (5.2, \"E\")\n -4 => (2.0, \"\")\n  3 => (3.5, \"H1\")\n  2 => (4.5, \"A\")\n  1 => (3.0, \"C\")\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getnodeheights_average","page":"Public","title":"PhyloNetworks.getnodeheights_average","text":"getnodeheights_average(net, checkpreorder::Bool=true; warn=true)\n\nVector of average node heights, that is: the average distance from the root to each node. The average is a weighted average with weights taken to be the hybrid edges' inheritance values γ, if available. Equal weights are used at hybrid nodes with some parents lacking a γ inheritance value (with a warning).\n\nmissing edge lengths:\n\nAn error is thrown if a tree edge has a missing edge length.\nIf all parent hybrid edges have missing lengths at a given hybrid node, then the hybrid node is assumed to be as close to the root as possible, that is, the reticulation is assumed \"zipped-up\" with one of its hybrid edges of length 0.\nIf some but not all parent hybrid edges have a missing length, then the average node height is calculated based on the non-missing parents only. If the hybrid node height turns out to be lower than one of the parent's height (such that some missing length would need to be negative) then a warning is issued.\n\nA warning is issued, unless warn=false, if the network is not time-consistent.\n\nSee also: istimeconsistent, getnodeheights, and getnodeheights_majortree](@ref).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getnodeheights_majortree","page":"Public","title":"PhyloNetworks.getnodeheights_majortree","text":"getnodeheights_majortree(net, checkpreorder::Bool=true; warn=true)\n\nVector of node heights from the major tree, that is: the distance from the root to each node when considering the major tree for node heights. \n\nmissing edge lengths:\n\nAn error is thrown if a tree edge has a missing edge length.\nIf all parent hybrid edges have missing lengths at a given hybrid node, then the hybrid node is assumed to be as close to the root as possible, that is, the reticulation is assumed \"zipped-up\" with one of its hybrid edges of length 0.\nIf a major hybrid edge has a missing length, then the hybrid node height will be calculated using the node height and edge length of the minor parent with the largest inheritance γ (with a warning). If the major hybrid edge lacks a length and all non-missing minor edges lack an inheritance γ or have the same value, then an error is thrown.\n\nA warning is issued, unless warn=false, if the network is not time-consistent.\n\nSee also: istimeconsistent, getnodeheights and getnodeheights_average.\n\n#node heights of time-consistent networks are the same \njulia> consistent_net = readnewick(\"((A:2.5,#H1:1.5::0.4):0.25,(C:1.5,(B:1)#H1:0.5::0.6):1.25);\");\n\njulia> heights = getnodeheights(consistent_net)\n7-element Vector{Float64}:\n 0.0\n 1.25\n 2.75\n 0.25\n 1.75\n 2.75\n 2.75\n\njulia> heights_average = getnodeheights_average(consistent_net);\n\njulia> heights_major = getnodeheights_majortree(consistent_net);\n\njulia> heights == heights_average == heights_major  \ntrue\n\n#inconsistent networks give different results\njulia> inconsistent_net = readnewick(\"((A:2.5,#H1:1.5::0.4):0.25,(C:1.5,(B:1)#H1:2.5::0.6):1.25);\");\n\njulia> getnodeheights_average(inconsistent_net;warn=false)\n7-element Vector{Float64}:\n 0.0\n 1.25\n 2.75\n 0.25\n 2.95\n 3.95\n 2.75\n\njulia> getnodeheights_majortree(inconsistent_net;warn=false) \n7-element Vector{Float64}:\n 0.0\n 1.25\n 2.75\n 0.25\n 3.75\n 4.75\n 2.75\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Public","title":"PhyloNetworks.getparent","text":"getparent(edge)\ngetparent(node)\ngetparentminor(node)\ngetparents(node)\n\nGet parental node(s).\n\ngetparent: major (or only) parent node of edge or node\ngetparentminor: minor parent node of node\ngetparents: vector of all parent nodes of node.\n\ngetparentedge(node)\ngetparentedgeminor(node)\n\nGet one parental edge of a node.\n\ngetparentedge: major parent edge. For a tree node, it's its only parent edge.\ngetparentedgeminor: minor parent edge, if node is hybrid (with an error if node has no minor parent).\n\nIf node has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.\n\nWarning: these functions use the field ischild1 of edges.\n\nSee also: getchild, getpartneredge.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.getparentedge","page":"Public","title":"PhyloNetworks.getparentedge","text":"getparent(edge)\ngetparent(node)\ngetparentminor(node)\ngetparents(node)\n\nGet parental node(s).\n\ngetparent: major (or only) parent node of edge or node\ngetparentminor: minor parent node of node\ngetparents: vector of all parent nodes of node.\n\ngetparentedge(node)\ngetparentedgeminor(node)\n\nGet one parental edge of a node.\n\ngetparentedge: major parent edge. For a tree node, it's its only parent edge.\ngetparentedgeminor: minor parent edge, if node is hybrid (with an error if node has no minor parent).\n\nIf node has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.\n\nWarning: these functions use the field ischild1 of edges.\n\nSee also: getchild, getpartneredge.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getparentedgeminor","page":"Public","title":"PhyloNetworks.getparentedgeminor","text":"getparent(edge)\ngetparent(node)\ngetparentminor(node)\ngetparents(node)\n\nGet parental node(s).\n\ngetparent: major (or only) parent node of edge or node\ngetparentminor: minor parent node of node\ngetparents: vector of all parent nodes of node.\n\ngetparentedge(node)\ngetparentedgeminor(node)\n\nGet one parental edge of a node.\n\ngetparentedge: major parent edge. For a tree node, it's its only parent edge.\ngetparentedgeminor: minor parent edge, if node is hybrid (with an error if node has no minor parent).\n\nIf node has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.\n\nWarning: these functions use the field ischild1 of edges.\n\nSee also: getchild, getpartneredge.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getparentminor","page":"Public","title":"PhyloNetworks.getparentminor","text":"getparent(edge)\ngetparent(node)\ngetparentminor(node)\ngetparents(node)\n\nGet parental node(s).\n\ngetparent: major (or only) parent node of edge or node\ngetparentminor: minor parent node of node\ngetparents: vector of all parent nodes of node.\n\ngetparentedge(node)\ngetparentedgeminor(node)\n\nGet one parental edge of a node.\n\ngetparentedge: major parent edge. For a tree node, it's its only parent edge.\ngetparentedgeminor: minor parent edge, if node is hybrid (with an error if node has no minor parent).\n\nIf node has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.\n\nWarning: these functions use the field ischild1 of edges.\n\nSee also: getchild, getpartneredge.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getparents","page":"Public","title":"PhyloNetworks.getparents","text":"getparent(edge)\ngetparent(node)\ngetparentminor(node)\ngetparents(node)\n\nGet parental node(s).\n\ngetparent: major (or only) parent node of edge or node\ngetparentminor: minor parent node of node\ngetparents: vector of all parent nodes of node.\n\ngetparentedge(node)\ngetparentedgeminor(node)\n\nGet one parental edge of a node.\n\ngetparentedge: major parent edge. For a tree node, it's its only parent edge.\ngetparentedgeminor: minor parent edge, if node is hybrid (with an error if node has no minor parent).\n\nIf node has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.\n\nWarning: these functions use the field ischild1 of edges.\n\nSee also: getchild, getpartneredge.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getpartneredge-Tuple{Any}","page":"Public","title":"PhyloNetworks.getpartneredge","text":"getpartneredge(edge::Edge)\ngetpartneredge(edge::Edge, node::Node)\n\nEdge that is the hybrid partner of edge, meaning that is has the same child node as edge. This child node is given as an argument in the second method. Assumptions, not checked:\n\nno in-coming polytomy: a node has 0, 1 or 2 parents, no more\nwhen node is given, it is assumed to be the child of edge (the first method calls the second).\n\nSee also: getparent, getchild\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.getroot-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.getroot","text":"getroot(net)\n\nNode used to root net. If net is to be considered as semi-directed or unrooted, this root node is used to write the networks' Newick parenthetical description or for network traversals.\n\nSee also: isrootof\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hardwiredcluster-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Union{AbstractVector{Int64}, AbstractVector{String}}}","page":"Public","title":"PhyloNetworks.hardwiredcluster","text":"hardwiredcluster(edge::Edge, taxa::Union{AbstractVector{String},AbstractVector{Int}})\nhardwiredcluster!(v::Vector{Bool}, edge::Edge, taxa)\nhardwiredcluster!(v::Vector{Bool}, edge::Edge, taxa, visited::Vector{Int})\n\nCalculate the hardwired cluster of edge, coded as a vector of booleans: true for taxa that are descendent of the edge, false for other taxa (including missing taxa).\n\nThe edge should belong in a rooted network for which ischild1 is up-to-date. Run directedges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.\n\nvisited: vector of node numbers, of all visited nodes.\n\nExamples:\n\njulia> net5 = \"(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));\" |> readnewick |> directedges! ;\n\njulia> taxa = net5 |> tiplabels # ABC EF D\n6-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n \"E\"\n \"F\"\n \"D\"\n\njulia> hardwiredcluster(net5.edge[12], taxa) # descendants of 12th edge = CEF\n6-element Vector{Bool}:\n 0\n 0\n 1\n 1\n 1\n 0\n\nSee also hardwiredclusterdistance and hardwiredclusters\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hardwiredclusterdistance-Tuple{HybridNetwork, HybridNetwork, Bool}","page":"Public","title":"PhyloNetworks.hardwiredclusterdistance","text":"hardwiredclusterdistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)\n\nHardwired cluster distance between the topologies of net1 and net2, that is, the number of hardwired clusters found in one network and not in the other (with multiplicity, see below).\n\nIf the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, then both networks are considered as semi-directed.\n\nNetworks are assumed bicombining (each hybrid has exactly 2 parents, no more).\n\nDissimilarity vs distance\n\nThis is not a distance per se on the full space of phylogenetic networks: there are pairs of distinct networks for which this dissimilarity is 0. But it is a distance on some classes of networks, such as the class of tree-child networks that are \"normal\" (without shortcuts), or the class of tree-child networks that can be assigned node ages such that hybrid edges have length 0 and tree edges have non-negative lengths. See Cardona, Rossello & Valiente (2008), Cardona, Llabres, Rossello & Valiente (2008), and Huson, Rupp, Scornavacca (2010).\n\nExample\n\njulia> net1 = readnewick(\"(t6,(t5,((t4,(t3,((t2,t1))#H1)),#H1)));\");\n\njulia> taxa = sort(tiplabels(net1)); # t1 through t6, sorted alphabetically\n\njulia> # using PhyloPlots; plot(net1, showedgenumber=true);\n\njulia> # in matrix below: column 1: edge number. last column: tree (10) vs hybrid (11) edge\n       # middle columns: for 'taxa': t1,...t6. 1=descendant, 0=not descendant\n       hardwiredclusters(net1, taxa)\n6×8 Matrix{Int64}:\n 13  1  1  1  1  1  0  10\n 12  1  1  1  1  0  0  10\n 10  1  1  1  1  0  0  10\n  9  1  1  1  0  0  0  10\n  8  1  1  0  0  0  0  11\n  7  1  1  0  0  0  0  10\n\njulia> net2 = readnewick(\"(t6,(t5,((t4,(t3)#H1),(#H1,(t1,t2)))));\");\n\njulia> hardwiredclusters(net2, taxa)\n6×8 Matrix{Int64}:\n 13  1  1  1  1  1  0  10\n 12  1  1  1  1  0  0  10\n  6  0  0  1  1  0  0  10\n  5  0  0  1  0  0  0  11\n 11  1  1  1  0  0  0  10\n 10  1  1  0  0  0  0  10\n\njulia> hardwiredclusterdistance(net1, net2, true) # true: as rooted networks\n4\n\nWhat is a hardwired cluster?\n\nEach edge in a network is associated with its hardwired cluster, that is, the set of all its descendant taxa (leaves). The set of hardwired cluster of a network is the set of its edges' hardwired clusters. The dissimilarity d_hard defined in Huson, Rupp, Scornavacca (2010) is the number of hardwired clusters that are in one network but not in the other.\n\nThis implementation is a slightly more discriminative version of d_hard, where each cluster is counted with multiplicity and annotated with its edge's hybrid status, as follows:\n\nExternal edges are not counted (they are tree edges to a leaf, shared by all phylogenetic networks).\nA cluster is counted for each edge for which it's the hardwired cluster.\nAt a given hybrid node, both hybrid partner edges have the same cluster, so this cluster is only counted once for both partners.\nA given cluster is matched between the two networks only if it's the cluster from a tree edge in both networks, or from a hybrid edge in both networks.\n\nIn the example above, net1 has a shortcut (hybrid edge 11) resulting in 2 tree edges (12 and 10) with the same cluster {t1,t2,t3,t4}. So cluster {t1,t2,t3,t4} has multiplicity 2 in net1. net2 also has this cluster, but only associated with 1 tree edge, so this cluster contributes (2-1)=1 towards the hardwired cluster distance between the two networks. The distance of 4 corresponds to these 4 clusters:\n\n{t1,t2,t3,t4}: twice in net1, once in net2\n{t3,t4}: absent in net1, once in net2\n{t1,t2}: twice in net1 (from a hybrid edge & a tree edge), once in net2\n{t3}: absent in net1 (because external edges are not counted), once in net2 (from a hybrid edge).\n\nDegree-2 nodes cause multiple edges to have the same cluster, so counting clusters with multiplicity distinguishes a network with extra degree-2 nodes from the \"same\" network after these nodes have been suppressed (e.g. with PhyloNetworks.fuseedgesat! or PhyloNetworks.shrinkedge!).\n\nNetworks as semi-directed\n\nIf rooted is false and one of the phylogenies is not a tree (1+ reticulations), then all degree-2 nodes are removed before comparing the hardwired clusters, and the minimum distance is returned over all possible ways to root the networks at internal nodes.\n\nSee also: hardwiredclusters, hardwiredcluster\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hardwiredclusters-Tuple{HybridNetwork, Union{AbstractVector{Int64}, AbstractVector{String}}}","page":"Public","title":"PhyloNetworks.hardwiredclusters","text":"hardwiredclusters(net::HybridNetwork, taxon_labels)\n\nReturns a matrix describing all the hardwired clusters in a network, with taxa listed in same order as in taxon_labels to describe their membership in each cluster. Allows for missing taxa, with entries all 0.\n\nWarnings:\n\nclusters are rooted, so the root must be correct.\neach hybrid node is assumed to have exactly 2 parents (no more).\n\nEach row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).\n\nfirst column: edge number\nnext columns: 0/1. 1=descendant of edge, 0=not a descendant, or missing taxon.\nlast column:  10/11 values. 10=tree edge, 11=hybrid edge\n\nSee also hardwiredclusterdistance and hardwiredcluster.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hashybridladder-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.hashybridladder","text":"hashybridladder(net::HybridNetwork)\n\nReturn true if net contains a hybrid ladder: where a hybrid node's child is itself a hybrid node. This makes the network not treechild, assuming it is fully resolved. (One of the nodes does not have any tree-node child).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hassinglechild-Tuple{PhyloNetworks.Node}","page":"Public","title":"PhyloNetworks.hassinglechild","text":"hassinglechild(node)\n\ntrue if node has a single child, based on the edges' ischild1 field; false otherwise.\n\nSee also: getchild, getparent\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hybridclades_support-Tuple{Vector{HybridNetwork}, HybridNetwork}","page":"Public","title":"PhyloNetworks.hybridclades_support","text":"hybridclades_support(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)\n\nMatch hybrid nodes in a reference network with those in an array of networks, like bootstrap networks or in a posterior sample of networks. All networks must be fully resolved, and on the same taxon set. If rooted=true, all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).\n\nTwo hybrid edges in two networks are said to match if they share the same \"hybrid\" clade (or recipient) and the same \"donor clade\", which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with γ>0.5) and one is its minor sister (following the major hybrid edge with γ<0.5).\n\nTo calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If rooted=false, sister clades are considered as bipartitions.\n\nOutput:\n\na \"node\" data frame (see below)\nan \"edge\" data frame (see below)\na \"clade\" data frame to describe the make up of all clades found as hybrids or sisters, starting with a column taxa that lists all taxa. All other columns correspond to a given clade and contain true/false values. true means that a given taxon belongs in a given clade. For a clade named H1, for instance, and if the data frame was named cla, the list of taxa in this clade can be obtained with cla[:taxa][cla[:H1]].\nan array of gamma values, with one row for each network in the sample and two columns (major/minor) for each hybrid edge in the reference network. If this hybrid edge was found in the sampled network (i.e. same hybrid and sister clades, after removal of all other hybrid nodes), its inheritcance gamma value is recorded here. Otherwise, the gamma entry is 0.0.\na vector with the number of each hybrid edge in the reference network, in the same order as for the columns in the array of gamma values above.\n\nThe \"node\" data frame has one row per clade and 9 columns giving:\n\n:clade: the clade's name, like the taxon name (if a hybrid is a single taxon) or the hybrid tag (like 'H1') in the reference network\n:node: the node number in the reference network. missing if the clade is not in this network.\n:hybridnode: typically the same node number as above, except for hybrid clades in the reference network. For those, the hybrid node number is listed here.\n:edge: number of the parent edge, parent to the node in column 2, if found in the ref network. missing otherwise.\n:BS_hybrid: percentage of sample networks in which the clade is found to be a hybrid clade.\n:BS_sister: percentage of sample networks in which the clade is found to be sister to some hybrid clade (sum of the next 2 columns)\n:BS_major_sister: percentage of sample networks in which the clade is found to be the major sister to some hybrid clade\n:BS_minor_sister: same as previous, but minor\n:BS_hybrid_samesisters: percentage of sample networks in which the clade is found to be a hybrid and with the same set of sister clades as in the reference network. Applies to hybrid clades found in the reference network only, missing for all other clades.\n\nThe \"edge\" data frame has one row for each pair of clades, and 8 columns:\n\n:edge: hybrid edge number, if the edge appears in the reference network. missing otherwise.\n:hybrid_clade: name of the clade found to be a hybrid, descendent of 'edge'\n:hybrid: node number of that clade, if it appears in the reference network. missing otherwise.\n:sister_clade: name of the clade that is sister to 'edge', i.e. be sister to a hybrid\n:sister: node number of that clade, if in the ref network.\n:BS_hybrid_edge: percentage of sample networks in which 'edge' is found to be a hybrid  edge, i.e. when the clade in the 'hybrid' column is found to be a hybrid and the clade in  the 'sister' column is one of its sisters.\n:BS_major: percentage of sample networks in which 'edge' is found to be a major hybrid  edge, i.e. when 'hybrid' is found to be a hybrid clade and 'sister' is found to be its  major sister.\n:BS_minor: same as previous, but minor\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hybridlambdaformat-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.hybridlambdaformat","text":"hybridlambdaformat(net::HybridNetwork; prefix=\"I\")\n\nOutput net as a string in the format that the Hybrid-Lambda simulator expects, namely:\n\nall internal nodes are named, including the root, with names that are unique and start with a letter.\nhybrid nodes are written as H6#γ1:length1 and H6#γ1:length2 instead of #H6:length1::γ1 and #H6:length2::γ2 (note the samme γ value expected by Hybrid-Lambda)\n\nThis is a modified version of the extended Newick format.\n\nOptional keyword argument prefix: must start with a letter, other than \"H\". Internal nodes are given names like \"I1\", \"I2\", etc. Existing internal non-hybrid node names are replaced, which is crucial if some of them don't start with a letter (e.g. in case node names are bootstrap values). See nameinternalnodes! to add node names.\n\nexamples\n\njulia> net = readnewick(\"((a:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);\");\n\njulia> hybridlambdaformat(net) # net is unchanged here\n\"((a:1.0,(b:1.0)H1#0.8:1.0)I1:5.0,(H1#0.8:0.0,c:1.0)I2:1.0)I3;\"\n\njulia> # using PhyloPlots; plot(net, shownodenumber=true) # shows that node -2 is the root\n\njulia> rotate!(net, -2)\n\njulia> writenewick(net) # now the minor edge with γ=0.2 appears first\n\"((#H1:0.0::0.2,c:1.0):1.0,(a:1.0,(b:1.0)#H1:1.0::0.8):5.0);\"\n\njulia> hybridlambdaformat(net)\n\"((H1#0.2:0.0,c:1.0)I2:1.0,(a:1.0,(b:1.0)H1#0.2:1.0)I1:5.0)I3;\"\n\njulia> net = readnewick(\"((((B)#H1:::.6)#H2,((D,C,#H2:::0.8),(#H1,A))));\"); # 2 reticulations, no branch lengths\n\njulia> writenewick(net, round=true)\n\"(#H2:::0.2,((D,C,((B)#H1:::0.6)#H2:::0.8),(#H1:::0.4,A)));\"\n\njulia> hybridlambdaformat(net; prefix=\"int\")\n\"(H2#0.2,((D,C,((B)H1#0.6)H2#0.2)int1,(H1#0.6,A)int2)int3)int4;\"\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.ischildof","page":"Public","title":"PhyloNetworks.ischildof","text":"isparentof(node, edge)\nischildof(node, edge)\n\ntrue if node is the tail / head, or parent / child, of edge; false otherwise. Assumes that the edge's direction is correct, meaning its field ischild1 is reliable (in sync with the rooting).\n\nSee also: getparent, getchild, isrootof\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.isexternal","page":"Public","title":"PhyloNetworks.isexternal","text":"isrootof(node, net)\n\ntrue if node is the root of net (or used as such for network traversals in case the network is considered as semi-directed); false otherwise.\n\nisleaf(node)\nisexternal(edge)\n\ntrue if node is a leaf or edge is adjacent to a leaf, false otherwise.\n\nSee also: getroot, getparent, getchild\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.isgalled","page":"Public","title":"PhyloNetworks.isgalled","text":"isgalled(net::HybridNetwork, checkpreorder::Bool=true)\n\ntrue (resp. false) if net is (resp. is not) a galled network, assuming that net is bicombining (every hybrid has exactly 2 parents). A network is galled if every hybrid node is contained in a cycle that has its 2 hybrid parent edges and otherwise tree edges only. See for example Huson, Rupp & Scornavacca (2010) and Gunawan, DasGupta & Zhang (2017). Equivalently, a bicombining network is galled if, for any hybrid node n, both of its parent edges originate from the same tree component. We get the tree components by deleting all hybrid edges from the network: we are left with a forest of trees.\n\nThe network is traversed in preorder (from the root to the leaves). Turn checkpreorder to false if the pre-ordering was run and is known to be up-to-date. Assumption: tree edges are directly correctly according to the current root.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.isleaf","page":"Public","title":"PhyloNetworks.isleaf","text":"isrootof(node, net)\n\ntrue if node is the root of net (or used as such for network traversals in case the network is considered as semi-directed); false otherwise.\n\nisleaf(node)\nisexternal(edge)\n\ntrue if node is a leaf or edge is adjacent to a leaf, false otherwise.\n\nSee also: getroot, getparent, getchild\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.isparentof-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Public","title":"PhyloNetworks.isparentof","text":"isparentof(node, edge)\nischildof(node, edge)\n\ntrue if node is the tail / head, or parent / child, of edge; false otherwise. Assumes that the edge's direction is correct, meaning its field ischild1 is reliable (in sync with the rooting).\n\nSee also: getparent, getchild, isrootof\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.isrootof-Tuple{PhyloNetworks.Node, HybridNetwork}","page":"Public","title":"PhyloNetworks.isrootof","text":"isrootof(node, net)\n\ntrue if node is the root of net (or used as such for network traversals in case the network is considered as semi-directed); false otherwise.\n\nisleaf(node)\nisexternal(edge)\n\ntrue if node is a leaf or edge is adjacent to a leaf, false otherwise.\n\nSee also: getroot, getparent, getchild\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.istimeconsistent","page":"Public","title":"PhyloNetworks.istimeconsistent","text":"istimeconsistent(net, checkpreorder::Bool=true)\n\nTrue (resp. false) if net network is (resp. is not) time-consistent. A network is time-consistent if for any node v, all paths from the root to v have the same length. It is sufficient to check this condition at nodes v that are hybrid nodes.\n\nSee also getnodeheights and getnodeheights_average.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.istreechild-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.istreechild","text":"istreechild(net::HybridNetwork)\n\nTuple (rooted, semi_weakly, semi_strongly) in which each element is true or false, to indicate if net is / is not\n\ntree-child as a rooted network\nweakly tree-child as a semidirected network\nstrongly tree-child as a semidirected network\n\nA rooted network is tree-child if all of its internal nodes have at least one child that is a tree node (or equivalently, one child edge that is a tree edge). A semidirected network is strongly (resp. weakly) tree-child if all (resp. at least one) of its rooted partners are tree-child.\n\nNote that degree-2 nodes are not suppressed: a degree-2 node with a single hybrid child causes the network to not be tree-child, despite the fact that suppressing this node may render the reduced network tree-child.\n\nAssumes that tree edges are directly correctly according to the current root.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.majortree-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.majortree","text":"majortree(net::HybridNetwork; nofuse::Bool=false, unroot::Bool=false,\n          keeporiginalroot::Bool=false)\n\nExtract the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node.\n\nnofuse: if true, edges and degree-2 nodes are retained during edge removal. Otherwise, at each reticulation the child edge (below the hybrid node) is retained: the major hybrid edge is fused with it.\n\nunroot: is true, the root will be deleted if it becomes of degree 2.\n\nkeeporiginalroot: the network's root is kept even if it becomes of degree 1.\n\nWarnings:\n\nif nofuse is true: the hybrid edges that are retained (without fusing) have their γ values unchanged, but their ismajor is changed to true\nassume correct ismajor attributes.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.minortreeat","page":"Public","title":"PhyloNetworks.minortreeat","text":"minortreeat(net::HybridNetwork, hybindex::Integer, nofuse=false, unroot::Bool=false)\n\nExtract the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i=hybindex), where the minor hybrid edge is kept instead of the major hybrid edge. If nofuse is true, edges are not fused (degree-2 nodes are kept). If unroot is true, the root will be deleted if it becomes of degree 2.\n\nWarning: assume correct ismajor fields.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.mudistance_rooted-Tuple{HybridNetwork, HybridNetwork}","page":"Public","title":"PhyloNetworks.mudistance_rooted","text":"mudistance_rooted(net1::HybridNetwork, net2::HybridNetwork;\n    labels::AbstractVector{<:AbstractString}=sort!(union(tiplabels(net1), tiplabels(net2))),\n    preorder::Bool=true)\n\nDistance or matrix of distances between the networks, considered as rooted, based on their node-based μ-representation: number of nodes in one network whose μ-vector does not match with that of a node in the other network. The μ-vector of a node has n+1 coordinates: one for each tip taxon, and one for hybrids. Each value counts the number of paths starting at the node and ending at a specific leaf, or ending at a hybrid node (any hybrid node).\n\nSee Cardona, Rossello & Valiente (2009) for the original μ-distance, and Cardona et al. (2024) for the extension using paths ending at hybrids.\n\nThe distance implemented here considers one μ-vector per non-leaf node: without ignoring any non-leaf node (including degree-2 nodes if any), and ignoring leaves whose μ-vectors are trivial.\n\nAssumption: networks have a single root.\n\nSee also node_murepresentation.\n\nkeyword arguments\n\npreorder indicates whether to preprocess each network with directedges! and preorder!.\nlabels: tip labels that each μ-vector will track, by default the union of taxon labels across both networks. If a taxon is absent from net1 (say) but tracked because present in net2, then there are 0 paths from any node in net1 to that taxon.\n\nIf the networks have different tip labels, consider pruning leaves that are not shared between them beforehand, using deleteleaf!, to compare the subnetworks on their shared leaf set.\n\nIf a non-default label set is used, such as the sorted shared taxon set sort!(intersect(tiplabels(net1), tiplabels(net2))), then the distance may drop, because the number of paths to non-shared taxa will be ignored. But all nodes still count towards the distance, including degree-2 nodes that would be suppressed in subnetworks.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.mudistance_semidirected-Tuple{HybridNetwork, HybridNetwork}","page":"Public","title":"PhyloNetworks.mudistance_semidirected","text":"mudistance_semidirected(net1::HybridNetwork, net2::HybridNetwork; ...)\nmudistance_semidirected(nets::AbstractVector{HybridNetwork}; ...)\n\nDistance or matrix of distances between the networks, considered as semidirected, based on their edge-based μ-representation: number of edges in one network whose μ-entry does not match with that of an edge in the other network.\n\nThe μ-vector of an edge, assigned some specific direction, has n+1 coordinates: one for each tip taxon, and one for hybrids. Each value counts the number of paths starting with the edge (directed as specified) and ending at a specific leaf, or ending at a (any) hybrid node. For more details, see Maxfield, Xu & Ané 2025. The implementation here departs from Maxfield, Xu & Ané (2025) by considering μ-vectors \"extended\" with the counts of paths ending at hybrids, as defined on rooted networks by Cardona et al. (2024).\n\nEach μ-entry includes 1 or 2 μ-vector(s) and tag(s) indicating the edge type (e.g. hybrid). The number of μ-vector(s) depends on the direction(s) that an edge may have under different rootings.\n\nIf the networks have different tip labels, the union of all their labels is considered to build μ-vectors, and the resulting distance must be positive. Consider pruning leaves that are not shared between the two networks beforehand, using deleteleaf!, to compare the subnetworks on their shared leaf set.\n\nAssumption: networks have a single root.\n\nSee also edge_murepresentation.\n\nkeyword arguments\n\npreorder=true indicates whether to preprocess each network with directedges! and preorder!.\nuserootμ=false controls whether the root μ-vector in included in the set of μ-entries being compared. It is ignored by default (departing from Maxfield, Xu & Ané 2025) because different root μ-vectors for networks with a single root would cause all μ-entries in their root components to be different.\nsuppressroot=true to exclude one internal tree edge incident to the root, in case the root is incident to exactly 2 edges which are not both hybrid edges. In that case, re-rooting the network would suppress that internal tree edge, hence its associated μ-entry. This option does not modify the network.\nlabels: tip labels that each μ-vector will track, by default the union of taxon labels across both networks, sorted alphabetically. If a taxon is absent from net1 (say) but tracked because present in net2, then there are 0 paths from any edge in net1 to that taxon.\n\nIf the networks have different tip labels, consider pruning leaves that are not shared between them beforehand, using deleteleaf!, to compare the subnetworks on their shared leaf set.\n\nIf a non-default label set is used, such as the sorted shared taxon set sort!(intersect(tiplabels(net1), tiplabels(net2))), then the distance may drop, as the number of paths to non-shared taxa will be ignored. But all edges still count towards the distance, whereas edges below degree-2 nodes would be suppressed in subnetworks.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.nameinternalnodes!","page":"Public","title":"PhyloNetworks.nameinternalnodes!","text":"nameinternalnodes!(net::HybridNetwork, prefix=\"i\")\n\nAdd names to nodes in net that don't already have a name. Leaves already have names; but if not, they will be given names as well. New node names will be of the form \"prefixk\" where k is an integer. So by default, new node names will be of the form \"i1\", \"i2\", etc.\n\nexamples\n\njulia> net = readnewick(\"((a:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);\");\n\njulia> nameinternalnodes!(net, \"I\") # by default, shown without internal node names\nHybridNetwork, Rooted Network\n7 edges\n7 nodes: 3 tips, 1 hybrid nodes, 3 internal tree nodes.\ntip labels: a, b, c\n((a:1.0,(b:1.0)#H1:1.0::0.8)I1:5.0,(#H1:0.0::0.2,c:1.0)I2:1.0)I3;\n\njulia> writenewick(net; internallabel=false) # by default, writenewick shows internal names if they exist\n\"((a:1.0,(b:1.0)#H1:1.0::0.8):5.0,(#H1:0.0::0.2,c:1.0):1.0);\"\n\njulia> net = readnewick(\"((int5:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);\"); # one taxon name starts with \"int\"\n\njulia> nameinternalnodes!(net, \"int\");\n\njulia> writenewick(net)\n\"((int5:1.0,(b:1.0)#H1:1.0::0.8)int6:5.0,(#H1:0.0::0.2,c:1.0)int7:1.0)int8;\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.nj-Tuple{DataFrames.DataFrame}","page":"Public","title":"PhyloNetworks.nj","text":"nj(D::DataFrame; force_nonnegative_edges::Bool=false)\n\nConstruct a tree from a distance matrix by neighbor joining, where D is a DataFrame of the distance matrix, with taxon names taken from the header of the data frame. The rows are assumed to correspond to tips in the tree in the same order as they do in columns. With force_nonnegative_edges being true, any negative edge length is changed to 0.0 (with a message).\n\nFor the algorithm, see Satou & Nei 1987.\n\nSee nj! for using a matrix as input.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.nni!-Tuple{HybridNetwork, Vararg{Any}}","page":"Public","title":"PhyloNetworks.nni!","text":"nni!([rng::AbstractRNG,]\n     net::HybridNetwork,\n     e::Edge,\n     nohybridladder::Bool=true,\n     no3cycle::Bool=true,\n     constraints::Vector{TopologyConstraint}=TopologyConstraint[]\n)\n\nAttempt to perform a nearest neighbor interchange (NNI) around edge e, randomly chosen among all possible NNIs (e.g 3, sometimes more depending on e) satisfying the constraints, and such that the new network is a DAG. The number of possible NNI moves around an edge depends on whether the edge's parent/child nodes are tree or hybrid nodes. This is calculated by nnimax.\n\nThe option no3cycle forbids moves that would create a 3-cycle in the network. When no3cycle = false, 2-cycle and 3-cycles may be generated.\n\nNote that the defaults values are for positional (not keyword) arguments, so two or more arguments can be used, but in a specific order: nni!(net, e) or nni!(net, e, nohybridladder), nni!(net, e, nohybridladder, no3cycle), nni!(net, e, nohybridladder, no3cycle, contraints).\n\nAssumptions:\n\nThe starting network does not have 3-cycles, if no3cycle=true. No check for the presence of 2- and 3-cycles in the input network.\nThe edges' field ischild1 is correct in the input network. (This field will be correct in the output network.)\n\nOutput: information indicating how to undo the move or nothing if all NNIs failed.\n\nexamples\n\njulia> str_network = \"(((S8,S9),(((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\";\n\njulia> net = readnewick(str_network);\n\njulia> # using Random; Random.seed!(3); ## commented out for doctest reproducibility across julia versions, but users can use this line to set the seed in their analyses.\n\njulia> undoinfo = nni!(net, net.edge[3], true, true); # true's to avoid hybrid ladders and 3-cycles\n\nIn the next example, we use a stable RNG to make the example reproducible across julia versions. However, this particular RNG is not recommended. The RNG used by default is better (e.g. much more efficient).\n\njulia> str_network = \"(((S8,S9),(((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\";\n\njulia> net = readnewick(str_network);\n\njulia> # using Pkg; Pkg.add(\"StableRNGs\") # to install StableRNGs if not done earlier\n\njulia> using StableRNGs\n\njulia> rng = StableRNG(791);\n\njulia> undoinfo = nni!(rng, net, net.edge[3], true, true); # true's to avoid hybrid ladders and 3-cycles\n\njulia> writenewick(net)\n\"((S9,((((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2,S8)),(#H2,S10));\"\n\njulia> nni!(undoinfo...);\n\njulia> writenewick(net) == str_network # net back to original topology: the NNI was \"undone\"\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.nni!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Public","title":"PhyloNetworks.nni!","text":"nni!(αu::Edge, u::Node, uv::Edge, v::Node, vδ::Edge)\nnni!(αu,u,uv,v,vδ, flip::Bool, inner::Bool, indices)\n\nTransform a network locally around the focus edge uv with the following NNI, that detaches u-β and grafts it onto vδ:\n\nα - u -- v ------ δ\n    |    |\n    β    γ\n\nα ------ v -- u - δ\n         |    |\n         γ    β\n\nflip boolean indicates if the uv edge was flipped inner boolean indicates if edges αu and uv both point toward node u, i.e. α->u<-v<-δ. If this is true, we flip the hybrid status of αu and vδ.\n\nindices give indices for nodes and edges uinαu, αuinu, vδinv, and vinvδ. These are interpreted as:\n\nu_in_αu: the index for u in the edge αu\nαu_in_u: the index for αu in node u\nvδ_in_v: the index for vδ in node v\nv_in_vδ: the index for v in edge vδ\n\nWarnings:\n\nNo check of assumed adjacencies\nNot implemented for cases that are not necessary thanks to symmetry, such as cases covered by nni!(vδ, v, uv, u, αu) or nni!(βu, u, v, vγ). More specifically, these cases are not implemented (and not checked):\nu not hybrid & v hybrid\nu hybrid, v not hybrid, α -> u <- v -> δ\nBecause of this, nni(αu,u,uv,v,vδ, ...) should not be used directly; use instead nni!(uv, move_number).\nnni!(undoinfo...) restores the topology, but edges below hybrid nodes will have length 0.0 even if they didn't before.\n\nNode numbers and edge numbers are not modified. Edge uv keeps its direction unchanged unless the directions were α -> u -> v -> δ or α <- u <- v <- δ, in which case the direction of uv is flipped.\n\nThe second version's input has the same signature as the output, but will undo the NNI more easily. This means that if output = nni!(input), then nni!(output...) is valid and undoes the first operation.\n\nRight now, branch lengths are not modified except when below a hybrid node. Future versions might implement options to modify branch lengths.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.nni!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, UInt8, Bool, Bool}","page":"Public","title":"PhyloNetworks.nni!","text":"nni!(uv::Edge, nummove::UInt8, nohybridladder::Bool, no3cycle::Bool)\n\nModify a network with a nearest neighbor interchange (NNI) around its edge uv. Return the information necessary to undo the NNI, or nothing if the move was not successful (such as if the resulting graph was not acyclic (not a DAG) or if the focus edge is adjacent to a polytomy). If the move fails, the network is not modified. nummove specifies which of the available NNIs is performed.\n\nrooted-NNI options according to Gambette et al. (2017), fig. 8:\n\nBB: 2 moves, both to BB, if directed edges. 8 moves if undirected.\nRR: 2 moves, both to RR.\nBR: 3 moves, 1 RB & 2 BRs, if directed. 6 moves if e is undirected.\nRB: 4 moves, all 4 BRs.\n\nThe extra options are due to assuming a semi-directed network, whereas Gambette et al (2017) describe options for rooted networks. On a semi-directed network, there might be a choice of how to direct the edges that may contain the root, e.g. choice of e=uv versus vu, and choice of labelling adjacent nodes as α/β (BB), or as α/γ (BR).\n\nnohybridladder = true prevents moves that would create a hybrid ladder in the network, that is, 2 consecutive hybrid nodes (one parent of the other). no3cycle = true prevents NNI moves that would make a 3-cycle, and assumes that the input network does not have any 2- or 3-cycles. If no3cycle is false, 3-cycles can be generated, but NNIs generating 2-cycles are prevented.\n\nThe edge field ischild1 is assumed to be correct in the overall network (that is, in sync with the network's field .rooti).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.pairwisetaxondistancematrix-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.pairwisetaxondistancematrix","text":"pairwisetaxondistancematrix(net; keepInternal=false,\n                            checkpreorder=true, nodeAges=[])\npairwisetaxondistancematrix!(M, net, nodeAges)\n\nReturn the matrix M of pairwise distances between nodes in the network:\n\nbetween all nodes (internal and leaves) if keepInternal=true, in which case the nodes are listed in M in the order in which they appear in net.vec_node\nbetween taxa only otherwise, in which case the nodes are listed in M in the order in which they appear in tiplabels(net) (i.e. same order as in net.leaf)\n\nThe second form modifies M in place, assuming all nodes.\n\nThe distance between the root and a given hybrid node (to take an example) is the weighted average of path lengths from the root to that node, where each path is weighted by the product of γs of all edges on that path. This distance measures the average genetic distance across the genome, if branch lengths are in substitutions/site.\n\noptional arguments:\n\ncheckpreorder: if true, net.vec_node is updated to get a topological ordering of nodes.\nnodeAges: if not provided, i.e. empty vector, the network is not modified.   If provided and non-empty, nodeAges should list node ages in the pre-order in which nodes are listed in vec_node (including leaves), and edge lengths in net are modified accordingly.\n\nProviding node ages hence makes the network time consistent: such that all paths from the root to a given hybrid node have the same length. If node ages are not provided, the network need not be time consistent.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.parsimonyGF-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}, Tuple{HybridNetwork, Dict{String, T}, Symbol}} where T","page":"Public","title":"PhyloNetworks.parsimonyGF","text":"parsimonyGF(net, tip_dictionary, criterion=:softwired)\nparsimonyGF(net, species, sequenceData, criterion=:softwired)\n\nCalculate the most parsimonious score of a network given discrete characters at the tips using a general framework (Van Iersel et al. 2018) allowing for various parsimony criteria: softwired (default), hardwired, parental etc. Only softwired is implemented at the moment.\n\nData can given in one of the following:\n\ntipdata: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named \"taxon\" or \"species\", and  trait values are to appear in column 2 or in a column named \"trait\".\ntipdata: dictionary taxon => state, for a single trait.\nspecies: array of strings, and sequences: array of sequences,   in the order corresponding to the order of species names.\n\nalgorithm\n\nThe complexity of the algorithm is exponential in the level of the network, that is, the maximum number of hybridizations in a single blob, or biconnected component (Fischer et al. 2015). The function loops over all the state assignments of the minor parent of each hybrid node within a blob, so its complexity is of the order of n * m * c^2 * c^level where n is the number of tips, m the number of traits and c the number of states.\n\nSee parsimonysoftwired for a faster algorithm, but solving the softwired criterion only.\n\nreferences\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\nUse the recursive helper function parsimonyGF_bottomup!. Use the fields ischild1, booln4 to know which nodes are at the root of a blob, and boole2 to know which edges are cut (below the minor parent of each hybrid).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.parsimonysoftwired-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T","page":"Public","title":"PhyloNetworks.parsimonysoftwired","text":"parsimonysoftwired(net, tipdata)\nparsimonysoftwired(net, species, sequences)\n\nCalculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network.\n\nData can given in one of the following:\n\ntipdata: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named \"taxon\" or \"species\", and  trait values are to appear in column 2 or in a column named \"trait\".\ntipdata: dictionary taxon => state, for a single trait.\nspecies: array of strings, and sequences: array of sequences,  in the order corresponding to the order of species names.\n\nalgorithm\n\nThe dynamic programming algorithm by Fischer et al. (2015) is used. The function loops over all the displayed subtrees within a blob (biconnected component), so its complexity is of the order of n * m * c^2 * 2^level where n is the number of tips, m the number of traits, c the number of states, and level is the level of the network: the maximum number of hybridizations within a blob.\n\nSee parsimonyGF for a different algorithm, slower but extendable to other parsimony criteria.\n\nreferences\n\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.preorder!-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.preorder!","text":"preorder!(net::HybridNetwork)\n\nUpdate attribute net.vec_node in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges' direction needs to be correct before calling preorder!, using directedges!\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.printedges-Tuple{Any}","page":"Public","title":"PhyloNetworks.printedges","text":"printedges(net)\nprintedges(io::IO, net)\n\nPrint information on the edges of a HybridNetwork net: edge number, numbers of nodes attached to it, edge length, whether it's a hybrid edge, its γ inheritance value, whether it's a major edge, if it could contain the root (this field is not always updated, though) and one more attribute pertaining to level-1 networks used in SNaQ: in which cycle it is contained (-1 if no cycle).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.printnodes-Tuple{Any}","page":"Public","title":"PhyloNetworks.printnodes","text":"printnodes(net)\nprintnodes(io, net)\n\nPrint information on the nodes of a HybridNetwork net: node number, whether it's a leaf, whether it's a hybrid node, it's name (label), its intn1 field (for level-1 networks in SNaQ: number given to the cycle in which the node might be, -1 if the node it not in a cycle cycle), and the list of edges attached to it, by their numbers.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.readfastatodna","page":"Public","title":"PhyloNetworks.readfastatodna","text":"readfastatodna(filename::String, countPatterns::Bool=false)\n\nRead a fasta file to a dataframe containing a column for each site. If countPatterns is true, calculate weights and remove identical site patterns to reduce matrix dimension.\n\nReturn a tuple containing:\n\ndata frame of BioSequence DNA sequences, with taxon names in column 1 followed by a column for each site pattern, in columns 2-npatterns;\narray of weights, one weight for each of the site columns. The length of the weight vector is equal to npatterns.\n\nWarning: assumes a semi-sequential format, not interleaved, where each taxon name appears only once. For this one time, the corresponding sequence may be broken across several lines though.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readmultinewick","page":"Public","title":"PhyloNetworks.readmultinewick","text":"readmultinewick(filename::AbstractString, fast=true)\nreadmultinewick(newicktrees_list::Vector{<:AbstractString})\n\nRead a list of networks in parenthetical format, either from a file (one network per line) if the input is a string giving the path to the file, or from a vector of strings with each string corresponding to a newick-formatted topology. By default (fast=true), Functors.fmap is used for repeatedly reading the newick trees into of HybridNetwork-type objects. The option fast=false corresponds to the behavior up until v0.14.3: with a file name as input, it prints a message (without failing) when a phylogeny cannot be parsed, and allows for empty lines. Each network is read with readnewick.\n\nReturn an array of HybridNetwork objects.\n\nExamples\n\njulia> multitreepath = joinpath(dirname(Base.find_package(\"PhyloNetworks\")), \"..\", \"examples\", \"multitrees.newick\");\njulia> multitree = readmultinewick(multitreepath) # vector of 25 HybridNetworks\njulia> multitree = readmultinewick(multitreepath, false) # same but slower & safer\njulia> treestrings = readlines(multitreepath) # vector of 25 strings\njulia> multitree = readmultinewick(treestrings)\njulia> readmultinewick(treestrings, false) # same, but slower\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readmultinewick_files-Tuple{AbstractString}","page":"Public","title":"PhyloNetworks.readmultinewick_files","text":"readmultinewick_files(listfile; relative2listfile=true)\n\nRead the list of file names in listfile, then read all the trees in each of these files. Output: vector of vectors of trees (networks with h>0 allowed).\n\nlistfile should be the name of a file containing the path/name to multiple bootstrap files, one on each line (no header). Each named bootstrap file should contain multiple trees, one per line (such as bootstrap trees from a single gene).\n\nThe path/name to each bootstrap file should be relative to listfile. Otherwise, use option relative2listfile=false, in which case the file names are interpreted as usual: relative to the user's current directory if not given as absolute paths.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.readnewick-Tuple{AbstractString}","page":"Public","title":"PhyloNetworks.readnewick","text":"readnewick(file name)\nreadnewick(parenthetical description)\nreadnewick(IO)\n\nRead tree or network topology from parenthetical format (extended Newick). If the root node has a single child: ignore (i.e. delete from the topology) the root node and its child edge.\n\nInput: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description. Nexus-style comments ([&...]) are ignored, and may be placed after (or instead) of a node name, and before/after an edge length.\n\nA root edge, not enclosed within a pair a parentheses, is ignored. If the root node has a single edge, this one edge is removed.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.readnexus_treeblock","page":"Public","title":"PhyloNetworks.readnexus_treeblock","text":"readnexus_treeblock(filename, treereader=readnewick, args...;\n                    reticulate=true, stringmodifier=[r\"#(\\d+)\" => s\"#H\\1\"])\n\nRead the first \"trees\" block of a nexus-formatted file, using the translate table if present, and return a vector of HybridNetworks. Information inside [&...] are interpreted as comments and are discarded by the default tree reader. Optional arguments args are passed to the tree reader.\n\nFor the nexus format, see Maddison, Swofford & Maddison (1997).\n\nUnless reticulate is false, the following is done to read networks with reticulations.\n\nPrior to reading each phylogeny, each instance of #number is replaced by #Hnumber to fit the standard extended Newick format at hybrid nodes. This behavior can be changed with option stringmodifier, which should be a vector of pairs accepted by replace.\n\nInheritance γ values are assumed to be given within \"comment\" blocks at minor hybrid edges (cut as tips to form the extended Newick) like this for example, as output by bacter (Vaughan et al. 2017):\n\n#11[&conv=0, relSize=0.08, ...\n\nor like this, as output by SpeciesNetwork (Zhang et al. 2018):\n\n#H11[&gamma=0.08]\n\nIn this example, the corresponding edge to hybrid H11 has γ=0.08.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.removedegree2nodes!","page":"Public","title":"PhyloNetworks.removedegree2nodes!","text":"removedegree2nodes!(net::HybridNetwork, keeproot::Bool=false)\n\nDelete all nodes of degree two in net, fusing the two adjacent edges together each time, and return the network. If the network has a degree-2 root and keeproot is false, then the root is eliminated as well, leaving the network unrooted. The only exception to this rule is if the root is incident to 2 (outgoing) hybrid edges. Removing the root should leave a loop-edge (equal end point), which we don't want to do, to preserve the paths in the original network. In this case, the root is maintained even if keeproot is false. If keeproot is true, then the root is kept even if it's of degree 2.\n\nSee fuseedgesat!.\n\njulia> net = readnewick(\"(((((S1,(S2)#H1),(#H1,S3)))#H2),(#H2,S4));\");\n\njulia> PhyloNetworks.breakedge!(net.edge[3], net); # create a degree-2 node along hybrid edge\n\njulia> PhyloNetworks.breakedge!(net.edge[3], net); # another one: 2 in a row\n\njulia> PhyloNetworks.breakedge!(net.edge[10], net); # another one, elsewhere\n\njulia> writenewick(net) # extra pairs of parentheses\n\"((#H2,S4),(((((S1,(((S2)#H1))),(#H1,S3)))#H2)));\"\n\njulia> removedegree2nodes!(net);\n\njulia> writenewick(net) # even the root is gone\n\"(#H2,S4,(((S1,(S2)#H1),(#H1,S3)))#H2);\"\n\njulia> net = readnewick(\"((((C:0.9)I1:0.1)I3:0.1,((A:1.0)I2:0.4)I3:0.6):1.4,(((B:0.2)H1:0.6)I2:0.5)I3:2.1);\");\n\njulia> removedegree2nodes!(net, true);\n\njulia> writenewick(net, round=true) # the root was kept\n\"((C:1.1,A:2.0):1.4,B:3.4);\"\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.rootatnode!-Tuple{HybridNetwork, PhyloNetworks.Node}","page":"Public","title":"PhyloNetworks.rootatnode!","text":"rootatnode!(HybridNetwork, nodeNumber::Integer; index::Bool=false)\nrootatnode!(HybridNetwork, Node)\nrootatnode!(HybridNetwork, nodeName::AbstractString)\n\nRoot the network/tree object at the node with name 'nodeName' or number 'nodeNumber' (by default) or with index 'nodeNumber' if index=true. Attributes ischild1 and containroot are updated along the way. Use plot(net, shownodenumber=true, showedgelength=false) to visualize and identify a node of interest. (see package PhyloPlots)\n\nReturn the network.\n\nWarnings:\n\nIf the node is a leaf, the root will be placed along the edge adjacent to the leaf. This might add a new node.\nIf the desired root placement is incompatible with one or more hybrids, then\nthe original network is restored with its old root and edges' direction.\na RootMismatch error is thrown.\n\nSee also: rootonedge!.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.rootonedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Public","title":"PhyloNetworks.rootonedge!","text":"rootonedge!(HybridNetwork, edgeNumber::Integer; index::Bool=false)\nrootonedge!(HybridNetwork, Edge)\n\nRoot the network/tree along an edge with number edgeNumber (by default) or with index edgeNumber if index=true. Attributes ischild1 and containroot are updated along the way.\n\nThis adds a new node and a new edge to the network. Use plot(net, showedgenumber=true, showedgelength=false) to visualize and identify an edge of interest. (see package PhyloPlots)\n\nSee also: rootatnode!.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.rotate!-Tuple{HybridNetwork, Integer}","page":"Public","title":"PhyloNetworks.rotate!","text":"rotate!(net::HybridNetwork, nodeNumber::Integer; orderedEdgeNum::Array{Int,1})\n\nRotates the order of the node's children edges. Useful for plotting, to remove crossing edges. If node is a tree node with no polytomy, the 2 children edges are switched and the optional argument orderedEdgeNum is ignored.\n\nUse plot(net, shownodenumber=true, showedgenumber=false) to map node and edge numbers on the network, as shown in the examples below. (see package PhyloPlots)\n\nWarning: assumes that edges are correctly directed (ischild1 updated). This is done by plot(net). Otherwise run directedges!(net).\n\nExample\n\njulia> net = readnewick(\"(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\");\njulia> using PhyloPlots\njulia> plot(net, shownodenumber=true)\njulia> rotate!(net, -4)\njulia> plot(net)\njulia> net=readnewick(\"(4,((1,(2)#H7:::0.864):2.069,(6,5):3.423):0.265,(3,#H7:::0.136):10.0);\");\njulia> plot(net, shownodenumber=true, showedgenumber=true)\njulia> rotate!(net, -1, orderedEdgeNum=[1,12,9])\njulia> plot(net, shownodenumber=true, showedgenumber=true)\njulia> rotate!(net, -3)\njulia> plot(net)\n\nNote that LinearAlgebra also exports a function named rotate! in Julia v1.5. If both packages need to be used in Julia v1.5 or higher, usage of rotate! needs to be qualified, such as with PhyloNetworks.rotate!.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.setgamma!","page":"Public","title":"PhyloNetworks.setgamma!","text":"setgamma!(Edge, new γ, change_other=true)\n\nSet inheritance probability γ for an edge, which must be a hybrid edge. The new γ needs to be in [0,1]. The γ of the \"partner\" hybrid edge is changed accordingly, to 1-γ. The field ismajor is also changed accordingly. If the new γ is approximately 0.5, Edge is set to the major parent, its partner is set to the minor parent.\n\nIf net is a HybridNetwork object, printedges(net) will show the list of edges and their γ's. The γ of the third hybrid edge (say) can be changed to 0.2 with setgamma!(net.edge[3],0.2). This will automatically set γ of the partner hybrid edge to 0.8.\n\nThe last argument is true by default. If false: the partner edge is not updated. This is useful if the new γ is 0.5, and the partner's γ is already 0.5, in which case the ismajor attributes can remain unchanged.\n\nSee also PhyloNetworks.setmultiplegammas!\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.setlength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Any}","page":"Public","title":"PhyloNetworks.setlength!","text":"setlength!(edge::Edge, new_length)\n\nAssign new length to edge. new_length should be non-negative, or missing (or -1, interpreted as missing).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.setlengths!-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}","page":"Public","title":"PhyloNetworks.setlengths!","text":"setlengths!(edges::Vector{Edge}, lengths::AbstractVector)\n\nAssign new lengths to a vector of edges. Checks that the new edge lengths are non-negative or missing (or -1 to be interpreted as missing).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.sharedpathmatrix-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.sharedpathmatrix","text":"sharedpathmatrix(net::HybridNetwork; checkpreorder::Bool=true)\n\nMatrix Ω of shared path lengths from the root to a pair of nodes, for all pairs of nodes in network net. This is the covariance under a Brownian motion model, returned as a data frame by vcv. The network is assumed to be pre-ordered if checkpreorder is false. If checkpreorder is true (default), preorder! is run on the network beforehand.\n\nReturns an object of type MatrixTopologicalOrder.\n\nSee also descendenceweight, which returns a matrix P independent of edge lengths. P only depends on the network topology and γ. Then Ω = PDP' where D is a diagonal matrix with the network's edge lengths on its diagonal.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.shrink2cycles!","page":"Public","title":"PhyloNetworks.shrink2cycles!","text":"shrink2cycles!(net::HybridNetwork, unroot::Bool=false)\n\nIf net contains a 2-cycle, collapse the cycle into one edge of length tA + γt1+(1-γ)t2 + tB (see below), and return true. Return false otherwise. A 2-cycle is a set of 2 parallel hybrid edges, from the same parent node to the same hybrid child node.\n\n       A                A\n       | tA             |\n     parent             |\n       | \\              |\nt2,1-γ |  | t1,γ        | tA + γ*t1 + (1-γ)*t2 + tB\n       | /              |\n     hybrid             |\n       | tB             |\n       B                B\n\nIf any of the lengths or gammas associated with a 2-cycle are missing, the combined length is missing. If γ is missing, branch lengths are calculated using γ=0.5.\n\nIf unroot is false and the root is up for deletion, it will be kept only if it is has degree 2 or more. If unroot is true and the root is up for deletion, it will be kept only if it has degree 3 or more. A root node with degree 1 will be deleted in both cases.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.shrink3cycles!","page":"Public","title":"PhyloNetworks.shrink3cycles!","text":"shrink3cycles!(net::HybridNetwork, unroot::Bool=false)\n\nRemove all 2- and 3-cycles from a network.\n\nReturn true if net contains a 2-cycle or a 3-cycle; false otherwise. A 3-cycle (2-cycle) is a set of 3 (2) nodes that are all connected. One of them must be a hybrid node, since net is a DAG.\n\nIf unroot is false and the root is up for deletion, it will be kept only if it is has degree 2 or more. If unroot is true and the root is up for deletion, it will be kept only if it has degree 3 or more. A root node with degree 1 will be deleted in both cases.\n\nSee shrink3cycleat! for details on branch lengths and inheritance values.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.tablequartetCF-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{<:AbstractString}}} where T<:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}","page":"Public","title":"PhyloNetworks.tablequartetCF","text":"tablequartetCF(quartetlist::Vector{QuartetT} [, taxonnames];\n               keepQwithoutgenes=true, colnames=nothing)\n\nConvert a vector of QuartetT objects to a table with 1 row for each four-taxon set in the list. Each four-taxon set contains quartet data of some type (vector of length 3 or 4, or 3×n matrix), which determines the number of columns in the table (3, 4, or 3n). The first 3 columns are named \"CF1234\", \"CF1324\", \"CF14_23\", unless the full list of column names is provided in colnames. See tablequartetdata for details.\n\nThe output is a NamedTuple, to which we can apply common table operations as a Table.jl-compatible source. It can easily be converted to other table formats such as a DataFrame.\n\nSee countquartetsintrees for examples.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.tablequartetf4-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{<:AbstractString}}} where T<:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}","page":"Public","title":"PhyloNetworks.tablequartetf4","text":"tablequartetf4(quartetlist::Vector{QuartetT} [, taxonnames];\n               keepQwithoutgenes=true, colnames=nothing)\n\nConvert a vector of QuartetT objects to a table with 1 row for each four-taxon set in the list. Each four-taxon set contains quartet data of some type (vector of length 3 or 4, or 3×n matrix), which determines the number of columns in the table (3, 4, or 3n). The first 3 columns are named \"f41234\", \"f41342\" and \"f41423\", unless the full list of column names is provided in colnames. See tablequartetdata for details.\n\nThe output is a NamedTuple, to which we can apply common table operations as a Table.jl-compatible source. It can easily be converted to other table formats such as a DataFrame.\n\nSee countquartetsintrees for examples.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.tiplabels-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.tiplabels","text":"tiplabels(x)\n\nVector of taxon names at the leaves, defined for objects of various types: HybridNetwork, MatrixTopologicalOrder.\n\nFor a network, the taxon names are coerced to strings.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.treeedgecomponents-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.treeedgecomponents","text":"treeedgecomponents(net::HybridNetwork)\n\nReturn the tree-edge components of the semidirected network as a membership dictionary Node => Int. Nodes with the same membership integer value are in the same tree-edge component. The tree-edge components of a network are the connected components of the network when all hybrid edges are removed.\n\nA RootMismatch error is thrown if there exists a cycle in any of the tree-edge components, or if a tree-edge component has more than one \"entry\" hybrid node.\n\nWarnings:\n\nsince Nodes are mutable, the network should not be modified until usage of the output membership dictionary is over.\nthe component IDs are not predicable, but will be consecutive integers from 1 to the number of components.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.treeedges_support-Tuple{Vector{HybridNetwork}, HybridNetwork}","page":"Public","title":"PhyloNetworks.treeedges_support","text":"treeedges_support(sample_net::Vector{HybridNetwork}, ref_net::HybridNetwork)`\n\nRead a sample of networks sample_net (such as a bootstrap sample or a posterior sample) and a reference network (ref_net), and calculate the support for the tree edges in the reference network. All minor hybrid edges (γ<0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.\n\noutput:\n\na data frame with one row per tree edge and two columns: edge number, bootstrap support (as a percentage)\nthe major tree from the reference network, where minor hybrid edges (with γ<0.5) have been removed.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.treeofblobs-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.treeofblobs","text":"treeofblobs(net::HybridNetwork; preorder::Bool=true, preprocess::Bool=true)\n\nTree of blobs for net. This tree is obtained from the network by shrinking any blob (2-edge connected component) that is not trivial (more than 1 edge) into a single node. The remaining edges are cut-edges (or bridges): they disconnect the network if removed. After shrinking blobs, only these cut-edges remain (with their edge length if any) and the graph forms a tree: the tree-of-blobs. It typically has polytomies, and may have degree-2 nodes. See Allman et al. (2022) (on binary networks) and Xu & Ané (2023).\n\nIf the network is binary, each blob is a block (biconnected component). If the network is not binary, then multiple blocks forming a single blob are shrunk into the same node.\n\nThe network is not modified. PhyloNetworks.treeofblobs!(net) modifies net, but is unsafe to use, in the sense that it assumes that the network is already preordered and preprocessed to get its biconnected component.\n\nIn the output tree, the biconnected component information is stored.\n\nArguments:\n\npreorder to direct edges according to the root and store a pre-ordering of nodes in net.vec_node, if not done earlier on the network (e.g. after a topology modification)\npreprocess to recalculate & store the biconnected components with process_biconnectedcomponents!, assuming the preordering was done.\n\nexamples\n\nIn this first example, the network is binary (no polytomies of any kind) and has 2 blobs.\n\njulia> net = readnewick(\"((S1:0.1,(((S2,(S3)#H1),(#H1,S4:0.4)):0.2)#H2:0.2),(#H2,S5));\");\n\njulia> tob = treeofblobs(net);\n\njulia> writenewick(tob) # 2 polytomies: at root, and to S2,S3,S4\n\"(S5,S1:0.1,(S4:0.4,S2,S3):0.2);\"\n\nNow we use the same network but without the edge connecting the 2 blobs: there are now 2 blocks sharing one node, so 1 blob only.\n\njulia> net = readnewick(\"((S1:0.1,((S2,(S3)#H1),(#H1,S4:0.4))#H2:0.2),(#H2,S5));\");\n\njulia> # using PhyloPlots; plot(net, style=:majortree, arrowlen=0.1);\n\njulia> tob = treeofblobs(net);\n\njulia> writenewick(tob) # star tree: 1 big polytomy\n\"(S5,S1:0.1,S4:0.4,S2,S3);\"\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.vcv-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.vcv","text":"vcv(net::HybridNetwork; model::AbstractString=\"BM\",\n                        corr::Bool=false,\n                        checkpreorder::Bool=true)\n\nThis function computes the variance covariance matrix between the tips of the network, assuming a Brownian model of trait evolution (with unit variance). If optional argument corr is set to true, then the correlation matrix is returned instead.\n\nThe function returns a DataFrame object, with columns named by the tips of the network.\n\nThe calculation of the covariance matrix requires a pre-ordering of nodes to be fast. If checkpreorder is true (default), then preorder! is run on the network beforehand. Otherwise, the network is assumed to be already in pre-order.\n\nThis function internally calls sharedpathmatrix, which computes the variance matrix between all the nodes of the network.\n\nExamples\n\njulia> tree_str = \"(((t2:0.14,t4:0.33):0.59,t3:0.96):0.14,(t5:0.70,t1:0.18):0.90);\";\n\njulia> tree = readnewick(tree_str);\n\njulia> C = vcv(tree)\n5×5 DataFrame\n Row │ t2       t4       t3       t5       t1      \n     │ Float64  Float64  Float64  Float64  Float64 \n─────┼─────────────────────────────────────────────\n   1 │    0.87     0.73     0.14      0.0     0.0\n   2 │    0.73     1.06     0.14      0.0     0.0\n   3 │    0.14     0.14     1.1       0.0     0.0\n   4 │    0.0      0.0      0.0       1.6     0.9\n   5 │    0.0      0.0      0.0       0.9     1.08\n\n\nThe following block needs ape to be installed (not run):\n\njulia> using RCall # Comparison with ape vcv function\n\njulia> R\"ape::vcv(ape::read.tree(text = $tree_str))\"\nRCall.RObject{RCall.RealSxp}\n     t2   t4   t3  t5   t1\nt2 0.87 0.73 0.14 0.0 0.00\nt4 0.73 1.06 0.14 0.0 0.00\nt3 0.14 0.14 1.10 0.0 0.00\nt5 0.00 0.00 0.00 1.6 0.90\nt1 0.00 0.00 0.00 0.9 1.08\n\n\nThe covariance can also be calculated on a network (for the model, see Bastide et al. 2018)\n\njulia> net = readnewick(\"((t1:1.0,#H1:0.1::0.30):0.5,((t2:0.9)#H1:0.2::0.70,t3:1.1):0.4);\");\n\njulia> C = vcv(net)\n3×3 DataFrame\n Row │ t1       t2       t3      \n     │ Float64  Float64  Float64 \n─────┼───────────────────────────\n   1 │    1.5     0.15      0.0\n   2 │    0.15    1.248     0.28\n   3 │    0.0     0.28      1.5\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.writemultinewick-Tuple{Vector{HybridNetwork}, AbstractString}","page":"Public","title":"PhyloNetworks.writemultinewick","text":"writemultinewick(nets, file_name; append=false)\nwritemultinewick(nets, IO)\n\nWrite an array of networks in parenthetical extended Newick format, one network per line. Use the option append=true to append to the file. Otherwise, the default is to create a new file or overwrite it, if it already existed. Each network is written with writenewick.\n\nExamples\n\njulia> net = [readnewick(\"(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10);\"),\n              readnewick(\"(A,(B,C));\"),readnewick(\"(E,F);\"),readnewick(\"(G,H,F);\")];\n\njulia> writemultinewick(net, \"fournets.net\") # to (over)write to file \"fournets.net\"\njulia> writemultinewick(net, \"fournets.net\", append=true) # to append to this file\njulia> writemultinewick(net, stdout)         # to write to the screen (standard out)\n(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10.0);\n(A,(B,C));\n(E,F);\n(G,H,F);\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.writenewick-Tuple{HybridNetwork, AbstractString}","page":"Public","title":"PhyloNetworks.writenewick","text":"writenewick(net)\nwritenewick(net, filename)\nwritenewick(net, IO)\n\nWrite the parenthetical extended Newick format of a network, as a string, to a file or to an IO buffer / stream. Optional arguments (default values):\n\ndi (false): write in format for Dendroscope\nround (false): rounds branch lengths and heritabilities γ\ndigits (3): digits after the decimal place for rounding\nappend (false): if true, appends to the file\ninternallabel (true): if true, writes internal node labels\n\nIf the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.\n\nUses lower-level function writesubtree!.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.writesubtree!-NTuple{5, Any}","page":"Public","title":"PhyloNetworks.writesubtree!","text":"writesubtree!(IO, node, edge, dendroscope::Bool, namelabel::Bool,\n              round_branch_lengths::Bool, digits::Integer, internallabel::Bool)\n\nWrite the extended newick format of the sub-network rooted at node and assuming that edge is a parent of node.\n\nIf the parent edge is nothing, the edge attribute ischild1 is used and assumed to be correct to write the subtree rooted at node. This is useful to write a subtree starting at a non-root node. Example:\n\nnet = readnewick(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\")\ndirectedges!(net)\ns = IOBuffer()\nwritesubtree!(s, net.node[7], nothing, false, true)\nString(take!(s))\n\nUsed by writenewick.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.writesubtree!-Tuple{IO, HybridNetwork, Bool, Bool, Bool, Integer, Bool}","page":"Public","title":"PhyloNetworks.writesubtree!","text":"writesubtree!(IO, network, dendroscope::Bool, namelabel::Bool,\n              round_branch_lengths::Bool, digits::Integer,\n              internallabel::Bool)\n\nWrite to IO the extended newick format (parenthetical description) of a network. If written for dendroscope, inheritance γ's are not written. If namelabel is true, taxa are labelled by their names; otherwise taxa are labelled by their number IDs. If unspecified, branch lengths and γ's are rounded to 3 digits. Use internallabel=false to suppress the labels of internal nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.HybridNetwork","page":"Public","title":"PhyloNetworks.HybridNetwork","text":"HybridNetwork\n\nSubtype of abstract Network type. Explicit network or tree with the following attributes:\n\nnumtaxa: number of taxa, that is, number of are leaves (or tips). Leaves are required to be attached to a single edge.\nnumnodes: total number of nodes: tips and internal nodes\nnumedges: total number of edges\nnumhybrids: total number of hybrid nodes\nedge: vector of Edges\nnode: vector of Nodes\nrooti: index of the root in vector 'node'. May be artificial in a semidirected network, but is necessary for printing and traversal purposes.\nhybrid: vector of Nodes: those are are hybrid nodes\nleaf: vector of Nodes: those that are leaves\nfscore: score after fitting network to data, i.e. parsimony score, or multipe of the negative log pseudodeviance for SNaQ\nisrooted: true or false\npartition: vector of Partition\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#index","page":"Public","title":"index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"man/expecteddata/#Pairwise-and-quartet-data","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"","category":"section"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"We show here some functionalities to calculate dissimilarities or distances between taxa, either expected from a given network, or observed in data. To calculate expectations under a network, this network's edges need to have branch lengths and γ inheritance values.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"We use 2 example networks in this section: net0 without reticulations (a tree) and net2 with 2 reticulations. net0 is in fact net2's major tree: obtained by deleting every minor hybrid edge.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"net0 = readnewick(\"(O:5.5,((E:4.0,(D:3.0,(C:1.0,B:1.0):2.0):1.0):1.0,A:5.0):0.5);\");\nnet2 = readnewick(\"(O:5.5,(((E:1.5)#H1:2.5::0.7,((#H1:0,D:1.5):1.5,\n    ((C:1,B:1):1)#H2:1::0.6):1.0):1.0,(#H2:0,A:2):3):0.5);\")\nnothing # hide","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"(Image: net02-distquartet)","category":"page"},{"location":"man/expecteddata/#average-pairwise-distance","page":"Pairwise and quartet data","title":"average pairwise distance","text":"","category":"section"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"One distance between pairs of taxa, say between t1 and t2, is the average length of all \"up-down\" paths in the network to go from t1 to t2 (see Xu & Ané 2023 for example). In a tree, there is a single such path: going up from t1 to their most recent common ancestor, then down to t2. In a general network, there can be multiple paths. Each path has an inheritance weight: the product of the inheritance γ's of all edges in the path. Under a simple model, this is the proportion of genetic material that took this path. The average distance between t1 and t2 is the weighted average of these paths' lengths, weighted by the paths' inheritance.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"It can be calculated with pairwisetaxondistancematrix. On our tree net0, we get this:","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"aveD_net0 = pairwisetaxondistancematrix(net0)","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"The order of rows and columns in this matrix is the same as given by tiplabels. For example, we can convert the distance matrix aveD_net0 to a data frame with a column named for each taxon like this.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"taxonlist0 = tiplabels(net0)\nusing DataFrames\nDataFrame(aveD_net0, taxonlist0)","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"Using the network net2, we see that its reticulations bring E closer to D; and bring B & C closer to A (and away from D & E since A is distant from them):","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"aveD_net2 = pairwisetaxondistancematrix(net2);\ntaxonlist2 = tiplabels(net2);\nDataFrame(aveD_net2, taxonlist2)","category":"page"},{"location":"man/expecteddata/#hamming-distance","page":"Pairwise and quartet data","title":"hamming distance","text":"","category":"section"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"To calculate pairwise distances observed in data, such as along a DNA alignment across multiple sites, we can use PhyloNetworks.hammingdistancematrix.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"dna_data = [\n    ['T','G','T','A','G'], # taxon 1\n    ['T','G','A','A','G'],\n    ['T','G','A','A','C'],\n    ['T','G','A',missing,missing],\n    ['T','G','A','T','C'], # taxon 5\n];\nd = PhyloNetworks.hammingdistancematrix(dna_data)","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"Perhaps we want to give weights to each trait, such as if an alignment is summarized by keeping each site pattern once, weighted by the number of sites having this pattern:","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"site_count = [3,2,1,1,1]; # invariable site patterns have higher counts\nd = PhyloNetworks.hammingdistancematrix(dna_data, site_count)","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"A Jukes-Cantor correction can be applied with PhyloNetworks.distancecorrection_JC!:","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"PhyloNetworks.distancecorrection_JC!(d, 4) # 4 states","category":"page"},{"location":"man/expecteddata/#expected-f2-statistics","page":"Pairwise and quartet data","title":"expected f2-statistics","text":"","category":"section"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"The f2-statistic gives another measure of dissimilarity between pairs of taxa. The expected value of f2 between taxa t₁ and t₂ is","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"f_2(t_1 t_2) = E(X(t_1) - X(t_2))^2","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"under a Brownian motion model for trait X evolving along the network, where X(t₁) and X(t₂) are the values of X for taxa t₁ and t₂.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"In the network, branch lengths measures units of drifts when the data X are allele frequencies, and with a variance factor dependent on the allele frequency at the root. For background, see for example Patterson et al. 2012 or Lipson 2020.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"If the network is a tree, then this is exactly the average distance (or simply, the length of the unique path) between t₁ and t₂.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"It can be calculated with expectedf2matrix. On our tree net0, we get an f2 matrix equal to the average distance matrix:","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"f2D_net0 = expectedf2matrix(net0)\nf2D_net0 == aveD_net0","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"Again, taxa are listed along rows and along columns in the same order as listed by tiplabels().   On our network net2, the f2 and average distances differ:","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"f2D_net2 = expectedf2matrix(net2);\nDataFrame(f2D_net2, taxonlist2)","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"In particular, we see that divergences between the outgroup O and tips B, C and E decrease because of the reticulations.","category":"page"},{"location":"man/expecteddata/#expected-f4-statistics","page":"Pairwise and quartet data","title":"expected f4-statistics","text":"","category":"section"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"The f4-statistic gives a measure of dissimilarity between quartets of taxa. The expected value of f4 between taxa t₁, t₂, t₃ and t₄ is","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"f_4(t_1 t_2 t_3 t_4) = E(X(t_2) - X(t_1))(X(t_4) - X(t_3))","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"under a Brownian motion model for trait X evolving along the network, where X(tᵢ) is the values of X for taxa tᵢ.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"There are 4! = 24 f4 statistics relating 4 taxa, but all can be computed using only 2 of them, using the symmetries such as: f_4(t_1 t_2 t_3 t_4) = - f_4(t_1 t_2 t_4 t_3); f_4(t_1 t_2 t_3 t_4) = f_4(t_3 t_4 t_1 t_2) and","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"f_4(t_1 t_2 t_3 t_4) + f_4(t_1 t_3 t_4 t_2) + f_4(t_1 t_4 t_2 t_3) = 0","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"The f4-statistics can be used to capture tree-likeness, as on a tree with no reticulation and quartet topology t₁t₂|t₃t₄, the 4-points condition writes:","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"f_4(t_1 t_2 t_3 t_4) = 0\nquad\ntextand\nquad\nf_4(t_1 t_4 t_2 t_3) = - f_4(t_1 t_3 t_4 t_2)  0","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"For background, see again for example Patterson et al. 2012 or Lipson 2020.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"The f4-statistics expected from a network can be calculated with expectedf4table.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"f4,t = expectedf4table(net0);\nt # taxa, but ordered alphabetically: not as in tiplabels(net0)\nfirst(f4,2) # first 2 4-taxon sets, each with 3 quartet f4s","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"The taxon numbers above are indices in the taxon list t. Here is a way to print all f4 statistics expected from our tree net0:","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"for q in f4\n    println(join(t[q.taxonnumber],\",\") * \": \" * string(round.(q.data, sigdigits=2)))\nend","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"For each set of 4 taxa,  the following f4 statistics are computed: f4(t1, t2; t3, t4), f4(t1, t3; t4, t2) and f4(t1, t4; t2, t3), so that they sum up to 0 as recalled above.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"On a tree with a split t1,t2|t4,t5, the corresponding f4 value should be 0, and the other 2 should give ± the length of the internal path separating the 2 groups of 2 taxa. (Again, the branch lengths unit depends on the data being considered.)","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"Here for example, the first 4-taxon set is A,B,C,D. In our tree, BC is a clade, separated from AD by a branch of length 2. Accordingly, the third f4 value, corresponding to AD|BC, is 0; and the other two f4s are 2 or -2.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"(Image: net02-distquartet-again)","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"We can see how adding reticulations to our tree affects expected f4s. The columns names below indicate the specific order of taxa for each f4. This order matters for the sign.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"f4,t = expectedf4table(net2, showprogressbar=false); # same t: alphabetically\nnt = tablequartetf4(f4, t);\ndf = DataFrame(nt) # convert table to data frame","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"We still have f4=0 on the 3rd column for first taxon set A,B,C,D, because BC are still sister in the network. But the last taxon set for example, C,D,E,O, has no 0 values of f4 due to the reticulation between ancestors of D and E: in the subnetwork for C,D,E,O, there is a cycle of 4 edges.","category":"page"},{"location":"man/expecteddata/#expected-f3-statistics","page":"Pairwise and quartet data","title":"expected f3-statistics","text":"","category":"section"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"The f3-statistics can give a measure of similarity between pairs of taxa, relative to a given reference taxon tₒ. Using the same notations as above, the expected value of f3 between taxa t₁ and t₂ is:","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"f_3(t_o t_1 t_2) = E(X(t_o) - X(t_1))(X(t_o) - X(t_2))","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"We may calculate f3 statistics expected from a network using PhyloNetworks.expectedf3matrix. Here we use the outgroup O as a reference taxon:","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"f3_net2 = PhyloNetworks.expectedf3matrix(net2, \"O\");\nDataFrame(f3_net2, taxonlist2)","category":"page"},{"location":"man/expecteddata/#quartet-concordance-factors","page":"Pairwise and quartet data","title":"quartet concordance factors","text":"","category":"section"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"The concordance factor of a quartet ab|cd is the proportion of the genome whose genealogy has this unrooted topology.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"Tools to calculate quartet concordance factors expected from a network under the coalescent model are provided in package QGoF: see its documentation about expected concordance factors.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"To calculate quartet concordance factors observed in data, one option is to count the number of gene trees that display each quartet, using countquartetsintrees and tablequartetCF.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"In the example below, the 4th gene tree is missing taxon A, and the 6th gene tree has a polytomies (unresolved ABE clade), such as if a branch of low support was collapsed. The number of genes underlying each quartet is captured in the table below.","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"sixgenetrees_nwk = [\n  \"(E,((A,B),(C,D)),O);\",\"(((A,B),(C,D)),(E,O));\",\"(A,B,((C,D),(E,O)));\",\n  \"(B,((C,D),(E,O)));\",\"((C,D),(A,(B,E)),O);\",\"((C,D),(A,B,E),O);\"];\ngenetrees = readnewick.(sixgenetrees_nwk);\nq,t = countquartetsintrees(genetrees, showprogressbar=false);\ndf = tablequartetCF(q,t) |> DataFrame","category":"page"},{"location":"man/expecteddata/","page":"Pairwise and quartet data","title":"Pairwise and quartet data","text":"If low-support branches are not collapsed, this counting method does not account for gene tree estimation error. (It biases concordance factors towards 1/3 for each resolution of a 4-taxon tree: lack of knowledge is mistaken as lack of concordance). Estimation error can be accounted for in a Bayesian framework: see PhyloUtilities for a pipeline.","category":"page"},{"location":"man/dist_reroot/#Comparing-and-manipulating-networks","page":"Network comparison and manipulation","title":"Comparing and manipulating networks","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Examples below use networks available from the package. We can load them as follows. astraltree is a tree estimated using ASTRAL, net0 is a network estimated using SNaQ under the constraint of 0 reticulation, so it's also a tree, and net1 is a network estimated under the constraint of 1 reticulation, so not a tree.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"All of them are to be interpreted as semidirected networks, because their root is not identifiable by the method used to estimate them. This affects how we want them.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"astralfile = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"astral.tre\")\nastraltree = readmultinewick(astralfile)[102] # 102th tree = last tree here\nnet0 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net0.out\"))\nnet1 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net1.out\"))\nnothing # hide","category":"page"},{"location":"man/dist_reroot/#Robinson-Foulds-distance-for-trees","page":"Network comparison and manipulation","title":"Robinson-Foulds distance for trees","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Do the 2 trees astraltree and net0 have the same topology, unrooted? We can calculate the Robinson-Foulds distance between them, using a function that extends the Robinson-Foulds distance to general networks (more on this below).","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"hardwiredclusterdistance(astraltree, net0, false)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"The last option false is to consider topologies as unrooted. The RF distance is 0, so the two unrooted topologies are the same. If we had considered them as rooted, with whatever root they currently have in their internal representation, we would find a difference:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"hardwiredclusterdistance(astraltree, net0, true)","category":"page"},{"location":"man/dist_reroot/#Re-rooting-trees-and-networks","page":"Network comparison and manipulation","title":"Re-rooting trees and networks","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can re-root our networks with the outgroup, O, and then re-compare the ASTRAL tree and the SNaQ tree as rooted topologies (and find no difference):","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"rootatnode!(astraltree, \"O\")\nrootatnode!(net0, \"O\")\nhardwiredclusterdistance(astraltree, net0, true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"using PhyloPlots, RCall\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\"\nR\"svg(name('net0_O.svg'), width=4, height=4)\"\nR\"par\"(mar=[0,0,0,0])\nplot(net0);\nR\"dev.off()\"\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: net0_O)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Note that we use the possibilities of RCall to save the plot. We only show these commands once, but they will be run behind the scene each time a plot is called.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"After trees/networks are rooted with a correct outgroup, their visualization is more meaningful.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Networks can be re-rooted at a given node or along a given edge. Get help (type ?) on the functions rootatnode! and rootonedge! for more info. There are examples in the Network support section.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"If the network is plotted with crossing edges, you may identify ways to rotate the children edges at some nodes to untangle some crossing edges. This can be done using the function rotate!. See an example in the Network support section, or type ? then rotate!.","category":"page"},{"location":"man/dist_reroot/#Does-the-root-conflict-with-the-direction-of-a-reticulation?","page":"Network comparison and manipulation","title":"Does the root conflict with the direction of a reticulation?","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"With 1 hybridization or more, the direction of hybrid edges constrain the position of the root. The root cannot be downstream of hybrid edges. Any hybrid node has to be younger than, or of the same age as both of its parents. So time has to flow \"downwards\" of any hybrid node, and the root cannot be placed \"below\" a hybrid node. An attempt to re-root the network at a position incompatible with hybrid edges will fail, with a RootMismatch error. To show an example, let's use the network below. We plotted the edge numbers, because we will want to use them later to place the root.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"net7taxa = readnewick(\"(C,D,((O,(E,#H7:::0.196):0.314):0.664,(((A1,A2))#H7:::0.804,B):10.0):10.0);\")\nR\"svg(name('reroot_net7taxa_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net7taxa, showgamma=true, showedgenumber=true, tipoffset=0.2);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: reroot net7taxa 1)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Let's imagine that A1 and A2 are our outgroups, and we estimated the network above. According to this network, time must flow from the hybrid node towards A1 and A2. So any attempt to reroot the network with A1 as outgroup, or with A2 as outgroup, or with the A clade (on edge 11), will fail with a RootMismatch error:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"rootatnode!(net7taxa, \"A1\"); # ERROR: RootMismatch: non-leaf node 5 had 0 children. ...\nrootatnode!(net7taxa, \"A2\"); # ERROR: RootMismatch (again)\nrootonedge!(net7taxa, 10);   # ERROR: RootMismatch (again)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"In this case, however, it is possible to root the network on either parent edge of the hybrid node. These edges have numbers 12 and 5, based on the plot above. We get these 2 rooted versions of the network:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"R\"svg(name('reroot_net7taxa_2.svg'), width=7, height=4)\"; # hide\nR\"layout(matrix(1:2,1,2))\";\nR\"par\"(mar=[0,0,0.5,0]); # hide\nrootonedge!(net7taxa, 11);\nrotate!(net7taxa, -5)\nplot(net7taxa, showgamma=true, tipoffset=0.2, shownodenumber=true);\nR\"mtext\"(\"rooted on hybrid edge 11 (major)\", line=-1)\nrootonedge!(net7taxa, 5);\nplot(net7taxa, showgamma=true, tipoffset=0.2);\nR\"mtext\"(\"rooted on hybrid edge 5 (minor)\", line=-1);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: reroot net7taxa 2)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"On the second plot, the A clade does not appear to be an outgroup, but this is just because the plot follows the major tree primarily, based the major hybrid edges (those with γ>0.5). We can display the exact same network differently, by changing the γ inheritance values to invert the major/minor consideration of the hybrid edges.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"net7taxa.edge[5] # just to check that it's one of the 2 hybrid edges of interest\nsetgamma!(net7taxa.edge[5], 0.501) # switch major/minor edges\nR\"svg(name('reroot_net7taxa_3.svg'), width=4, height=4)\"; # hide\nR\"layout(matrix(1,1,1))\"; # hide\nR\"par\"(mar=[0,0,0,0]); # hide\nplot(net7taxa, tipoffset=0.2); # not showing gamma values, because we changed them artificially\nR\"mtext\"(\"rooted on hybrid edge 5 (considered major)\", line=-1);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: reroot net7taxa 3)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Conclusion, in this particular example: it is possible to re-root the network to a place where the A clade is indeed an outgroup. But it did require some care, and we discovered that there are 2 acceptable rooting options. The first is more plausible, if we think that the species tree is the major tree, meaning that any gene flow or introgression event replaced less than 50% of the genes in the recipient population.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"In other cases, it may not be possible to re-root the network with a known outgroup. It would be the case if A1 was the only outgroup, and if A2 was an ingroup taxon. In such a case, the outgroup knowledge tells us that our estimated network is wrong. One (or more) reticulation in the network must be incorrect. Its placement might be correct, but then its direction would be incorrect.","category":"page"},{"location":"man/dist_reroot/#Extracting-the-major-tree","page":"Network comparison and manipulation","title":"Extracting the major tree","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can also compare the networks estimated with h=0 (net0) and h=1 (net1):","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"rootatnode!(net1, \"O\"); # the ; suppresses screen output\nhardwiredclusterdistance(net0, net1, true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"R\"svg(name('net1_O.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, showgamma=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: net1_O)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"They differ by 2 clusters: that's because A is of hybrid descent in net1 (descendant of each hybrid edge), not in net0.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"To beyond this hybrid difference, we can extract the major tree from the network with 1 hybridization, that is, delete the hybrid edge supported by less than 50% of genes. Then we can compare this tree with the ASTRAL/SNaQ tree net0.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"tree1 = majortree(net1); # major tree from net1\nhardwiredclusterdistance(net0, tree1, true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"They are identical (at distance 0), so here the species network with 1 hybrid node is a refinement of the estimated species tree (this needs not be the case always).","category":"page"},{"location":"man/dist_reroot/#Hardwired-cluster-distance","page":"Network comparison and manipulation","title":"Hardwired-cluster distance","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Is net1, the SNaQ network with 1 hybrid node, the same as the true network, the network that was initially used to simulate the data?","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Digression on this example's data: gene trees were simulated under the coalescent along some \"true\" network, then 500 base-pair alignments were simulated along each gene tree with the HKY model, gene trees were estimated from each alignment with RAxML, and these estimated gene trees served as input to both ASTRAL and SNaQ.)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"The \"true\" network is shown below, correctly rooted at the outgroup O, and plotted with branch lengths proportional to their values in coalescence units:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"truenet = readnewick(\"((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,\n(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\");","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"R\"svg(name('truenet_sim.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, useedgelength=true, showgamma=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: truenet)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can compare two networks using the hardwired-cluster dissimilarity.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"This dissimilarity counts the number of hardwired clusters present in one network but absent in the other.\nThe hardwired cluster associated with an edge is the set of all tips descendant from that edge, i.e. all tips that inherited at least some genetic material from that edge.\nEach edge is associated with its hardwired cluster of descendants, and also with a \"tree\" tag or \"hybrid\" tag depending on the edge type.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"info: distance versus dissimilarity\nWhen comparing level-1 networks, or tree-child networks more generally, the hardwired-cluster dissimilarity is a distance: d(N, N') = 0 exactly when N and N' have the same topology. (Cardona et al. 2009, Bai et al. Maxfield, Xu & Ané 2025). Unfortunately, this is not generally true for complex network: there are networks at hardwired-cluster 'distance' 0, that have different topologies. But no dissimilarity measure can both be fast to calculate and be a distance on the full space of phylogenetic networks (Cardona et al. 2014).","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"hardwiredclusterdistance(net1, truenet, true) # true: nets considered as rooted","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Our estimated network is at distance 4 (not 0), so it is different from the true network (there was estimation error). The 4 cluster differences correspond to the hybrid edges in net1 (whose cluster is A), the hybrid edges in truenet (whose cluster is AB); and the parent of their minor hybrid edges: with cluster EA in net1 versus EAB in truenet.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"From the plots, we see that:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"the underlying tree is correctly estimated\nthe origin of gene flow is correctly estimated: E\nthe target of gene flow is not correctly estimated: it was the lineage ancestral to (A,B), but it is estimated to be A only.","category":"page"},{"location":"man/dist_reroot/#μ-distances","page":"Network comparison and manipulation","title":"μ distances","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"The node-based μ-representation of rooted networks and the edge-based μ-representation of semidirected networks lead to μ-distances, which generalize the RF-distance on trees. See Cardona et al. (2024) and Maxfield, Xu & Ané (2025)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Each μ-representation lists a number of counts: counting the number of paths from each node / edge to each leaf (and to some/any hybrid node). From these path numbers, we can get the hardwired cluster associated to node or leaf: the tips that can be reached via 1 or more paths.   So then the μ-distance is more discriminant (larger) than the hardwired-cluster distance.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"For semidirected networks, the calculation of the μ-distance is much faster than the calculation of the hardwired-cluster distance, because it requires a single traversal of the network.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"info: distance versus dissimilarity\nAgain, the μ-distances are only dissimilarities generally. They are known to provided a distance, with d(N,N') = 0 exactly when N and N' share the same topology, when N and N' are tree-child rooted or semidirected networks.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"mudistance_rooted(net1, truenet)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Here both networks have an edge leading to the cluster ABCDE (the stem of the clade), but these edges have different number of paths to B: only 1 path in net1 versus 2 paths in truenet. So these edges did not count towards the hardwired-cluster distance, but do count towards the rooted μ-distance now.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"mudistance_semidirected(net1, truenet)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"When considered as undirected, the μ-distance is greater here: this is because each edge is considered in each direction it can take if its direction may change depending on the root. To math edges between 2 networks, the edges' number of paths to taxa need to match – in both directions (unlike when the networks are considered rooted). Here, each network has 6 internal edges (after suppressing the root) and none of them match between the 2 networks.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"But the distance does not depend on the root position (which may be unknown):","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"net1_E = deepcopy(net1); rootatnode!(net1_E, \"E\");\nmudistance_semidirected(net1_E, truenet) # same as with net1","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"and if we ignore B the μ-distance drops to 0, consistent with the 2 subnetworks being equal:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"net1_noB    = deepcopy(net1);    deleteleaf!(net1_noB, \"B\");\ntruenet_noB = deepcopy(truenet); deleteleaf!(truenet_noB, \"B\");\nmudistance_semidirected(net1_noB, truenet_noB)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"To get the μ-representations themselves, see PhyloNetworks.node_murepresentation and PhyloNetworks.edge_murepresentation.","category":"page"},{"location":"man/dist_reroot/#Displayed-trees-and-subnetworks","page":"Network comparison and manipulation","title":"Displayed trees and subnetworks","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can extract all trees displayed in a network. These trees are obtained by picking one parent hybrid edge at each hybrid node, and dropping the other parent hybrid edge. We can choose to pick the \"important\" hybrid edges only, with heritability γ at or above a threshold. Below we use a γ threshold of 0, so we get all displayed trees:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"t = displayedtrees(net1, 0.0) # list of trees displayed in network\nwritenewick(t[1], round=true)\nwritenewick(t[2], round=true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"If we decide to keep edges with γ>0.2 only, then we are left with a single tree in the list (the major tree). This is because our example has 1 hybrid node with minor γ=0.196.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"t = displayedtrees(net1, 0.2)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can also delete all \"non-important\" reticulations, those with a minor heritability γ below some threshold. The function below changes our network net1, as indicated by its name ending with a !.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"deletehybridthreshold!(net1, 0.1)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Nothing happened to our network: because its γ is above 0.1. But if we set the threshold to 0.3, then our reticulation disappears:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"deletehybridthreshold!(net1, 0.3)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"See also function displayednetworkat! to get the network with a single reticulation of interest, and eliminate all other reticulations.","category":"page"},{"location":"man/network_support/#Network-support","page":"Network support","title":"Network support","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We show here how to summarize a sample of networks. This may be used to get bootstrap support or posterior probabilities for network features, if the sample of networks comes from a bootstrap analysis (as possible with SNaQ) or if it's a posterior sample of networks from a Bayesian analysis.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"To demonstrate summarizing a sample of networks, we use here a sample of 100 networks, obtained by running 100 bootstrap replicates of SNaQ. The file containing the 100 networks comes with the package:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"bootnet = readmultinewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"bootsnaq.out\"));\nlength(bootnet)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We seek to summarize what these 100 networks have in common (highly supported features) and what they don't (areas of uncertainty). Unlike for trees, there are a variety of features that we may summarize in a network. Below we show how to calculate support for tree edges, for a clade to be of hybrid origin, or for a clade to be sister to a hybrid clade, or combinations.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We also assume that we have a reference network, such as the best-fitting network on the original (non-bootstrapped) data, or some other \"consensus\" network. We focus on features (tree edges and clades) in this reference network and quantify the support for these features in the sample of networks.","category":"page"},{"location":"man/network_support/#support-for-tree-edges","page":"Network support","title":"support for tree edges","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"To summarize our sample of 100 networks on our reference network, it is best to re-read this network to get a reproducible internal numbering of its nodes and edges, used later for mapping support to edges. As our reference network, we use here a network with 1 reticulation (best-fitting network on the original data):","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"net1 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net1.out\"))","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"It turns out that the direction of gene flow is quite uncertain in this example (see below) with a wrong direction inferred sometimes, so we re-root our reference network net1 to the base of O,E, for the figures to be less confusing later.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"using PhyloPlots, RCall\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('net1_rotate1_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, showedgenumber=true); # edge 7 leads to O+E\nR\"dev.off()\" # hide\nrootonedge!(net1, 7) # makes (O,E) outgroup clade\nR\"svg(name('net1_rotate1_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, shownodenumber=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: net1_rotate1 1) (Image: net1_rotate1 2)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Edges cross: but rotating at node -6 should remove this crossing of edges","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"rotate!(net1, -6)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('net1_rotate2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, showgamma=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: net1_rotate2)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We can now summarize our sample of networks. The functions treeedges_support and hybridclades_support read all networks in the sample and map the edges / nodes onto a reference network, here net1.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSe_tree, tree1 = treeedges_support(bootnet,net1);","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"This calculates the major tree tree1 displayed in net1, that is, the tree obtained by following the major parent (γ>0.5) of each hybrid node. This tree can be visualized like this, with edge numbers shown for later use.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('major_tree.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(tree1, showedgenumber=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: major_tree)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Next, we can look at the support table BSe_tree, which has one row for each tree edge in net1. One column contains the edge number (same as shown in the plot) and another column contains the edge (bootstrap) support: the proportion of sample networks in which this edge was found in the major tree of that network. We can see the full support table and see which tree edges have support lower than 100% (none here) with","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"using DataFrames # for showall() below\nshow(BSe_tree, allrows=true, allcols=true)\nfilter(row -> row[:proportion] < 100, BSe_tree)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Finally, we can map the support values onto the reference network or its main tree by passing the support table to the edgelabel option of plot:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('boot_tree_net_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(tree1, edgelabel=BSe_tree);\nR\"dev.off()\" # hide\nR\"svg(name('boot_tree_net_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, edgelabel=BSe_tree);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: boot_tree_net 1) (Image: boot_tree_net 2)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Here, it is important that the numbers assigned to edges when building the boostrap table –those in net1 at the time– correspond to the current edge numbers in tree1 and net1. That was the purpose of reading the network from the output file of snaq! earlier, for consistency across different Julia sessions.)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"If we wanted to plot only certain support values, like those below 100% (1.0), we could do this:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"plot(net1, edgelabel=filter(row -> row[:proportion] < 100, BSe_tree));","category":"page"},{"location":"man/network_support/#support-for-hybrid-edges","page":"Network support","title":"support for hybrid edges","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Summarizing the placement of reticulations is not standard. The function hybridclades_support attempts to do so.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"The descendants of a given hybrid node form the \"recipient\" or \"hybrid\" clade, and is obtained after removing all other reticulations.\nTo remove the reticulations other than one of interest, their minor hybrid parent edge (with γ<0.5) is removed. If a reticulation is due to introgression, this minor edge may be interpreted as the \"gene flow\" edge.\nThe descendants of the lineage from which gene flow originated is then a second \"sister\" of the hybrid clade.   Because of the reticulation event, the hybrid clade has 2 sister clades, not 1: the major sister (through the major hybrid edge with γ>0.5) and the minor sister (through the minor hybrid edge with γ<0.5).","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Note that the network says nothing about the process: its shows the relationships only. We can calculate the frequency that each clade is a hybrid clade, or a major or minor sister for some other hybrid, in the sample of networks:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSn, BSe, BSc, BSgam, BSedgenum = hybridclades_support(bootnet, net1);","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Let's look at the results. We can list all the clades and the percentage of sample networks (support) in which each clade is a hybrid or sister to a hybrid:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSn","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"If a clade contains a single taxon, it is listed with its taxon name. The clade found in the best network is listed with its tag, starting with H (e.g. \"H7\"). The name of other clades start with \"c_\" followed by their number in the best network, if they do appear in the best network. The node numbers, as used internally in the best network, are listed in a separate column. They can be used later to display the support values onto the network. Various columns give the support that each clade is a hybrid, or a (major/minor) sister to a hybrid. The last column gives the support for the full relationship in the best network: same hybrid with same two sisters. These support values are associated with nodes (or possibly, their parent edges).","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"To see what is the clade named \"H7\", for instance:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSc # this might be too big\nshow(BSc, allrows=true, allcols=true)\n# BSc[BSc[!,:H7], :taxa] # just a different syntax to subset the data in the same way\nfilter(row -> row[:H7], BSc).taxa","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We can also get support values associated with edges, to describe the support that a given hybrid clade has a given sister clade.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSe","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Here, each row describes a pair of 2 clades: one being the hybrid, the other being its sister, connected by a hybrid edge. The first rows corresponds to hybrid edges in the best network. Other rows correspond to edges seen in the sample of networks but not in the reference network.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSedgenum","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"lists all the hybrid edges in the best network, two for each hybrid node: the major parent edge and then the minor parent edge. In our case, there is only one reticulation, so only 2 hybrid edges.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We can plot the support values of the 2 hybrid edges in the best network:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('boot_net_net.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, edgelabel=BSe[:,[:edge,:BS_hybrid_edge]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: boot_net_net)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"This is showing the support for each hybrid edge: the percentage of networks in the sample, with an edge from the same sister clade to the same hybrid clade. Alternatively, we could show the support for the full reticulation relationships in the network, one at each hybrid node (support for same hybrid with same sister clades). Here, we find that A received gene flow from E (and is sister to B otherwise) in just 32% of sampled networks. In another 1% of sampled networks, A received gene flow from another source.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('boot_net_ret.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, nodelabel=BSn[!,[:hybridnode,:BS_hybrid_samesisters]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: boot_net_ret)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Below is example code to place tree edge support and hybrid edge support on the same plot.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"tmp = filter(row -> !ismissing(row[:edge]), BSe) # filter rows\nselect!(tmp, [:edge,:BS_hybrid_edge])            # select 2 columns only\nrename!(tmp, :BS_hybrid_edge => :proportion)     # rename those columns, to match names in BSe_tree\nrename!(tmp, :edge => :edgeNumber)\ntmp = vcat(BSe_tree, tmp)\nplot(net1, edgelabel=tmp, nodelabel=BSn[:, [:hybridnode,:BS_hybrid_samesisters]])","category":"page"},{"location":"man/network_support/#support-for-hybrid-clades","page":"Network support","title":"support for hybrid clades","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"On a different plot, we can show the support for hybrid clades, first mapped to each node with positive hybrid support, and then mapped on the parent edge of these nodes. A is estimated as a hybrid in only 33% of our sampled networks. In another 44%, it is the lineage to (E,O) that is estimated as being of hybrid origin.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('boot_net_hyb_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, nodelabel=filter(row->row[:BS_hybrid]>0, BSn)[!,[:hybridnode,:BS_hybrid]]);\nR\"dev.off()\" # hide\nnothing # hide\nR\"svg(name('boot_net_hyb_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, edgelabel=filter(row->row[:BS_hybrid]>0, BSn)[!,[:edge,:BS_hybrid]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: boot_net_hyb 1) (Image: boot_net_hyb 2)","category":"page"},{"location":"man/network_support/#support-for-the-origin-of-gene-flow","page":"Network support","title":"support for the origin of gene flow","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We can plot the support for the various placements of the gene flow origin (minor sister clade), first mapped to each node with positive support for being the origin of gene flow, and then mapped along the parent edge of these nodes. We filtered clades to show those with sister support > 5%:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('boot_net_clade_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, nodelabel=filter(r->r[:BS_minor_sister]>5, BSn)[!,[:node,:BS_minor_sister]]);\nR\"dev.off()\" # hide\nnothing # hide\nR\"svg(name('boot_net_clade_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, edgelabel=filter(r->r[:BS_minor_sister]>5, BSn)[!,[:edge,:BS_minor_sister]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: boot_net_clade 1) (Image: boot_net_clade 2)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"In our best network, the lineage to E is estimated as the origin of gene flow, but this is recovered in only 41% of our sampled networks. In another 49%, it is the lineage to A that is the origin of gene flow: in these networks, gene flow is in the opposite direction compared to our reference network. In this example, there is support for gene flow between (A,B) and (E,O), but there is much uncertainty about its exact placement and about its direction.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Mapping the support for major sister clades might be interesting too:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"plot(net1, nodelabel=filter(r->r[:BS_major_sister]>5, BSn)[!,[:node,:BS_major_sister]])","category":"page"},{"location":"man/network_support/#summarizing-heritabilities-in-a-network-sample","page":"Network support","title":"summarizing heritabilities in a network sample","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"For each hybrid edge in the reference network, when present in a sampled network, its heritability γ in the sampled network was also extracted:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSgam[1:3,:] # first 3 rows only","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"γ=0 values are for sampled networks that did not have the edge. Basic summaries on γ values for a given edge, say the minor parent, could be obtained like this:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"minimum(BSgam[:,2])\nmaximum(BSgam[:,2])\nusing Statistics # for functions like mean and std (standard deviation)\nmean(BSgam[:,2])\nstd(BSgam[:,2])","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Julia is a high-level and interactive programming language (like R or Matlab), but it is also high-performance (like C). To install Julia, follow instructions here. For a quick & basic tutorial on Julia, see learn x in y minutes.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Editors:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Visual Studio Code provides an editor and an integrated development environment (IDE) for Julia: highly recommended! Positron is a great (and similar) alternative.\nInstall the Julia extension in VS Code or Positron.\nWe can also run Julia in a Pluto notebook. Pluto.jl is a great to get started with Julia.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Julia code is just-in-time compiled. This means that the first time we run a function, it will be compiled at that moment. Future calls to the function will be much faster. Trying out toy examples for the first calls is a good idea.","category":"page"},{"location":"man/installation/#Install-PhyloNetworks","page":"Installation","title":"Install PhyloNetworks","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To install the package, type inside Julia:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"PhyloNetworks\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you already installed the package and want the latest registered version, do this to update all of your packages:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Pkg.update()","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"It is important to update the package regularly as it is undergoing constant development. Join the google group for updates here.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Pkg.update() will install the latest registered version, but there could be other improvements in the master branch of the repository. If you want to update to the latest unregistered version of the package, you can do Pkg.add(PackageSpec(name=\"PhyloNetworks\", rev=\"master\")) just beware that the latest changes could be not as robust. If you want to go back to the registered package, you can do Pkg.free(\"PhyloNetworks\").","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Similarly, you can pin a version of the package Pkg.pin(\"PhyloNetworks\") so that Pkg.update() will not modify it. You can always free a pinned package with Pkg.free(\"PhyloNetworks\"). More on package management here.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The PhyloNetworks package has dependencies like NLopt and DataFrames (see the Project.toml file for the full list), but everything is installed automatically.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The companion package PhyloPlots has utilities to visualize networks, and for interoperability, such as to export networks to R (which can then be plotted via R). To install:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"PhyloPlots\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"PhyloPlots depends on PhyloNetworks, and has further dependencies like RCall","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To check that your installation worked, type this in Julia to load the package. This is something to type every time you start a Julia session:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using PhyloNetworks","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This step can also take a while, to pre-compile the code (after a package update for instance).","category":"page"},{"location":"man/parsimony/#Parsimony-on-networks","page":"Parsimony on networks","title":"Parsimony on networks","text":"","category":"section"},{"location":"man/parsimony/#Parsimony-score-of-a-given-network","page":"Parsimony on networks","title":"Parsimony score of a given network","text":"","category":"section"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"We can calculate the parsimony score of a given network topology and a given set of characters. The characters could be in a CSV file in this format:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"taxon trait1 trait2 trait3 trait4 trait5 trait6 ...\nEnglish 1 2 1 1 1 3\n...      ...","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The trait values can be integer numbers, or strings. The data table may have missing data, and may contain extra taxa that we might want to exclude.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"An example file comes with the package, available here or here.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"First, we need to read the trait table as a DataFrame object:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"using CSV, DataFrames\ncsvfile = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"Swadesh.csv\");\ndat = CSV.File(csvfile) |> DataFrame;\nfirst(dat, 6) # to see the first 6 rows","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"Then, we need to convert the DataFrame object dat into a vector of species and traits. The species names are in column 1 named taxon, and the traits are in columns 2-11. The trait data need to be converted to a list of vectors, with one vector for each species. An internal function is provided for this:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"species, traits = PhyloNetworks.readcsvtoarray(dat);\nspecies\ntraits","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"Then, we read the network as usual:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"net = readnewick(\"(Spanish,((English)#H1,(Norwegian,(German,#H1))));\");","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"using PhyloPlots, RCall\nR\"svg(name('parsimony-fixed-net.svg'), width=4, height=4)\"; # hide\nR\"par\"(mar = [0,0,0,0]);\nplot(net, xlim=[0.8,7.5]);\nR\"dev.off\"(); # hide\nnothing # hide","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"(Image: parsimony-fixed-net)","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"There are different types of parsimony scores on networks. Currently, we have implemented the softwired criterion only, with two different functions: parsimonysoftwired and parsimonyGF.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The function parsimonysoftwired uses a faster algorithm than parsimonyGF, but can solve the softwired criterion only.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"score = parsimonysoftwired(net, species, traits)\nscore = parsimonyGF(net,species,traits,:softwired)","category":"page"},{"location":"man/parsimony/#Finding-the-most-parsimonious-network","page":"Parsimony on networks","title":"Finding the most parsimonious network","text":"","category":"section"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"warning: feature to be re-implemented\nThe search for the most parsimonious network is no longer available. It will be re-implemented, and without the level-1 restriction. Please use version 0.16 of PhyloNetworks to access this older functionality, until a better one is made available.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The function maxParsimonyNet searches for the most parsimonious level-1 network. It uses the parsimonyGF function, with softwired criterion as default, which may be extended to other criteria later.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"maxParsimonyNet requires a starting topology, which can be a tree or a level-1 network, and returns a level-1 network. Taxa present in the data but absent from the starting topology will be ignored during the search.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"starttree = readnewick(\"(((English,German),Norwegian),Spanish);\");\nnet1 = maxParsimonyNet(starttree, dat, hmax=1, outgroup=\"Spanish\", rootname=\"swadesh\")","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The example data is very small: only 1 of the 11 traits is parsimony informative, on the 4 taxa specified by the starting topology. So these data happen to be compatible with a tree, and that tree is returned despite allowing for up to 1 reticulation: (Spanish,((English,Norwegian),German));.","category":"page"},{"location":"man/net_plot/#Network-Visualization","page":"Network visualization","title":"Network Visualization","text":"","category":"section"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"To visualize a network, we can use the companion package PhyloPlots. Its manual has more examples, beyond the basic examples provided here.","category":"page"},{"location":"man/net_plot/#text-parenthetical-format:-extended-newick","page":"Network visualization","title":"text parenthetical format: extended newick","text":"","category":"section"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"To get started, we load a few networks that we will later visualize. They are available in files that come with the package.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"net2 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net2.out\"))\nnet3 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net3.out\"))","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"These networks are stored in extended newick parenthetical format, widely used by various software packages. This format encodes the network's topology, edge lengths, and edge inheritance γ for hybrid edges. These γ values measure the proportion of genes inherited via each parent at a reticulation event.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"A hybrid edge with γ=0.804 means that its child node (a hybrid or admixed population) received 80.4% of its genetic material from that edge.\nThe other parent hybrid edge of this hybrid population should have γ=0.196. If the event was introgression, then this means that 19.6% of genetic material was inherited by gene flow.   Generally, the γ values of all partners contributing to a given admixed population sum up to 100%.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Let's see this newick format, printed to the screen or written to a file:","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"net1\nwritenewick(net2)  # writes to screen, full precision for branch lengths and γ\nwritenewick(net2, round=true, digits=2)\nwritenewick(net2, di=true) # γ omitted: for dendroscope\nwritenewick(net2, \"mynetwork_net2.tre\") # writes to file: creates or overwrites file\nrm(\"mynetwork_net2.tre\") # hide","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"The option di=true is for the parenthetical format used by Dendroscope (without reticulation heritabilities). Copy this parenthetical description and paste it into Dendroscope, or use the plotting function described below.","category":"page"},{"location":"man/net_plot/#visualize-the-network-topology-and-γ-inheritance","page":"Network visualization","title":"visualize the network topology and γ inheritance","text":"","category":"section"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"The newick format is great for computers, but not quite for human eyes. Are our 2 networks similar? Below, we plot them side-by-side, using extra commands that use the RCall package (more on that later).","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"The key command here is plot, with option showgamma=true to plot γ values below each hybrid edge.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"using PhyloPlots\nusing RCall                  # to be able to tweak our plot within R\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('snaqplot_net23.svg'), width=7, height=3)\" # hide\nR\"layout(matrix(1:2, 1, 2))\" # to get 2 plots into a single figure: 1 row, 2 columns\nR\"par\"(mar=[0,0,1,0])        # for smaller margins\nplot(net2, showgamma=true);\nR\"mtext\"(\"hmax=2\")           # add text annotation: title here\nplot(net3, showgamma=true);\nR\"mtext\"(\"hmax=3\")\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"(Image: net23)","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Both networks have a single reticulation. In both, A is of hybrid origin, 80.4% sister to B, and 19.6% sister to E (which is otherwise sister to O). C & D are sister to each other, if we were to re-root the networks along the edge tha leads to ABEO.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"So, these 2 networks appear identical. Are they really? To be sure, we can calculate the hardwired-cluster distance between them, which extends the Robinson-Foulds distance on trees. See Comparing and manipulating networks for more on this dissimilarity.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"hardwiredclusterdistance(net2, net3, false) # rooted=false: to consider net2 and net3 as semidirected","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Indeed, these networks have the same semidirected topology.","category":"page"},{"location":"man/net_plot/#saving-the-plot","page":"Network visualization","title":"saving the plot","text":"","category":"section"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"In the example below, julia creates and sends the plot to R via RCall, so we can tweak the plot in various ways via commands sent to R. To save the plot in a file: we first tell R to create an image file, then we send the plot of the network, then we tell R to wrap up and save its image file.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"using PhyloPlots # to visualize networks\nusing RCall      # to send additional commands to R like this: R\"...\"\nimagefilename = \"../assets/figures/snaqplot_net1_2.svg\"\nR\"svg\"(imagefilename, width=4, height=3) # starts image file\nR\"par\"(mar=[0,0,0,0]) # to reduce margins (no margins at all here)\nplot(net1, showgamma=true, showedgenumber=true); # network is plotted & sent to file\nR\"dev.off()\"; # wrap up and save image file\nnothing # hide","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"(Image: net1_2)","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"The plot function has many options, to annotate nodes and edges. In the example above, hybrid edges were annotated with their γ inheritance values (in blue: light blue for the minor edge with γ<0.5, and dark blue for the major edge with γ>0.5), and edges were annotated with their internal numbers.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"We also used the option showedgenumber=true to see the edge numbers used internally. They is sometimes useful to re-root the network on some particular edge, for example.","category":"page"},{"location":"man/net_plot/#styles-and-options","page":"Network visualization","title":"styles and options","text":"","category":"section"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"To see the list of all options, type ? to switch to the help mode of Julia, then type the name of the function, here plot.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Below are two visualizations. The first uses the default style (:fulltree) and modified edge colors. The second uses the :majortree style. That style doesn't have an arrow by default for minor hybrid edges, but we can ask for one by specifying a positive arrow length.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"R\"svg(name('snaqplot_net1_3.svg'), width=7, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nR\"layout(matrix(1:2,1,2))\";\nplot(net1, showedgelength=true, minorhybridedgecolor=\"tan\");\nplot(net1, style=:majortree, arrowlen=0.07);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"(Image: net1_3)","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Edge lengths are shown, too. They were estimated in coalescent units: number of generations / effective population size. Some edge lengths are not identifiable, hence missing.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Below is another example, where space was added between the network and the taxon names via the tipoffset option. Also, edge colors were changed, and the nodes numbers are shown (used internally)","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"R\"svg(name('snaqplot_net1_4.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, tipoffset=0.5, shownodenumber=true, edgecolor=\"tomato4\",\n     minorhybridedgecolor=\"skyblue\", majorhybridedgecolor=\"tan\");\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"(Image: net1_4)","category":"page"},{"location":"man/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"With PhyloNetworks installed, we can load the package and start using it to read, manipulate, and analyze phylogenetic trees and networks in Julia.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"using PhyloNetworks","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Here is a very small test to see if we correctly installed and loaded PhyloNetworks.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"net = readnewick(\"(A,(B,(C,D)));\");\ntiplabels(net)","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"You can see a list of all the functions with","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"varinfo(PhyloNetworks)","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"and press ? inside Julia to switch to help mode, followed by the name of a function (or type) to get more details about it.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Often you may wish to work in the directory that contains your data. To change the directory used by julia in a session, say the \"examples\" folder found in the  you have 2 options:","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"quit your session, navigate to the directory and restart julia there.\nor change the working directory within your Julia session by using the cd().","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"The following code changes the working directory to the examples folder within PhyloNetworks' source directory.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"examples_path = joinpath(dirname(dirname(pathof(PhyloNetworks))), \"examples\");\ncd(examples_path)","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"You will need to set the path to the folder where your data are located.","category":"page"},{"location":"man/introduction/#Julia-types","page":"Introduction","title":"Julia types","text":"","category":"section"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Each object in Julia has a type. We show here small examples on how to get more info on an object. If we want to know the type of a particular object, use typeof For example, let's read a list of gene trees that come with the package. First, we need the file name. Assuming we are in the \"examples\" folder:  ","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"raxmltreefile = joinpath(examples_path, \"raxmltrees.tre\")\n# raxmltreefile = \"raxmltrees.tre\" # if your working directory contains the file\ntypeof(raxmltreefile)","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"The object raxmltreefile is a basic string (of letters). Let's create our list of gene trees by reading this file. Note that if you changed your working directory as mentioned above, you do not need to use joinpath to join the path to the examples folder with the file name.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"genetrees = readmultinewick(raxmltreefile); # the semicolon suppresses info on the result\ntypeof(genetrees)","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"which shows us that genetrees is of type Vector{HybridNetwork}, that is, a vector containing networks. If we want to know about the attributes the object has, we can type ? in Julia, followed by HybridNetwork for a description.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Typing varinfo() will provide a list of objects and packages in memory, including raxmltreefile and genetrees that we just created.","category":"page"},{"location":"man/introduction/#Quick-start","page":"Introduction","title":"Quick start","text":"","category":"section"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Here we could check the length of our list of gene trees, as a check for correctness to make sure we have all gene trees we expected, and check that the third tree has whatever taxon names we expected:","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"length(genetrees)\ntiplabels(genetrees[3])","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"We can also see some basic information on the third gene tree, say:","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"genetrees[3]","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"To visualize any of these gene trees, use the PhyloPlots package:","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"using PhyloPlots\nusing RCall # hide\nmkpath(\"../assets/figures\") # hide\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('inputdata_gene3.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0])                          # hide\nplot(genetrees[3]); # tree for 3rd gene\nR\"dev.off()\"                                   # hide\nnothing # hide","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"(Image: gene3)","category":"page"},{"location":"man/introduction/#Phylogenetic-networks","page":"Introduction","title":"Phylogenetic networks","text":"","category":"section"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"In phylogenetics, there two types of networks:","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Explicit networks have a biological interpretation: internal nodes represent ancestral species (or populations); the main evolutionary history is depicted by the \"major tree\". Various methods that estimate explicit networks use models that account for ILS and for gene tree estimation error.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"(Image: explicit network)","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Implicit networks are typically descriptive: internal nodes do not represent ancestral species. Implicit networks do not discriminate between ILS, gene flow/hybridization or gene tree estimation error, and can be hard to interpret biologically.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"<img src=\"../../assets/implicit.png\" width=\"50%\" alt=\"implicit split network\" class=\"center\"/>","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"In PhyloNetworks, we consider explicit phylogenetic networks exclusively.","category":"page"},{"location":"man/introduction/#Extended-newick-format","page":"Introduction","title":"Extended newick format","text":"","category":"section"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"In parenthetical format, internal nodes can have a name, like node C below, in a tree written as (A,B)C in newick format:","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"<img src=\"../../assets/intNode.png\" width=\"45%\" alt=\"internal tree node C\"/>","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"To represent networks in parenthetical format, the extended newick format splits each hybrid node into two nodes with the same name:","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"<img src=\"../../assets/netNewick.png\" width=\"70%\" alt=\"hybrid node split into 2 nodes of the same name\"/>","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"By convention, the hybrid tag is # + H,LGT,R + number, and the minor hybrid edge leads to a leaf.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Thus, we get: (((A,(B)#H1),(C,#H1)),D);. We can write inheritance probabilities in the parenthetical format: (C,#H1):branch length:bootstrap support:inheritance probability.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"We can read a network from a newick-formatted string, and, for example, print a list of its edges:","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"newickstring = \"(((A,(B)#H1),(C,#H1)),D);\";\nnet = readnewick(newickstring);\nprintedges(net)","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"We see that the edges do not have branch lengths, and the hybrid edges do not have gamma (inheritance) values. We can set them with","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"setlength!(net.edge[1], 1.9)\nsetgamma!(net.edge[3],  0.8)\nprintedges(net)","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"where 1 and 3 correspond to the position of the given edge to modify in the list of edges. We can only change the γ value of hybrid edges, not tree edges (for which γ=1 necessarily). Such an attempt below will cause an error with a message to explain that the edge was a tree edge:","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"setgamma!(net.edge[4], 0.7)\n# should return this:\n# ERROR: cannot change gamma in a tree edge","category":"page"},{"location":"man/nj/#Neighbor-joining","page":"Neighbour Joining","title":"Neighbor joining","text":"","category":"section"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"A tree can be inferred from pairwise distances using the neighbor joining algorithm (Satou & Nei 1987)","category":"page"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"The nj function takes a data frame of pairwise distances as input and constructs a tree using the neighbor joining method.  The column names (headers) are used as taxon names.  Rows are assumed to correspond to taxa in the same order as they do in columns.","category":"page"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"D = DataFrame(CSV.File(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"caudata_dist.txt\")); copycols=false);\ntree = nj(D)","category":"page"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"There is also a method PhyloNetworks.nj!, which takes a distance matrix and a vector of the names as argument.  This function, however, would modify D.  One also has to make sure the vector of names match the columns/rows of the distance matrix.","category":"page"},{"location":"#PhyloNetworks.jl","page":"Home","title":"PhyloNetworks.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PhyloNetworks is a Julia package with core utilities for phylogenetic networks. Phylogenetic networks represent the evolutionary relationships between a set of organisms, e.g. populations, species, languages, cultures etc. They provide an explicit representation of splitting events (when populations diverge from one another) and of merging events (when populations mix together due to migration of individuals, hybridization, polyploidization, recombination, etc.). Phylogenetic networks are called admixture graphs in population genetics, when merging events are interpreted as admixture between populations. They can also summarize ancestral recombination graphs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PhyloNetworks is a core package that supports reading, writing, manipulating phylogenetic networks, and other standard tools. It is used by other packages for more specialized tasks, such as","category":"page"},{"location":"","page":"Home","title":"Home","text":"PhyloPlots to visualize phylogenetic networks,\nSNaQ for the inference of phylogenetic networks from quartet concordance factors (qCF),\nQuartetNetworkGoodnessFit to calculate quartet concordance factors expected from a general network and test the adequacy of a network to qCF data,\nPhyloTraits for the inference of trait evolution along a phylogenetic network,\nPhyloCoalSimulations to simulate gene trees under a coalescent process along a phylogenetic networks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"How to get help","category":"page"},{"location":"","page":"Home","title":"Home","text":"PhyloUtilities: website for a step-by-step tutorial with background on networks (done for the MBL workshop, last revised 2022) and associated scripts\ntutorial for comparative methods, including network calibration (2023 workshop)\nthe google group has answers to common questions.\nthe Manual and below has a quick tutorial (navigation on the left).\nthe Library further below has the full list of documented functions.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See their bibtex format.","category":"page"},{"location":"","page":"Home","title":"Home","text":"for the package in particular, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Claudia Solís-Lemus, Paul Bastide and Cécile Ané (2017). PhyloNetworks: a package for phylogenetic networks. Molecular Biology and Evolution 34(12):3292–3298. doi:10.1093/molbev/msx235","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/installation.md\",\n    \"man/introduction.md\",\n    \"man/netmanipulation.md\",\n    \"man/net_plot.md\",\n    \"man/dist_reroot.md\",\n    \"man/network_support.md\",\n    \"man/parsimony.md\",\n    \"man/nj.md\",\n    \"man/expecteddata.md\",\n]\nDepth = 3","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For help on individual functions, see the library:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/public.md\",\n    \"lib/internals.md\",\n]\nDepth = 3","category":"page"}]
}
