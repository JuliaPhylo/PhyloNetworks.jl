<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · PhyloNetworks.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="PhyloNetworks.jl logo"/></a><h1>PhyloNetworks.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/installation/">Installation</a></li><li><a class="toctext" href="../../man/inputdata/">Input Data for SNaQ</a></li><li><a class="toctext" href="../../man/ticr_howtogetQuartetCFs/">TICR pipeline</a></li><li><a class="toctext" href="../../man/snaq_plot/">Network estimation and display</a></li><li><a class="toctext" href="../../man/dist_reroot/">Network comparison and manipulation</a></li><li><a class="toctext" href="../../man/fixednetworkoptim/">Candidate Networks</a></li><li><a class="toctext" href="../../man/expectedCFs/">Extract Expected CFs</a></li><li><a class="toctext" href="../../man/bootstrap/">Bootstrap</a></li><li><a class="toctext" href="../../man/multiplealleles/">Multiple Alleles</a></li><li><a class="toctext" href="../../man/trait_tree/">Continuous Trait Evolution</a></li><li><a class="toctext" href="../../man/parsimony/">Parsimony on networks</a></li><li><a class="toctext" href="../../man/fitDiscrete/">Discrete Trait Evolution</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href>Public</a><ul class="internal"><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#types-1">types</a></li><li><a class="toctext" href="#utilities-1">utilities</a></li><li><a class="toctext" href="#data-and-topology-read/write-1">data and topology read/write</a></li><li><a class="toctext" href="#network-inference-1">network inference</a></li><li><a class="toctext" href="#network-Comparisons-1">network Comparisons</a></li><li><a class="toctext" href="#continuous-trait-evolution-1">continuous trait evolution</a></li><li><a class="toctext" href="#discrete-trait-evolution-1">discrete trait evolution</a></li></ul></li><li><a class="toctext" href="../internals/">Internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Public</a></li></ul><a class="edit-page" href="https://github.com/crsl4/PhyloNetworks.jl/blob/master/docs/src/lib/public.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Public</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Public-Documentation-1" href="#Public-Documentation-1">Public Documentation</a></h1><p>Documentation for <code>PhyloNetworks</code>&#39;s public (exported) interface.</p><p>See <a href="../internals/#Internal-Documentation-1">Internal Documentation</a> for documentation on internal functions.</p><ul><li><a href="#Public-Documentation-1">Public Documentation</a></li><ul><li><a href="#Index-1">Index</a></li><li><a href="#types-1">types</a></li><li><a href="#utilities-1">utilities</a></li><li><a href="#data-and-topology-read/write-1">data and topology read/write</a></li><li><a href="#network-inference-1">network inference</a></li><li><a href="#network-Comparisons-1">network Comparisons</a></li><li><a href="#continuous-trait-evolution-1">continuous trait evolution</a></li><li><a href="#discrete-trait-evolution-1">discrete trait evolution</a></li></ul></ul><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#PhyloNetworks.BinaryTraitSubstitutionModel"><code>PhyloNetworks.BinaryTraitSubstitutionModel</code></a></li><li><a href="#PhyloNetworks.DataCF"><code>PhyloNetworks.DataCF</code></a></li><li><a href="#PhyloNetworks.EqualRatesSubstitutionModel"><code>PhyloNetworks.EqualRatesSubstitutionModel</code></a></li><li><a href="#PhyloNetworks.HKY85"><code>PhyloNetworks.HKY85</code></a></li><li><a href="#PhyloNetworks.HybridNetwork"><code>PhyloNetworks.HybridNetwork</code></a></li><li><a href="#PhyloNetworks.JC69"><code>PhyloNetworks.JC69</code></a></li><li><a href="#PhyloNetworks.ParamsBM"><code>PhyloNetworks.ParamsBM</code></a></li><li><a href="#PhyloNetworks.PhyloNetworkLinearModel"><code>PhyloNetworks.PhyloNetworkLinearModel</code></a></li><li><a href="#PhyloNetworks.Quartet"><code>PhyloNetworks.Quartet</code></a></li><li><a href="#PhyloNetworks.RateVariationAcrossSites"><code>PhyloNetworks.RateVariationAcrossSites</code></a></li><li><a href="#PhyloNetworks.ReconstructedStates"><code>PhyloNetworks.ReconstructedStates</code></a></li><li><a href="#PhyloNetworks.ShiftNet"><code>PhyloNetworks.ShiftNet</code></a></li><li><a href="#PhyloNetworks.TraitSimulation"><code>PhyloNetworks.TraitSimulation</code></a></li><li><a href="#PhyloNetworks.TraitSubstitutionModel"><code>PhyloNetworks.TraitSubstitutionModel</code></a></li><li><a href="#PhyloNetworks.TwoBinaryTraitSubstitutionModel"><code>PhyloNetworks.TwoBinaryTraitSubstitutionModel</code></a></li><li><a href="#Base.getindex-Tuple{TraitSimulation,Symbol}"><code>Base.getindex</code></a></li><li><a href="#PhyloNetworks.Q"><code>PhyloNetworks.Q</code></a></li><li><a href="#PhyloNetworks.ancestralStateReconstruction"><code>PhyloNetworks.ancestralStateReconstruction</code></a></li><li><a href="#PhyloNetworks.biconnectedComponents"><code>PhyloNetworks.biconnectedComponents</code></a></li><li><a href="#PhyloNetworks.blobDecomposition"><code>PhyloNetworks.blobDecomposition</code></a></li><li><a href="#PhyloNetworks.bootsnaq"><code>PhyloNetworks.bootsnaq</code></a></li><li><a href="#PhyloNetworks.calibrateFromPairwiseDistances!"><code>PhyloNetworks.calibrateFromPairwiseDistances!</code></a></li><li><a href="#PhyloNetworks.cladewiseorder!"><code>PhyloNetworks.cladewiseorder!</code></a></li><li><a href="#PhyloNetworks.deleteHybridThreshold!"><code>PhyloNetworks.deleteHybridThreshold!</code></a></li><li><a href="#PhyloNetworks.deleteleaf!"><code>PhyloNetworks.deleteleaf!</code></a></li><li><a href="#PhyloNetworks.descendenceMatrix"><code>PhyloNetworks.descendenceMatrix</code></a></li><li><a href="#PhyloNetworks.directEdges!"><code>PhyloNetworks.directEdges!</code></a></li><li><a href="#PhyloNetworks.displayedNetworkAt!"><code>PhyloNetworks.displayedNetworkAt!</code></a></li><li><a href="#PhyloNetworks.displayedTrees"><code>PhyloNetworks.displayedTrees</code></a></li><li><a href="#PhyloNetworks.empiricalDNAfrequencies"><code>PhyloNetworks.empiricalDNAfrequencies</code></a></li><li><a href="#PhyloNetworks.expectations"><code>PhyloNetworks.expectations</code></a></li><li><a href="#PhyloNetworks.expectationsPlot"><code>PhyloNetworks.expectationsPlot</code></a></li><li><a href="#PhyloNetworks.fitdiscrete"><code>PhyloNetworks.fitdiscrete</code></a></li><li><a href="#PhyloNetworks.fittedQuartetCF"><code>PhyloNetworks.fittedQuartetCF</code></a></li><li><a href="#PhyloNetworks.getNodeAges"><code>PhyloNetworks.getNodeAges</code></a></li><li><a href="#PhyloNetworks.getShiftEdgeNumber"><code>PhyloNetworks.getShiftEdgeNumber</code></a></li><li><a href="#PhyloNetworks.getShiftValue"><code>PhyloNetworks.getShiftValue</code></a></li><li><a href="#PhyloNetworks.getlabels"><code>PhyloNetworks.getlabels</code></a></li><li><a href="#PhyloNetworks.hardwiredCluster"><code>PhyloNetworks.hardwiredCluster</code></a></li><li><a href="#PhyloNetworks.hardwiredClusterDistance"><code>PhyloNetworks.hardwiredClusterDistance</code></a></li><li><a href="#PhyloNetworks.hardwiredClusters"><code>PhyloNetworks.hardwiredClusters</code></a></li><li><a href="#PhyloNetworks.hybridBootstrapSupport"><code>PhyloNetworks.hybridBootstrapSupport</code></a></li><li><a href="#PhyloNetworks.hybridDetection"><code>PhyloNetworks.hybridDetection</code></a></li><li><a href="#PhyloNetworks.hybridatnode!"><code>PhyloNetworks.hybridatnode!</code></a></li><li><a href="#PhyloNetworks.lambda_estim"><code>PhyloNetworks.lambda_estim</code></a></li><li><a href="#PhyloNetworks.majorTree"><code>PhyloNetworks.majorTree</code></a></li><li><a href="#PhyloNetworks.mapAllelesCFtable"><code>PhyloNetworks.mapAllelesCFtable</code></a></li><li><a href="#PhyloNetworks.maxParsimonyNet"><code>PhyloNetworks.maxParsimonyNet</code></a></li><li><a href="#PhyloNetworks.minorTreeAt"><code>PhyloNetworks.minorTreeAt</code></a></li><li><a href="#PhyloNetworks.mu_estim"><code>PhyloNetworks.mu_estim</code></a></li><li><a href="#PhyloNetworks.nparams"><code>PhyloNetworks.nparams</code></a></li><li><a href="#PhyloNetworks.nstates"><code>PhyloNetworks.nstates</code></a></li><li><a href="#PhyloNetworks.pairwiseTaxonDistanceMatrix"><code>PhyloNetworks.pairwiseTaxonDistanceMatrix</code></a></li><li><a href="#PhyloNetworks.parsimonyGF"><code>PhyloNetworks.parsimonyGF</code></a></li><li><a href="#PhyloNetworks.parsimonySoftwired"><code>PhyloNetworks.parsimonySoftwired</code></a></li><li><a href="#PhyloNetworks.phyloNetworklm"><code>PhyloNetworks.phyloNetworklm</code></a></li><li><a href="#PhyloNetworks.predint"><code>PhyloNetworks.predint</code></a></li><li><a href="#PhyloNetworks.predintPlot"><code>PhyloNetworks.predintPlot</code></a></li><li><a href="#PhyloNetworks.preorder!"><code>PhyloNetworks.preorder!</code></a></li><li><a href="#PhyloNetworks.printEdges"><code>PhyloNetworks.printEdges</code></a></li><li><a href="#PhyloNetworks.printNodes"><code>PhyloNetworks.printNodes</code></a></li><li><a href="#PhyloNetworks.randomTrait"><code>PhyloNetworks.randomTrait</code></a></li><li><a href="#PhyloNetworks.randomTrait!"><code>PhyloNetworks.randomTrait!</code></a></li><li><a href="#PhyloNetworks.readBootstrapTrees"><code>PhyloNetworks.readBootstrapTrees</code></a></li><li><a href="#PhyloNetworks.readInputTrees"><code>PhyloNetworks.readInputTrees</code></a></li><li><a href="#PhyloNetworks.readMultiTopology"><code>PhyloNetworks.readMultiTopology</code></a></li><li><a href="#PhyloNetworks.readNexusTrees"><code>PhyloNetworks.readNexusTrees</code></a></li><li><a href="#PhyloNetworks.readSnaqNetwork"><code>PhyloNetworks.readSnaqNetwork</code></a></li><li><a href="#PhyloNetworks.readTableCF"><code>PhyloNetworks.readTableCF</code></a></li><li><a href="#PhyloNetworks.readTableCF!"><code>PhyloNetworks.readTableCF!</code></a></li><li><a href="#PhyloNetworks.readTopology"><code>PhyloNetworks.readTopology</code></a></li><li><a href="#PhyloNetworks.readTopologyLevel1"><code>PhyloNetworks.readTopologyLevel1</code></a></li><li><a href="#PhyloNetworks.readTrees2CF"><code>PhyloNetworks.readTrees2CF</code></a></li><li><a href="#PhyloNetworks.readfastatodna"><code>PhyloNetworks.readfastatodna</code></a></li><li><a href="#PhyloNetworks.regressorHybrid"><code>PhyloNetworks.regressorHybrid</code></a></li><li><a href="#PhyloNetworks.regressorShift"><code>PhyloNetworks.regressorShift</code></a></li><li><a href="#PhyloNetworks.rootatnode!"><code>PhyloNetworks.rootatnode!</code></a></li><li><a href="#PhyloNetworks.rootonedge!"><code>PhyloNetworks.rootonedge!</code></a></li><li><a href="#PhyloNetworks.rotate!"><code>PhyloNetworks.rotate!</code></a></li><li><a href="#PhyloNetworks.setGamma!"><code>PhyloNetworks.setGamma!</code></a></li><li><a href="#PhyloNetworks.setLength!"><code>PhyloNetworks.setLength!</code></a></li><li><a href="#PhyloNetworks.sharedPathMatrix"><code>PhyloNetworks.sharedPathMatrix</code></a></li><li><a href="#PhyloNetworks.shiftHybrid"><code>PhyloNetworks.shiftHybrid</code></a></li><li><a href="#PhyloNetworks.sigma2_estim"><code>PhyloNetworks.sigma2_estim</code></a></li><li><a href="#PhyloNetworks.simulate"><code>PhyloNetworks.simulate</code></a></li><li><a href="#PhyloNetworks.snaq!"><code>PhyloNetworks.snaq!</code></a></li><li><a href="#PhyloNetworks.sorttaxa!"><code>PhyloNetworks.sorttaxa!</code></a></li><li><a href="#PhyloNetworks.stationary"><code>PhyloNetworks.stationary</code></a></li><li><a href="#PhyloNetworks.summarizeDataCF"><code>PhyloNetworks.summarizeDataCF</code></a></li><li><a href="#PhyloNetworks.summarizeHFdf"><code>PhyloNetworks.summarizeHFdf</code></a></li><li><a href="#PhyloNetworks.ticr"><code>PhyloNetworks.ticr</code></a></li><li><a href="#PhyloNetworks.ticr!"><code>PhyloNetworks.ticr!</code></a></li><li><a href="#PhyloNetworks.tipLabels"><code>PhyloNetworks.tipLabels</code></a></li><li><a href="#PhyloNetworks.topologyMaxQPseudolik!"><code>PhyloNetworks.topologyMaxQPseudolik!</code></a></li><li><a href="#PhyloNetworks.topologyQPseudolik!"><code>PhyloNetworks.topologyQPseudolik!</code></a></li><li><a href="#PhyloNetworks.treeEdgesBootstrap"><code>PhyloNetworks.treeEdgesBootstrap</code></a></li><li><a href="#PhyloNetworks.undirectedOtherNetworks"><code>PhyloNetworks.undirectedOtherNetworks</code></a></li><li><a href="#PhyloNetworks.vcv"><code>PhyloNetworks.vcv</code></a></li><li><a href="#PhyloNetworks.writeMultiTopology"><code>PhyloNetworks.writeMultiTopology</code></a></li><li><a href="#PhyloNetworks.writeSubTree!"><code>PhyloNetworks.writeSubTree!</code></a></li><li><a href="#PhyloNetworks.writeTableCF"><code>PhyloNetworks.writeTableCF</code></a></li><li><a href="#PhyloNetworks.writeTopology"><code>PhyloNetworks.writeTopology</code></a></li></ul><h2><a class="nav-anchor" id="types-1" href="#types-1">types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.BinaryTraitSubstitutionModel" href="#PhyloNetworks.BinaryTraitSubstitutionModel"><code>PhyloNetworks.BinaryTraitSubstitutionModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BinaryTraitSubstitutionModel(α, β [, label])</code></pre><p>Model for binary traits, that is, with 2 states. Default labels are &quot;0&quot; and &quot;1&quot;. α is the rate of transition from &quot;0&quot; to &quot;1&quot;, and β from &quot;1&quot; to &quot;0&quot;.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L269-L274">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.DataCF" href="#PhyloNetworks.DataCF"><code>PhyloNetworks.DataCF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DataCF</code></pre><p>type that contains the following attributes:</p><ul><li>quartet (vector of Quartets)</li><li>numQuartets</li><li>tree (vector of trees: empty if a table of CF was input instead of list of trees)</li><li>numTrees (-1 if a table CF was input instead of list of trees)</li><li>repSpecies (taxon names that were repeated in table of CF or input gene trees: used inside snaq for multiple alleles case)</li></ul><p>The list of Quartet may be accessed with the attribute .quartet. If the input was a list of trees, the HybridNetwork&#39;s can be accessed with the attribute .tree. For example, if the DataCF object is named d, d.quartet[1] will show the first quartet and d.tree[1] will print the first input tree.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/types.jl#L322-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.EqualRatesSubstitutionModel" href="#PhyloNetworks.EqualRatesSubstitutionModel"><code>PhyloNetworks.EqualRatesSubstitutionModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">EqualRatesSubstitutionModel(numberStates, α, labels)</code></pre><p><a href="#PhyloNetworks.TraitSubstitutionModel"><code>TraitSubstitutionModel</code></a> for traits with any number of states and equal substitution rates α between all states. Default labels are &quot;1&quot;,&quot;2&quot;,...</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = EqualRatesSubstitutionModel(2, [1.0], [&quot;low&quot;,&quot;high&quot;])
Equal Rates Substitution Model with k=2,
all rates equal to α=1.0.
rate matrix Q:
             low    high
     low       *  1.0000
    high  1.0000       *</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L422-L440">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.HKY85" href="#PhyloNetworks.HKY85"><code>PhyloNetworks.HKY85</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HKY85(rate, pi, relative)</code></pre><p>A nucleic acid substitution model based on Hasegawa et al. 1985 substitution model. <code>rate</code> should be a vector of 1 or 2 rates, and <code>pi</code> a vector of 4 probabilities summing to 1.</p><p>If <code>relative</code> is false, the 2 rates represent the transition rate and the transversion rate, α and β. If <code>relative</code> is true (default), only the first rate is used and represents the transition/transversion ratio: κ=α/β. The rate transition matrix Q is normalized to have 1 change / unit of time on average, i.e. the absolute version of Q is divided by <code>2(piT*piC + piA*piG)α + 2(piY*piR)β</code>.</p><p><code>nparams</code> returns 1 or 2. In other words: the stationary distribution is not counted in the number of parameters (and <code>fitdiscrete</code> does not optimize the pi values at the moment).</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = HKY85([.5], [0.20, 0.30, 0.30, 0.20])
HKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]
relative rate version with transition/tranversion ratio kappa = 0.5,
 scaled so that there is one substitution per unit time
rate matrix Q:
               A       C       G       T
       A       *  0.4839  0.2419  0.3226
       C  0.3226       *  0.4839  0.1613
       G  0.1613  0.4839       *  0.3226
       T  0.3226  0.2419  0.4839       *


julia&gt; nstates(m1)
4

julia&gt; m2 = HKY85([0.5, 0.5], [0.20, 0.30, 0.30, 0.20], false)
HKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]
absolute rate version with transition/transversion ratio kappa = a/b = 1.0
 with rates a = 0.5 and b = 0.5
rate matrix Q:
               A       C       G       T
       A       *  0.1500  0.1500  0.1000
       C  0.1000       *  0.1500  0.1000
       G  0.1000  0.1500       *  0.1000
       T  0.1000  0.1500  0.1500       *

</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L731-L778">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.HybridNetwork" href="#PhyloNetworks.HybridNetwork"><code>PhyloNetworks.HybridNetwork</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HybridNetwork</code></pre><p>Subtype of abstract <code>Network</code> type. Explicit network or tree with the following attributes:</p><ul><li>numTaxa</li><li>numNodes (total number of nodes)</li><li>numEdges</li><li>numHybrids (number of hybrid nodes)</li><li>edge (array of Edges)</li><li>node (array of Nodes)</li><li>root (index of root in vector &#39;node&#39;. May be artificial, for printing and traversal purposes only.)</li><li>hybrid (array of Nodes: those are are hybrid nodes)</li><li>leaf (array of Nodes: those that are leaves)</li><li>loglik (negative log pseudolik after estimation)</li><li>isRooted (true or false)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/types.jl#L170-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.JC69" href="#PhyloNetworks.JC69"><code>PhyloNetworks.JC69</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">JC69(rate, relative)</code></pre><p>Jukes Cantor (1969) nucleic acid substitution model, which has a single rate parameter. <code>rate</code> corresponds to the absolute diagonal elements, that is, the rate of change (to any of the other 2 states). Individual rates are <code>rate</code>/3. If <code>relative</code> is true (default), the transition matrix <a href="#PhyloNetworks.Q"><code>Q</code></a> is normalized to an average of 1 transition per unit of time: in which case <code>rate</code> is set to 1.0.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = JC69([0.25], false)
Jukes and Cantor 69 Substitution Model,
absolute rate version
off-diagonal rates equal to 0.25/3.
rate matrix Q:
               A       C       G       T
       A       *  0.0833  0.0833  0.0833
       C  0.0833       *  0.0833  0.0833
       G  0.0833  0.0833       *  0.0833
       T  0.0833  0.0833  0.0833       *


julia&gt; nstates(m1)
4

julia&gt; nparams(m1)
1

julia&gt; m2 = JC69([0.5])
Jukes and Cantor 69 Substitution Model,
relative rate version
off-diagonal rates equal to 1/3
rate matrix Q:
               A       C       G       T
       A       *  0.3333  0.3333  0.3333
       C  0.3333       *  0.3333  0.3333
       G  0.3333  0.3333       *  0.3333
       T  0.3333  0.3333  0.3333       *


julia&gt; nparams(m2)
0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L639-L684">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.ParamsBM" href="#PhyloNetworks.ParamsBM"><code>PhyloNetworks.ParamsBM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ParamsBM &lt;: ParamsProcess</code></pre><p>Type for a BM process on a network. Fields are <code>mu</code> (expectation), <code>sigma2</code> (variance), <code>randomRoot</code> (whether the root is random, default to <code>false</code>), and <code>varRoot</code> (if the root is random, the variance of the root, defalut to <code>NaN</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L857-L864">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.PhyloNetworkLinearModel" href="#PhyloNetworks.PhyloNetworkLinearModel"><code>PhyloNetworks.PhyloNetworkLinearModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PhyloNetworkLinearModel&lt;:GLM.LinPredModel</code></pre><p>Regression object for a phylogenetic regression. Result of fitting function <a href="#PhyloNetworks.phyloNetworklm"><code>phyloNetworklm</code></a>. Dominated by the <code>GLM.LinPredModel</code> class, from package <code>GLM</code>.</p><p>The following StatsBase functions can be applied to it: <code>coef</code>, <code>nobs</code>, <code>vcov</code>, <code>stderror</code>, <code>confint</code>, <code>coeftable</code>, <code>dof_residual</code>, <code>dof</code>, <code>deviance</code>, <code>residuals</code>, <code>response</code>, <code>predict</code>, <code>loglikelihood</code>, <code>nulldeviance</code>, <code>nullloglikelihood</code>, <code>r2</code>, <code>adjr2</code>, <code>aic</code>, <code>aicc</code>, <code>bic</code>.</p><p>For accessing the model matrix (<code>object.mm</code> and <code>object.mm.m</code>), the model frame (<code>object.mf</code>) or formula (<code>object.mf.f</code>), refer to <a href="https://juliastats.github.io/StatsModels.jl/stable/">StatsModels</a> functions, like <code>show(object.mf.f)</code>, <code>terms(object.mf.f)</code>, <code>coefnames(object.mf.f)</code>, <code>terms(object.mf.f.rhs)</code>, <code>response(object)</code> etc.</p><p>Estimated variance and mean of the BM process used can be retrieved with functions <a href="#PhyloNetworks.sigma2_estim"><code>sigma2_estim</code></a> and <a href="#PhyloNetworks.mu_estim"><code>mu_estim</code></a>.</p><p>If a Pagel&#39;s lambda model is fitted, the parameter can be retrieved with function <a href="#PhyloNetworks.lambda_estim"><code>lambda_estim</code></a>.</p><p>An ancestral state reconstruction can be performed from this fitted object using function: <a href="#PhyloNetworks.ancestralStateReconstruction"><code>ancestralStateReconstruction</code></a>.</p><p>The <code>PhyloNetworkLinearModel</code> object has fields: <code>lm</code>, <code>V</code>, <code>Vy</code>, <code>RL</code>, <code>Y</code>, <code>X</code>, <code>logdetVy</code>, <code>ind</code>, <code>nonmissing</code>, <code>model</code>, <code>lambda</code>. Type in &quot;?PhyloNetworkLinearModel.field&quot; to get help on a specific field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1122-L1150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.Quartet" href="#PhyloNetworks.Quartet"><code>PhyloNetworks.Quartet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Quartet</code></pre><p>type that saves the information on a given 4-taxon subset. It contains the following attributes:</p><ul><li>number: integer</li><li>taxon: vector of taxon names, like t1 t2 t3 t4</li><li>obsCF: vector of observed CF, in order 12|34, 13|24, 14|23</li><li>logPseudoLik</li><li>ngenes: number of gene trees used to compute the observed CF; -1.0 if unknown</li><li>qnet: <a href="../internals/#PhyloNetworks.QuartetNetwork"><code>QuartetNetwork</code></a>, which saves the expCF after snaq estimation to emphasize that the expCF depend on a specific network, not the data</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/types.jl#L282-L294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.RateVariationAcrossSites" href="#PhyloNetworks.RateVariationAcrossSites"><code>PhyloNetworks.RateVariationAcrossSites</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RateVariationAcrossSites(α=1.0, ncat=4)</code></pre><p>Model for variable substitution rates across sites (or across traits) using the discrete Gamma model (Yang 1994, Journal of Molecular Evolution). Turn any SM model to SM + Gamma. Using this model increases the number of parameters by one.</p><p>Because the mean of the desired continuous Gamma distribution is 1, we use shape α and scale θ=1/α (e.g. rate β=α). The shape parameter is referred to as alpha here. The Gamma distribution is discretized into <code>ncat</code> categories. In each category, the category&#39;s rate multiplier is a normalized quantile of the gamma distribution.</p><pre><code class="language-julia-repl">julia&gt; rv = RateVariationAcrossSites()
Rate Variation Across Sites using Discretized Gamma Model
alpha: 1.0
categories for Gamma discretization: 4
ratemultiplier: [0.14578, 0.51313, 1.07083, 2.27025]

julia&gt; PhyloNetworks.setalpha!(rv, 2.0)

julia&gt; rv
Rate Variation Across Sites using Discretized Gamma Model
alpha: 2.0
categories for Gamma discretization: 4
ratemultiplier: [0.31907, 0.68336, 1.10898, 1.8886]

julia&gt; RateVariationAcrossSites(2.0, 4)
Rate Variation Across Sites using Discretized Gamma Model
alpha: 2.0
categories for Gamma discretization: 4
ratemultiplier: [0.31907, 0.68336, 1.10898, 1.8886]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L970-L1005">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.ReconstructedStates" href="#PhyloNetworks.ReconstructedStates"><code>PhyloNetworks.ReconstructedStates</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ReconstructedStates</code></pre><p>Type containing the inferred information about the law of the ancestral states given the observed tips values. The missing tips are considered as ancestral states.</p><p>The following functions can be applied to it: <a href="#PhyloNetworks.expectations"><code>expectations</code></a> (vector of expectations at all nodes), <code>stderror</code> (the standard error), <code>predint</code> (the prediction interval).</p><p>The <code>ReconstructedStates</code> object has fields: <code>traits_nodes</code>, <code>variances_nodes</code>, <code>NodeNumbers</code>, <code>traits_tips</code>, <code>tipNumbers</code>, <code>model</code>. Type in &quot;?ReconstructedStates.field&quot; to get help on a specific field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1931-L1943">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.ShiftNet" href="#PhyloNetworks.ShiftNet"><code>PhyloNetworks.ShiftNet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ShiftNet</code></pre><p>Shifts associated to a <a href="#PhyloNetworks.HybridNetwork"><code>HybridNetwork</code></a> sorted in topological order. Its <code>shift</code> field is a vector of shift values, one for each node, corresponding to the shift on the parent edge of the node (which makes sense for tree nodes only: they have a single parent edge).</p><p>Two <code>ShiftNet</code> objects on the same network can be concatened with <code>*</code>.</p><p><code>ShiftNet(node::Vector{Node}, value::AbstractVector, net::HybridNetwork; checkPreorder=true::Bool)</code></p><p>Constructor from a vector of nodes and associated values. The shifts are located on the edges above the nodes provided. Warning, shifts on hybrid edges are not allowed.</p><p><code>ShiftNet(edge::Vector{Edge}, value::AbstractVector, net::HybridNetwork; checkPreorder=true::Bool)</code></p><p>Constructor from a vector of edges and associated values. Warning, shifts on hybrid edges are not allowed.</p><p>Extractors: <a href="#PhyloNetworks.getShiftEdgeNumber"><code>getShiftEdgeNumber</code></a>, <a href="#PhyloNetworks.getShiftValue"><code>getShiftValue</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L720-L742">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.TraitSimulation" href="#PhyloNetworks.TraitSimulation"><code>PhyloNetworks.TraitSimulation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TraitSimulation</code></pre><p>Result of a trait simulation on an <a href="#PhyloNetworks.HybridNetwork"><code>HybridNetwork</code></a> with function <a href="#PhyloNetworks.simulate"><code>simulate</code></a>.</p><p>The following functions and extractors can be applied to it: <a href="#PhyloNetworks.tipLabels"><code>tipLabels</code></a>, <code>obj[:Tips]</code>, <code>obj[:InternalNodes]</code> (see documentation for function <a href="#Base.getindex-Tuple{TraitSimulation,Symbol}"><code>getindex(::TraitSimulation, ::Symbol)</code></a>).</p><p>The <code>TraitSimulation</code> object has fields: <code>M</code>, <code>params</code>, <code>model</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L915-L923">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.TraitSubstitutionModel" href="#PhyloNetworks.TraitSubstitutionModel"><code>PhyloNetworks.TraitSubstitutionModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TraitSubstitutionModel</code></pre><p>For subtypes, see <a href="#PhyloNetworks.BinaryTraitSubstitutionModel"><code>BinaryTraitSubstitutionModel</code></a>, <a href="#PhyloNetworks.EqualRatesSubstitutionModel"><code>EqualRatesSubstitutionModel</code></a>, <a href="#PhyloNetworks.TwoBinaryTraitSubstitutionModel"><code>TwoBinaryTraitSubstitutionModel</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L21-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.TwoBinaryTraitSubstitutionModel" href="#PhyloNetworks.TwoBinaryTraitSubstitutionModel"><code>PhyloNetworks.TwoBinaryTraitSubstitutionModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TwoBinaryTraitSubstitutionModel(rate [, label])</code></pre><p><a href="#PhyloNetworks.TraitSubstitutionModel"><code>TraitSubstitutionModel</code></a> for two binary traits, possibly correlated. Default labels are &quot;x0&quot;, &quot;x1&quot; for trait 1, and &quot;y0&quot;, &quot;y1&quot; for trait 2. If provided, <code>label</code> should be a vector of size 4, listing labels for trait 1 first then labels for trait 2. <code>rate</code> should be a vector of substitution rates of size 8. rate[1],...,rate[4] describe rates of changes in trait 1. rate[5],...,rate[8] describe rates of changes in trait 2. In the transition matrix, trait combinations are listed in the following order: x0-y0, x0-y1, x1-y0, x1-y1.</p><p><strong>example</strong></p><pre><code class="language-julia">model = TwoBinaryTraitSubstitutionModel([2.0,1.2,1.1,2.2,1.0,3.1,2.0,1.1],
        [&quot;carnivory&quot;, &quot;noncarnivory&quot;, &quot;wet&quot;, &quot;dry&quot;]);
model
using PhyloPlots
plot(model) # to visualize states and rates</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L357-L379">source</a></section><h2><a class="nav-anchor" id="utilities-1" href="#utilities-1">utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.tipLabels" href="#PhyloNetworks.tipLabels"><code>PhyloNetworks.tipLabels</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tipLabels(x)</code></pre><p>Return a vector of taxon names at the leaves, for objects of various types: <code>HybridNetwork</code>, Vector of <code>HybridNetwork</code>s (in which case the union is taken then sorted), Vector of <code>Quartet</code>s, <code>DataCF</code>, <code>TraitSimulation</code>, <code>MatrixTopologicalOrder</code>.</p><p>For a network, the taxon names are coerced to strings.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/descriptive.jl#L4-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.sorttaxa!" href="#PhyloNetworks.sorttaxa!"><code>PhyloNetworks.sorttaxa!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sorttaxa!(DataFrame, columns)</code></pre><p>Reorder the 4 taxa and reorders the observed concordance factors accordingly, on each row of the data frame. If <code>columns</code> is ommitted, taxon names are assumed to be in columns 1-4 and CFs are assumed to be in columns 5-6 with quartets in this order: <code>12_34</code>, <code>13_24</code>, <code>14_23</code>. Does <strong>not</strong> reorder credibility interval values, if present.</p><pre><code class="language-none">sorttaxa!(DataCF)
sorttaxa!(Quartet, permutation_tax, permutation_cf)</code></pre><p>Reorder the 4 taxa in each element of the DataCF <code>quartet</code>. For a given Quartet, reorder the 4 taxa in its fields <code>taxon</code> and <code>qnet.quartetTaxon</code> (if non-empty) and reorder the 3 concordance values accordingly, in <code>obsCF</code> and <code>qnet.expCF</code>.</p><p><code>permutation_tax</code> and <code>permutation_cf</code> should be vectors of short integers (Int8) of length 4 and 3 respectively, whose memory allocation gets reused. Their length is <em>not checked</em>.</p><p><code>qnet.names</code> is unchanged: the order of taxon names here relates to the order of nodes in the network (???)</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L1228-L1248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.printEdges" href="#PhyloNetworks.printEdges"><code>PhyloNetworks.printEdges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">printEdges(net)
printEdges(io::IO, net)</code></pre><p>Print information on the edges of a <code>HybridNetwork</code> or <code>QuartetNetwork</code> object <code>net</code>: edge number, numbers of nodes attached to it, edge length, whether it&#39;s a hybrid edge, its γ inheritance value, whether it&#39;s a major edge, if it could contain the root (this field is not always updated, though) and attributes pertaining to level-1 networks used in SNaQ: in which cycle it is contained (-1 if no cycle), and if the edge length is identifiable (based on quartet concordance factors).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L594-L605">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.printNodes" href="#PhyloNetworks.printNodes"><code>PhyloNetworks.printNodes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">printNodes(net)
printNodes(io, net)</code></pre><p>Print information on the nodes of a <code>HybridNetwork</code> net: node number, whether it&#39;s a leaf, whether it&#39;s a hybrid node, whether it&#39;s connected to one or more hybrid edges, it&#39;s name (label), the cycle in which it is belong (-1 if no cycle; makes sense for level-1 networks), and the list of edges attached to it, by their numbers.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L632-L641">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.summarizeDataCF" href="#PhyloNetworks.summarizeDataCF"><code>PhyloNetworks.summarizeDataCF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>summarizeDataCF(d::DataCF)</code></p><p>function to summarize the information contained in a DataCF object. It has the following optional arguments:</p><ul><li>filename: if provided, the summary will be saved in the filename, not to screen</li><li>pc (number between (0,1)): threshold of percentage of missing genes to identify 4-taxon subsets with fewer genes than the threshold</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L769-L775">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.directEdges!" href="#PhyloNetworks.directEdges!"><code>PhyloNetworks.directEdges!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">directEdges!(net::HybridNetwork; checkMajor=true::Bool)</code></pre><p>Updates the edges&#39; attribute <code>isChild1</code>, according to the root placement. Also updates edges&#39; attribute <code>containRoot</code>, for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if checkMajor=true.</p><p>Warning: Assumes that isChild1 is correct on hybrid edges (to avoid changing the identity of which nodes are hybrids and which are not).</p><p>Returns the network. Throws a &#39;RootMismatch&#39; Exception if the root was found to conflict with the direction of any hybrid edge.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L441-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.preorder!" href="#PhyloNetworks.preorder!"><code>PhyloNetworks.preorder!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">preorder!(net::HybridNetwork)</code></pre><p>Updates attribute net.nodes_changed in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges&#39; direction needs to be correct before calling preorder!, using directEdges!</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L588-L594">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.cladewiseorder!" href="#PhyloNetworks.cladewiseorder!"><code>PhyloNetworks.cladewiseorder!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cladewiseorder!(net::HybridNetwork)</code></pre><p>Updates attribute net.cladewiseorder_nodeIndex. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges&#39; direction needs to be correct before calling <a href="#PhyloNetworks.cladewiseorder!"><code>cladewiseorder!</code></a>, using <a href="#PhyloNetworks.directEdges!"><code>directEdges!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L631-L639">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.rootatnode!" href="#PhyloNetworks.rootatnode!"><code>PhyloNetworks.rootatnode!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rootatnode!(HybridNetwork, nodeNumber::Integer; index=false::Bool, verbose=true::Bool)
rootatnode!(HybridNetwork, Node; verbose=true)
rootatnode!(HybridNetwork, nodeName::AbstractString; verbose=true)</code></pre><p>Root the network/tree object at the node with name &#39;nodeName&#39; or number &#39;nodeNumber&#39; (by default) or with index &#39;nodeNumber&#39; if index=true. Attributes isChild1 and containRoot are updated along the way. Use <code>plot(net, showNodeNumber=true, showEdgeLength=false)</code> to visualize and identify a node of interest. (see package <a href="https://github.com/cecileane/PhyloPlots.jl">PhyloPlots</a>)</p><p>Return the network.</p><p>Warnings:</p><ul><li><p>If the node is a leaf, the root will be placed along the edge adjacent to the leaf. This might add a new node.</p></li><li><p>If the desired root placement is incompatible with one or more hybrids, then</p><ul><li>a RootMismatch error is thrown; use <code>verbose=false</code> to silence the root mismatch info printed before the error is thrown.</li><li>the input network will still have some attributes modified.</li></ul></li></ul><p>See also: <a href="#PhyloNetworks.rootonedge!"><code>rootonedge!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L225-L250">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.rootonedge!" href="#PhyloNetworks.rootonedge!"><code>PhyloNetworks.rootonedge!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rootonedge!(HybridNetwork, edgeNumber::Integer; index=false::Bool, verbose=true::Bool)
rootonedge!(HybridNetwork, Edge; verbose=true::Bool)</code></pre><p>Root the network/tree along an edge with number <code>edgeNumber</code> (by default) or with index <code>edgeNumber</code> if <code>index=true</code>. Attributes <code>isChild1</code> and <code>containRoot</code> are updated along the way.</p><p>This adds a new node and a new edge to the network. Use <code>plot(net, showEdgeNumber=true, showEdgeLength=false)</code> to visualize and identify an edge of interest. (see package <a href="https://github.com/cecileane/PhyloPlots.jl">PhyloPlots</a>)</p><p>See also: <a href="#PhyloNetworks.rootatnode!"><code>rootatnode!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L305-L319">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.hybridatnode!" href="#PhyloNetworks.hybridatnode!"><code>PhyloNetworks.hybridatnode!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hybridatnode!(net::HybridNetwork, nodeNumber::Integer)</code></pre><p>Change the status of edges in network <code>net</code>, to move the hybrid node in a cycle to the node with number <code>nodeNumber</code>. This node must be in one (and only one) cycle, otherwise an error will be thrown.</p><p><code>net</code> is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. Check and update the nodes&#39; field <code>inCycle</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; net = readTopology(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
julia&gt; using PhyloPlots
julia&gt; plot(net, showNodeNumber=true)
julia&gt; hybridatnode!(net, -4)
julia&gt; plot(net)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L96-L116">source</a><div><div><pre><code class="language-none">hybridatnode!(net, hybrid::Node, newNode::Node)</code></pre><p>Move the reticulation from <code>hybrid</code> to <code>newNode</code>, which must in the same cycle. <code>net</code> is assumed to be of level 1, but <strong>no checks</strong> are made and fields are supposed up-to-date.</p><p>Called by <code>hybridatnode!(net, node number)</code>, which is itself called by <a href="public/#PhyloNetworks.undirectedOtherNetworks"><code>undirectedOtherNetworks</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L142-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.setLength!" href="#PhyloNetworks.setLength!"><code>PhyloNetworks.setLength!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>setLength!(Edge,new length)</code></p><p>set a new length for an object Edge. The new length needs to be positive. For example, if you have a HybridNetwork object net, and do printEdges(net), you can see the list of Edges and their lengths. You can then change the length of the 3rd edge with setLength!(net.edge[3],1.2). If <code>new length</code> is above 10, the value 10 will be used, as an upper limit to coalescent units that can be reliably estimated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L812-L819">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.setGamma!" href="#PhyloNetworks.setGamma!"><code>PhyloNetworks.setGamma!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setGamma!(Edge, new γ)
setGamma!(Edge, new γ, change other=true::Bool)</code></pre><p>Set inheritance probability γ for an edge, which must be a hybrid edge. The new γ needs to be in [0,1]. The γ of the &quot;partner&quot; hybrid edge is changed accordingly, to 1-γ. The field <code>isMajor</code> is also changed accordingly. If the new γ is approximately 0.5, <code>Edge</code> is set to the major parent, its partner is set to the minor parent.</p><p>If <code>net</code> is a HybridNetwork object, <code>printEdges(net)</code> will show the list of edges and their γ&#39;s. The γ of the third hybrid edge (say) can be changed to 0.2 with <code>setGamma!(net.edge[3],0.2)</code>. This will automatically set γ of the partner hybrid edge to 0.8.</p><p>The last argument is true by default. If false: the partner edge is not updated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L837-L853">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.deleteleaf!" href="#PhyloNetworks.deleteleaf!"><code>PhyloNetworks.deleteleaf!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">deleteleaf!(HybridNetwork, leafName::AbstractString; simplify=true)
deleteleaf!(HybridNetwork, Node; simplify=true)
deleteleaf!(HybridNetwork, Integer; index=false, simplify=true)</code></pre><p>Deletes a leaf node from the network, possibly from its name, number, or index in the network&#39;s array of nodes.</p><p>simplify: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.</p><p>The first 2 versions require that <code>node</code> is a leaf. The 3rd version does <strong>not</strong> require that <code>node</code> is a leaf. If <code>node</code> has degree 3 or more, nothing happens. If it has degree 1 or 2, it is deleted.</p><p>Warning: does <strong>not</strong> update attributes related to level-1 networks, such as inCycle, partition, gammaz, etc. Does not require branch lengths, and designed to work on networks of all levels.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L731-L751">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.deleteHybridThreshold!" href="#PhyloNetworks.deleteHybridThreshold!"><code>PhyloNetworks.deleteHybridThreshold!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">deleteHybridThreshold!(net::HybridNetwork, threshold::Float64, keepNodes=false)</code></pre><p>Deletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.</p><ul><li>if threshold&lt;0.5: delete minor hybrid edges with γ &lt; threshold (or with a missing γ, for any threshold &gt; -1.0)</li><li>if threshold=0.5: delete all minor hybrid edges (i.e normally with γ &lt; 0.5, if γ non-missing)</li><li><code>keepNodes</code>: if true, keep all original nodes; delete edges only.</li></ul><p>Warnings:</p><ul><li>by default, <code>keepNodes</code> is false, and partner hybrid edges have their γ changed to 1.0. If <code>keepNodes</code> is true: the γ&#39;s of partner hybrid edges are unchanged.</li><li>assumes correct isMajor attributes.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/compareNetworks.jl#L250-L266">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.rotate!" href="#PhyloNetworks.rotate!"><code>PhyloNetworks.rotate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rotate!(net::HybridNetwork, nodeNumber::Integer; orderedEdgeNum::Array{Int,1})</code></pre><p>Rotates the order of the node&#39;s children edges. Useful for plotting, to remove crossing edges. If <code>node</code> is a tree node with no polytomy, the 2 children edges are switched and the optional argument <code>orderedEdgeNum</code> is ignored.</p><p>Use <code>plot(net, showNodeNumber=true, showEdgeNumber=false)</code> to map node and edge numbers on the network, as shown in the examples below. (see package <a href="https://github.com/cecileane/PhyloPlots.jl">PhyloPlots</a>)</p><p>Warning: assumes that edges are correctly directed (isChild1 updated). This is done by <code>plot(net)</code>. Otherwise run <code>directEdges!(net)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; net = readTopology(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
julia&gt; using PhyloPlots
julia&gt; plot(net, showNodeNumber=true)
julia&gt; rotate!(net, -4)
julia&gt; plot(net)
julia&gt; net=readTopology(&quot;(4,((1,(2)#H7:::0.864):2.069,(6,5):3.423):0.265,(3,#H7:::0.136):10.0);&quot;);
julia&gt; plot(net, showNodeNumber=true, showEdgeNumber=true)
julia&gt; rotate!(net, -1, orderedEdgeNum=[1,12,9])
julia&gt; plot(net, showNodeNumber=true, showEdgeNumber=true)
julia&gt; rotate!(net, -3)
julia&gt; plot(net)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L660-L690">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{TraitSimulation,Symbol}" href="#Base.getindex-Tuple{TraitSimulation,Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getindex(obj, d)</code></pre><p>Getting submatrices of an object of type <a href="public/#PhyloNetworks.TraitSimulation"><code>TraitSimulation</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>obj::TraitSimulation</code>: the matrix from which to extract.</li><li><code>d::Symbol</code>: a symbol precising which sub-matrix to extract. Can be:<ul><li><code>:Tips</code> columns and/or rows corresponding to the tips</li><li><code>:InternalNodes</code> columns and/or rows corresponding to the internal nodes</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1092-L1102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getNodeAges" href="#PhyloNetworks.getNodeAges"><code>PhyloNetworks.getNodeAges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getNodeAges(net)</code></pre><p>vector of node ages in pre-order, as in <code>nodes_changed</code>, which is assumed to have been calculated before.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/pairwiseDistanceLS.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.pairwiseTaxonDistanceMatrix" href="#PhyloNetworks.pairwiseTaxonDistanceMatrix"><code>PhyloNetworks.pairwiseTaxonDistanceMatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pairwiseTaxonDistanceMatrix(net; keepInternal=false,
                            checkPreorder=true, nodeAges=[])
pairwiseTaxonDistanceMatrix!(M, net, nodeAges)</code></pre><p>Return the matrix <code>M</code> of pairwise distances between nodes in the network:</p><ul><li>between all nodes (internal and leaves) if <code>keepInternal=true</code>, in which case the nodes are listed in <code>M</code> in the order in which they appear in <code>net.nodes_changed</code></li><li>between taxa only otherwise, in which case the nodes are listed in <code>M</code> in the order in which they appear in <code>tipLabels(net)</code> (i.e. same order as in <code>net.leaf</code>)</li></ul><p>The second form modifies <code>M</code> in place, assuming all nodes.</p><p>The distance between the root and a given hybrid node (to take an example) is the weighted average of path lengths from the root to that node, where each path is weighted by the product of γs of all edges on that path. This distance measures the average genetic distance across the genome, if branch lengths are in substitutions/site.</p><p>optional arguments:</p><ul><li><code>checkPreorder</code>: if true, <code>net.nodes_changed</code> is updated to get a topological ordering of nodes.</li><li><code>nodeAges</code>: if not provided, i.e. empty vector, the network is <em>not</em> modified.   If provided and non-empty, <code>nodeAges</code> should list node ages in the pre-order in which nodes are listed in <code>nodes_changed</code> (including leaves), and <strong>edge lengths</strong> in <code>net</code> <strong>are modified</strong> accordingly.</li></ul><p>Providing node ages hence makes the network time consistent: such that all paths from the root to a given hybrid node have the same length. If node ages are not provided, the network need not be time consistent.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/pairwiseDistanceLS.jl#L27-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.biconnectedComponents" href="#PhyloNetworks.biconnectedComponents"><code>PhyloNetworks.biconnectedComponents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">biconnectedComponents(network, ignoreTrivial=false)</code></pre><p>Calculate biconnected components (aka &quot;blobs&quot;) using Tarjan&#39;s algorithm: the output is an array of arrays of edges. These blobs are returned in post-order, but within a blob, edges are <em>not</em> necessarily sorted in topological order. If <code>ignoreTrivial</code> is true, trivial components (of a single edge) are not returned. The network is assumed to be connected.</p><p><strong>Warnings</strong>: for nodes, fields <code>k</code>, <code>inCycle</code>, and <code>prev</code> are modified during the algorithm. They are used to store the node&#39;s &quot;index&quot; (time of visitation), &quot;lowpoint&quot;, and the node&#39;s &quot;parent&quot;, as defined by the order in which nodes are visited.</p><p>References:</p><ul><li>p. 153 of <a href="http://epubs.siam.org/doi/pdf/10.1137/0201010">Tarjan (1972)</a>. Depth first search and linear graph algorithms, SIAM Journal on Computing, 1(2):146-160</li><li>on <a href="https://www.geeksforgeeks.org/biconnected-components/">geeksforgeeks</a>, there is an error (as of 2018-01-30): <code>elif v != parent[u] and low[u] &gt; disc[v]:</code> (python version) should be replaced by <code>elif v != parent[u] and disc[u] &gt; disc[v]:</code></li><li>nice explanation at this <a href="https://www.cs.cmu.edu/~avrim/451f12/lectures/biconnected.pdf">url</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/biconnectedComponents.jl#L1-L28">source</a><div><div><pre><code class="language-none">biconnectedComponents(node, index, S, blobs, ignoreTrivial)</code></pre><p>Helper recursive function starting at a node (not a network). <code>index</code> is an array containing a single integer, thus mutable: order in which nodes are visited.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/biconnectedComponents.jl#L53-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.blobDecomposition" href="#PhyloNetworks.blobDecomposition"><code>PhyloNetworks.blobDecomposition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">blobDecomposition!(network)
blobDecomposition(network)</code></pre><p>Find blobs using <a href="#PhyloNetworks.biconnectedComponents"><code>biconnectedComponents</code></a>; find their roots using <a href="../internals/#PhyloNetworks.blobInfo"><code>blobInfo</code></a>; create a forest in the form of a disconnected network (for efficiency), by deconnecting the root of each non-trivial blob from its parent. The root of each blob corresponds to a new leaf (in another tree of the forest): the number of the blob&#39;s root is given to the newly created leaf.</p><p>The first (bang) version modifies the network and returns the array of blob roots. The second version copies the network then returns a tuple: the forest and the blob roots.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/biconnectedComponents.jl#L186-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getlabels" href="#PhyloNetworks.getlabels"><code>PhyloNetworks.getlabels</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getlabels(model)</code></pre><p>State labels of a substitution model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L77-L81">source</a><div><div><p>for a given <a href="../internals/#PhyloNetworks.NucleicAcidSubstitutionModel"><code>NucleicAcidSubstitutionModel</code></a>, labels are symbols from <a href="https://github.com/BioJulia/BioSymbols.jl">BioSymbols</a>. For now, only ACGTs are allowed. (When fitting data, any ambiguity code in the data would be treated as missing value).</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; getlabels(JC69([0.03], false))
4-element Array{BioSymbols.DNA,1}:
 DNA_A
 DNA_C
 DNA_G
 DNA_T

julia&gt; getlabels(HKY85([.5], repeat([0.25], 4)))
4-element Array{BioSymbols.DNA,1}:
 DNA_A
 DNA_C
 DNA_G
 DNA_T
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L112-L136">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.nparams" href="#PhyloNetworks.nparams"><code>PhyloNetworks.nparams</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nparams(model)</code></pre><p>Number of parameters for a given trait evolution model (length of field <code>model.rate</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L46-L51">source</a><div><div><p>for <code>JC69</code> model: 0 if relative, 1 if absolute</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L844-L846">source</a><div><div><p>for <code>HKY85</code> model: 1 if relative, 2 if absolute</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L851-L853">source</a></section><h2><a class="nav-anchor" id="data-and-topology-read/write-1" href="#data-and-topology-read/write-1">data and topology read/write</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readfastatodna" href="#PhyloNetworks.readfastatodna"><code>PhyloNetworks.readfastatodna</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readfastatodna(filename::String)</code></pre><p>Read a fasta file to a dataframe containing a column for each site. Calculate weights and remove matching site patterns to reduce matrix dimension.</p><p>Return a tuple containing:</p><ol><li>data frame of BioSequence DNA sequences, with taxon names in column 1 followed by a column for each site pattern, in columns 2-npatterns;</li><li>array of weights, one weight for each of the site columns. The length of the weight vector is equal to npatterns.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L397-L408">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readTopology" href="#PhyloNetworks.readTopology"><code>PhyloNetworks.readTopology</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readTopology(file name)
readTopology(parenthetical description)</code></pre><p>Read tree or network topology from parenthetical format (extended Newick). If the root node has a single child: ignore (i.e. delete from the topology) the root node and its child edge.</p><p>Input: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description.</p><p>A root edge, not enclosed within a pair a parentheses, is ignored. If the root node has a single edge, this one edge is removed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L453-L467">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readTopologyLevel1" href="#PhyloNetworks.readTopologyLevel1"><code>PhyloNetworks.readTopologyLevel1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readTopologyLevel1(filename)
readTopologyLevel1(parenthetical format)</code></pre><p>same as readTopology, reads a tree or network from parenthetical format, but this function enforces the necessary conditions for any starting topology in SNaQ: non-intersecting cycles, no polytomies, unrooted. It sets any missing branch length to 1.0.</p><p>If the network has a bad diamond II (in which edge lengths are γ&#39;s are not identifiable) and if the edge below this diamond has a length <code>t</code> different from 0, then this length is set back to 0 and the major parent hybrid edge is lengthened by <code>t</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L872-L884">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readInputTrees" href="#PhyloNetworks.readInputTrees"><code>PhyloNetworks.readInputTrees</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readInputTrees(file)</code></pre><p>Read a text file with a list of trees/networks in parenthetical format (one tree per line) and transform them like <a href="#PhyloNetworks.readTopologyLevel1"><code>readTopologyLevel1</code></a> does: to be unrooted, with resolved polytomies, missing branch lengths set to 1.0, etc. See <a href="#PhyloNetworks.readMultiTopology"><code>readMultiTopology</code></a> to read multiple trees or networks with no modification.</p><p>Output: array of HybridNetwork objects.</p><p>Each line starting with &quot;(&quot; will be considered as describing one topology. The file can have extra lines that are ignored.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L188-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readMultiTopology" href="#PhyloNetworks.readMultiTopology"><code>PhyloNetworks.readMultiTopology</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>readMultiTopology(file)</code></p><p>Read a text file with a list of networks in parenthetical format (one per line). Each network is read with <a href="#PhyloNetworks.readTopology"><code>readTopology</code></a>. Return an array of HybridNetwork object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L1240-L1246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readNexusTrees" href="#PhyloNetworks.readNexusTrees"><code>PhyloNetworks.readNexusTrees</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readNexusTrees(filename::AbstractString, treereader=readTopology::Function [, args...])</code></pre><p>Read trees in nexus-formatted file and return a vector of <code>HybridNetwork</code>s. For the nexus format, see Maddison, Swofford &amp; Maddison (1997) https://doi.org/10.1093/sysbio/46.4.590. The optional arguments are passed onto the individual tree reader.</p><p>Warnings:</p><ul><li>&quot;translate&quot; tables are not supported yet</li><li>only the first tree block is read</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L981-L992">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readSnaqNetwork" href="#PhyloNetworks.readSnaqNetwork"><code>PhyloNetworks.readSnaqNetwork</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readSnaqNetwork(output file)</code></pre><p>Read the estimated network from a <code>.out</code> file generated by <code>snaq!</code>. The network score is read also, and stored in the network&#39;s field <code>.loglik</code>.</p><p>Warning: despite the name &quot;loglik&quot;, this score is only proportional to the network&#39;s pseudo-deviance: the lower, the better. Do NOT use this score to calculate an AIC or BIC (etc.) value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L1183-L1192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readTrees2CF" href="#PhyloNetworks.readTrees2CF"><code>PhyloNetworks.readTrees2CF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readTrees2CF(treefile)
readTrees2CF(vector of trees)</code></pre><p>Read trees in parenthetical format from a file, or take a vector of trees already read, and calculate the proportion of these trees having a given quartet (concordance factor: CF), for all quartets or for a sample of quartets. Optional arguments include:</p><ul><li>quartetfile: name of text file with list of 4-taxon subsets to be analyzed. If none is specified, the function will list all possible 4-taxon subsets.</li><li>whichQ=&quot;rand&quot;: to choose a random sample of 4-taxon subsets</li><li>numQ: size of random sample (ignored if whichQ is not set to &quot;rand&quot;)</li><li>writeTab=false: does not write the observedCF to a table (default true)</li><li>CFfile: name of file to save the observedCF (default tableCF.txt)</li><li>writeQ=true: save intermediate files with the list of all 4-taxon subsets and chosen random sample (default false).</li><li>writeSummary: write descriptive stats of input data (default: true)</li><li>nexus: if true, it assumes the gene trees are written in nexus file (default: false)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L648-L665">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readTableCF" href="#PhyloNetworks.readTableCF"><code>PhyloNetworks.readTableCF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readTableCF(file)
readTableCF(data frame)
readTableCF!(data frame)</code></pre><p>Read a file or DataFrame object containing a table of concordance factors (CF), with one row per 4-taxon set. The first 4 columns are assumed to give the labels of the 4 taxa in each set (tx1, tx2, tx3, tx4). Columns containing the CFs are assumed to be named <code>CF12_34</code>, <code>CF13_24</code> and <code>CF14_23</code>; or <code>CF12.34</code>, <code>CF13.24</code> and <code>CF14.23</code>; or else are assumed to be columns 5,6,7. If present, a column named &#39;ngenes&#39; will be used to get the number of loci used to estimate the CFs for each 4-taxon set.</p><p>Output: <a href="#PhyloNetworks.DataCF"><code>DataCF</code></a> object</p><p>Optional arguments:</p><ul><li>summaryfile: if specified, a summary file will be created with that name.</li><li>delim (for the first form only): to specify how columns are delimited, with single quotes: delim=&#39;;&#39;. Default is a <code>csv</code> file, i.e. <code>delim=&#39;,&#39;</code>.</li></ul><p>The last version modifies the input data frame, if species are represented by multiple alleles for instance (see <a href="#PhyloNetworks.readTableCF!"><code>readTableCF!</code></a>(data frame, columns)).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L45-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readTableCF!" href="#PhyloNetworks.readTableCF!"><code>PhyloNetworks.readTableCF!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readTableCF!(data frame, columns)</code></pre><p>Read in quartet CFs from data frame, assuming information is in columns numbered <code>columns</code>, of length <strong>7 or 8</strong>: 4 taxon labels then 3 CFs then ngenes possibly.</p><p>If some species appears more than once in the same 4-taxon set (e.g. t1,t1,t2,t3), then the data frame is modified to remove rows (4-taxon sets) that are uninformative about between-species relationships. This situation may occur if multiple individuals are sampled from the same species. A 4-taxon set is uninformative (and its row is removed) if one taxon is repeated 3 or 4 times (like t1,t1,t1,t1 or t1,t2,t2,t2). The list of species appearing twice in some 4-taxon sets is stored in the output DataCF object. For these species, the length of their external edge is identifiable (in coalescent units). If multiple rows correspond to the same 4-taxon set, these rows are merged and their CF values (and number of genes) are averaged.</p><pre><code class="language-none">readTableCF!(DataCF, data frame, columns)</code></pre><p>Modify the <code>.quartet.obsCF</code> values in the <code>DataCF</code> object with those read from the data frame in columns numbered <code>columns</code>. <code>columns</code> should have <strong>3</strong> columns numbers for the 3 CFs in this order: <code>12_34</code>, <code>13_24</code> and <code>14_23</code>.</p><p>Assumptions:</p><ul><li>same 4-taxon sets in <code>DataCF</code> and in the data frame, and in the same order, but this assumption is <em>not checked</em> (for speed, e.g. during bootstrapping).</li><li>one single row per 4-taxon set (multiple individuals representatives of the same 4-taxon set should have been already merged); basically: the DataCF should have been created from the data frame by <code>readTableCF!(df, colums)</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L147-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.writeTableCF" href="#PhyloNetworks.writeTableCF"><code>PhyloNetworks.writeTableCF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">writeTableCF(vector of quartets)
writeTableCF(DataCF)</code></pre><p>Build a DataFrame containing observed quartet concordance factors, with columns named:</p><ul><li><code>:tx1</code>, <code>:tx2</code>, <code>:tx3</code>, <code>:tx4</code> for the four taxon names in each quartet</li><li><code>:CF12_34</code>, <code>:CF13_24</code>, <code>:CF14_23</code> for the 3 quartets of a given four-taxon set</li><li><code>:ngenes</code> if this information is available for some quartets</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L17-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readBootstrapTrees" href="#PhyloNetworks.readBootstrapTrees"><code>PhyloNetworks.readBootstrapTrees</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readBootstrapTrees(listfile; relative2listfile=true)</code></pre><p>Read the list of file names in <code>listfile</code>, then read all the trees in each of these files. Output: vector of vectors of trees (networks with h&gt;0 allowed).</p><p><code>listfile</code> should be the name of a file containing the path/name to multiple bootstrap files, one on each line (no header). Each named bootstrap file should contain multiple trees, one per line (such as bootstrap trees from a single gene).</p><p>The path/name to each bootstrap file should be relative to <code>listfile</code>. Otherwise, use option <code>relative2listfile=false</code>, in which case the file names are interpreted as usual: relative to the user&#39;s current directory if not given as absolute paths.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/bootstrap.jl#L5-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.writeSubTree!" href="#PhyloNetworks.writeSubTree!"><code>PhyloNetworks.writeSubTree!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">writeSubTree!(IO, network, dendroscope::Bool, namelabel::Bool,
              round_branch_lengths::Bool, digits::Integer,
              internallabel::Bool)</code></pre><p>Write to IO the extended newick format (parenthetical description) of a network. If written for dendroscope, inheritance γ&#39;s are not written. If <code>namelabel</code> is true, taxa are labelled by their names; otherwise taxa are labelled by their number IDs. If unspecified, branch lengths and γ&#39;s are rounded to 3 digits. Use <code>internallabel=false</code> to suppress the labels of internal nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L921-L933">source</a><div><div><pre><code class="language-none">writeSubTree!(IO, node, edge, dendroscope::Bool, namelabel::Bool,
              round_branch_lengths::Bool, digits::Integer, internallabel::Bool)</code></pre><p>Write the extended newick format of the sub-network rooted at <code>node</code> and assuming that <code>edge</code> is a parent of <code>node</code>.</p><p>If the parent <code>edge</code> is <code>nothing</code>, the edge attribute <code>isChild1</code> is used and assumed to be correct to write the subtree rooted at <code>node</code>. This is useful to write a subtree starting at a non-root node. Example:</p><pre><code class="language-julia">net = readTopology(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;)
directEdges!(net)
s = IOBuffer()
writeSubTree!(s, net.node[7], nothing, false, true)
String(take!(s))</code></pre><p>Used by <a href="#PhyloNetworks.writeTopology"><code>writeTopology</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L955-L976">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.writeTopology" href="#PhyloNetworks.writeTopology"><code>PhyloNetworks.writeTopology</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">writeTopology(net)
writeTopology(net, filename)
writeTopology(net, IO)</code></pre><p>Write the parenthetical extended Newick format of a network, as a string, to a file or to an IO buffer / stream. Optional arguments (default values):</p><ul><li>di (false): write in format for Dendroscope</li><li>round (false): rounds branch lengths and heritabilities γ</li><li>digits (3): digits after the decimal place for rounding</li><li>append (false): if true, appends to the file</li><li>internallabel (true): if true, writes internal node labels</li></ul><p>If the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.</p><p>Uses lower-level function <a href="#PhyloNetworks.writeSubTree!"><code>writeSubTree!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L1313-L1332">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.writeMultiTopology" href="#PhyloNetworks.writeMultiTopology"><code>PhyloNetworks.writeMultiTopology</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">writeMultiTopology(nets, file_name; append=false)
writeMultiTopology(nets, IO)</code></pre><p>Write an array of networks in parenthetical extended Newick format, one network per line. Use the option append=true to append to the file. Otherwise, the default is to create a new file or overwrite it, if it already existed. Each network is written with <code>writeTopology</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; net = [readTopology(&quot;(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10);&quot;),
              readTopology(&quot;(A,(B,C));&quot;),readTopology(&quot;(E,F);&quot;),readTopology(&quot;(G,H,F);&quot;)];

julia&gt; writeMultiTopology(net, &quot;fournets.net&quot;) # to (over)write to file &quot;fournets.net&quot;
julia&gt; writeMultiTopology(net, &quot;fournets.net&quot;, append=true) # to append to this file
julia&gt; writeMultiTopology(net, stdout)         # to write to the screen (standard out)
(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10.0);
(A,(B,C));
(E,F);
(G,H,F);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L1268-L1290">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.mapAllelesCFtable" href="#PhyloNetworks.mapAllelesCFtable"><code>PhyloNetworks.mapAllelesCFtable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mapAllelesCFtable(mapping file, CF file; filename, columns, delim)</code></pre><p>Create a new DataFrame containing the same concordance factors as in the input CF file, but with modified taxon names. Each allele name in the input CF table is replaced by the species name that the allele maps onto, based on the mapping file. The mapping file should have column names: allele and species.</p><p>Optional arguments:</p><ul><li>file name to write/save resulting CF table. If not specified, then the output data frame is not saved to a file.</li><li>column numbers for the taxon names. 1-4 by default.</li><li>any keyword arguments that <code>CSV.read</code> would accept. For example, delim=&#39;,&#39; by default: columns are delimited by commas. Unless specified otherwise by the user, <code>categorical</code>=false (to read taxon names as Strings, not levels of a categorical factor, for combining the 4 columns with taxon names more easily). The same CSV arguments are used to read both input file (mapping file and quartet file)</li></ul><p>See also <a href="../internals/#PhyloNetworks.mapAllelesCFtable!-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Array{Int64,1},Bool,AbstractString}"><code>mapAllelesCFtable!</code></a> to input DataFrames instead of file names.</p><p>If a <code>filename</code> is specified, such as &quot;quartetCF_speciesNames.csv&quot; in the example below, this file is best read later with the option <code>categorical=false</code>. example:</p><pre><code class="language-julia">mapAllelesCFtable(&quot;allele-species-map.csv&quot;, &quot;allele-quartet-CF.csv&quot;;
                  filename = &quot;quartetCF_speciesNames.csv&quot;)
df_sp = CSV.read(&quot;quartetCF_speciesNames.csv&quot;, categorical=false); # DataFrame object
dataCF_specieslevel = readTableCF!(df_sp); # DataCF object</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/multipleAlleles.jl#L8-L39">source</a></section><h2><a class="nav-anchor" id="network-inference-1" href="#network-inference-1">network inference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.snaq!" href="#PhyloNetworks.snaq!"><code>PhyloNetworks.snaq!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">snaq!(T::HybridNetwork, d::DataCF)</code></pre><p>Estimate the network (or tree) to fit observed quartet concordance factors (CFs) stored in a DataCF object, using maximum pseudo-likelihood. A level-1 network is assumed. The search starts from topology <code>T</code>, which can be a tree or a network with no more than <code>hmax</code> hybrid nodes. The function name ends with ! because it modifies the CF data <code>d</code> by updating its attributes <code>expCF</code>: CFs expected under the network model. It does <em>not</em> modify <code>T</code>. The quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.</p><p>Output:</p><ul><li>estimated network in file <code>.out</code> (also in <code>.log</code>): best network overall and list of networks from each individual run.</li><li>the best network and modifications of it, in file <code>.networks</code>. All networks in this file have the same undirected topology as the best network, but have different hybrid/gene flow directions. These other networks are reported with their pseudo-likelihood scores, because  non-identifiability issues can cause them to have very similar scores, and because  SNaQ was shown to estimate the undirected topology accurately but not the direction of  hybridization in cases of near non-identifiability.</li><li>if any error occurred, file <code>.err</code> provides information (seed) to reproduce the error.</li></ul><p>There are many optional arguments, including</p><ul><li><code>hmax</code> (default 1): maximum number of hybridizations allowed</li><li><code>verbose</code> (default false): if true, print information about the numerical optimization</li><li><code>runs</code> (default 10): number of independent starting points for the search</li><li><code>outgroup</code> (default none): outgroup taxon to root the estimated topology at the very end</li><li><code>filename</code> (default &quot;snaq&quot;): root name for the output files (<code>.out</code>, <code>.err</code>). If empty (&quot;&quot;), files are <em>not</em> created, progress log goes to the screen only (standard out).</li><li><code>seed</code> (default 0 to get it from the clock): seed to replicate a given search</li><li><code>probST</code> (default 0.3): probability to start from <code>T</code> at each given run. With problability 1-probST, the search is started from an NNI modification of <code>T</code> along a tree edge with no hybrid neighbor, with a possible modification of one reticulation if <code>T</code> has one.</li><li><code>updateBL</code> (default true): If true and if <code>T</code> is a tree, the branch lengths in <code>T</code> are first optimized roughly with <a href="../internals/#PhyloNetworks.updateBL!-Tuple{HybridNetwork,DataCF}"><code>updateBL!</code></a> by using the average CF of all quartets defining each branch and back-calculating the coalescent units.</li></ul><p>The following optional arguments control when to stop the optimization of branch lengths and γ&#39;s on each individual candidate network. Defaults are in parentheses:</p><ul><li><code>ftolRel</code> (1e-6) and <code>ftolAbs</code> (1e-6): relative and absolute differences of the network score between the current and proposed parameters,</li><li><code>xtolRel</code> (1e-2) and <code>xtolAbs</code> (1e-3): relative and absolute differences between the current and proposed parameters.</li></ul><p>Greater values will result in a less thorough but faster search. These parameters are used when evaluating candidate networks only. The following optional arguments control when to stop proposing new network topologies:</p><ul><li><code>Nfail</code> (75): maximum number of times that new topologies are proposed and rejected (in a row).</li><li><code>liktolAbs</code> (1e-6): the proposed network is accepted if its score is better than the current score by at least liktolAbs.</li></ul><p>Lower values of <code>Nfail</code> and greater values of <code>liktolAbs</code> and <code>ftolAbs</code> would result in a less thorough but faster search.</p><p>At the end, branch lengths and γ&#39;s are optimized on the last &quot;best&quot; network with different and very thorough tolerance parameters: 1e-12 for ftolRel, 1e-10 for ftolAbs, xtolRel, xtolAbs.</p><p>See also: <a href="#PhyloNetworks.topologyMaxQPseudolik!"><code>topologyMaxQPseudolik!</code></a> to optimize parameters on a fixed topology, and <a href="#PhyloNetworks.topologyQPseudolik!"><code>topologyQPseudolik!</code></a> to get the deviance (pseudo log-likelihood up to a constant) of a fixed topology with fixed parameters.</p><p>Reference:   Claudia Solís-Lemus and Cécile Ané (2016). Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting. <a href="http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1005896">PLoS Genetics</a> 12(3):e1005896</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L1791-L1865">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.topologyMaxQPseudolik!" href="#PhyloNetworks.topologyMaxQPseudolik!"><code>PhyloNetworks.topologyMaxQPseudolik!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>topologyMaxQPseudolik!(net::HybridNetwork, d::DataCF)</code></p><p>Estimate the branch lengths and inheritance probabilities (γ&#39;s) for a given network topology. The network is <em>not</em> modified, only the object <code>d</code> is, with updated expected concordance factors.</p><p>Ouput: new network, with optimized parameters (branch lengths and gammas). The maximized quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0. This is also an attribute of the network, which can be accessed with <code>net.loglik</code>.</p><p>Optional arguments (default value):</p><ul><li>verbose (false): if true, information on the numerical optimization is printed to screen</li><li>ftolRel (1e-5), ftolAbs (1e-6), xtolRel (1e-3), xtolAbs (1e-4): absolute and relative tolerance values for the pseudo-deviance function and the parameters</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L409-L426">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.topologyQPseudolik!" href="#PhyloNetworks.topologyQPseudolik!"><code>PhyloNetworks.topologyQPseudolik!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>topologyQPseudolik!(net::HybridNetwork, d::DataCF)</code></p><p>Calculate the quartet pseudo-deviance of a given network/tree for DataCF <code>d</code>. This is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.</p><p>Be careful if the net object does not have all internal branch lengths specified because then the pseudolikelihood will be meaningless.</p><p>The loglik attribute of the network is undated, and <code>d</code> is updated with the expected concordance factors under the input network.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/pseudolik.jl#L1296-L1309">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.fittedQuartetCF" href="#PhyloNetworks.fittedQuartetCF"><code>PhyloNetworks.fittedQuartetCF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fittedQuartetCF(d::DataCF, format::Symbol)</code></p><p>return a data frame with the observed and expected quartet concordance factors after estimation of a network with snaq(T,d). The format can be :wide (default) or :long.</p><ul><li>if wide, the output has one row per 4-taxon set, and each row has 10 columns: 4 columns for the taxon names, 3 columns for the observed CFs and 3 columns for the expected CF.</li><li>if long, the output has one row per quartet, i.e. 3 rows per 4-taxon sets, and 7 columns: 4 columns for the taxon names, one column to give the quartet resolution, one column for the observed CF and the last column for the expected CF.</li></ul><p>see also: <code>topologyQPseudolik!</code> and <code>topologyMaxQPseudolik!</code> to update the fitted CF expected under a specific network, inside the DataCF object <code>d</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/descriptive.jl#L22-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.bootsnaq" href="#PhyloNetworks.bootsnaq"><code>PhyloNetworks.bootsnaq</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bootsnaq(T::HybridNetwork, df::DataFrame)
bootsnaq(T::HybridNetwork, vector of tree lists)</code></pre><p>Bootstrap analysis for SNaQ. Bootstrap data can be quartet concordance factors (CF), drawn from sampling uniformly in their credibility intervals, as given in the data frame <code>df</code>. Alternatively, bootstrap data can be gene trees sampled from a vector of tree lists: one list of bootstrap trees per locus (see <code>readBootstrapTrees</code> to generate this, from a file containing a list of bootstrap files: one per locus).</p><p>From each bootstrap replicate, a network is estimated with snaq!, with a search starting from topology <code>T</code>. Optional arguments include the following, with default values in parentheses:</p><ul><li><code>hmax</code> (1): max number of reticulations in the estimated networks</li><li><code>nrep</code> (10): number of bootstrap replicates.</li><li><code>runs</code> (10): number of independent optimization runs for each replicate</li><li><code>filename</code> (&quot;bootsnaq&quot;): root name for output files. No output files if &quot;&quot;.</li><li><code>seed</code> (0 to get a random seed from the clock): seed for random number generator</li><li><code>otherNet</code> (empty): another starting topology so that each replicate will start prcnet% runs on otherNet and (1-prcnet)% runs on <code>T</code></li><li><code>prcnet</code> (0): percentage of runs starting on <code>otherNet</code>; error if different than 0.0, and otherNet not specified.</li><li><code>ftolRel</code>, <code>ftolAbs</code>, <code>xtolRel</code>, <code>xtolAbs</code>, <code>liktolAbs</code>, <code>Nfail</code>, <code>probST</code>, <code>verbose</code>, <code>outgroup</code>: see <code>snaq!</code>, same defaults.</li></ul><p>If <code>T</code> is a tree, its branch lengths are first optimized roughly with <a href="../internals/#PhyloNetworks.updateBL!-Tuple{HybridNetwork,DataCF}"><code>updateBL!</code></a> (by using the average CF of all quartets defining each branch and calculating the coalescent units corresponding to this quartet CF). If <code>T</code> has one or more reticulations, its branch lengths are taken as is to start the search. The branch lengths of <code>otherNet</code> are always taken as is to start the search.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/bootstrap.jl#L302-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.calibrateFromPairwiseDistances!" href="#PhyloNetworks.calibrateFromPairwiseDistances!"><code>PhyloNetworks.calibrateFromPairwiseDistances!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">calibrateFromPairwiseDistances!(net, distances::Matrix{Float64},
    taxon_names::Vector{String})</code></pre><p>Calibrate the network to match (as best as possible) input pairwise distances between taxa, such as observed from sequence data. <code>taxon_names</code> should provide the list of taxa, in the same order in which they they are considered in the <code>distances</code> matrix. The optimization criterion is the sum of squares between the observed distances, and the distances from the network (weighted average of tree distances, weighted by γ&#39;s). The network&#39;s edge lengths are modified.</p><p>Warning: for many networks, mutiple calibrations can fit the pairwise distance data equally well (lack of identifiability). This function will output <em>one</em> of these equally good calibrations.</p><p>optional arguments (default):</p><ul><li>checkPreorder (true)</li><li>forceMinorLength0 (false) to force minor hybrid edges to have a length of 0</li><li>NLoptMethod (:LD<em>MMA) for the optimization algorithm. Other options include :LN</em>COBYLA (derivative-free); see NLopt package.</li><li>tolerance values to control when the optimization is stopped: ftolRel (1e-12), ftolAbs (1e-10) on the criterion, and xtolRel (1e-10), xtolAbs (1e-10) on branch lengths / divergence times.</li><li>verbose (false)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/pairwiseDistanceLS.jl#L211-L237">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.ticr" href="#PhyloNetworks.ticr"><code>PhyloNetworks.ticr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">ticr!(net, D::DataFrame, optimizeBL::Bool)
ticr!(net, D::DataCF,    optimizeBL::Bool)
ticr(D::DataCF)</code></pre><p>Goodness-of-fit test for the adequacy of the multispecies network coalescent, to see if a given population or species network explains the quartet concordance factor data adequately (see Stenz et al 2015 and <a href="http://www.stat.wisc.edu/~ane/publis/2015Stenz_TICR_addendum.pdf">addendum</a> for the method on trees) Obviously the acronym TICR (Tree Incongruence Checking with R) becomes outdated: with a method extended to networks and implemented in Julia. Oh well :smiley:.</p><p>The tree / network needs to have branch lengths in coalescent units, must be fully resolved, and must be of level 1.</p><p>The model assumes a Dirichlet distribution for the observed quartet concordance factor, with concentration parameter estimated from the data. An outlier p-value is calculated for each four-taxon set. Four-taxon sets are then binned into  categories according to their p-values: <code>0-0.01</code>, <code>0.01-0.05</code>, <code>0.05-0.10</code>, and <code>0.10-1</code>. Finally, a chi-square goodness-of-fit test is performed on these binned frequency with 3 degrees of freedom, to determine if they departs from the expected proportions <code>(0.01, 0.04, 0.05, 0.90)</code>.</p><ul><li>The first version takes a DataFrame object where each row corresponds to a given four-taxon set. The DataFrame is modified by having an additional another column containing the p-values corresponding to each four-taxon set.</li><li>The second version takes a DataCF object and modifies it by updating the expected concordance factors stored in that object.</li><li>The last version (which all others call) assumes that the expected concordance factors in the DataCF object are correctly calculated from the test network.</li></ul><p><code>optimizeBL</code>: when false, the loglik field of <code>net</code> is updated; when <code>true</code>, a copy of <code>net</code> with updated branch lengths (in coalescent units) and update loglik is returned.</p><p>output:</p><ul><li>p-value of the χ^2 test</li><li>χ^2 statistic</li><li>value of the pseudo likelihood</li><li>value of the concentration parameter α</li><li>a vector of outlier p-values, one for each four-taxon set</li><li>network (first and second versions): <code>net</code> with loglik field updated if <code>optimizeBL</code> is false;  copy of <code>net</code> with optimized branch lengths and loglik if <code>optimizeBL</code> is true</li></ul><p><strong>References</strong></p><p>NWM Stenz, B Larget, DA Baum and C Ané (2015). Exploring tree-like and non-tree-like patterns using genome sequences: An example using the inbreeding plant species <em>Arabidopsis thaliana</em> (L.) Heynh. Systematic Biology, 64(5):809-823. (https://doi.org/10.1093/sysbio/syv039)</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/ticr.jl#L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.ticr!" href="#PhyloNetworks.ticr!"><code>PhyloNetworks.ticr!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ticr!(net, D::DataFrame, optimizeBL::Bool)
ticr!(net, D::DataCF,    optimizeBL::Bool)
ticr(D::DataCF)</code></pre><p>Goodness-of-fit test for the adequacy of the multispecies network coalescent, to see if a given population or species network explains the quartet concordance factor data adequately (see Stenz et al 2015 and <a href="http://www.stat.wisc.edu/~ane/publis/2015Stenz_TICR_addendum.pdf">addendum</a> for the method on trees) Obviously the acronym TICR (Tree Incongruence Checking with R) becomes outdated: with a method extended to networks and implemented in Julia. Oh well :smiley:.</p><p>The tree / network needs to have branch lengths in coalescent units, must be fully resolved, and must be of level 1.</p><p>The model assumes a Dirichlet distribution for the observed quartet concordance factor, with concentration parameter estimated from the data. An outlier p-value is calculated for each four-taxon set. Four-taxon sets are then binned into  categories according to their p-values: <code>0-0.01</code>, <code>0.01-0.05</code>, <code>0.05-0.10</code>, and <code>0.10-1</code>. Finally, a chi-square goodness-of-fit test is performed on these binned frequency with 3 degrees of freedom, to determine if they departs from the expected proportions <code>(0.01, 0.04, 0.05, 0.90)</code>.</p><ul><li>The first version takes a DataFrame object where each row corresponds to a given four-taxon set. The DataFrame is modified by having an additional another column containing the p-values corresponding to each four-taxon set.</li><li>The second version takes a DataCF object and modifies it by updating the expected concordance factors stored in that object.</li><li>The last version (which all others call) assumes that the expected concordance factors in the DataCF object are correctly calculated from the test network.</li></ul><p><code>optimizeBL</code>: when false, the loglik field of <code>net</code> is updated; when <code>true</code>, a copy of <code>net</code> with updated branch lengths (in coalescent units) and update loglik is returned.</p><p>output:</p><ul><li>p-value of the χ^2 test</li><li>χ^2 statistic</li><li>value of the pseudo likelihood</li><li>value of the concentration parameter α</li><li>a vector of outlier p-values, one for each four-taxon set</li><li>network (first and second versions): <code>net</code> with loglik field updated if <code>optimizeBL</code> is false;  copy of <code>net</code> with optimized branch lengths and loglik if <code>optimizeBL</code> is true</li></ul><p><strong>References</strong></p><p>NWM Stenz, B Larget, DA Baum and C Ané (2015). Exploring tree-like and non-tree-like patterns using genome sequences: An example using the inbreeding plant species <em>Arabidopsis thaliana</em> (L.) Heynh. Systematic Biology, 64(5):809-823. (https://doi.org/10.1093/sysbio/syv039)</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/ticr.jl#L1-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.undirectedOtherNetworks" href="#PhyloNetworks.undirectedOtherNetworks"><code>PhyloNetworks.undirectedOtherNetworks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">undirectedOtherNetworks(net::HybridNetwork)</code></pre><p>Return a vector of HybridNetwork objects, obtained by switching the placement of each hybrid node to other nodes inside its cycle. This amounts to changing the direction of a gene flow event (recursively to move around the whole cycle of each reticulation).</p><p>Optional argument: <code>outgroup</code>, as a String. If an outgroup is specified, then networks conflicting with the placement of the root are avoided.</p><p>Assumptions: <code>net</code> is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. All level-1 fields of <code>net</code> are assumed up-to-date.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; net = readTopology(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
julia&gt; vnet = undirectedOtherNetworks(net)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L1-L20">source</a></section><h2><a class="nav-anchor" id="network-Comparisons-1" href="#network-Comparisons-1">network Comparisons</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.majorTree" href="#PhyloNetworks.majorTree"><code>PhyloNetworks.majorTree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>majorTree(net::HybridNetwork)</code></p><p>Warning: assumes correct isMajor attributes.</p><p>Extracts the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node. Returns a HybridNetwork object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/compareNetworks.jl#L364-L371">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.minorTreeAt" href="#PhyloNetworks.minorTreeAt"><code>PhyloNetworks.minorTreeAt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">minorTreeAt(net::HybridNetwork, hybindex::Integer, keepNodes=false)</code></pre><p>Extract the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i=<code>hybindex</code>), where the minor hybrid edge is kept instead of the major hybrid edge. If <code>keepNodes</code> is true, all nodes are kept during edge removal.</p><p>Warning: assume correct <code>isMajor</code> fields.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/compareNetworks.jl#L387-L396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.displayedTrees" href="#PhyloNetworks.displayedTrees"><code>PhyloNetworks.displayedTrees</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">displayedTrees(net::HybridNetwork, gamma::Float64; keepNodes=false::Bool)</code></pre><p>Extracts all trees displayed in a network, following hybrid edges with heritability &gt;= γ threshold (or &gt;0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than γ. Returns an array of trees, as HybridNetwork objects.</p><p><code>keepNodes</code>: if true, keep all nodes during hybrid edge removal.</p><p>Warnings:</p><ul><li>if <code>keepNodes</code> is true: the retained partner hybrid edges have their γ values unchanged, but their <code>isMajor</code> is changed to true</li><li>assume correct <code>isMajor</code> attributes.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/compareNetworks.jl#L305-L320">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.displayedNetworkAt!" href="#PhyloNetworks.displayedNetworkAt!"><code>PhyloNetworks.displayedNetworkAt!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">displayedNetworkAt!(net::HybridNetwork, node::Node, keepNodes=false)</code></pre><p>Delete all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before. If <code>keepNodes</code> is true, all nodes are kept during edge removal.</p><p>Warning: assume correct <code>isMajor</code> fields.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/compareNetworks.jl#L408-L416">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.hardwiredClusters" href="#PhyloNetworks.hardwiredClusters"><code>PhyloNetworks.hardwiredClusters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>hardwiredClusters(net::HybridNetwork, S::Union{Vector{String},Vector{Int}})</code></p><p>Returns a matrix describing all the hardwired clusters in a network. Warnings: Clusters are rooted, so the root must be correct.           Allows for missing taxa, with entries all 0.</p><p>Each row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).</p><ul><li>first column: edge number</li><li>next columns: 0/1 values. 1=descendant of edge, 0=not a descendant, or missing taxon.</li><li>last column:  10/11 values. 10=tree edge, 11=hybrid edge</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/compareNetworks.jl#L57-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.hardwiredCluster" href="#PhyloNetworks.hardwiredCluster"><code>PhyloNetworks.hardwiredCluster</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hardwiredCluster(edge::Edge,taxa::Union{Vector{String},Vector{Int}})
hardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}})
hardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}},
                  visited::Vector{Int})</code></pre><p>Calculate the hardwired cluster of <code>node</code>, coded a vector of booleans: true for taxa that are descendent of nodes, false for other taxa (including missing taxa).</p><p>The node should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.</p><p>visited: vector of node numbers, of all visited nodes.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; net5 = &quot;(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));&quot; |&gt; readTopology |&gt; directEdges! ;

julia&gt; taxa = net5 |&gt; tipLabels # ABC EF D
6-element Array{String,1}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;C&quot;
 &quot;E&quot;
 &quot;F&quot;
 &quot;D&quot;

julia&gt; hardwiredCluster(net5.edge[12], taxa) # descendants of 12th edge = CEF
6-element Array{Bool,1}:
 0
 0
 1
 1
 1
 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/compareNetworks.jl#L135-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.hardwiredClusterDistance" href="#PhyloNetworks.hardwiredClusterDistance"><code>PhyloNetworks.hardwiredClusterDistance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>hardwiredClusterDistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)</code></p><p>Takes 2 networks and returns their hardwired cluster distance, that is, the number of hardwired clusters found in one network and not in the other. Note that this is not a distance per se on the full space of hybrid networks: there are pairs of different networks for which this measure is 0. But it is a distance on some network subspaces.</p><p>If the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, the trees are considered unrooted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/compareNetworks.jl#L428-L439">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.treeEdgesBootstrap" href="#PhyloNetworks.treeEdgesBootstrap"><code>PhyloNetworks.treeEdgesBootstrap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>treeEdgesBootstrap(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork)</code></p><p>Read a list of bootstrap networks (<code>boot_net</code>) and a reference network (<code>ref_net</code>), and calculate the bootstrap support of the tree edges in the reference network. All minor hybrid edges (γ&lt;0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.</p><p>output:</p><ul><li>a data frame with one row per tree edge and two columns: edge number, bootstrap support (as a percentage)</li><li>the major tree from the reference network, where minor hybrid edges (with γ&lt;0.5) have been removed.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/bootstrap.jl#L404-L418">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.hybridDetection" href="#PhyloNetworks.hybridDetection"><code>PhyloNetworks.hybridDetection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hybridDetection(net::Vector{HybridNetwork}, net1::HybridNetwork, outgroup::AbstractString)</code></pre><p>function can only compare hybrid nodes in networks that have the same underlying major tree also, need to root all networks in the same place, and the root has to be compatible with the direction of the hybrid edges</p><p>it computes the rooted hardwired distance between networks, the root matters. input: vector of bootstrap networks (net), estimated network (net1), outgroup</p><p>returns</p><ul><li>a matrix with one row per bootstrap network, and 2*number of hybrids in net1, column i corresponds to whether hybrid i (<code>net1.hybrid[i]</code>) is found in the bootstrap network, column 2i+1 corresponds to the estimated gamma on the bootstrap network (0.0 if hybrid not found). To know the order of hybrids, print <code>net1.hybrid</code> or <code>h.name for h in net1.hybrid</code></li><li>list of discrepant trees (trees not matching the main tree in net1)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/bootstrap.jl#L459-L477">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.summarizeHFdf" href="#PhyloNetworks.summarizeHFdf"><code>PhyloNetworks.summarizeHFdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">summarizeHFdf(HFmat::Matrix)</code></pre><p>Summarize data frame output from <a href="#PhyloNetworks.hybridDetection"><code>hybridDetection</code></a>. Output: dataframe with one row per hybrid, and 5 columns:</p><ul><li>hybrid index (order from estimated network, see <a href="#PhyloNetworks.hybridDetection"><code>hybridDetection</code></a>,</li><li>number of bootstrap trees that match the underlying tree of estimated network</li><li>number of bootstrap networks that have the hybrid</li><li>mean estimated gamma in the bootstrap networks that have the hybrid</li><li>sd estimated gamma in the bootstrap networks that have the hybrid also</li></ul><p>last row has index -1, and the third column has the number of networks that have all hybrids (hybrid index, mean gamma, sd gamma are meaningless in this last row)</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/bootstrap.jl#L982-L998">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.hybridBootstrapSupport" href="#PhyloNetworks.hybridBootstrapSupport"><code>PhyloNetworks.hybridBootstrapSupport</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>hybridBootstrapSupport(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)</code></p><p>Match hybrid nodes in a reference network with those in an array of networks, like bootstrap networks. All networks must be fully resolved, and on the same taxon set. If <code>rooted=true</code>, all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).</p><p>Two hybrid edges in two networks are said to match if they share the same &quot;hybrid&quot; clade (or recipient) and the same &quot;donor clade&quot;, which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with γ&gt;0.5) and one is its minor sister (following the major hybrid edge with γ&lt;0.5).</p><p>To calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If <code>rooted=false</code>, sister clades are considered as bipartitions.</p><p>Output:</p><ol><li>a &quot;node&quot; data frame (see below)</li><li>an &quot;edge&quot; data frame (see below)</li><li>a &quot;clade&quot; data frame to describe the make up of all clades found as hybrids or sisters, starting with a column <code>taxa</code> that lists all taxa. All other columns correspond to a given clade and contain true/false values. <code>true</code> means that a given taxon belongs in a given clade. For a clade named <code>H1</code>, for instance, and if the data frame was named <code>cla</code>, the list of taxa in this clade can be obtained with <code>cla[:taxa][cla[:H1]]</code>.</li><li>an array of gamma values, with one row for each bootstrap network and two columns (major/minor) for each hybrid edge in the reference network. If this hybrid edge was found in the bootstrap network (i.e. same hybrid and sister clades, after removal of all other hybrid nodes), its bootstrap gamma value is recorded here. Otherwise, the gamma entry is 0.0.</li><li>a vector with the number of each hybrid edge in the reference network, in the same order as for the columns in the array of gamma values above.</li></ol><p>The &quot;node&quot; data frame has one row per clade and 9 columns giving:</p><ul><li><code>:clade</code>: the clade&#39;s name, like the taxon name (if a hybrid is a single taxon) or the hybrid tag (like &#39;H1&#39;) in the reference network</li><li><code>:node</code>: the node number in the reference network. missing if the clade is not in this network.</li><li><code>:hybridnode</code>: typically the same node number as above, except for hybrid clades in the reference network. For those, the hybrid node number is listed here.</li><li><code>:edge</code>: number of the parent edge, parent to the node in column 2, if found in the ref network. missing otherwise.</li><li><code>:BS_hybrid</code>: percentage of bootstrap networks in which the clade is found to be a hybrid clade.</li><li><code>:BS_sister</code>: percentage of bootstrap networks in which the clade is found to be sister to some hybrid clade (sum of the next 2 columns)</li><li><code>:BS_major_sister</code>: percentage of bootstrap networks in which the clade is found to be the major sister to some hybrid clade</li><li><code>:BS_minor_sister</code>: same as previous, but minor</li><li><code>:BS_hybrid_samesisters</code>: percentage of bootstrap networks in which the clade is found to be a hybrid and with the same set of sister clades as in the reference network. Applies to hybrid clades found in the reference network only, missing for all other clades.</li></ul><p>The &quot;edge&quot; data frame has one row for each pair of clades, and 8 columns:</p><ul><li><code>:edge</code>: hybrid edge number, if the edge appears in the reference network. missing otherwise.</li><li><code>:hybrid_clade</code>: name of the clade found to be a hybrid, descendent of &#39;edge&#39;</li><li><code>:hybrid</code>: node number of that clade, if it appears in the reference network. missing otherwise.</li><li><code>:sister_clade</code>: name of the clade that is sister to &#39;edge&#39;, i.e. be sister to a hybrid</li><li><code>:sister</code>: node number of that clade, if in the ref network.</li><li><code>:BS_hybrid_edge</code>: percentage of bootstrap networks in which &#39;edge&#39; is found to be a hybrid  edge, i.e. when the clade in the &#39;hybrid&#39; column is found to be a hybrid and the clade in  the &#39;sister&#39; column is one of its sisters.</li><li><code>:BS_major</code>: percentage of bootstrap networks in which &#39;edge&#39; is found to be a major hybrid  edge, i.e. when &#39;hybrid&#39; is found to be a hybrid clade and &#39;sister&#39; is found to be its  major sister.</li><li><code>:BS_minor</code>: same as previous, but minor</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/bootstrap.jl#L553-L623">source</a></section><h2><a class="nav-anchor" id="continuous-trait-evolution-1" href="#continuous-trait-evolution-1">continuous trait evolution</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.simulate" href="#PhyloNetworks.simulate"><code>PhyloNetworks.simulate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simulate(net::HybridNetwork, params::ParamsProcess, checkPreorder=true::Bool)</code></pre><p>Simulate traits on <code>net</code> using the parameters <code>params</code>. For now, only parameters of type <a href="#PhyloNetworks.ParamsBM"><code>ParamsBM</code></a> (Brownian Motion) are accepted.</p><p>The simulation using a recursion from the root to the tips of the network, therefore, a pre-ordering of nodes is needed. If <code>checkPreorder=true</code> (default), <a href="#PhyloNetworks.preorder!"><code>preorder!</code></a> is called on the network beforehand. Otherwise, it is assumed that the preordering has already been calculated.</p><p>Returns an object of type <a href="#PhyloNetworks.TraitSimulation"><code>TraitSimulation</code></a>, which has a matrix with two rows: row 1 for the trait expectations at all the nodes, and row 2 for the actual simulated trait values at all the nodes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; phy = readTopology(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;, &quot;examples&quot;, &quot;carnivores_tree.txt&quot;));

julia&gt; par = ParamsBM(1, 0.1) # BM with expectation 1 and variance 0.1.
ParamsBM:
Parameters of a BM with fixed root:
mu: 1
Sigma2: 0.1


julia&gt; using Random; Random.seed!(17920921); # for reproducibility

julia&gt; sim = simulate(phy, par) # Simulate on the tree.
TraitSimulation:
Trait simulation results on a network with 16 tips, using a BM model, with parameters:
mu: 1
Sigma2: 0.1


julia&gt; traits = sim[:Tips] # Extract simulated values at the tips.
16-element Array{Float64,1}:
  2.17618427971927   
  1.0330846124205684 
  3.048979175536912  
  3.0379560744947876 
  2.189704751299587  
  4.031588898597555  
  4.647725850651446  
 -0.8772851731182523 
  4.625121065244063  
 -0.5111667949991542 
  1.3560351170535228 
 -0.10311152349323893
 -2.088472913751017  
  2.6399137689702723 
  2.8051193818084057 
  3.1910928691142915 </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L943-L998">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.shiftHybrid" href="#PhyloNetworks.shiftHybrid"><code>PhyloNetworks.shiftHybrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shiftHybrid(value::Vector{T} where T&lt;:Real, net::HybridNetwork; checkPreorder=true::Bool)</code></pre><p>Construct an object <a href="#PhyloNetworks.ShiftNet"><code>ShiftNet</code></a> with shifts on all the edges below hybrid nodes, with values provided. The vector of values must have the same length as the number of hybrids in the network.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L778-L785">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getShiftEdgeNumber" href="#PhyloNetworks.getShiftEdgeNumber"><code>PhyloNetworks.getShiftEdgeNumber</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getShiftEdgeNumber(shift::ShiftNet)</code></pre><p>Get the edge numbers where the shifts are located, for an object <a href="#PhyloNetworks.ShiftNet"><code>ShiftNet</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L796-L800">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getShiftValue" href="#PhyloNetworks.getShiftValue"><code>PhyloNetworks.getShiftValue</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getShiftValue(shift::ShiftNet)</code></pre><p>Get the values of the shifts, for an object <a href="#PhyloNetworks.ShiftNet"><code>ShiftNet</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L812-L816">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.phyloNetworklm" href="#PhyloNetworks.phyloNetworklm"><code>PhyloNetworks.phyloNetworklm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">phyloNetworklm(f, fr, net, model=&quot;BM&quot;,
    fTolRel=1e^-10, fTolAbs=1e^-10, xTolRel=1e^-10, xTolAbs=1e^-10,
    startingValue=0.5)`</code></pre><p>Phylogenetic regression, using the correlation structure induced by the network.</p><p>Returns an object of class <a href="#PhyloNetworks.PhyloNetworkLinearModel"><code>PhyloNetworkLinearModel</code></a>. See documentation for this type and example to see all the functions that can be applied to it.</p><p><strong>Arguments</strong></p><ul><li><code>f::StatsModels.FormulaTerm</code>: formula to use for the regression</li><li><code>fr::AbstractDataFrame</code>: DataFrame containing the data and regressors at the tips. It should have an extra column labelled &quot;tipNames&quot;, that gives the names of the taxa for each observation.</li><li><code>net::HybridNetwork</code>: phylogenetic network to use. Should have labelled tips.</li><li><code>model::AbstractString=&quot;BM&quot;</code>: the model to use, &quot;BM&quot; (default) or &quot;lambda&quot; (for Pagel&#39;s lambda).</li><li><code>no_names::Bool=false</code>: if <code>true</code>, force the function to ignore the tips names. The data is then assumed to be in the same order as the tips of the network. Default to false, setting it to true is dangerous, and strongly discouraged.</li></ul><p>If <code>model=&quot;lambda&quot;</code>, these parameters control the optimization of lambda:</p><ul><li><code>fTolRel::AbstractFloat=1e-10</code>: relative tolerance on the likelihood value for the optimization in lambda.</li><li><code>fTolAbs::AbstractFloat=1e-10</code>: absolute tolerance on the likelihood value for the optimization in lambda.</li><li><code>xTolRel::AbstractFloat=1e-10</code>: relative tolerance on the parameter value for the optimization in lambda.</li><li><code>xTolAbs::AbstractFloat=1e-10</code>: absolute tolerance on the parameter value for the optimization in lambda.</li><li><code>startingValue::Real=0.5</code>: the starting value for the parameter in the optimization in lambda.</li></ul><p><strong>See also</strong></p><p>Type <a href="#PhyloNetworks.PhyloNetworkLinearModel"><code>PhyloNetworkLinearModel</code></a>, Function <a href="#PhyloNetworks.ancestralStateReconstruction"><code>ancestralStateReconstruction</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; phy = readTopology(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;, &quot;examples&quot;, &quot;caudata_tree.txt&quot;));

julia&gt; using CSV # to read data file, next

julia&gt; dat = CSV.read(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;, &quot;examples&quot;, &quot;caudata_trait.txt&quot;));

julia&gt; using StatsModels # for stat model formulas

julia&gt; fitBM = phyloNetworklm(@formula(trait ~ 1), dat, phy);

julia&gt; fitBM # Shows a summary
StatsModels.TableRegressionModel{PhyloNetworkLinearModel,Array{Float64,2}}

Formula: trait ~ 1

Model: BM

Parameter(s) Estimates:
Sigma2: 0.00294521

Coefficients:
──────────────────────────────────────────────────────────────────────────
             Estimate  Std. Error  t value  Pr(&gt;|t|)  Lower 95%  Upper 95%
──────────────────────────────────────────────────────────────────────────
(Intercept)     4.679    0.330627  14.1519    &lt;1e-31    4.02696    5.33104
──────────────────────────────────────────────────────────────────────────
Log Likelihood: -78.9611507833
AIC: 161.9223015666

julia&gt; round(sigma2_estim(fitBM), digits=6) # rounding for jldoctest convenience
0.002945

julia&gt; round(mu_estim(fitBM), digits=4)
4.679

julia&gt; using StatsBase # for aic() stderror() loglikelihood() etc.

julia&gt; round(loglikelihood(fitBM), digits=10)
-78.9611507833

julia&gt; round(aic(fitBM), digits=10)
161.9223015666

julia&gt; round(aicc(fitBM), digits=10)
161.9841572367

julia&gt; round(bic(fitBM), digits=10)
168.4887090241

julia&gt; round.(coef(fitBM), digits=4)
1-element Array{Float64,1}:
 4.679

julia&gt; confint(fitBM)
1×2 Array{Float64,2}:
 4.02696  5.33104

julia&gt; abs(round(r2(fitBM), digits=10)) # absolute value for jldoctest convenience
0.0

julia&gt; abs(round(adjr2(fitBM), digits=10))
0.0

julia&gt; round.(vcov(fitBM), digits=6)
1×1 Array{Float64,2}:
 0.109314

julia&gt; round.(residuals(fitBM), digits=6)
197-element Array{Float64,1}:
 -0.237648
 -0.357937
 -0.159387
 -0.691868
 -0.323977
 -0.270452
 -0.673486
 -0.584654
 -0.279882
 -0.302175
  ⋮
 -0.777026
 -0.385121
 -0.443444
 -0.327303
 -0.525953
 -0.673486
 -0.603158
 -0.211712
 -0.439833

julia&gt; round.(response(fitBM), digits=5)
197-element Array{Float64,1}:
 4.44135
 4.32106
 4.51961
 3.98713
 4.35502
 4.40855
 4.00551
 4.09434
 4.39912
 4.37682
 ⋮
 3.90197
 4.29388
 4.23555
 4.3517
 4.15305
 4.00551
 4.07584
 4.46729
 4.23917

julia&gt; round.(predict(fitBM), digits=5)
197-element Array{Float64,1}:
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 ⋮
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1472-L1638">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.sigma2_estim" href="#PhyloNetworks.sigma2_estim"><code>PhyloNetworks.sigma2_estim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sigma2_estim(m::PhyloNetworkLinearModel)</code></pre><p>Estimated variance for a fitted object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1785-L1789">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.mu_estim" href="#PhyloNetworks.mu_estim"><code>PhyloNetworks.mu_estim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mu_estim(m::PhyloNetworkLinearModel)</code></pre><p>Estimated root value for a fitted object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1795-L1799">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.lambda_estim" href="#PhyloNetworks.lambda_estim"><code>PhyloNetworks.lambda_estim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lambda_estim(m::PhyloNetworkLinearModel)</code></pre><p>Estimated lambda parameter for a fitted object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1819-L1823">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.ancestralStateReconstruction" href="#PhyloNetworks.ancestralStateReconstruction"><code>PhyloNetworks.ancestralStateReconstruction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ancestralStateReconstruction(net::HybridNetwork, Y::Vector, params::ParamsBM)</code></pre><p>Compute the conditional expectations and variances of the ancestral (un-observed) traits values at the internal nodes of the phylogenetic network (<code>net</code>), given the values of the traits at the tips of the network (<code>Y</code>) and some known parameters of the process used for trait evolution (<code>params</code>, only BM with fixed root works for now).</p><p>This function assumes that the parameters of the process are known. For a more general function, see <code>ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L2049-L2061">source</a><div><div><pre><code class="language-none">ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])</code></pre><p>Function to find the ancestral traits reconstruction on a network, given an object fitted by function <a href="#PhyloNetworks.phyloNetworklm"><code>phyloNetworklm</code></a>. By default, the function assumes that the regressor is just an intercept. If the value of the regressor for all the ancestral states is known, it can be entered in X_n, a matrix with as many columns as the number of predictors used, and as many lines as the number of unknown nodes or tips.</p><p>Returns an object of type <a href="#PhyloNetworks.ReconstructedStates"><code>ReconstructedStates</code></a>. See documentation for this type and examples for functions that can be applied to it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using CSV # to read data file

julia&gt; phy = readTopology(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;, &quot;examples&quot;, &quot;carnivores_tree.txt&quot;));

julia&gt; dat = CSV.read(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;, &quot;examples&quot;, &quot;carnivores_trait.txt&quot;));

julia&gt; using StatsModels # for statistical model formulas

julia&gt; fitBM = phyloNetworklm(@formula(trait ~ 1), dat, phy);

julia&gt; ancStates = ancestralStateReconstruction(fitBM) # Should produce a warning, as variance is unknown.
┌ Warning: These prediction intervals show uncertainty in ancestral values,
│ assuming that the estimated variance rate of evolution is correct.
│ Additional uncertainty in the estimation of this variance rate is
│ ignored, so prediction intervals should be larger.
└ @ PhyloNetworks ~/build/crsl4/PhyloNetworks.jl/src/traits.jl:2163
ReconstructedStates:
───────────────────────────────────────────────
  Node index      Pred.        Min.  Max. (95%)
───────────────────────────────────────────────
        -5.0   1.32139   -0.288423     2.9312
        -8.0   1.03258   -0.539072     2.60423
        -7.0   1.41575   -0.0934395    2.92495
        -6.0   1.39417   -0.0643135    2.85265
        -4.0   1.39961   -0.0603343    2.85955
        -3.0   1.51341   -0.179626     3.20644
       -13.0   5.3192     3.96695      6.67145
       -12.0   4.51176    2.94268      6.08085
       -16.0   1.50947    0.0290151    2.98992
       -15.0   1.67425    0.241696     3.10679
       -14.0   1.80309    0.355568     3.2506
       -11.0   2.7351     1.21896      4.25123
       -10.0   2.73217    1.16545      4.29889
        -9.0   2.41132    0.639075     4.18357
        -2.0   2.04138   -0.0340955    4.11686
        14.0   1.64289    1.64289      1.64289
         8.0   1.67724    1.67724      1.67724
         5.0   0.331568   0.331568     0.331568
         2.0   2.27395    2.27395      2.27395
         4.0   0.275237   0.275237     0.275237
         6.0   3.39094    3.39094      3.39094
        13.0   0.355799   0.355799     0.355799
        15.0   0.542565   0.542565     0.542565
         7.0   0.773436   0.773436     0.773436
        10.0   6.94985    6.94985      6.94985
        11.0   4.78323    4.78323      4.78323
        12.0   5.33016    5.33016      5.33016
         1.0  -0.122604  -0.122604    -0.122604
        16.0   0.73989    0.73989      0.73989
         9.0   4.84236    4.84236      4.84236
         3.0   1.0695     1.0695       1.0695
───────────────────────────────────────────────

julia&gt; expectations(ancStates)
31×2 DataFrames.DataFrame
│ Row │ nodeNumber │ condExpectation │
│     │ Int64      │ Float64         │
├─────┼────────────┼─────────────────┤
│ 1   │ -5         │ 1.32139         │
│ 2   │ -8         │ 1.03258         │
│ 3   │ -7         │ 1.41575         │
│ 4   │ -6         │ 1.39417         │
│ 5   │ -4         │ 1.39961         │
│ 6   │ -3         │ 1.51341         │
│ 7   │ -13        │ 5.3192          │
⋮
│ 24  │ 7          │ 0.773436        │
│ 25  │ 10         │ 6.94985         │
│ 26  │ 11         │ 4.78323         │
│ 27  │ 12         │ 5.33016         │
│ 28  │ 1          │ -0.122604       │
│ 29  │ 16         │ 0.73989         │
│ 30  │ 9          │ 4.84236         │
│ 31  │ 3          │ 1.0695          │

julia&gt; predint(ancStates)
31×2 Array{Float64,2}:
 -0.288423    2.9312
 -0.539072    2.60423
 -0.0934395   2.92495
 -0.0643135   2.85265
 -0.0603343   2.85955
 -0.179626    3.20644
  3.96695     6.67145
  2.94268     6.08085
  0.0290151   2.98992
  0.241696    3.10679
  ⋮
  0.542565    0.542565
  0.773436    0.773436
  6.94985     6.94985
  4.78323     4.78323
  5.33016     5.33016
 -0.122604   -0.122604
  0.73989     0.73989
  4.84236     4.84236
  1.0695      1.0695

julia&gt; expectationsPlot(ancStates) # format the ancestral states
31×2 DataFrames.DataFrame
│ Row │ nodeNumber │ PredInt   │
│     │ Int64      │ Abstract… │
├─────┼────────────┼───────────┤
│ 1   │ -5         │ 1.32      │
│ 2   │ -8         │ 1.03      │
│ 3   │ -7         │ 1.42      │
│ 4   │ -6         │ 1.39      │
│ 5   │ -4         │ 1.4       │
│ 6   │ -3         │ 1.51      │
│ 7   │ -13        │ 5.32      │
⋮
│ 24  │ 7          │ 0.77      │
│ 25  │ 10         │ 6.95      │
│ 26  │ 11         │ 4.78      │
│ 27  │ 12         │ 5.33      │
│ 28  │ 1          │ -0.12     │
│ 29  │ 16         │ 0.74      │
│ 30  │ 9          │ 4.84      │
│ 31  │ 3          │ 1.07      │

julia&gt; using PhyloPlots # next: plot ancestral states on the tree

julia&gt; plot(phy, :RCall, nodeLabel = expectationsPlot(ancStates));

julia&gt; predintPlot(ancStates)
31×2 DataFrames.DataFrame
│ Row │ nodeNumber │ PredInt       │
│     │ Int64      │ Abstract…     │
├─────┼────────────┼───────────────┤
│ 1   │ -5         │ [-0.29, 2.93] │
│ 2   │ -8         │ [-0.54, 2.6]  │
│ 3   │ -7         │ [-0.09, 2.92] │
│ 4   │ -6         │ [-0.06, 2.85] │
│ 5   │ -4         │ [-0.06, 2.86] │
│ 6   │ -3         │ [-0.18, 3.21] │
│ 7   │ -13        │ [3.97, 6.67]  │
⋮
│ 24  │ 7          │ 0.77          │
│ 25  │ 10         │ 6.95          │
│ 26  │ 11         │ 4.78          │
│ 27  │ 12         │ 5.33          │
│ 28  │ 1          │ -0.12         │
│ 29  │ 16         │ 0.74          │
│ 30  │ 9          │ 4.84          │
│ 31  │ 3          │ 1.07          │

julia&gt; plot(phy, :RCall, nodeLabel = predintPlot(ancStates));

julia&gt; using DataFrames # to use allowmissing!

julia&gt; allowmissing!(dat, :trait);

julia&gt; dat[[2, 5], :trait] .= missing; # missing values allowed to fit model

julia&gt; fitBM = phyloNetworklm(@formula(trait ~ 1), dat, phy);

julia&gt; ancStates = ancestralStateReconstruction(fitBM);
┌ Warning: These prediction intervals show uncertainty in ancestral values,
│ assuming that the estimated variance rate of evolution is correct.
│ Additional uncertainty in the estimation of this variance rate is
│ ignored, so prediction intervals should be larger.
└ @ PhyloNetworks ~/build/crsl4/PhyloNetworks.jl/src/traits.jl:2163

julia&gt; expectations(ancStates)
31×2 DataFrames.DataFrame
│ Row │ nodeNumber │ condExpectation │
│     │ Int64      │ Float64         │
├─────┼────────────┼─────────────────┤
│ 1   │ -5         │ 1.42724         │
│ 2   │ -8         │ 1.35185         │
│ 3   │ -7         │ 1.61993         │
│ 4   │ -6         │ 1.54198         │
│ 5   │ -4         │ 1.53916         │
│ 6   │ -3         │ 1.64984         │
│ 7   │ -13        │ 5.33508         │
⋮
│ 24  │ 7          │ 0.773436        │
│ 25  │ 10         │ 6.94985         │
│ 26  │ 11         │ 4.78323         │
│ 27  │ 12         │ 5.33016         │
│ 28  │ 1          │ -0.122604       │
│ 29  │ 16         │ 0.73989         │
│ 30  │ 9          │ 4.84236         │
│ 31  │ 3          │ 1.0695          │

julia&gt; predint(ancStates)
31×2 Array{Float64,2}:
 -0.31245     3.16694
 -0.625798    3.3295
 -0.110165    3.35002
 -0.0710391   3.15501
 -0.0675924   3.14591
 -0.197236    3.49692
  3.89644     6.77373
  2.8741      6.22808
 -0.0358627   3.12834
  0.182594    3.2534
  ⋮
  0.542565    0.542565
  0.773436    0.773436
  6.94985     6.94985
  4.78323     4.78323
  5.33016     5.33016
 -0.122604   -0.122604
  0.73989     0.73989
  4.84236     4.84236
  1.0695      1.0695

julia&gt; expectationsPlot(ancStates) # format node &lt;-&gt; ancestral state
31×2 DataFrames.DataFrame
│ Row │ nodeNumber │ PredInt   │
│     │ Int64      │ Abstract… │
├─────┼────────────┼───────────┤
│ 1   │ -5         │ 1.43      │
│ 2   │ -8         │ 1.35      │
│ 3   │ -7         │ 1.62      │
│ 4   │ -6         │ 1.54      │
│ 5   │ -4         │ 1.54      │
│ 6   │ -3         │ 1.65      │
│ 7   │ -13        │ 5.34      │
⋮
│ 24  │ 7          │ 0.77      │
│ 25  │ 10         │ 6.95      │
│ 26  │ 11         │ 4.78      │
│ 27  │ 12         │ 5.33      │
│ 28  │ 1          │ -0.12     │
│ 29  │ 16         │ 0.74      │
│ 30  │ 9          │ 4.84      │
│ 31  │ 3          │ 1.07      │

julia&gt; plot(phy, :RCall, nodeLabel = expectationsPlot(ancStates));

julia&gt; predintPlot(ancStates) # prediction intervals, in data frame, useful to plot
31×2 DataFrames.DataFrame
│ Row │ nodeNumber │ PredInt       │
│     │ Int64      │ Abstract…     │
├─────┼────────────┼───────────────┤
│ 1   │ -5         │ [-0.31, 3.17] │
│ 2   │ -8         │ [-0.63, 3.33] │
│ 3   │ -7         │ [-0.11, 3.35] │
│ 4   │ -6         │ [-0.07, 3.16] │
│ 5   │ -4         │ [-0.07, 3.15] │
│ 6   │ -3         │ [-0.2, 3.5]   │
│ 7   │ -13        │ [3.9, 6.77]   │
⋮
│ 24  │ 7          │ 0.77          │
│ 25  │ 10         │ 6.95          │
│ 26  │ 11         │ 4.78          │
│ 27  │ 12         │ 5.33          │
│ 28  │ 1          │ -0.12         │
│ 29  │ 16         │ 0.74          │
│ 30  │ 9          │ 4.84          │
│ 31  │ 3          │ 1.07          │

julia&gt; plot(phy, :RCall, nodeLabel = predintPlot(ancStates));</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L2171-L2443">source</a><div><div><pre><code class="language-none">ancestralStateReconstruction(fr::AbstractDataFrame, net::HybridNetwork; kwargs...)</code></pre><p>Function to find the ancestral traits reconstruction on a network, given some data at the tips. Uses function <a href="#PhyloNetworks.phyloNetworklm"><code>phyloNetworklm</code></a> to perform a phylogenetic regression of the data against an intercept (amounts to fitting an evolutionary model on the network, BM being the only option available for now).</p><p>See documentation on <a href="#PhyloNetworks.phyloNetworklm"><code>phyloNetworklm</code></a> and <code>ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])</code> for further details.</p><p>Returns an object of type <a href="#PhyloNetworks.ReconstructedStates"><code>ReconstructedStates</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L2464-L2476">source</a><div><div><pre><code class="language-none">ancestralStateReconstruction(obj::SSM, trait::Integer)
ancestralStateReconstruction(obj::SSM)</code></pre><p>Estimate the marginal probability of ancestral states for discrete character number <code>trait</code>, or for the active trait if <code>trait</code> is unspecified: <code>obj.activesite</code>. The parameters of the <a href="../internals/#PhyloNetworks.StatisticalSubstitutionModel"><code>StatisticalSubstitutionModel</code></a> object <code>obj</code> must first be fitted using <a href="#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a>, and ancestral state reconstruction is conditional on the estimated parameters. If these parameters were estimated using all traits, they are used as is to do ancestral state reconstruction of the particular <code>trait</code> of interest. number <code>trait</code>, or for the active trait if <code>trait</code> is unspecified: <code>obj.activesite</code>. <strong>output</strong>: data frame with a first column for the node numbers, a second column for the node labels, and a column for each possible state: the entries in these columns give the marginal probability that a given node has a given state.</p><p>warnings:</p><ul><li>node numbers and node labels refer to those in <code>obj.net</code>, which might have a different internal representation of nodes than the original network used to build <code>obj</code>.</li><li><code>obj</code> is modified: its likelihood fields (forward, directional &amp; backward) are updated to make sure that they correspond to the current parameter values in <code>obj.model</code>, and to the <code>trait</code> of interest.</li></ul><p>See also <a href="../internals/#PhyloNetworks.discrete_backwardlikelihood_tree!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer}"><code>discrete_backwardlikelihood_tree!</code></a> to update <code>obj.backwardlik</code>.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);&quot;);

julia&gt; m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [&quot;lo&quot;, &quot;hi&quot;]);

julia&gt; using DataFrames

julia&gt; dat = DataFrame(species=[&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;D&quot;], trait=[&quot;hi&quot;,&quot;lo&quot;,&quot;lo&quot;,&quot;hi&quot;]);

julia&gt; fit1 = fitdiscrete(net, m1, dat);

julia&gt; asr = ancestralStateReconstruction(fit1)
9×4 DataFrames.DataFrame
│ Row │ nodenumber │ nodelabel │ lo       │ hi       │
│     │ Int64      │ String    │ Float64  │ Float64  │
├─────┼────────────┼───────────┼──────────┼──────────┤
│ 1   │ 1          │ A         │ 1.0      │ 0.0      │
│ 2   │ 2          │ B         │ 1.0      │ 0.0      │
│ 3   │ 3          │ C         │ 0.0      │ 1.0      │
│ 4   │ 4          │ D         │ 0.0      │ 1.0      │
│ 5   │ 5          │ 5         │ 0.286019 │ 0.713981 │
│ 6   │ 6          │ 6         │ 0.319454 │ 0.680546 │
│ 7   │ 7          │ 7         │ 0.168549 │ 0.831451 │
│ 8   │ 8          │ 8         │ 0.76736  │ 0.23264  │
│ 9   │ 9          │ H1        │ 0.782777 │ 0.217223 │

julia&gt; round.(exp.(fit1.postltw), digits=6) # marginal (posterior) probability that the trait evolved on each displayed tree
2-element Array{Float64,1}:
 0.919831
 0.080169

julia&gt; using PhyloPlots

julia&gt; plot(fit1.net, :R, nodeLabel = asr[!,[:nodenumber, :lo]], tipOffset=0.2); # pp for &quot;lo&quot; state</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traitsLikDiscrete.jl#L700-L763">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.expectations" href="#PhyloNetworks.expectations"><code>PhyloNetworks.expectations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">expectations(obj::ReconstructedStates)</code></pre><p>Estimated reconstructed states at the nodes and tips.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1959-L1963">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.predint" href="#PhyloNetworks.predint"><code>PhyloNetworks.predint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">predint(obj::ReconstructedStates; level=0.95::Real)</code></pre><p>Prediction intervals with level <code>level</code> for internal nodes and missing tips.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1999-L2003">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.expectationsPlot" href="#PhyloNetworks.expectationsPlot"><code>PhyloNetworks.expectationsPlot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">expectationsPlot(obj::ReconstructedStates)</code></pre><p>Compute and format the expected reconstructed states for the plotting function. The resulting dataframe can be readily used as a <code>nodeLabel</code> argument to <code>plot</code> from package <a href="https://github.com/cecileane/PhyloPlots.jl"><code>PhyloPlots</code></a>. Keyword argument <code>markMissing</code> is a string that is appended to predicted tip values, so that they can be distinguished from the actual datapoints. Default to &quot;*&quot;. Set to &quot;&quot; to remove any visual cue.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1968-L1977">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.predintPlot" href="#PhyloNetworks.predintPlot"><code>PhyloNetworks.predintPlot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">predintPlot(obj::ReconstructedStates; level=0.95::Real, withExp=false::Bool)</code></pre><p>Compute and format the prediction intervals for the plotting function. The resulting dataframe can be readily used as a <code>nodeLabel</code> argument to <code>plot</code> from package <a href="https://github.com/cecileane/PhyloPlots.jl"><code>PhyloPlots</code></a>. Keyworks argument <code>level</code> control the confidence level of the prediction interval. If <code>withExp</code> is set to true, then the best predicted value is also shown along with the interval.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L2022-L2031">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.descendenceMatrix" href="#PhyloNetworks.descendenceMatrix"><code>PhyloNetworks.descendenceMatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">descendenceMatrix(net::HybridNetwork; checkPreorder=true::Bool)</code></pre><p>This function computes the inciednce matrix between all the nodes of a network. It assumes that the network is in the pre-order. If checkPreorder is true (default), then it runs function <code>preoder</code> on the network beforehand.</p><p>Returns an object of type <a href="../internals/#PhyloNetworks.MatrixTopologicalOrder"><code>MatrixTopologicalOrder</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L421-L430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.regressorShift" href="#PhyloNetworks.regressorShift"><code>PhyloNetworks.regressorShift</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">regressorShift(node::Vector{Node}, net::HybridNetwork; checkPreorder=true::Bool)</code></pre><p><code>regressorShift(edge::Vector{Edge}, net::HybridNetwork; checkPreorder=true::Bool)</code></p><p>Compute the regressor vectors associated with shifts on edges that are above nodes <code>node</code>, or on edges <code>edge</code>, on a network <code>net</code>. It uses function <a href="#PhyloNetworks.descendenceMatrix"><code>descendenceMatrix</code></a>, so <code>net</code> might be modified to sort it in a pre-order. Return a <code>DataFrame</code> with as many rows as there are tips in net, and a column for each shift, each labelled according to the pattern shift<em>{number</em>of_edge}. It has an aditional column labelled <code>tipNames</code> to allow easy fitting afterward (see example).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5);&quot;);

julia&gt; preorder!(net)

julia&gt; using PhyloPlots

julia&gt; plot(net, :RCall, showNodeNumber=true); # to locate nodes

julia&gt; nodes_shifts = indexin([1,-5], [n.number for n in net.node]) # Put a shift on edges ending at nodes 1 and -5
2-element Array{Union{Nothing, Int64},1}:
 1
 7

julia&gt; params = ParamsBM(10, 0.1, ShiftNet(net.node[nodes_shifts], [3.0, -3.0],  net))
ParamsBM:
Parameters of a BM with fixed root:
mu: 10
Sigma2: 0.1

There are 2 shifts on the network:
──────────────────────────
  Edge Number  Shift Value
──────────────────────────
          8.0         -3.0
          1.0          3.0
──────────────────────────

julia&gt; using Random; Random.seed!(2468); # sets the seed for reproducibility

julia&gt; sim = simulate(net, params); # simulate a dataset with shifts

julia&gt; using DataFrames # to handle data frames

julia&gt; dat = DataFrame(trait = sim[:Tips], tipNames = sim.M.tipNames)
4×2 DataFrames.DataFrame
│ Row │ trait   │ tipNames │
│     │ Float64 │ String   │
├─────┼─────────┼──────────┤
│ 1   │ 13.392  │ A        │
│ 2   │ 9.55741 │ B        │
│ 3   │ 7.17704 │ C        │
│ 4   │ 7.88906 │ D        │

julia&gt; dfr_shift = regressorShift(net.node[nodes_shifts], net) # the regressors matching the shifts.
4×3 DataFrames.DataFrame
│ Row │ shift_1 │ shift_8 │ tipNames │
│     │ Float64 │ Float64 │ String   │
├─────┼─────────┼─────────┼──────────┤
│ 1   │ 1.0     │ 0.0     │ A        │
│ 2   │ 0.0     │ 0.0     │ B        │
│ 3   │ 0.0     │ 1.0     │ C        │
│ 4   │ 0.0     │ 0.6     │ D        │

julia&gt; dfr = join(dat, dfr_shift, on=:tipNames); # join data and regressors in a single dataframe

julia&gt; using StatsModels # for statistical model formulas

julia&gt; fitBM = phyloNetworklm(@formula(trait ~ shift_1 + shift_8), dfr, net) # actual fit
StatsModels.TableRegressionModel{PhyloNetworkLinearModel,Array{Float64,2}}

Formula: trait ~ 1 + shift_1 + shift_8

Model: BM

Parameter(s) Estimates:
Sigma2: 0.0112618

Coefficients:
───────────────────────────────────────────────────────────────────────────
             Estimate  Std. Error   t value  Pr(&gt;|t|)  Lower 95%  Upper 95%
───────────────────────────────────────────────────────────────────────────
(Intercept)   9.48238    0.327089  28.9902     0.0220    5.32632   13.6384
shift_1       3.9096     0.46862    8.34279    0.0759   -2.04479    9.86399
shift_8      -2.4179     0.422825  -5.71843    0.1102   -7.7904     2.95461
───────────────────────────────────────────────────────────────────────────
Log Likelihood: 1.8937302027
AIC: 4.2125395947
</code></pre><p><strong>See also</strong></p><p><a href="#PhyloNetworks.phyloNetworklm"><code>phyloNetworklm</code></a>, <a href="#PhyloNetworks.descendenceMatrix"><code>descendenceMatrix</code></a>, <a href="#PhyloNetworks.regressorHybrid"><code>regressorHybrid</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L467-L563">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.regressorHybrid" href="#PhyloNetworks.regressorHybrid"><code>PhyloNetworks.regressorHybrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">regressorHybrid(net::HybridNetwork; checkPreorder=true::Bool)</code></pre><p>Compute the regressor vectors associated with shifts on edges that imediatly below all hybrid nodes of <code>net</code>. It uses function <a href="#PhyloNetworks.descendenceMatrix"><code>descendenceMatrix</code></a> through a call to <a href="#PhyloNetworks.regressorShift"><code>regressorShift</code></a>, so <code>net</code> might be modified to sort it in a pre-order. Return a <code>DataFrame</code> with as many rows as there are tips in net, and a column for each hybrid, each labelled according to the pattern shift<em>{number</em>of_edge}. It has an aditional column labelled <code>tipNames</code> to allow easy fitting afterward (see example).</p><p>This function can be used to test for heterosis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames # Needed to handle data frames.

julia&gt; net = readTopology(&quot;(A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5);&quot;);

julia&gt; preorder!(net)

julia&gt; using PhyloPlots

julia&gt; plot(net, :RCall, showNodeNumber=true); # to locate nodes: node 5 is child of hybrid node

julia&gt; nodes_hybrids = indexin([5], [n.number for n in net.node]) # Put a shift on edges below hybrids
1-element Array{Union{Nothing, Int64},1}:
 5

julia&gt; params = ParamsBM(10, 0.1, ShiftNet(net.node[nodes_hybrids], [3.0],  net))
ParamsBM:
Parameters of a BM with fixed root:
mu: 10
Sigma2: 0.1

There are 1 shifts on the network:
──────────────────────────
  Edge Number  Shift Value
──────────────────────────
          6.0          3.0
──────────────────────────


julia&gt; using Random; Random.seed!(2468); # sets the seed for reproducibility

julia&gt; sim = simulate(net, params); # simulate a dataset with shifts

julia&gt; dat = DataFrame(trait = sim[:Tips], tipNames = sim.M.tipNames)
4×2 DataFrames.DataFrame
│ Row │ trait   │ tipNames │
│     │ Float64 │ String   │
├─────┼─────────┼──────────┤
│ 1   │ 10.392  │ A        │
│ 2   │ 9.55741 │ B        │
│ 3   │ 10.177  │ C        │
│ 4   │ 12.6891 │ D        │

julia&gt; dfr_hybrid = regressorHybrid(net) # the reressors matching the hybrids.
4×3 DataFrames.DataFrame
│ Row │ shift_6 │ tipNames │ sum     │
│     │ Float64 │ String   │ Float64 │
├─────┼─────────┼──────────┼─────────┤
│ 1   │ 0.0     │ A        │ 0.0     │
│ 2   │ 0.0     │ B        │ 0.0     │
│ 3   │ 0.0     │ C        │ 0.0     │
│ 4   │ 1.0     │ D        │ 1.0     │

julia&gt; dfr = join(dat, dfr_hybrid, on=:tipNames); # join data and regressors in a single dataframe

julia&gt; using StatsModels

julia&gt; fitBM = phyloNetworklm(@formula(trait ~ shift_6), dfr, net) # actual fit
StatsModels.TableRegressionModel{PhyloNetworkLinearModel,Array{Float64,2}}

Formula: trait ~ 1 + shift_6

Model: BM

Parameter(s) Estimates:
Sigma2: 0.041206

Coefficients:
───────────────────────────────────────────────────────────────────────────
             Estimate  Std. Error   t value  Pr(&gt;|t|)  Lower 95%  Upper 95%
───────────────────────────────────────────────────────────────────────────
(Intercept)  10.064      0.277959  36.2068     0.0008    8.86805   11.26
shift_6       2.72526    0.315456   8.63912    0.0131    1.36796    4.08256
───────────────────────────────────────────────────────────────────────────
Log Likelihood: -0.7006021946
AIC: 7.4012043891
</code></pre><p><strong>See also</strong></p><p><a href="#PhyloNetworks.phyloNetworklm"><code>phyloNetworklm</code></a>, <a href="#PhyloNetworks.descendenceMatrix"><code>descendenceMatrix</code></a>, <a href="#PhyloNetworks.regressorShift"><code>regressorShift</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L608-L702">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.sharedPathMatrix" href="#PhyloNetworks.sharedPathMatrix"><code>PhyloNetworks.sharedPathMatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sharedPathMatrix(net::HybridNetwork; checkPreorder=true::Bool)</code></pre><p>This function computes the shared path matrix between all the nodes of a network. It assumes that the network is in the pre-order. If checkPreorder is true (default), then it runs function <code>preoder</code> on the network beforehand.</p><p>Returns an object of type <a href="../internals/#PhyloNetworks.MatrixTopologicalOrder"><code>MatrixTopologicalOrder</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L359-L368">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.vcv" href="#PhyloNetworks.vcv"><code>PhyloNetworks.vcv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">vcv(net::HybridNetwork; model=&quot;BM&quot;::AbstractString, 
                        corr=false::Bool,
                        checkPreorder=true::Bool)</code></pre><p>This function computes the variance covariance matrix between the tips of the network, assuming a Brownian model of trait evolution (with unit variance). If optional argument <code>corr</code> is set to <code>true</code>, then the correlation matrix is returned instead.</p><p>The function returns a <code>DataFrame</code> object, with columns named by the tips of the network.</p><p>The calculation of the covariance matrix requires a pre-ordering of nodes to be fast. If <code>checkPreorder</code> is true (default), then <a href="#PhyloNetworks.preorder!"><code>preorder!</code></a> is run on the network beforehand. Otherwise, the network is assumed to be already in pre-order.</p><p>This function internally calls <a href="#PhyloNetworks.sharedPathMatrix"><code>sharedPathMatrix</code></a>, that computes the variance matrix between all the nodes of the network.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tree_str = &quot;(((t2:0.14,t4:0.33):0.59,t3:0.96):0.14,(t5:0.70,t1:0.18):0.90);&quot;;

julia&gt; tree = readTopology(tree_str);

julia&gt; C = vcv(tree)
5×5 DataFrames.DataFrame
│ Row │ t2      │ t4      │ t3      │ t5      │ t1      │
│     │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │
├─────┼─────────┼─────────┼─────────┼─────────┼─────────┤
│ 1   │ 0.87    │ 0.73    │ 0.14    │ 0.0     │ 0.0     │
│ 2   │ 0.73    │ 1.06    │ 0.14    │ 0.0     │ 0.0     │
│ 3   │ 0.14    │ 0.14    │ 1.1     │ 0.0     │ 0.0     │
│ 4   │ 0.0     │ 0.0     │ 0.0     │ 1.6     │ 0.9     │
│ 5   │ 0.0     │ 0.0     │ 0.0     │ 0.9     │ 1.08    │
</code></pre><p>The following block needs <code>ape</code> to be installed (not run):</p><pre><code class="language-julia">julia&gt; using RCall # Comparison with ape vcv function

julia&gt; R&quot;ape::vcv(ape::read.tree(text = $tree_str))&quot;
RCall.RObject{RCall.RealSxp}
     t2   t4   t3  t5   t1
t2 0.87 0.73 0.14 0.0 0.00
t4 0.73 1.06 0.14 0.0 0.00
t3 0.14 0.14 1.10 0.0 0.00
t5 0.00 0.00 0.00 1.6 0.90
t1 0.00 0.00 0.00 0.9 1.08
</code></pre><p>The covariance can also be calculated on a network (for the model, see for Bastide et al. 2018)</p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;((t1:1.0,#H1:0.1::0.30):0.5,((t2:0.9)#H1:0.2::0.70,t3:1.1):0.4);&quot;);

julia&gt; C = vcv(net)
3×3 DataFrames.DataFrame
│ Row │ t1      │ t2      │ t3      │
│     │ Float64 │ Float64 │ Float64 │
├─────┼─────────┼─────────┼─────────┤
│ 1   │ 1.5     │ 0.15    │ 0.0     │
│ 2   │ 0.15    │ 1.248   │ 0.28    │
│ 3   │ 0.0     │ 0.28    │ 1.5     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L279-L344">source</a></section><h2><a class="nav-anchor" id="discrete-trait-evolution-1" href="#discrete-trait-evolution-1">discrete trait evolution</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parsimonySoftwired" href="#PhyloNetworks.parsimonySoftwired"><code>PhyloNetworks.parsimonySoftwired</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">parsimonySoftwired(net, tipdata)
parsimonySoftwired(net, species, sequences)</code></pre><p>Calculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network.</p><p>Data can given in one of the following:</p><ul><li><code>tipdata</code>: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named &quot;taxon&quot; or &quot;species&quot;, and  trait values are to appear in column 2 or in a column named &quot;trait&quot;.</li><li><code>tipdata</code>: dictionary taxon =&gt; state, for a single trait.</li><li><code>species</code>: array of strings, and <code>sequences</code>: array of sequences,  in the order corresponding to the order of species names.</li></ul><p><strong>algorithm</strong></p><p>The dynamic programming algorithm by Fischer et al. (2015) is used. The function loops over all the displayed subtrees within a blob (biconnected component), so its complexity is of the order of <code>n * m * c^2 * 2^level</code> where <code>n</code> is the number of tips, <code>m</code> the number of traits, <code>c</code> the number of states, and <code>level</code> is the level of the network: the maximum number of hybridizations within a blob.</p><p>See <a href="#PhyloNetworks.parsimonyGF"><code>parsimonyGF</code></a> for a different algorithm, slower but extendable to other parsimony criteria.</p><p><strong>references</strong></p><ol><li>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L207-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parsimonyGF" href="#PhyloNetworks.parsimonyGF"><code>PhyloNetworks.parsimonyGF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">parsimonyGF(net, tip_dictionary, criterion=:softwired)
parsimonyGF(net, species, sequenceData, criterion=:softwired)</code></pre><p>Calculate the most parsimonious score of a network given discrete characters at the tips using a general framework (Van Iersel et al. 2018) allowing for various parsimony criteria: softwired (default), hardwired, parental etc. Only softwired is implemented at the moment.</p><p>Data can given in one of the following:</p><ul><li><code>tipdata</code>: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named &quot;taxon&quot; or &quot;species&quot;, and  trait values are to appear in column 2 or in a column named &quot;trait&quot;.</li><li><code>tipdata</code>: dictionary taxon =&gt; state, for a single trait.</li><li><code>species</code>: array of strings, and <code>sequences</code>: array of sequences,   in the order corresponding to the order of species names.</li></ul><p><strong>algorithm</strong></p><p>The complexity of the algorithm is exponential in the level of the network, that is, the maximum number of hybridizations in a single blob, or biconnected component (Fischer et al. 2015). The function loops over all the state assignments of the minor parent of each hybrid node within a blob, so its complexity is of the order of <code>n * m * c^2 * c^level</code> where <code>n</code> is the number of tips, <code>m</code> the number of traits and <code>c</code> the number of states.</p><p>See <a href="#PhyloNetworks.parsimonySoftwired"><code>parsimonySoftwired</code></a> for a faster algorithm, but solving the softwired criterion only.</p><p><strong>references</strong></p><ol><li><p>Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).</p></li><li><p>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</p></li></ol><p>Use the recursive helper function <a href="../internals/#PhyloNetworks.parsimonyBottomUpGF!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray,AbstractArray,AbstractArray}"><code>parsimonyBottomUpGF!</code></a>. Use the fields <code>isChild1</code>, <code>isExtBadTriangle</code> to know which nodes are at the root of a blob, and <code>fromBadDiamondI</code> to know which edges are cut (below the minor parent of each hybrid).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L500-L546">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.Q" href="#PhyloNetworks.Q"><code>PhyloNetworks.Q</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Q(model)</code></pre><p>Substitution rate matrix for a given substitution model: Q[i,j] is the rate of transitioning from state i to state j.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L141-L146">source</a><div><div><p>For a BinaryTraitSubstitutionModel, the rate matrix Q is of the form:</p><pre><code class="language-none">-α  α
 β -β</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L329-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.randomTrait" href="#PhyloNetworks.randomTrait"><code>PhyloNetworks.randomTrait</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">randomTrait(model, t, start)
randomTrait!(end, model, t, start)</code></pre><p>Simulate traits along one edge of length t. <code>start</code> must be a vector of integers, each representing the starting value of one trait. The bang version (ending with !) uses the vector <code>end</code> to store the simulated values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = BinaryTraitSubstitutionModel(1.0, 2.0)
Binary Trait Substitution Model:
rate 0→1 α=1.0
rate 1→0 β=2.0


julia&gt; using Random; Random.seed!(12345);

julia&gt; randomTrait(m1, 0.2, [1,2,1,2,2])
5-element Array{Int64,1}:
 1
 2
 1
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L496-L522">source</a><div><div><pre><code class="language-none">randomTrait(model, net; ntraits=1, keepInternal=true, checkPreorder=true)</code></pre><p>Simulate evolution of discrete traits on a rooted evolutionary network based on the supplied evolutionary model. Trait sampling is uniform at the root.</p><p>optional arguments:</p><ul><li><code>ntraits</code>: number of traits to be simulated (default: 1 trait).</li><li><code>keepInternal</code>: if true, export character states at all nodes, including internal nodes. if false, export character states at tips only.</li></ul><p>output:</p><ul><li>matrix of character states with one row per trait, one column per node; these states are <em>indices</em> in <code>model.label</code>, not the trait labels themselves.</li><li>vector of node labels (for tips) or node numbers (for internal nodes) in the same order as columns in the character state matrix</li></ul><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = BinaryTraitSubstitutionModel(1.0, 2.0, [&quot;low&quot;,&quot;high&quot;]);

julia&gt; net = readTopology(&quot;(((A:4.0,(B:1.0)#H1:1.1::0.9):0.5,(C:0.6,#H1:1.0::0.1):1.0):3.0,D:5.0);&quot;);

julia&gt; using Random; Random.seed!(1234);

julia&gt; trait, lab = randomTrait(m1, net)
([1 2 … 1 1], [&quot;-2&quot;, &quot;D&quot;, &quot;-3&quot;, &quot;-6&quot;, &quot;C&quot;, &quot;-4&quot;, &quot;H1&quot;, &quot;B&quot;, &quot;A&quot;])

julia&gt; trait
1×9 Array{Int64,2}:
 1  2  1  1  2  2  1  1  1

julia&gt; lab
9-element Array{String,1}:
 &quot;-2&quot; 
 &quot;D&quot;  
 &quot;-3&quot; 
 &quot;-6&quot; 
 &quot;C&quot;  
 &quot;-4&quot; 
 &quot;H1&quot;
 &quot;B&quot;  
 &quot;A&quot;  </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L539-L586">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.randomTrait!" href="#PhyloNetworks.randomTrait!"><code>PhyloNetworks.randomTrait!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">randomTrait(model, t, start)
randomTrait!(end, model, t, start)</code></pre><p>Simulate traits along one edge of length t. <code>start</code> must be a vector of integers, each representing the starting value of one trait. The bang version (ending with !) uses the vector <code>end</code> to store the simulated values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = BinaryTraitSubstitutionModel(1.0, 2.0)
Binary Trait Substitution Model:
rate 0→1 α=1.0
rate 1→0 β=2.0


julia&gt; using Random; Random.seed!(12345);

julia&gt; randomTrait(m1, 0.2, [1,2,1,2,2])
5-element Array{Int64,1}:
 1
 2
 1
 1
 2</code></pre></div></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L528">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.fitdiscrete" href="#PhyloNetworks.fitdiscrete"><code>PhyloNetworks.fitdiscrete</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fitdiscrete(net, model, tipdata)
fitdiscrete(net, model, RateVariationAcrossSites, tipdata)
fitdiscrete(net, model, species, traits)
fitdiscrete(net, model, RateVariationAcrossSites, species, traits)
fitdiscrete(net, model, dnadata, dnapatternweights)
fitdiscrete(net, model, RateVariationAcrossSites, dnadata, dnapatternweights)
fitdiscrete(net, modSymbol, species, traits)
fitdiscrete(net, modSymbol, dnadata, dnapatternweights)</code></pre><p>Calculate the maximum likelihood (ML) score of a network given one or more discrete characters at the tips. Along each edge, transitions are modelled with a continous time Markov <code>model</code>, whose parameters are estimated (by maximizing the likelihood). At each hybrid node, the trait is assumed to be inherited from either of the two immediate parents according to the parents&#39; average genetic contributions (inheritance γ). The model ignores incomplete lineage sorting. The algorithm extracts all trees displayed in the network.</p><p>Data can given in one of the following:</p><ul><li><code>tipdata</code>: dictionary taxon =&gt; state label, for a single trait.</li><li><code>tipdata</code>: data frame for a single trait, in which case the taxon names are to appear in column 1 or in a column named &quot;taxon&quot; or &quot;species&quot;, and trait <em>labels</em> are to appear in column 2 or in a column named &quot;trait&quot;. Here, trait labels should be as they appear in <code>getlabels(model)</code>.</li><li><code>species</code>: vector of strings, and <code>traits</code>: DataFrame of traits, with rows in the order corresponding to the order of species names. Again, trait labels should be as they appear in <code>getlabels(model)</code>. All traits are assumed to follow the same model, with same parameters.</li><li>&#39;dnadata&#39;: the first part of the output of readfastatodna,    a dataframe of BioSequence DNA sequences, with taxon in column 1 and a column for each site.</li><li>&#39;dnapatternweights&#39;: the second part of the output of readfastatodna,    an array of weights, one weights for each of the site columns. The length of the weight is equal to nsites.   If using dnapatternweights, must provide dnadata.</li><li>RateVariationAcrossSites: model for rate variation (optional)</li></ul><p>Optional arguments (default):</p><ul><li><code>optimizeQ</code> (true): should model rate parameters be fixed, or should they be optimized?</li><li><code>optimizeRVAS</code> (true): should the model optimize the variable rates across sites?</li><li><code>NLoptMethod</code> (<code>:LN_COBYLA</code>, derivative-free) for the optimization algorithm. For other options, see the <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/">NLopt</a>.</li><li>tolerance values to control when the optimization is stopped: <code>ftolRel</code> (1e-12), <code>ftolAbs</code> (1e-10) on the likelihood, and <code>xtolRel</code> (1e-10), <code>xtolAbs</code> (1e-10) on the model parameters.</li><li>bounds for the alpha parameter of the Gamma distribution of rates across sites: <code>alphamin=0.05</code>, <code>alphamax=500</code>.</li><li><code>verbose</code> (false): if true, more information is output.</li></ul><p><strong>examples:</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);&quot;);

julia&gt; m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [&quot;lo&quot;, &quot;hi&quot;]);

julia&gt; using DataFrames

julia&gt; dat = DataFrame(species=[&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;D&quot;], trait=[&quot;hi&quot;,&quot;lo&quot;,&quot;lo&quot;,&quot;hi&quot;]);

julia&gt; fit1 = fitdiscrete(net, m1, dat)
PhyloNetworks.StatisticalSubstitutionModel:
Binary Trait Substitution Model:
rate lo→hi α=0.27222
rate hi→lo β=0.34981
1 traits, 4 species
on a network with 1 reticulations
log-likelihood: -2.7277

julia&gt; tips = Dict(&quot;A&quot; =&gt; &quot;lo&quot;, &quot;B&quot; =&gt; &quot;lo&quot;, &quot;C&quot; =&gt; &quot;hi&quot;, &quot;D&quot; =&gt; &quot;hi&quot;);

julia&gt; fit2 = fitdiscrete(net, m1, tips; xtolRel=1e-16, xtolAbs=1e-16, ftolRel=1e-16)
PhyloNetworks.StatisticalSubstitutionModel:
Binary Trait Substitution Model:
rate lo→hi α=0.27222
rate hi→lo β=0.34981
1 traits, 4 species
on a network with 1 reticulations
log-likelihood: -2.7277</code></pre><p>Note that a copy of the network is stored in the fitted object, but the internal representation of the network may be different in <code>fit1.net</code> and in the original network <code>net</code>:</p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(sp1:3.0,(sp2:2.0,(sp3:1.0,sp4:1.0):1.0):1.0);&quot;);

julia&gt; using BioSymbols

julia&gt; tips = Dict(&quot;sp1&quot; =&gt; BioSymbols.DNA_A, &quot;sp2&quot; =&gt; BioSymbols.DNA_A, &quot;sp3&quot; =&gt; BioSymbols.DNA_G, &quot;sp4&quot; =&gt; BioSymbols.DNA_G);

julia&gt; mJC69 = JC69([0.25], false);

julia&gt; fitJC69 = fitdiscrete(net, mJC69, tips)
PhyloNetworks.StatisticalSubstitutionModel:
Jukes and Cantor 69 Substitution Model,
absolute rate version
off-diagonal rates equal to 0.29234/3.
rate matrix Q:
               A       C       G       T
       A       *  0.0974  0.0974  0.0974
       C  0.0974       *  0.0974  0.0974
       G  0.0974  0.0974       *  0.0974
       T  0.0974  0.0974  0.0974       *
1 traits, 4 species
on a network with 0 reticulations
log-likelihood: -4.99274

julia&gt; rv = RateVariationAcrossSites()
Rate Variation Across Sites using Discretized Gamma Model
alpha: 1.0
categories for Gamma discretization: 4
ratemultiplier: [0.14578, 0.51313, 1.07083, 2.27025]

julia&gt; fitdiscrete(net, mJC69, rv, tips; optimizeQ=false, optimizeRVAS=false)
PhyloNetworks.StatisticalSubstitutionModel:
Jukes and Cantor 69 Substitution Model,
absolute rate version
off-diagonal rates equal to 0.25/3.
rate matrix Q:
               A       C       G       T
       A       *  0.0833  0.0833  0.0833
       C  0.0833       *  0.0833  0.0833
       G  0.0833  0.0833       *  0.0833
       T  0.0833  0.0833  0.0833       *
1 traits, 4 species
variable rates across sites ~ discretized gamma with
 alpha=1.0
 4 categories
 rate multipliers: [0.14578, 0.51313, 1.07083, 2.27025]
on a network with 0 reticulations
log-likelihood: -5.2568</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traitsLikDiscrete.jl#L69-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.maxParsimonyNet" href="#PhyloNetworks.maxParsimonyNet"><code>PhyloNetworks.maxParsimonyNet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">maxParsimonyNet(T::HybridNetwork, df::DataFrame)</code></pre><p>Search for the most parsimonious network (or tree). A level-1 network is assumed. <code>df</code> should be a data frame containing the species names in column 1, or in a column named <code>species</code> or <code>taxon</code>. Trait data are assumed to be in all other columns. The search starts from topology <code>T</code>, which can be a tree or a network with no more than <code>hmax</code> hybrid nodes (see optional arguments below for <code>hmax</code>).</p><p>Output:</p><ul><li>estimated network in file <code>.out</code> (also in <code>.log</code>): best network overall and list of networks from each individual run.</li><li>if any error occurred, file <code>.err</code> provides information (seed) to reproduce the error.</li></ul><p>Optional arguments include</p><ul><li>hmax: maximum number of hybridizations allowed (default 1)</li><li>runs: number of starting points for the search (default 10); each starting point is <code>T</code> with probability <code>probST</code>=0.3 or a modification of <code>T</code> otherwise (using a NNI move, or a hybrid edge direction change)</li><li>Nfail: number of failures (proposed networks with equal or worse score) before the search is aborted. 75 by default: this is quite small, which is okay for a first trial. Larger values are recommended.</li><li>outgroup: outgroup taxon.           It can be a taxon name (String) or Node number (Integer).           If none provided, or if the outgroup conflicts the starting           topology, the function returns an error</li><li>filename: root name for the output files. Default is &quot;mp&quot;. If empty (&quot;&quot;), files are <em>not</em> created, progress log goes to the screen only (standard out).</li><li>seed: seed to replicate a given search</li><li>criterion: parsimony score could be hardwired, softwired (default) or parental. Currently,            only softwired is implemented</li></ul><p><strong>References</strong></p><ol><li><p>Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).</p></li><li><p>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</p></li></ol><p>For a roadmap of the functions inside maxParsimonyNet, see <a href="../internals/#PhyloNetworks.maxParsimonyNetRun1!"><code>maxParsimonyNetRun1!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L1111-L1160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.nstates" href="#PhyloNetworks.nstates"><code>PhyloNetworks.nstates</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nstates(model)</code></pre><p>Number of character states for a given evolution model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L86-L90">source</a><div><div><p>For example, this is 4 for a <code>NucleicAcidSubstitutionModel</code>.</p><pre><code class="language-julia-repl">julia&gt; nstates(JC69([0.03], false))
4

julia&gt; nstates(HKY85([.5], [0.25, 0.25, 0.25, 0.25]))
4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L93-L103">source</a><div><div><p>for a <code>BinaryTraitSubstitutionModel</code>, this is 2:</p><pre><code class="language-julia-repl">julia&gt; m1 = BinaryTraitSubstitutionModel([1.0,2.0], [&quot;low&quot;,&quot;high&quot;])
Binary Trait Substitution Model:
rate low→high α=1.0
rate high→low β=2.0

julia&gt; nstates(m1)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L310-L322">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.stationary" href="#PhyloNetworks.stationary"><code>PhyloNetworks.stationary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">stationary(substitutionmodel)</code></pre><p>Stationary distribution of a Markov model</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L1141-L1145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.empiricalDNAfrequencies" href="#PhyloNetworks.empiricalDNAfrequencies"><code>PhyloNetworks.empiricalDNAfrequencies</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">empiricalDNAfrequencies(DNAdata::AbstractDataFrame, DNAweights,
                        correction=true, useambiguous=true)</code></pre><p>Estimate base frequencies in DNA data <code>DNAdata</code>, ordered ACGT.</p><ul><li><code>DNAdata</code>: data frame. All columns are used. If the first column gives species names, find a way to ignore it before calculating empirical frequencies, e.g. <code>empiricalDNAfrequencies(view(DNAdata, :, 2:ncol(DNAdata)))</code>. Data type must be <code>BioSymbols.DNA</code> or <code>Char</code> or <code>String</code>. WARNING: this is checked on the first column only.</li><li><code>DNAweights</code>: vector of weights, to weigh each column in <code>DNAdata</code>.</li><li><code>correction</code>: if <code>true</code>, add 1 to each count and 4 to the denominator for a more stable estimator, similar to Bayes prior of 1/4 and the Agresti-Coull interval in binomial estimation.</li><li><code>useambiguous</code>: if <code>true</code>, ambiguous bases are used (except gaps and Ns). For example, <code>Y</code> adds 0.5 weight to <code>C</code> and 0.5 weight to <code>T</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L1055-L1072">source</a></section><footer><hr/><a class="previous" href="../../man/fitDiscrete/"><span class="direction">Previous</span><span class="title">Discrete Trait Evolution</span></a><a class="next" href="../internals/"><span class="direction">Next</span><span class="title">Internals</span></a></footer></article></body></html>
