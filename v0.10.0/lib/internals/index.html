<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · PhyloNetworks.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="PhyloNetworks.jl logo"/></a><h1>PhyloNetworks.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/installation/">Installation</a></li><li><a class="toctext" href="../../man/inputdata/">Input Data for SNaQ</a></li><li><a class="toctext" href="../../man/ticr_howtogetQuartetCFs/">TICR pipeline</a></li><li><a class="toctext" href="../../man/snaq_plot/">Network estimation and display</a></li><li><a class="toctext" href="../../man/dist_reroot/">Network comparison and manipulation</a></li><li><a class="toctext" href="../../man/fixednetworkoptim/">Candidate Networks</a></li><li><a class="toctext" href="../../man/expectedCFs/">Extract Expected CFs</a></li><li><a class="toctext" href="../../man/bootstrap/">Bootstrap</a></li><li><a class="toctext" href="../../man/multiplealleles/">Multiple Alleles</a></li><li><a class="toctext" href="../../man/trait_tree/">Continuous Trait Evolution</a></li><li><a class="toctext" href="../../man/parsimony/">Parsimony on networks</a></li><li><a class="toctext" href="../../man/fitDiscrete/">Discrete Trait Evolution</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../public/">Public</a></li><li class="current"><a class="toctext" href>Internals</a><ul class="internal"><li><a class="toctext" href="#Contents-1">Contents</a></li><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#types-1">types</a></li><li><a class="toctext" href="#functions-1">functions</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Internals</a></li></ul><a class="edit-page" href="https://github.com/crsl4/PhyloNetworks.jl/blob/master/docs/src/lib/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Internals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Internal-Documentation-1" href="#Internal-Documentation-1">Internal Documentation</a></h1><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="#Internal-Documentation-1">Internal Documentation</a></li><ul><li><a href="#Contents-1">Contents</a></li><li><a href="#Index-1">Index</a></li><li><a href="#types-1">types</a></li><li><a href="#functions-1">functions</a></li></ul></ul><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#PhyloNetworks.fAbs"><code>PhyloNetworks.fAbs</code></a></li><li><a href="#PhyloNetworks.ANode"><code>PhyloNetworks.ANode</code></a></li><li><a href="#PhyloNetworks.Edge"><code>PhyloNetworks.Edge</code></a></li><li><a href="#PhyloNetworks.MatrixTopologicalOrder"><code>PhyloNetworks.MatrixTopologicalOrder</code></a></li><li><a href="#PhyloNetworks.Node"><code>PhyloNetworks.Node</code></a></li><li><a href="#PhyloNetworks.NucleicAcidSubstitutionModel"><code>PhyloNetworks.NucleicAcidSubstitutionModel</code></a></li><li><a href="#PhyloNetworks.QuartetNetwork"><code>PhyloNetworks.QuartetNetwork</code></a></li><li><a href="#PhyloNetworks.StatisticalSubstitutionModel"><code>PhyloNetworks.StatisticalSubstitutionModel</code></a></li><li><a href="#PhyloNetworks.SubstitutionModel"><code>PhyloNetworks.SubstitutionModel</code></a></li><li><a href="#Base.getindex"><code>Base.getindex</code></a></li><li><a href="#Base.getindex"><code>Base.getindex</code></a></li><li><a href="#PhyloNetworks.P-Tuple{PhyloNetworks.SubstitutionModel,Float64}"><code>PhyloNetworks.P</code></a></li><li><a href="#PhyloNetworks.P!-Tuple{AbstractArray{T,2} where T,PhyloNetworks.SubstitutionModel,Float64}"><code>PhyloNetworks.P!</code></a></li><li><a href="#PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork,DataFrames.DataFrame}"><code>PhyloNetworks.addAlternativeHybridizations!</code></a></li><li><a href="#PhyloNetworks.afterOptBL!-Tuple{HybridNetwork,DataCF,Bool,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.afterOptBL!</code></a></li><li><a href="#PhyloNetworks.afterOptBLAll!-Tuple{HybridNetwork,DataCF,Integer,Bool,Float64,Float64,Bool,Array{Int64,1},Float64,Float64,Float64}"><code>PhyloNetworks.afterOptBLAll!</code></a></li><li><a href="#PhyloNetworks.afterOptBLRepeat!-Tuple{HybridNetwork,DataCF,Integer,Bool,Bool,Bool,Array{Int64,1}}"><code>PhyloNetworks.afterOptBLRepeat!</code></a></li><li><a href="#PhyloNetworks.anova-Union{Tuple{Vararg{StatsModels.TableRegressionModel{PhyloNetworkLinearModel,T},N} where N}, Tuple{T}} where T"><code>PhyloNetworks.anova</code></a></li><li><a href="#PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}"><code>PhyloNetworks.assignhybridnames!</code></a></li><li><a href="#PhyloNetworks.blobInfo"><code>PhyloNetworks.blobInfo</code></a></li><li><a href="#PhyloNetworks.breakedge!-Tuple{PhyloNetworks.Edge,HybridNetwork}"><code>PhyloNetworks.breakedge!</code></a></li><li><a href="#PhyloNetworks.calculateObsCFAll!-Tuple{DataCF,Union{Array{Int64,1}, Array{String,1}}}"><code>PhyloNetworks.calculateObsCFAll!</code></a></li><li><a href="#PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}"><code>PhyloNetworks.checkNumHybEdges!</code></a></li><li><a href="#PhyloNetworks.check_matchtaxonnames!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,HybridNetwork}"><code>PhyloNetworks.check_matchtaxonnames!</code></a></li><li><a href="#PhyloNetworks.deleteEdge!-Tuple{HybridNetwork,PhyloNetworks.Edge}"><code>PhyloNetworks.deleteEdge!</code></a></li><li><a href="#PhyloNetworks.deleteHybridEdge!"><code>PhyloNetworks.deleteHybridEdge!</code></a></li><li><a href="#PhyloNetworks.deleteLeaf!-Tuple{PhyloNetworks.Network,AbstractString}"><code>PhyloNetworks.deleteLeaf!</code></a></li><li><a href="#PhyloNetworks.deleteNode!-Tuple{HybridNetwork,PhyloNetworks.Node}"><code>PhyloNetworks.deleteNode!</code></a></li><li><a href="#PhyloNetworks.descendants-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.descendants</code></a></li><li><a href="#PhyloNetworks.discrete_backwardlikelihood_tree!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer}"><code>PhyloNetworks.discrete_backwardlikelihood_tree!</code></a></li><li><a href="#PhyloNetworks.discrete_corelikelihood!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}"><code>PhyloNetworks.discrete_corelikelihood!</code></a></li><li><a href="#PhyloNetworks.discrete_corelikelihood_tree!"><code>PhyloNetworks.discrete_corelikelihood_tree!</code></a></li><li><a href="#PhyloNetworks.displayedNetworks!"><code>PhyloNetworks.displayedNetworks!</code></a></li><li><a href="#PhyloNetworks.fuseedgesat!-Tuple{Integer,HybridNetwork}"><code>PhyloNetworks.fuseedgesat!</code></a></li><li><a href="#PhyloNetworks.gammaZero!-Tuple{HybridNetwork,DataCF,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.gammaZero!</code></a></li><li><a href="#PhyloNetworks.getChild-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.getChild</code></a></li><li><a href="#PhyloNetworks.getChildren-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getChildren</code></a></li><li><a href="#PhyloNetworks.getDataValue!-Tuple{IO,Int64,Array{Int64,1}}"><code>PhyloNetworks.getDataValue!</code></a></li><li><a href="#PhyloNetworks.getGammas-Tuple{HybridNetwork}"><code>PhyloNetworks.getGammas</code></a></li><li><a href="#PhyloNetworks.getHeights-Tuple{HybridNetwork}"><code>PhyloNetworks.getHeights</code></a></li><li><a href="#PhyloNetworks.getMajorParent-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getMajorParent</code></a></li><li><a href="#PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getMajorParentEdge</code></a></li><li><a href="#PhyloNetworks.getMinorParent"><code>PhyloNetworks.getMinorParent</code></a></li><li><a href="#PhyloNetworks.getMinorParentEdge"><code>PhyloNetworks.getMinorParentEdge</code></a></li><li><a href="#PhyloNetworks.getParent-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.getParent</code></a></li><li><a href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getParents</code></a></li><li><a href="#PhyloNetworks.getPartner-Tuple{Any}"><code>PhyloNetworks.getPartner</code></a></li><li><a href="#PhyloNetworks.getTipSubmatrix-Tuple{Array{T,2} where T,HybridNetwork}"><code>PhyloNetworks.getTipSubmatrix</code></a></li><li><a href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.hybridEdges</code></a></li><li><a href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge}"><code>PhyloNetworks.hybridEdges</code></a></li><li><a href="#PhyloNetworks.hybridatnode"><code>PhyloNetworks.hybridatnode</code></a></li><li><a href="#PhyloNetworks.inheritanceWeight-Tuple{HybridNetwork}"><code>PhyloNetworks.inheritanceWeight</code></a></li><li><a href="#PhyloNetworks.initializeWeightsFromLeaves!-Tuple{AbstractArray,HybridNetwork,Any,Any,Symbol}"><code>PhyloNetworks.initializeWeightsFromLeaves!</code></a></li><li><a href="#PhyloNetworks.initializeWeightsFromLeavesSoftwired!-Tuple{AbstractArray,HybridNetwork,Any,Any}"><code>PhyloNetworks.initializeWeightsFromLeavesSoftwired!</code></a></li><li><a href="#PhyloNetworks.learnLabels-Tuple{Symbol,Array{String,N} where N,DataFrames.DataFrame}"><code>PhyloNetworks.learnLabels</code></a></li><li><a href="#PhyloNetworks.majoredgelength-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgelength</code></a></li><li><a href="#PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgematrix</code></a></li><li><a href="#PhyloNetworks.makemissing!-Tuple{AbstractArray{T,1} where T}"><code>PhyloNetworks.makemissing!</code></a></li><li><a href="#PhyloNetworks.mapAllelesCFtable!-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Array{Int64,1},Bool,AbstractString}"><code>PhyloNetworks.mapAllelesCFtable!</code></a></li><li><a href="#PhyloNetworks.maxParsimonyNetRun1"><code>PhyloNetworks.maxParsimonyNetRun1</code></a></li><li><a href="#PhyloNetworks.maxParsimonyNetRun1!"><code>PhyloNetworks.maxParsimonyNetRun1!</code></a></li><li><a href="#PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationgamma</code></a></li><li><a href="#PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationlength</code></a></li><li><a href="#PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationmatrix</code></a></li><li><a href="#PhyloNetworks.moveHybrid!-Tuple{HybridNetwork,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.moveHybrid!</code></a></li><li><a href="#PhyloNetworks.optBL!-Tuple{HybridNetwork,DataCF,Bool,Float64,Float64,Float64,Float64}"><code>PhyloNetworks.optBL!</code></a></li><li><a href="#PhyloNetworks.optTopLevel!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},IO,Bool}"><code>PhyloNetworks.optTopLevel!</code></a></li><li><a href="#PhyloNetworks.optTopRun1!-Tuple{HybridNetwork,Any,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,IO,Bool,Float64}"><code>PhyloNetworks.optTopRun1!</code></a></li><li><a href="#PhyloNetworks.optTopRuns!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,AbstractString,AbstractString,Integer,Float64}"><code>PhyloNetworks.optTopRuns!</code></a></li><li><a href="#PhyloNetworks.pairwiseTaxonDistanceGrad-Tuple{HybridNetwork}"><code>PhyloNetworks.pairwiseTaxonDistanceGrad</code></a></li><li><a href="#PhyloNetworks.parseEdgeData!-Tuple{IO,PhyloNetworks.Edge,PhyloNetworks.Node,Array{Int64,1}}"><code>PhyloNetworks.parseEdgeData!</code></a></li><li><a href="#PhyloNetworks.parseHybridNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,String,HybridNetwork,Array{String,1}}"><code>PhyloNetworks.parseHybridNode!</code></a></li><li><a href="#PhyloNetworks.parseRemainingSubtree!-Tuple{IO,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>PhyloNetworks.parseRemainingSubtree!</code></a></li><li><a href="#PhyloNetworks.parseTreeNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.parseTreeNode!</code></a></li><li><a href="#PhyloNetworks.parsimonyBottomUpFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}},Array{Int64,1}}} where T"><code>PhyloNetworks.parsimonyBottomUpFitch!</code></a></li><li><a href="#PhyloNetworks.parsimonyBottomUpGF!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray,AbstractArray,AbstractArray}"><code>PhyloNetworks.parsimonyBottomUpGF!</code></a></li><li><a href="#PhyloNetworks.parsimonyBottomUpSoftwired!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray}"><code>PhyloNetworks.parsimonyBottomUpSoftwired!</code></a></li><li><a href="#PhyloNetworks.parsimonyDiscreteFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{String,T}}} where T"><code>PhyloNetworks.parsimonyDiscreteFitch</code></a></li><li><a href="#PhyloNetworks.parsimonySummaryFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{Int64,Set{T}}}} where T"><code>PhyloNetworks.parsimonySummaryFitch</code></a></li><li><a href="#PhyloNetworks.parsimonyTopDownFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}}}} where T"><code>PhyloNetworks.parsimonyTopDownFitch!</code></a></li><li><a href="#PhyloNetworks.proposedTop!-Tuple{Integer,HybridNetwork,Bool,Integer,Integer,Array{Int64,1},Array{Int64,1},Bool}"><code>PhyloNetworks.proposedTop!</code></a></li><li><a href="#PhyloNetworks.readCSVtoArray-Tuple{DataFrames.DataFrame}"><code>PhyloNetworks.readCSVtoArray</code></a></li><li><a href="#PhyloNetworks.readInputData-Tuple{AbstractString,AbstractString,Symbol,Integer,Bool,AbstractString,Bool,Bool}"><code>PhyloNetworks.readInputData</code></a></li><li><a href="#PhyloNetworks.readSubtree!-Tuple{IO,PhyloNetworks.Node,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>PhyloNetworks.readSubtree!</code></a></li><li><a href="#PhyloNetworks.recursionPostOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Any}"><code>PhyloNetworks.recursionPostOrder</code></a></li><li><a href="#PhyloNetworks.recursionPreOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Function,Any}"><code>PhyloNetworks.recursionPreOrder</code></a></li><li><a href="#PhyloNetworks.recursionPreOrder!"><code>PhyloNetworks.recursionPreOrder!</code></a></li><li><a href="#PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network,PhyloNetworks.Node}"><code>PhyloNetworks.removeHybrid!</code></a></li><li><a href="#PhyloNetworks.resetEdgeNumbers!-Tuple{HybridNetwork}"><code>PhyloNetworks.resetEdgeNumbers!</code></a></li><li><a href="#PhyloNetworks.resetNodeNumbers!-Tuple{HybridNetwork}"><code>PhyloNetworks.resetNodeNumbers!</code></a></li><li><a href="#PhyloNetworks.sameTaxa-Tuple{Quartet,HybridNetwork}"><code>PhyloNetworks.sameTaxa</code></a></li><li><a href="#PhyloNetworks.sampleBootstrapTrees-Tuple{Array{Array{HybridNetwork,1},1}}"><code>PhyloNetworks.sampleBootstrapTrees</code></a></li><li><a href="#PhyloNetworks.sampleCFfromCI"><code>PhyloNetworks.sampleCFfromCI</code></a></li><li><a href="#PhyloNetworks.setBLGammaParsimony!-Tuple{HybridNetwork}"><code>PhyloNetworks.setBLGammaParsimony!</code></a></li><li><a href="#PhyloNetworks.setBranchLength!-Tuple{PhyloNetworks.Edge,Number}"><code>PhyloNetworks.setBranchLength!</code></a></li><li><a href="#PhyloNetworks.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.setGammaBLfromGammaz!</code></a></li><li><a href="#PhyloNetworks.setGammas!-Tuple{HybridNetwork,Array{T,1} where T}"><code>PhyloNetworks.setGammas!</code></a></li><li><a href="#PhyloNetworks.setNonIdBL!-Tuple{HybridNetwork}"><code>PhyloNetworks.setNonIdBL!</code></a></li><li><a href="#PhyloNetworks.setalpha!-Tuple{RateVariationAcrossSites,Float64}"><code>PhyloNetworks.setalpha!</code></a></li><li><a href="#PhyloNetworks.seteigeninfo!-Tuple{PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.seteigeninfo!</code></a></li><li><a href="#PhyloNetworks.seteigeninfo!-Tuple{HKY85}"><code>PhyloNetworks.seteigeninfo!</code></a></li><li><a href="#PhyloNetworks.seteigeninfo!-Tuple{JC69}"><code>PhyloNetworks.seteigeninfo!</code></a></li><li><a href="#PhyloNetworks.seteigeninfo!-Tuple{EqualRatesSubstitutionModel}"><code>PhyloNetworks.seteigeninfo!</code></a></li><li><a href="#PhyloNetworks.seteigeninfo!-Tuple{BinaryTraitSubstitutionModel}"><code>PhyloNetworks.seteigeninfo!</code></a></li><li><a href="#PhyloNetworks.setrates!-Tuple{PhyloNetworks.SubstitutionModel,AbstractArray{T,1} where T}"><code>PhyloNetworks.setrates!</code></a></li><li><a href="#PhyloNetworks.showQ-Tuple{IO,PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.showQ</code></a></li><li><a href="#PhyloNetworks.sortUnionTaxa!-Tuple{Any}"><code>PhyloNetworks.sortUnionTaxa!</code></a></li><li><a href="#PhyloNetworks.startingrate-Tuple{HybridNetwork}"><code>PhyloNetworks.startingrate</code></a></li><li><a href="#PhyloNetworks.symmetricNet"><code>PhyloNetworks.symmetricNet</code></a></li><li><a href="#PhyloNetworks.symmetricNet-Tuple{Int64,Int64,Int64,Real,Real}"><code>PhyloNetworks.symmetricNet</code></a></li><li><a href="#PhyloNetworks.symmetricTree"><code>PhyloNetworks.symmetricTree</code></a></li><li><a href="#PhyloNetworks.synchronizePartnersData!-Tuple{PhyloNetworks.Edge,PhyloNetworks.Node}"><code>PhyloNetworks.synchronizePartnersData!</code></a></li><li><a href="#PhyloNetworks.taxadiff-Tuple{Array{Quartet,1},HybridNetwork}"><code>PhyloNetworks.taxadiff</code></a></li><li><a href="#PhyloNetworks.ticr_optimalpha-Tuple{DataCF}"><code>PhyloNetworks.ticr_optimalpha</code></a></li><li><a href="#PhyloNetworks.traitlabels2indices-Tuple{AbstractArray{T,1} where T,PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.traitlabels2indices</code></a></li><li><a href="#PhyloNetworks.traverseContainRoot!-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge,Array{PhyloNetworks.Edge,1},Array{Bool,1}}"><code>PhyloNetworks.traverseContainRoot!</code></a></li><li><a href="#PhyloNetworks.undoGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.undoGammaz!</code></a></li><li><a href="#PhyloNetworks.updateBL!-Tuple{HybridNetwork,DataCF}"><code>PhyloNetworks.updateBL!</code></a></li><li><a href="#PhyloNetworks.updateContainRoot!"><code>PhyloNetworks.updateContainRoot!</code></a></li><li><a href="#PhyloNetworks.updatePostOrder!"><code>PhyloNetworks.updatePostOrder!</code></a></li><li><a href="#PhyloNetworks.updatePreOrder!"><code>PhyloNetworks.updatePreOrder!</code></a></li><li><a href="#PhyloNetworks.writeTopologyLevel1-Tuple{HybridNetwork}"><code>PhyloNetworks.writeTopologyLevel1</code></a></li><li><a href="#StatsBase.fit-Tuple{Type{PhyloNetworks.StatisticalSubstitutionModel},HybridNetwork,PhyloNetworks.SubstitutionModel,RateVariationAcrossSites,AbstractArray{T,1} where T}"><code>StatsBase.fit</code></a></li></ul><h2><a class="nav-anchor" id="types-1" href="#types-1">types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.ANode" href="#PhyloNetworks.ANode"><code>PhyloNetworks.ANode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>ANode</code></p><p>Abstract node. An object of type <a href="#PhyloNetworks.Edge"><code>Edge</code></a> has a <code>node</code> attribute, which is an vector of 2 <code>ANode</code> objects. The object of type <a href="#PhyloNetworks.Node"><code>Node</code></a> is an <code>ANode</code>, and has an <code>edge</code> attribute, which is vector of <code>Edge</code> objects.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/types.jl#L17-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.Edge" href="#PhyloNetworks.Edge"><code>PhyloNetworks.Edge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Edge(number)</code></pre><p>Data structure for an edge and its various attributes. Most notably:</p><ul><li><code>number</code> (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example</li><li><code>node</code>: a vector of [<code>Node</code>]s, normally just 2 of them</li><li><code>isChild1</code> (boolean): <code>true</code> if <code>node[1]</code> is the child node of the edge, false if <code>node[1]</code> is the parent node of the edge</li><li><code>length</code>: branch length</li><li><code>hybrid</code> (boolean): whether the edge is a tree edge or a hybrid edge (in which case <code>isChild1</code> is important, even if the network is semi-directed)</li><li><code>gamma</code>: proportion of genetic material inherited by the child node via the edge; 1.0 for a tree edge</li><li><code>isMajor</code> (boolean): whether the edge is the major path to the child node; <code>true</code> for tree edges, since a tree edge is the only path to its child node; normally true if <code>gamma&gt;0.5</code>.</li></ul><p>and other fields, used very internally</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/types.jl#L27-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.MatrixTopologicalOrder" href="#PhyloNetworks.MatrixTopologicalOrder"><code>PhyloNetworks.MatrixTopologicalOrder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MatrixTopologicalOrder</code></pre><p>Matrix associated to an <a href="../public/#PhyloNetworks.HybridNetwork"><code>HybridNetwork</code></a> sorted in topological order.</p><p>The following functions and extractors can be applied to it: <a href="../public/#PhyloNetworks.tipLabels"><code>tipLabels</code></a>, <code>obj[:Tips]</code>, <code>obj[:InternalNodes]</code>, <code>obj[:TipsNodes]</code> (see documentation for function <a href="#Base.getindex"><code>getindex(::MatrixTopologicalOrder, ::Symbol)</code></a>).</p><p>Functions <a href="../public/#PhyloNetworks.sharedPathMatrix"><code>sharedPathMatrix</code></a> and <a href="../public/#PhyloNetworks.simulate"><code>simulate</code></a> return objects of this type.</p><p>The <code>MatrixTopologicalOrder</code> object has fields: <code>V</code>, <code>nodeNumbersTopOrder</code>, <code>internalNodeNumbers</code>, <code>tipNumbers</code>, <code>tipNames</code>, <code>indexation</code>. Type in &quot;?MatrixTopologicalOrder.field&quot; to get documentation on a specific field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L11-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.Node" href="#PhyloNetworks.Node"><code>PhyloNetworks.Node</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Node(number, leaf)</code></pre><p>Data structure for an edge and its various attributes. Most notably:</p><ul><li><code>number</code> (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example</li><li><code>leaf</code> (boolean): whether the node is a leaf (with data typically) or an internal node (no data typically)</li><li><code>name</code> (string): taxon name for leaves; internal node may or may not have a name</li><li><code>edge</code>: vector of [<code>Edge</code>]s that the node is attached to; 1 if the node is a leaf, 2 if the node is the root, 3 otherwise, and potentially more if the node has a polytomy</li><li><code>hybrid</code> (boolean): whether the node is a hybrid node (with 2 or more parents) or a tree node (with a single parent)</li></ul><p>Other more internal attributes include:</p><ul><li><code>isBadDiamondI</code> and <code>isBadDiamondII</code> (booleans): whether the node is a hybrid node where the reticulation forms a cycle of 4 nodes (diamond), and where both parents of the hybrid nodes are connected to a leaf. In a bad diamond of type I, the hybrid node itself is also connected to a leaf but the common neighbor of the 2 hybrid&#39;s parents is not connected to a leaf. In a bad diamond of type II, the hybrid node has an internal node as child, and the common neighbor of the 2 hybrid&#39;s parents is connected to a leaf.</li><li><code>isBadTriangle</code>, <code>isVeryBadTriangle</code> and <code>isExtBadTriangle</code> (booleans): true if the reticulation forms a cycle of 3 nodes (triangle) and depending on the number of leaves attached these 3 nodes. The triangle means that the 2 parents of the hybrid node are directly related: one is the child of the other. <code>isBadTriangle</code> is true if the triangle is &quot;good&quot;, as per Solís-Lemus &amp; Ané (2016), that is, if all 3 nodes in the cycle are not connected to any leaves (the reticulation is detectable from quartet concordance factors, even though all branch lengths are not identifiable). <code>isVeryBadTriangle</code> is true if 2 (or all) of the 3 nodes are connected to a leaf, in which case the reticulation is undetectable from unrooted gene tree topologies (thus it&#39;s best to exclude these reticulations from a search). <code>isBadTriangle</code> is true if exactly 1 of the 3 nodes is connected to a leaf.</li></ul><p>For details see Solís-Lemus &amp; Ané (2016, doi:10.1371/journal.pgen.1005896)</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/types.jl#L90-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.NucleicAcidSubstitutionModel" href="#PhyloNetworks.NucleicAcidSubstitutionModel"><code>PhyloNetworks.NucleicAcidSubstitutionModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NucleicAcidSubstitutionModel</code></pre><p>Adapted from <a href="https://github.com/BioJulia/SubstitutionModels.jl/">SubstitutionModels.jl</a> in BioJulia. The same <a href="../public/#PhyloNetworks.Q"><code>Q</code></a> and <a href="#PhyloNetworks.P-Tuple{PhyloNetworks.SubstitutionModel,Float64}"><code>P</code></a> function names are used for the transition rates and probabilities.</p><p>For subtypes, see <a href="../public/#PhyloNetworks.JC69"><code>JC69</code></a>, <a href="../public/#PhyloNetworks.HKY85"><code>HKY85</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L31-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.QuartetNetwork" href="#PhyloNetworks.QuartetNetwork"><code>PhyloNetworks.QuartetNetwork</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">QuartetNetwork(net::HybridNetwork)</code></pre><p>Subtype of <code>Network</code> abstract type. need documentation!</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/types.jl#L242-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.StatisticalSubstitutionModel" href="#PhyloNetworks.StatisticalSubstitutionModel"><code>PhyloNetworks.StatisticalSubstitutionModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StatisticalSubstitutionModel</code></pre><p>Subtype of <code>StatsBase.StatisticalModel</code>, to fit discrete data to a model of trait substitution along a network. See <a href="../public/#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a> to fit a trait substitution model to discrete data. It returns an object of type <code>StatisticalSubstitutionModel</code>, to which standard functions can be applied, like <code>loglikelihood(object)</code>, <code>aic(object)</code> etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traitsLikDiscrete.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.SubstitutionModel" href="#PhyloNetworks.SubstitutionModel"><code>PhyloNetworks.SubstitutionModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SubstitutionModel</code></pre><p>Abstract type for substitution models, using a continous time Markov model on a phylogeny. Adapted from <a href="https://github.com/BioJulia/SubstitutionModels.jl/">SubstitutionModels.jl</a> in BioJulia.</p><p>For variable rates, see <a href="../public/#PhyloNetworks.RateVariationAcrossSites"><code>RateVariationAcrossSites</code></a></p><p>For sub types, see <a href="#PhyloNetworks.NucleicAcidSubstitutionModel"><code>NucleicAcidSubstitutionModel</code></a>, <a href="../public/#PhyloNetworks.TraitSubstitutionModel"><code>TraitSubstitutionModel</code></a></p><p>All these models are supposed to have fields <code>rate</code> and <code>eigeninfo</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L1-L14">source</a></section><h2><a class="nav-anchor" id="functions-1" href="#functions-1">functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getindex(obj, d)</code></pre><p>Getting submatrices of an object of type <a href="../public/#PhyloNetworks.TraitSimulation"><code>TraitSimulation</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>obj::TraitSimulation</code>: the matrix from which to extract.</li><li><code>d::Symbol</code>: a symbol precising which sub-matrix to extract. Can be:<ul><li><code>:Tips</code> columns and/or rows corresponding to the tips</li><li><code>:InternalNodes</code> columns and/or rows corresponding to the internal nodes</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1092-L1102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getindex(obj, d,[ indTips, nonmissing])</code></pre><p>Getting submatrices of an object of type <a href="#PhyloNetworks.MatrixTopologicalOrder"><code>MatrixTopologicalOrder</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>obj::MatrixTopologicalOrder</code>: the matrix from which to extract.</li><li><code>d::Symbol</code>: a symbol precising which sub-matrix to extract. Can be:<ul><li><code>:Tips</code> columns and/or rows corresponding to the tips</li><li><code>:InternalNodes</code> columns and/or rows corresponding to the internal nodes</li><li><code>:TipsNodes</code> columns corresponding to internal nodes, and row to tips (works only is indexation=&quot;b&quot;)</li></ul></li><li><code>indTips::Vector{Int}</code>: optional argument precising a specific order for the tips (internal use).</li><li><code>nonmissing::BitArray{1}</code>: optional argument saying which tips have data (internal use).</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L223-L237">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.P!-Tuple{AbstractArray{T,2} where T,PhyloNetworks.SubstitutionModel,Float64}" href="#PhyloNetworks.P!-Tuple{AbstractArray{T,2} where T,PhyloNetworks.SubstitutionModel,Float64}"><code>PhyloNetworks.P!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">P!(Pmat::AbstractMatrix, obj::SM, t::Float64)</code></pre><p>Fill in the input matrix <code>Pmat</code> with the transition rates to go from each state to another in time <code>t</code>, according to rates in <code>Q</code>. see also: <a href="#PhyloNetworks.P-Tuple{PhyloNetworks.SubstitutionModel,Float64}"><code>P</code></a>.</p><pre><code class="language-julia-repl">julia&gt; m1 = BinaryTraitSubstitutionModel([1.0,2.0], [&quot;low&quot;,&quot;high&quot;])
Binary Trait Substitution Model:
rate low→high α=1.0
rate high→low β=2.0

julia&gt; PhyloNetworks.P!(Matrix{Float64}(undef,2,2), m1, 3.0) # fills an uninitialized 2x2 matrix of floats
2×2 Array{Float64,2}:
 0.666708  0.333292
 0.666584  0.333416

julia&gt; m2 = JC69([1.]);

julia&gt; PhyloNetworks.P!(Matrix{Float64}(undef,4,4), m2, 0.2)
4×4 Array{Float64,2}:
 0.824446   0.0585179  0.0585179  0.0585179
 0.0585179  0.824446   0.0585179  0.0585179
 0.0585179  0.0585179  0.824446   0.0585179
 0.0585179  0.0585179  0.0585179  0.824446 
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L235-L263">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.P-Tuple{PhyloNetworks.SubstitutionModel,Float64}" href="#PhyloNetworks.P-Tuple{PhyloNetworks.SubstitutionModel,Float64}"><code>PhyloNetworks.P</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">P(obj, t)</code></pre><p>Probability transition matrix for a <a href="../public/#PhyloNetworks.TraitSubstitutionModel"><code>TraitSubstitutionModel</code></a>, of the form</p><pre><code class="language-none">P[1,1] ... P[1,k]
   .          .
   .          .
P[k,1] ... P[k,k]</code></pre><p>where P[i,j] is the probability of ending in state j after time t, given that the process started in state i. see also: <a href="#PhyloNetworks.P!-Tuple{AbstractArray{T,2} where T,PhyloNetworks.SubstitutionModel,Float64}"><code>P!</code></a>.</p><p>HKY example:</p><pre><code class="language-julia-repl">julia&gt; m1 = HKY85([0.5], [0.20, 0.30, 0.30, 0.20])
HKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]
relative rate version with transition/tranversion ratio kappa = 0.5,
 scaled so that there is one substitution per unit time
rate matrix Q:
               A       C       G       T
       A       *  0.4839  0.2419  0.3226
       C  0.3226       *  0.4839  0.1613
       G  0.1613  0.4839       *  0.3226
       T  0.3226  0.2419  0.4839       *



julia&gt; PhyloNetworks.P(m1, 3.0)
4×4 StaticArrays.MArray{Tuple{4,4},Float64,2,16} with indices SOneTo(4)×SOneTo(4):
 0.217509  0.198417  0.190967  0.198417
 0.297625  0.312992  0.297625  0.28645
 0.28645   0.297625  0.312992  0.297625
 0.198417  0.190967  0.198417  0.217509</code></pre><p>Juke-Cantor example:</p><pre><code class="language-julia-repl">julia&gt; m1 = JC69([1.]);

julia&gt; PhyloNetworks.P(m1, 0.2)
4×4 StaticArrays.MArray{Tuple{4,4},Float64,2,16} with indices SOneTo(4)×SOneTo(4):
 0.824446   0.0585179  0.0585179  0.0585179
 0.0585179  0.824446   0.0585179  0.0585179
 0.0585179  0.0585179  0.824446   0.0585179
 0.0585179  0.0585179  0.0585179  0.824446 </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L179-L227">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork,DataFrames.DataFrame}" href="#PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork,DataFrames.DataFrame}"><code>PhyloNetworks.addAlternativeHybridizations!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addAlternativeHybridizations!(net::HybridNetwork, BSe::DataFrame;
                              cutoff=10::Number, top=3::Int)</code></pre><p>Modify the network <code>net</code> (the best network estimated with snaq) by adding other hybridizations that are present in the bootstrap networks. By default, it will only consider hybrid edges with more than 10% bootstrap support (<code>cutoff</code>) and it will only include the three top hybridizations (<code>top</code>) sorted by bootstrap support. The function also modifies the dataframe <code>BSe</code> obtained with <code>hybridBootstrapSupport</code>. In the original <code>BSe</code> dataframe, hybrid edges that do not appear in the best network have a missing number. After the hybrid edges are added with <code>addAlternativeHybridizations</code>, <code>BSe</code> is modified to include the edge numbers of the newly added hybrid edges. Note that the function only adds the hybrid edges as minor to keep the underlying tree topology.</p><p><strong>example</strong></p><pre><code class="language-julia">bootnet = readMultiTopology(&quot;bootstrap-networks.txt&quot;)
bestnet = readTopology(&quot;best.tre&quot;)
BSn, BSe, BSc, BSgam, BSedgenum = hybridBootstrapSupport(bootnet, bestnet);
addAlternativeHybridizations!(bestnet,BSe)
using PhyloPlots
plot(bestnet, edgeLabel=BSe[[:edge,:BS_hybrid_edge]])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/addHybrid.jl#L355-L379">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.afterOptBL!-Tuple{HybridNetwork,DataCF,Bool,Bool,Bool,Integer,Array{Int64,1}}" href="#PhyloNetworks.afterOptBL!-Tuple{HybridNetwork,DataCF,Bool,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.afterOptBL!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>afterOptBL</code> road map</p><p>Function that will check if there are <code>h==0,1;t==0,hz==0,1</code> cases in a network after calling <code>optBL!</code>.</p><p>Arguments:</p><ul><li><code>closeN=true</code> will move origin/target, if false, add/delete N times before giving up (we have only tested <code>closeN=true</code>)</li><li><code>origin=true</code> will move origin, false will move target. We added this to avoid going back and forth between the same networks</li><li><code>movesgamma</code> vector of counts of number of times each move is proposed to fix a gamma zero problem: <code>(add,mvorigin,mvtarget,chdir,delete,nni)</code></li></ul><p>Procedure:</p><ul><li><p>First we split the <code>ht</code> vector in <code>nh,nt,nhz</code> (gammas, lengths, gammaz)</p></li><li><p>If we find a <code>h==0,1</code>, we loop through <code>nh</code> to find a hybrid edge with h==0 or 1 and want to try to fix this by doing:</p><ul><li><code>gammaZero!(currT,d,edge,closeN,origin,N,movesgamma)</code> which returns true if there was a successful change, and we stop the loop</li></ul></li><li><p>If we find a <code>t==0</code>, we loop through all <code>nt</code> to find such edge, and do NNI move on this edge; return true if change successful and we stop the loop</p></li><li><p>If we find a <code>hz==0,1</code>, we loop through <code>nhz</code> to find such hybrid edge and call <code>gammaZero</code> again</p></li><li><p>If we did a successful change, we run <code>optBL</code> again, and recheck if there are no more problems.</p></li><li><p>Returns successchange, flagh, flagt,flaghz (flag=true means no problems)</p></li><li><p>If it is the multiple alleles case, it will not try to fix <code>h==0,1;hz==0,1</code> because it can reach a case that violates the multiple alleles condition. If we add a check here, things become horribly slow and inefficient, so we just delete a hybridization that has <code>h==0,1;hz==0,1</code></p></li></ul><p>** Important: ** <code>afterOptBL</code> is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call <code>afterOptBLRepeat</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L572-L596">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.afterOptBLAll!-Tuple{HybridNetwork,DataCF,Integer,Bool,Float64,Float64,Bool,Array{Int64,1},Float64,Float64,Float64}" href="#PhyloNetworks.afterOptBLAll!-Tuple{HybridNetwork,DataCF,Integer,Bool,Float64,Float64,Bool,Array{Int64,1},Float64,Float64,Float64}"><code>PhyloNetworks.afterOptBLAll!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>afterOptBLAll</code> road map</p><p>After <code>optBL</code>, we want to call <code>afterOptBLAll</code> (or <code>afterOptBLAllMultipleAlleles</code>) to check if there are <code>h==0,1</code>; <code>t==0</code>; <code>hz==0,1</code>. This function will try to fix the gamma zero problem, but if it cannot, it will call <code>moveDownLevel</code>, to delete the hybridization from the network.</p><p>Procedure:</p><p>While <code>startover=true</code> and <code>tries&lt;N</code></p><ul><li>While <code>badliks &lt; N2</code> (number of bad pseudolikelihoods are less than <code>N2</code>)<ul><li>Run <code>success = afterOptBLRepeat</code></li><li>If <code>success = true</code> (it changed something):<ul><li>If worse pseudolik, then go back to original topology <code>currT</code>, set <code>startover=true</code> and <code>badliks++</code></li><li>If better pseudolik, then check flags. If all good, then <code>startover=false</code>; otherwise <code>startover = true</code></li></ul></li><li>If <code>success = false</code> (nothing changed), then set <code>badliks=N2+1</code> (to end the while on <code>currT</code>)<ul><li>If all flags are ok, then <code>startover = false</code></li><li>If bad h or hz, then call <code>moveDownLevel</code> (delete one hybridization), and set <code>startover = true</code> (maybe deleting that hybridization did not fix other gamma zero problems)</li><li>If bad t, then set <code>startover = false</code></li></ul></li></ul></li><li>If left second while by back to original <code>currT</code>, and still bad h/hz, then move down one level, and <code>startover=true</code>; otherwise <code>startover=false</code></li></ul><p>If first while ends by <code>tries&gt;N</code>, then it checks one last time the flags, if bad h/hz will move down one level, and exit</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L757-L776">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.afterOptBLRepeat!-Tuple{HybridNetwork,DataCF,Integer,Bool,Bool,Bool,Array{Int64,1}}" href="#PhyloNetworks.afterOptBLRepeat!-Tuple{HybridNetwork,DataCF,Integer,Bool,Bool,Bool,Array{Int64,1}}"><code>PhyloNetworks.afterOptBLRepeat!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>afterOptBLRepeat</code> road map</p><p><code>afterOptBL</code> is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call <code>afterOptBLRepeat</code>. This function will repeat <code>afterOptBL</code> every time a successful change happened; this is done only if <code>closeN=false</code>, because we would delete/add hybridizations and need to stop after tried N times. If <code>closeN=true</code> (default), then <code>afterOptBLRepeat</code> only does one <code>afterOptBL</code>, because in this case, only the neighbor edges need to be tested, and this would have been done already in <code>gammaZero</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L689-L695">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.anova-Union{Tuple{Vararg{StatsModels.TableRegressionModel{PhyloNetworkLinearModel,T},N} where N}, Tuple{T}} where T" href="#PhyloNetworks.anova-Union{Tuple{Vararg{StatsModels.TableRegressionModel{PhyloNetworkLinearModel,T},N} where N}, Tuple{T}} where T"><code>PhyloNetworks.anova</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">anova(objs::PhyloNetworkLinearModel...)</code></pre><p>Takes several nested fits of the same data, and computes the F statistic for each pair of models.</p><p>The fits must be results of function <a href="../public/#PhyloNetworks.phyloNetworklm"><code>phyloNetworklm</code></a> called on the same data, for models that have more and more effects.</p><p>Returns a DataFrame object with the anova table.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1883-L1893">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}" href="#PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}"><code>PhyloNetworks.assignhybridnames!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">assignhybridnames!(net)</code></pre><p>Assign names to hybrid nodes in the network <code>net</code>. Hybrid nodes with an empty <code>name</code> field (&quot;&quot;) are modified with a name that does not conflict with other hybrid names in the network. The preferred name is &quot;H3&quot; if the node number is 3 or -3, but an index other than 3 would be used if &quot;H3&quot; were the name of another node already.</p><p>If two hybrid nodes have non-empty and equal names, the name of one of them is changed and re-assigned as described above (with a warning).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L1171-L1182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.blobInfo" href="#PhyloNetworks.blobInfo"><code>PhyloNetworks.blobInfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">blobInfo(network, ignoreTrivial=true)</code></pre><p>Calculate the biconnected components (blobs) using function <a href="../public/#PhyloNetworks.biconnectedComponents"><code>biconnectedComponents</code></a> then:</p><ul><li>set node field <code>isExtBadTriangle</code> to true at the root of each non-trivial blob (and at the network root), false otherwise. (a better name for the field would be something like &quot;isBlobRoot&quot;.)</li><li>output:<ol><li>array of nodes that are the roots of each non-trivial blob,</li></ol>and the network root. If the root of the full network is   not part of a non-trivial blob, a corresponding blob is   added to the list.<ol><li>array of arrays: for each non-trivial blob, array of major hybrid edges in that blob.</li><li>array of arrays: same as #2 but for minor hybrid edges, with hybrids listed in the same order, for each blob.</li></ol></li></ul><p>Blobs are ordered in reverse topological ordering (aka post order). If <code>ignoreTrivial</code> is true, trivial components are ignored.</p><p>keyword argument: <code>checkPreorder</code>, true by default. If false, the <code>isChild1</code> edge field and the <code>net.nodes_changed</code> network field are supposed to be correct.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/biconnectedComponents.jl#L115-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.breakedge!-Tuple{PhyloNetworks.Edge,HybridNetwork}" href="#PhyloNetworks.breakedge!-Tuple{PhyloNetworks.Edge,HybridNetwork}"><code>PhyloNetworks.breakedge!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">breakedge!(Edge, HybridNetwork)</code></pre><p>breaks an edge into 2 edges (each of length half that of original edge). creates new node of degree 2. Useful to root network along an edge.</p><p>warning: updates <code>isChild1</code> and <code>containRoot</code>, but does NOT update attributes like: inCycle, partition, gammaz, etc.</p><p>returns the index of the newly created node in the network</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L353-L363">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.calculateObsCFAll!-Tuple{DataCF,Union{Array{Int64,1}, Array{String,1}}}" href="#PhyloNetworks.calculateObsCFAll!-Tuple{DataCF,Union{Array{Int64,1}, Array{String,1}}}"><code>PhyloNetworks.calculateObsCFAll!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">calculateObsCFAll!(DataCF, taxa::Union{Vector{String}, Vector{Int}})</code></pre><p>Calculate observed concordance factors: update the <code>.quartet[i].obsCF</code> values of the <code>DataCF</code> object based on its .tree vector.</p><pre><code class="language-none">calculateObsCFAll!(vector of quartets, vector of trees, taxa)</code></pre><p>Calculate observed concordance factors: update the <code>.obsCF</code> values of the quartets, based on the trees, and returns a new <code>DataCF</code> object with these updated quartets and trees.</p><pre><code class="language-none">calculateObsCFAll_noDataCF!(vector of quartets, vector of trees, taxa)</code></pre><p>update the <code>.obsCF</code> values of the quartets based on the trees, but returns nothing.</p><p>Warning: all these functions need input trees (h=0).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L423-L440">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}" href="#PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}"><code>PhyloNetworks.checkNumHybEdges!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`checkNumHybEdges!(net)`</code></pre><p>Check for consistency between hybrid-related attributes in the network:</p><ul><li>for each hybrid node: 2 or more hybrid edges</li><li>exception: allows for a leaf to be attached to a single hybrid edge</li><li>exactly 2 incoming parent hybrid edges</li></ul><p>Run after <code>storeHybrids!</code>. See also <code>check2HybEdges</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L537-L545">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.check_matchtaxonnames!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,HybridNetwork}" href="#PhyloNetworks.check_matchtaxonnames!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,HybridNetwork}"><code>PhyloNetworks.check_matchtaxonnames!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">check_matchtaxonnames!(species, data, net)</code></pre><p>Modify <code>species</code> and <code>dat</code> by removing the species (rows) absent from the network. Return a new network (<code>net</code> is <em>not</em> modified) with tips matching those in species: if some species in <code>net</code> have no data, these species are pruned from the network. The network also has its node names reset, such that leaves have nodes have consecutive numbers starting at 1, with leaves first. Used by <a href="../public/#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a> to build a new <a href="#PhyloNetworks.StatisticalSubstitutionModel"><code>StatisticalSubstitutionModel</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traitsLikDiscrete.jl#L648-L657">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.deleteEdge!-Tuple{HybridNetwork,PhyloNetworks.Edge}" href="#PhyloNetworks.deleteEdge!-Tuple{HybridNetwork,PhyloNetworks.Edge}"><code>PhyloNetworks.deleteEdge!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">deleteEdge!(net::HybridNetwork,  e::Edge, part=true)
deleteEdge!(net::QuartetNetwork, e::Edge)</code></pre><p>Delete edge <code>e</code> from <code>net.edge</code> and update <code>net.numEdges</code>. If <code>part</code> is true, update the network&#39;s partition field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L472-L478">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.deleteHybridEdge!" href="#PhyloNetworks.deleteHybridEdge!"><code>PhyloNetworks.deleteHybridEdge!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">deleteHybridEdge!(net::HybridNetwork, edge::Edge, keepNodes=false)</code></pre><p>Deletes a hybrid edge from a network. The network does not have to be of level 1, and may contain some polytomies. Updates branch lengths, allowing for missing values. Returns the network.</p><p>At each of the 2 junctions, the child edge is retained (below the hybrid node). If <code>keepNodes</code> is true, all nodes are retained during edge removal.</p><p>Warnings:</p><ul><li>if <code>keepNodes</code> is true: partner hybrid parent edge has its γ value unchanged</li><li>if the parent of <code>edge</code> is the root and if <code>keepNodes</code> is false, the root is moved to keep the network unrooted with a root of degree two.</li><li>does <strong>not</strong> update containRoot (could be implemented later)</li><li>does <strong>not</strong> update attributes needed for snaq! (like containRoot, inCycle, edge.z, edge.y etc.)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/deleteHybrid.jl#L296-L313">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.deleteLeaf!-Tuple{PhyloNetworks.Network,AbstractString}" href="#PhyloNetworks.deleteLeaf!-Tuple{PhyloNetworks.Network,AbstractString}"><code>PhyloNetworks.deleteLeaf!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>deleteLeaf!(net::HybridNetwork, leaf::AbstractString)</code> <code>deleteLeaf!(net::Network, leaf::Node)</code></p><p>Deletes the leaf taxon from the network. The leaf argument is the name of the taxon to delete.</p><p>Warnings:</p><ul><li>requires a level-1 network with up-to-date attributes for snaq! (e.g. non-missing branch lengths, gammaz, etc.)</li><li>does not care where the root is and does not update it to a sensible location if the root is affected by the leaf removal.</li><li>does not merge edges, i.e. does not remove all nodes of degree 2. Within snaq!, this is used to extract quartets and to keep track of which edge lengths in the original network map to the quartet network.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/pseudolik.jl#L349-L363">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.deleteNode!-Tuple{HybridNetwork,PhyloNetworks.Node}" href="#PhyloNetworks.deleteNode!-Tuple{HybridNetwork,PhyloNetworks.Node}"><code>PhyloNetworks.deleteNode!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>deleteNode!(net::HybridNetwork, n::Node)</code></p><p>deletes a Node from a network, i.e. removes it from net.node, and from net.hybrid or net.leaf as appropriate. Updates attributes numNodes, numTaxa, numHybrids (it does not update net.names though).</p><p>Warning: if the root is deleted, the new root is arbitrarily set to the first node in the list. This is intentional to save time because this function is used frequently in snaq!, which handles semi-directed (unrooted) networks.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L409-L421">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.descendants-Tuple{PhyloNetworks.Edge}" href="#PhyloNetworks.descendants-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.descendants</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">descendants(edge::Edge)</code></pre><p>Return the node numbers of all the descendants of a given edge.</p><p>The node should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net5 = &quot;(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));&quot; |&gt; readTopology |&gt; directEdges! ;

julia&gt; PhyloNetworks.descendants(net5.edge[12]) # descendants of 12th
7-element Array{Int64,1}:
 -6
 -7
  4
  6
  5
 -9
  7</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/compareNetworks.jl#L204-L227">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.discrete_backwardlikelihood_tree!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer}" href="#PhyloNetworks.discrete_backwardlikelihood_tree!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer}"><code>PhyloNetworks.discrete_backwardlikelihood_tree!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">discrete_backwardlikelihood_tree!(obj::SSM, tree::Integer, trait::Integer)</code></pre><p>Update <code>obj.backwardlik</code>; assume correct forward likelihood, directional likelihood and transition probabilities.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traitsLikDiscrete.jl#L799-L804">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.discrete_corelikelihood!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}" href="#PhyloNetworks.discrete_corelikelihood!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}"><code>PhyloNetworks.discrete_corelikelihood!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">discrete_corelikelihood!(obj::StatisticalSubstitutionModel; whichtrait=:all)
discrete_corelikelihood_tree!(obj, t::Integer, traitrange::AbstractArray)</code></pre><p>Calculate the likelihood and update <code>obj.loglik</code> for discrete characters on a network (or on a single tree: <code>t</code>th tree displayed in the network, for the second form). Update forward and direct partial likelihoods while doing so. The algorithm extracts all displayed trees and weights the likelihood under all these trees.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traitsLikDiscrete.jl#L479-L487">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.discrete_corelikelihood_tree!" href="#PhyloNetworks.discrete_corelikelihood_tree!"><code>PhyloNetworks.discrete_corelikelihood_tree!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">discrete_corelikelihood!(obj::StatisticalSubstitutionModel; whichtrait=:all)
discrete_corelikelihood_tree!(obj, t::Integer, traitrange::AbstractArray)</code></pre><p>Calculate the likelihood and update <code>obj.loglik</code> for discrete characters on a network (or on a single tree: <code>t</code>th tree displayed in the network, for the second form). Update forward and direct partial likelihoods while doing so. The algorithm extracts all displayed trees and weights the likelihood under all these trees.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traitsLikDiscrete.jl#L518">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.displayedNetworks!" href="#PhyloNetworks.displayedNetworks!"><code>PhyloNetworks.displayedNetworks!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">displayedNetworks!(net::HybridNetwork, node::Node, keepNode=false)</code></pre><p>Extracts the two networks that simplify a given network at a given hybrid node: deleting either one or the other parent hybrid edge. If <code>keepNodes</code> is true, all original nodes are kept in both networks.</p><ul><li>the original network is modified: the minor edge removed.</li><li>returns one HybridNetwork object: the network with the major edge removed</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/compareNetworks.jl#L283-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.fuseedgesat!-Tuple{Integer,HybridNetwork}" href="#PhyloNetworks.fuseedgesat!-Tuple{Integer,HybridNetwork}"><code>PhyloNetworks.fuseedgesat!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fuseedgesat!(i::Integer,net::HybridNetwork)</code></pre><p>Removes <code>i</code>th node in net.node, if it is of degree 2. The parent and child edges of this node are fused. Reverts the action of breakedge!.</p><p>returns the fused edge.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L391-L399">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.gammaZero!-Tuple{HybridNetwork,DataCF,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}" href="#PhyloNetworks.gammaZero!-Tuple{HybridNetwork,DataCF,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.gammaZero!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>gammaZero</code> road map</p><p>Function that tries to fix a gamma zero problem (<code>h==0,1; t==0; hz==0,1</code>)</p><ol><li>First tries to do <code>changeDirection</code></li><li>If not successful from start, we call <code>moveHybrid</code></li><li>If successful move (change direction), we call <code>optBL</code> and check if we fixed the problem</li><li>If problem fixed and we do not have worse pseudolik, we return <code>success=true</code></li><li>If still problem or worse pseudolik, we call <code>moveHybrid</code></li></ol><p>** Important: ** Any function (<code>afterOptBL</code>) calling <code>gammaZero</code> is assuming that it only made a change, so if the returned value is true, then a change was made, and the other function needs to run <code>optBL</code> and check that all parameters are &#39;valid&#39;. If the returned value is false, then no change was possible and we need to remove a hybridization if the problem is h==0,1; hz==0,1. If the problem is t==0, we ignore this problem.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L517-L528">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getChild-Tuple{PhyloNetworks.Edge}" href="#PhyloNetworks.getChild-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.getChild</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getChild(edge::Edge)</code></pre><p>Return child node using the <code>isChild1</code> attribute of the edge.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L147-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getChildren-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.getChildren-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getChildren</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getChildren(node)</code></pre><p>return a vector with all children <em>nodes</em> of <code>node</code>.   <strong>warning</strong>: assume <code>isChild1</code> field (for edges) are correct</p><p>To get all parent <em>nodes</em>: see <a href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>getParents</code></a>.  </p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L570-L577">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getDataValue!-Tuple{IO,Int64,Array{Int64,1}}" href="#PhyloNetworks.getDataValue!-Tuple{IO,Int64,Array{Int64,1}}"><code>PhyloNetworks.getDataValue!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getdataValue!(s::IO, int, numLeft::Array{Int,1})</code></pre><p>Helper function for <code>parseEdgeData!</code>. Read a single floating point edge data value in a tree topology. Return -1.0 if no value exists before the next colon, return the value as a float otherwise. Modifies s by advancing past the next colon character. Only call this function to read a value when you know a numerical value exists!</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L247-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getGammas-Tuple{HybridNetwork}" href="#PhyloNetworks.getGammas-Tuple{HybridNetwork}"><code>PhyloNetworks.getGammas</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getGammas(net)</code></pre><p>Get inheritance γ&#39;s of major hybrid edges. Assume pre-order calculated already (with up-to-date field <code>nodes_changed</code>). See <a href="#PhyloNetworks.setGammas!-Tuple{HybridNetwork,Array{T,1} where T}"><code>setGammas!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1244-L1249">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getHeights-Tuple{HybridNetwork}" href="#PhyloNetworks.getHeights-Tuple{HybridNetwork}"><code>PhyloNetworks.getHeights</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getHeights(net)</code></pre><p>Return the height (distance to the root) of all nodes, assuming a time-consistent network (where all paths from the root to a given hybrid node have the same length). Also assumes that the network has been preordered, because it uses <a href="#PhyloNetworks.getGammas-Tuple{HybridNetwork}"><code>getGammas</code></a> and <a href="#PhyloNetworks.setGammas!-Tuple{HybridNetwork,Array{T,1} where T}"><code>setGammas!</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1293-L1300">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getMajorParent-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.getMajorParent-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getMajorParent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getMajorParent(node)
getMinorParent(node)</code></pre><p>Return major or minor parent of a node using the <code>isChild1</code> field of edges (and assuming correct <code>isMajor</code> field). See also <a href="#PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}"><code>getMajorParentEdge</code></a> and <a href="#PhyloNetworks.getMinorParentEdge"><code>getMinorParentEdge</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L204-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getMajorParentEdge</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getMajorParentEdge(node)
getMinorParentEdge(node)</code></pre><p>return the parent edge of a given node: the major / minor if hybrid.   <strong>warning</strong>: assume isChild1 and isMajor attributes are correct</p><p>To get all parent <em>nodes</em>: see <a href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>getParents</code></a>.  </p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L543-L551">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getMinorParent" href="#PhyloNetworks.getMinorParent"><code>PhyloNetworks.getMinorParent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">getMajorParent(node)
getMinorParent(node)</code></pre><p>Return major or minor parent of a node using the <code>isChild1</code> field of edges (and assuming correct <code>isMajor</code> field). See also <a href="#PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}"><code>getMajorParentEdge</code></a> and <a href="#PhyloNetworks.getMinorParentEdge"><code>getMinorParentEdge</code></a></p></div></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getMinorParentEdge" href="#PhyloNetworks.getMinorParentEdge"><code>PhyloNetworks.getMinorParentEdge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">getMajorParentEdge(node)
getMinorParentEdge(node)</code></pre><p>return the parent edge of a given node: the major / minor if hybrid.   <strong>warning</strong>: assume isChild1 and isMajor attributes are correct</p><p>To get all parent <em>nodes</em>: see <a href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>getParents</code></a>.  </p></div></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L560">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getParent-Tuple{PhyloNetworks.Edge}" href="#PhyloNetworks.getParent-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.getParent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getParent(e::Edge)</code></pre><p>Return parent node of edge <code>e</code> using the <code>isChild1</code> attribute of the edge. To get parents of nodes: see <a href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>getParents</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L157-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getParents</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getParents(node)</code></pre><p>Get vector of all parent nodes of <code>n</code>, based on <code>isChild1</code> field (for edges). To get the parent node of an edge: see <a href="#PhyloNetworks.getParent-Tuple{PhyloNetworks.Edge}"><code>getParent</code></a>.   To get individual parent edges (rather than all parent <em>nodes</em>): see <a href="#PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}"><code>getMajorParentEdge</code></a> and <code>getMinorParentEdge</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L523-L530">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getPartner-Tuple{Any}" href="#PhyloNetworks.getPartner-Tuple{Any}"><code>PhyloNetworks.getPartner</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getPartner(edge::Edge)
getPartner(edge::Edge, node::Node)</code></pre><p>Return hybrid partner of edge, that is, hybrid edge pointing to the same child as <code>edge</code>. Assumptions (not checked):</p><ul><li>correct <code>isChild1</code> field for <code>edge</code> and for hybrid edges</li><li>no in-coming polytomy: a node has 0, 1 or 2 parents, no more</li></ul><p>When <code>node</code> is given, it is assumed to be the child of <code>edge</code> (the first form calls the second).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L167-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.getTipSubmatrix-Tuple{Array{T,2} where T,HybridNetwork}" href="#PhyloNetworks.getTipSubmatrix-Tuple{Array{T,2} where T,HybridNetwork}"><code>PhyloNetworks.getTipSubmatrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getTipSubmatrix(M, net; indexation=:both)</code></pre><p>Extract submatrix of M, with rows and/or columns corresponding to tips in the network, ordered like in <code>net.leaf</code>. In M, rows and/or columns are assumed ordered as in <code>net.nodes_changed</code>.</p><p>indexation: one of <code>:rows</code>, <code>:cols</code> or <code>:both</code>: are nodes numbers indexed in the matrix by rows, by columns, or both? Subsetting is taken accordingly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/pairwiseDistanceLS.jl#L80-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge}" href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge}"><code>PhyloNetworks.hybridEdges</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hybridEdges(node::Node, e::Edge)</code></pre><p>Return the 2 edges connected to <code>node</code> other than <code>e</code>, in the same order as <code>node.edge</code>, except that <code>e</code> absent from the list.</p><p>Despite what the name suggest, <code>node</code> need not be a hybrid node! <code>node</code> is assumed to have 3 edges, though.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L731-L740">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.hybridEdges</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hybridEdges(node::Node)</code></pre><p>Return the 3 edges attached to <code>node</code> in a specific order [e1,e2,e3]. <strong>Warning</strong>: assume a level-1 network with node field <code>hasHybEdge</code> and edge field <code>inCycle</code> up-to-date.</p><p>If <code>node</code> is a hybrid node:</p><ul><li>e1 is the major hybrid parent edge of <code>node</code></li><li>e2 is the minor hybrid parent edge</li><li>e3 is the tree edge, child of <code>node</code>.</li></ul><p>If <code>node</code> is a tree node parent of one child edge:</p><ul><li>e1 is the hybrid edge, child of <code>node</code></li><li>e2 is the tree edge that belongs to the cycle created by e1</li><li>e3 is the other tree edge attached to <code>node</code> (not in a cycle)</li></ul><p>Otherwise:</p><ul><li>e3 is an external edge from <code>node</code> to a leaf, if one exists.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L657-L679">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.hybridatnode" href="#PhyloNetworks.hybridatnode"><code>PhyloNetworks.hybridatnode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">hybridatnode!(net::HybridNetwork, nodeNumber::Integer)</code></pre><p>Change the status of edges in network <code>net</code>, to move the hybrid node in a cycle to the node with number <code>nodeNumber</code>. This node must be in one (and only one) cycle, otherwise an error will be thrown.</p><p><code>net</code> is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. Check and update the nodes&#39; field <code>inCycle</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; net = readTopology(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
julia&gt; using PhyloPlots
julia&gt; plot(net, showNodeNumber=true)
julia&gt; hybridatnode!(net, -4)
julia&gt; plot(net)</code></pre></div></div><div><div><pre><code class="language-none">hybridatnode!(net, hybrid::Node, newNode::Node)</code></pre><p>Move the reticulation from <code>hybrid</code> to <code>newNode</code>, which must in the same cycle. <code>net</code> is assumed to be of level 1, but <strong>no checks</strong> are made and fields are supposed up-to-date.</p><p>Called by <code>hybridatnode!(net, node number)</code>, which is itself called by <a href="../public/#PhyloNetworks.undirectedOtherNetworks"><code>undirectedOtherNetworks</code></a>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.inheritanceWeight-Tuple{HybridNetwork}" href="#PhyloNetworks.inheritanceWeight-Tuple{HybridNetwork}"><code>PhyloNetworks.inheritanceWeight</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inheritanceWeight(tree::HybridNetwork)</code></pre><p>Return the <em>log</em> inheritance weight of a network or tree (as provided by <a href="../public/#PhyloNetworks.displayedTrees"><code>displayedTrees</code></a> with <code>keepNodes</code> = true for instance). For a tree displayed in a network, its inheritance weight is the log of the product of γ&#39;s of all edges retained in the tree. To avoid underflow, the log is calculated: i.e. sum of log(γ) across retained edges.</p><p>If any edge has a negative γ, it is assumed to mean that its γ is missing, and the function returns <code>missing</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;);

julia&gt; trees = displayedTrees(net,0.0; keepNodes=true);

julia&gt; PhyloNetworks.inheritanceWeight.(trees)
2-element Array{Float64,1}:
 -0.105361
 -2.30259 </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/compareNetworks.jl#L329-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.initializeWeightsFromLeaves!-Tuple{AbstractArray,HybridNetwork,Any,Any,Symbol}" href="#PhyloNetworks.initializeWeightsFromLeaves!-Tuple{AbstractArray,HybridNetwork,Any,Any,Symbol}"><code>PhyloNetworks.initializeWeightsFromLeaves!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">initializeWeightsFromLeaves!(w, net, tips, stateset, criterion)</code></pre><p>Modify weight in w: to Inf for w[n, i] if the &quot;tips&quot; data has a state different from the lineage state of index i at node number n. Assumes that w was initialized to 0 for the leaves.</p><p>criterion: should be one of <code>:softwired</code>, <code>:parental</code> or <code>:hardwired</code>.</p><ul><li>softwired parsimony: lineage states are in this order: ∅,{1},{2},{3},...,{nstates}</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L792-L801">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.initializeWeightsFromLeavesSoftwired!-Tuple{AbstractArray,HybridNetwork,Any,Any}" href="#PhyloNetworks.initializeWeightsFromLeavesSoftwired!-Tuple{AbstractArray,HybridNetwork,Any,Any}"><code>PhyloNetworks.initializeWeightsFromLeavesSoftwired!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">initializeWeightsFromLeavesSoftwired!(w, net, tips, charset)</code></pre><p>Modify weight in w: to Inf for w[n, s] if the &quot;tips&quot; data has a state different from s at node number n. Assumes that w was initialized to 0 for the leaves.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L352-L358">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.learnLabels-Tuple{Symbol,Array{String,N} where N,DataFrames.DataFrame}" href="#PhyloNetworks.learnLabels-Tuple{Symbol,Array{String,N} where N,DataFrames.DataFrame}"><code>PhyloNetworks.learnLabels</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">learnLabels(model::SubstitutionModel, species::Array{String}, dat::DataFrame)</code></pre><p>Learn label names and length from data for fitdiscrete wrapper function with species vector and trait dataframe data</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traitsLikDiscrete.jl#L842-L846">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.majoredgelength-Tuple{HybridNetwork}" href="#PhyloNetworks.majoredgelength-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgelength</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">majoredgelength(net::HybridNetwork)</code></pre><p>Generate vector of edge lengths of major <code>net</code> edges organized in the same order as the <code>edge</code> matrix created via <code>majoredgematrix</code>. Considers values of <code>-1.0</code> as missing values, recognized as NA in <code>R</code>. Output: vector allowing for missing values.</p><p>Assume <code>nodes_changed</code> was updated, to list nodes in pre-order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A:3.1,(B:0.2)#H1:0.3::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);&quot;);

julia&gt; directEdges!(net); preorder!(net);

julia&gt; PhyloNetworks.majoredgelength(net)
8-element Array{Union{Missing, Float64},1}:
  missing
 0.7     
  missing
 1.1     
  missing
 3.1     
 0.3     
 0.2     </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/interop.jl#L60-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}" href="#PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgematrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">majoredgematrix(net::HybridNetwork)</code></pre><p>Matrix of major edges from <code>net</code> where edge[i,1] is the number of the parent node of edge i and edge[i,2] is the number of the child node of edge i. Assume <code>nodes_changed</code> was updated, to list nodes in pre-order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(A,(B,(C,D)));&quot;);

julia&gt; PhyloNetworks.resetNodeNumbers!(net);

julia&gt; PhyloNetworks.majoredgematrix(net)
6×2 Array{Int64,2}:
 5  1
 5  6
 6  2
 6  7
 7  3
 7  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/interop.jl#L19-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.makemissing!-Tuple{AbstractArray{T,1} where T}" href="#PhyloNetworks.makemissing!-Tuple{AbstractArray{T,1} where T}"><code>PhyloNetworks.makemissing!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">makemissing!(x::AbstractVector)</code></pre><p>Turn to <code>missing</code> any element of <code>x</code> exactly equal to -1.0. Used for branch lengths and γs. <code>x</code> needs to accept missing values. If not, this can be done with <code>allowmissing(x)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/interop.jl#L4-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.mapAllelesCFtable!-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Array{Int64,1},Bool,AbstractString}" href="#PhyloNetworks.mapAllelesCFtable!-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Array{Int64,1},Bool,AbstractString}"><code>PhyloNetworks.mapAllelesCFtable!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mapAllelesCFtable!(quartet CF DataFrame, mapping DataFrame, columns, write?, filename)</code></pre><p>Modify (and return) the quartet concordance factor (CF) DataFrame: replace each allele name by the species name that the allele maps onto based on the mapping data frame. This mapping data frame should have columns named &quot;allele&quot; and &quot;species&quot; (see <code>rename!</code> to change column names if need be).</p><p>If <code>write?</code> is <code>true</code>, the modified data frame is written to a file named &quot;filename&quot;.</p><p>Warning: <a href="../public/#PhyloNetworks.mapAllelesCFtable"><code>mapAllelesCFtable</code></a> takes the quartet data file as its second argument, while <code>mapAllelesCFtable!</code> takes the quartet data (which it modifies) as its first argument.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/multipleAlleles.jl#L51-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.maxParsimonyNetRun1" href="#PhyloNetworks.maxParsimonyNetRun1"><code>PhyloNetworks.maxParsimonyNetRun1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p>Road map for various functions behind maxParsimonyNet</p><pre><code class="language-none">maxParsimonyNet
maxParsimonyNetRun1
maxParsimonyNetRun1!</code></pre><p>All return their optimized network. Only maxParsimonyNet returns a rooted network (though all functions guarantee that the returned networks agree with the outgroup).</p><ul><li>maxParsimonyNet calls maxParsimonyNetRun1 per run, after a read(write(.)) of the starting network (to ensure level-1 and semi-directedness).</li><li>maxParsimonyNetRun1 will make a copy of the topology, and will call findStartingTopology! to modify the topology according to random NNI/move origin/move target moves. It then calls maxParsimonyNetRun1! on the modified network</li><li>maxParsimonyNetRun1! proposes new network with various moves (same moves as snaq), and stops when it finds the most parsimonious network, using <a href="../public/#PhyloNetworks.parsimonyGF"><code>parsimonyGF</code></a>.</li></ul><p>None of these functions allow for multiple alleles yet.</p><p>Note that the search algorithm keeps two HybridNetworks at a time: currT (current topology) and newT (proposed topology). Both are kept unrooted (semi-directed), otherwise the moves in proposedTop! function fail. We only root the topologies to calculate the parsimony, so we create a rooted copy (currTr, newTr) to compute parsimony score in this copied topology. We do not root and calculate parsimony score in the original HybridNetworks objects (currT,newT) because the computation of the parsimony score overwrites the inCycle attribute of the Nodes, which messes with the search moves.</p><p>Extensions:</p><ul><li>other criteria: hardwired, parental (only softwired implemented now)</li><li>remove level-1 restriction: this will involve changing the proposedTop! function to use rSPR or rNNI moves (instead of the level-1 moves coded for snaq!). We need:<ul><li>functions for rSPR and rNNI moves</li><li>create new proposedTop! function (proposedRootedTop?) to choose from the rSPR/rNNI/other moves</li><li>have the search in maxParsimonuNetRun1! to have rooted currT and rooted newT, instead of keeping semi-directed objects (currT, newT), only to root for the parsimony score (currTr, newTr)</li></ul></li><li>outgroup is currently String or Node number, but it would be good if it allowed Edge number as an option too. Not sure best way to distinguish between Node number and Edge number, which is why left as Node number for now.</li></ul></div></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L1094">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.maxParsimonyNetRun1!" href="#PhyloNetworks.maxParsimonyNetRun1!"><code>PhyloNetworks.maxParsimonyNetRun1!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Road map for various functions behind maxParsimonyNet</p><pre><code class="language-none">maxParsimonyNet
maxParsimonyNetRun1
maxParsimonyNetRun1!</code></pre><p>All return their optimized network. Only maxParsimonyNet returns a rooted network (though all functions guarantee that the returned networks agree with the outgroup).</p><ul><li>maxParsimonyNet calls maxParsimonyNetRun1 per run, after a read(write(.)) of the starting network (to ensure level-1 and semi-directedness).</li><li>maxParsimonyNetRun1 will make a copy of the topology, and will call findStartingTopology! to modify the topology according to random NNI/move origin/move target moves. It then calls maxParsimonyNetRun1! on the modified network</li><li>maxParsimonyNetRun1! proposes new network with various moves (same moves as snaq), and stops when it finds the most parsimonious network, using <a href="public/#PhyloNetworks.parsimonyGF"><code>parsimonyGF</code></a>.</li></ul><p>None of these functions allow for multiple alleles yet.</p><p>Note that the search algorithm keeps two HybridNetworks at a time: currT (current topology) and newT (proposed topology). Both are kept unrooted (semi-directed), otherwise the moves in proposedTop! function fail. We only root the topologies to calculate the parsimony, so we create a rooted copy (currTr, newTr) to compute parsimony score in this copied topology. We do not root and calculate parsimony score in the original HybridNetworks objects (currT,newT) because the computation of the parsimony score overwrites the inCycle attribute of the Nodes, which messes with the search moves.</p><p>Extensions:</p><ul><li>other criteria: hardwired, parental (only softwired implemented now)</li><li>remove level-1 restriction: this will involve changing the proposedTop! function to use rSPR or rNNI moves (instead of the level-1 moves coded for snaq!). We need:<ul><li>functions for rSPR and rNNI moves</li><li>create new proposedTop! function (proposedRootedTop?) to choose from the rSPR/rNNI/other moves</li><li>have the search in maxParsimonuNetRun1! to have rooted currT and rooted newT, instead of keeping semi-directed objects (currT, newT), only to root for the parsimony score (currTr, newTr)</li></ul></li><li>outgroup is currently String or Node number, but it would be good if it allowed Edge number as an option too. Not sure best way to distinguish between Node number and Edge number, which is why left as Node number for now.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L978-L1016">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}" href="#PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationgamma</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">minorreticulationgamma(net::HybridNetwork)</code></pre><p>Vector of minor edge gammas (inheritance probabilities) organized in the same order as in the matrix created via <code>minorreticulationmatrix</code>. Considers values of <code>-1.0</code> as missing values, recognized as NA in <code>R</code>. Output: vector allowing for missing values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;);

julia&gt; PhyloNetworks.minorreticulationgamma(net)
1-element Array{Union{Float64, Missings.Missing},1}:
 0.1</code></pre><pre><code class="language-none"></code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/interop.jl#L167-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}" href="#PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationlength</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">minorreticulationlength(net::HybridNetwork)</code></pre><p>Vector of lengths for the minor hybrid edges, organized in the same order as in the matrix created via <code>minorreticulationmatrix</code>. Replace values of <code>-1.0</code> with missing values recognized by <code>R</code>. Output: vector allowing for missing values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A:3.1,(B:0.2)#H1:0.4::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);&quot;);

julia&gt; PhyloNetworks.minorreticulationlength(net)
1-element Array{Union{Missing, Float64},1}:
 0.3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/interop.jl#L138-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}" href="#PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationmatrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">minorreticulationmatrix(net::HybridNetwork)</code></pre><p>Matrix of integers, representing the minor hybrid edges in <code>net</code>. edge[i,1] is the number of the parent node of the ith minor hybrid edge, and edge[i,2] is the number of its child node. Node numbers may be negative, unless they were modified by <code>resetNodeNumbers!</code>. Assumes correct <code>isChild1</code> fields.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;);
julia&gt; PhyloNetworks.minorreticulationmatrix(net)
1×2 Array{Int64,2}:
 -6  3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/interop.jl#L107-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.moveHybrid!-Tuple{HybridNetwork,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}" href="#PhyloNetworks.moveHybrid!-Tuple{HybridNetwork,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.moveHybrid!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>moveHybrid</code> road map</p><p>Function that tries to fix a gamma zero problem (<code>h==0,1; t==0; hz==0,1</code>) after changing direction of hybrid edge failed. This function is called in <code>gammaZero</code>.</p><p>Arguments:</p><ul><li><code>closeN=true</code> will try move origin/target on all neighbors (first choose minor/major edge at random, then make list of all neighbor edges and tries to put the hybrid node in all the neighbors until successful move); if false, will delete and add hybrid until successful move up to N times (this is never tested)</li></ul><p>Returns true if change was successful (not testing <code>optBL</code> again), and false if we could not move anything</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L472-L482">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.optBL!-Tuple{HybridNetwork,DataCF,Bool,Float64,Float64,Float64,Float64}" href="#PhyloNetworks.optBL!-Tuple{HybridNetwork,DataCF,Bool,Float64,Float64,Float64,Float64}"><code>PhyloNetworks.optBL!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>optBL</code> road map</p><p>Function that optimizes the numerical parameters (branch lengths and inheritance probabilities) for a given network. This function is called multiple times inside <code>optTopLevel!</code>.</p><ul><li>Input: network <code>net</code>, data <code>d</code></li><li>Numerical tolerances: <code>ftolAbs, ftolRel, xtolAbs, xtolRel</code></li><li>Function based on <code>MixedModels</code> <code>fit</code> function</li><li>The function assumes <code>net</code> has all the right attributes, and cannot check this inside because it would be inefficient</li></ul><p>Procedure:</p><ul><li><code>ht = parameters!(net)</code> extracts the vector of parameters to estimate <code>(h,t,gammaz)</code>, and sets as <code>net.ht</code>; identifies a bad diamond I, sets <code>net.numht</code> (vector of hybrid node numbers for h, edge numbers for t, hybrid node numbers for gammaz), and <code>net.index</code> to keep track of the vector of parameters to estimate</li><li><code>extractQuartet!(net,d)</code> does the following for all quartets in <code>d.quartet</code>:<ul><li>Extract quartet by deleting all leaves not in q -&gt; create <code>QuartetNetwork</code> object saved in <code>q.qnet</code></li><li>This network is ugly and does not have edges collapsed. This is done to keep a one-to-one correspondence between the edges in <code>q.qnet</code> and the edges in <code>net</code> (if we remove nodes with only two edges, we will lose this correspondence)</li><li>Calculate expected CF with <code>calculateExpCFAll</code> for a copy of <code>q.qnet</code>. We do this copy because we want to keep <code>q.qnet</code> as it is (without collapsed edges into one). The function will then save the <code>expCF</code> in <code>q.qnet.expCF</code></li></ul></li><li><code>calculateExpCFAll!(qnet)</code> will<ul><li>identify the type of quartet as type 1 (equivalent to a tree) or type 2 (minor CF different). Here the code will first clean up any hybrid node by removing nodes with only two edges before identifying the <code>qnet</code> (because identification depends on neighbor nodes to hybrid node); later, set <code>qnet.which</code> (1 or 2), <code>node.prev</code> (neighbor node to hybrid node), updates <code>node.k</code> (number of nodes in hybridization cycle, this can change after deleting the nodes with only two edges), <code>node.typeHyb</code> (1,2,3,4,5 depending on the number of nodes in the hybridization cycle and the origin/target of the minor hybrid edge; this attribute is never used).</li><li>eliminate hybridization: this will remove type 1 hybridizations first. If <code>qnet.which=1</code>, then the <code>qnet</code> is similar to a tree quartet, so it will calculate the internal length of the tree quartet: <code>qnet.t1</code>.</li><li>update split for <code>qnet.which=1</code>, to determine which taxa are together. For example, for the quartet 12|34, the split is [1,1,2,2] or [2,2,1,1], that is, taxon 1 and 2 are on the same side of the split. This will update <code>qnet.split</code></li><li>update formula for <code>qnet.which=1</code> to know the order of minorCF and majorCF in the vector <code>qnet.expCF</code>. That is, if the quartet is 1342 (order in <code>qnet.quartet.taxon</code>), then the expected CF should match the observed CF in 13|42, 14|32, 12|34 and the <code>qnet</code> is 12|34 (given by <code>qnet.split</code>), <code>qnet.formula</code> will be [2,2,1] minor, minor, major</li><li><code>calculateExpCF!(qnet)</code> for <code>qnet.which=1</code>, it will do <code>1-2/3exp(-qnet.t1)</code> if <code>qnet.formula[i]==1</code>, and <code>1/3exp(qnet.t1)</code> if <code>qnet.formula[i]==2</code>. For <code>qnet.which=2</code>, we need to make sure that there is only one hybrid node, and compute the major, minor1,minor2 expected CF in the order 12|34, 13|24, 14|23 of the taxa in <code>qnet.quartet.taxon</code></li></ul></li></ul><p>Then we create a <code>NLopt</code> object with algorithm BOBYQA and k parameters (length of ht). We define upper and lower bounds and define the objective function that should only depend on <code>x=(h,t,gz)</code> and g (gradient, which we do not have, but still need to put as argument).</p><p>The objective function <code>obj(x,g)</code> calls</p><ul><li><code>calculateExpCFAll!(d,x,net)</code> needs to be run after <code>extractQuartet(net,d)</code> that will update <code>q.qnet</code> for all quartet.  Assumes that <code>qnet.indexht</code> is updated already: we only need to do this at the beginning of <code>optBL!</code> because the topology is fixed at this point)<ul><li>First it will update the edge lengths according to x</li><li>If the <code>q.qnet.changed=true</code> (that is, any of <code>qnet</code> branches changed value), we need to call <code>calculateExpCFAll!(qnet)</code> on a copy of <code>q.qnet</code> (again because we want to leave <code>q.qnet</code> with the edge correspondence to <code>net</code>)</li></ul></li><li><code>update!(net,x)</code> simply saves the new x in <code>net.ht</code></li></ul><p>Finally, we call <code>NLopt.optimize</code>, and we update the <code>net.loglik</code> and <code>net.ht</code> at the end. After <code>optBL</code>, we want to call <code>afterOptBLAll</code> (or <code>afterOptBLAllMultipleAlleles</code>) to check if there are <code>h==0,1</code>; <code>t==0</code>; <code>hz==0,1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L297-L344">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.optTopLevel!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},IO,Bool}" href="#PhyloNetworks.optTopLevel!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},IO,Bool}"><code>PhyloNetworks.optTopLevel!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>optTopLevel</code> road map</p><p>Function that does most of the heavy-lifting of <code>snaq</code>. It optimizes the pseudolikelihood for a given starting topology, and returns the best network. Assumes that the starting topology is level-1 network, and has all the attributes correctly updated.</p><p>Input parameters:</p><ul><li>Starting topology <code>currT</code>, input data <code>DataCF</code> <code>d</code>, maximum number of hybridizations <code>hmax</code></li><li>Numerical optimization parameters: <code>liktolAbs, Nfail, ftolRel, ftolAbs, xtolRel, xtolAbs</code></li><li>Print parameters: <code>verbose, logfile, writelog</code></li><li>Parameters to tune the search in space of networks: <code>closeN=true</code> only propose move origin/target to neighbor edges (coded, but not tested with <code>closeN=false</code>), <code>Nmov0</code> vector with maximum number of trials allowed per type of move <code>(add, mvorigin, mvtarget, chdir, delete, nni)</code>, by default computed inside with coupon’s collector formulas</li></ul><p>The optimization procedure keeps track of</p><ul><li><code>movescount</code>: count of proposed moves,</li><li><code>movesgamma</code>: count of proposed moves to fix a gamma zero situation (see below for definition of this situation),</li><li><code>movesfail</code>: count of failed moves by violation of level-1 network (<code>inCycle</code> attribute) or worse pseudolikelihood than current,</li><li><code>failures</code>: number of failed proposals that had a worse pseudolikelihood</li></ul><p>Optimization procedure:</p><p>While the difference between current loglik and proposed loglik is greater than <code>liktolAbs</code>, or <code>failures&lt;Nfail</code>, or <code>stillmoves=true</code>:</p><ul><li><p><code>Nmov</code> is updated based on <code>newT</code>. The type of move proposed will depend on <code>newT</code> (which is the same as <code>currT</code> at this point). For example, if <code>currT</code> is a tree, we cannot propose move origin/target.</p></li><li><p><code>move = whichMove</code> selects randomly a type of move, depending on <code>Nmov,movesfail,hmax,newT</code> with weights 1/5 by default for all, and 0 for delete. These weights are adjusted depending on <code>newT.numHybrids</code> and <code>hmax</code>. If <code>newT.numHybrids</code> is far from <code>hmax</code>, we give higher probability to adding a new hybrid (we want to reach the <code>hmax</code> sooner, maybe not the best strategy, easy to change).  Later, we adjust the weights by <code>movesfail</code> (first, give weight of 0 if <code>movesfail[i]&gt;Nmov[i]</code>, that is, if we reached the maximum possible number of moves allowed for a certain type) and then increase the probability of the other moves.  So, unless one move has <code>w=0</code>, nothing changes. This could be improved by using the outlier quartets to guide the proposal of moves.</p></li><li><p><code>whichMove</code> will choose a move randomly from the weights, it will return <code>none</code> if no more moves allowed, in which case, the optimization ends</p></li><li><p><code>flag=proposedTop!(move, newT)</code> will modify <code>newT</code> based on <code>move</code>. The function <code>proposedTop</code> will return <code>flag=true</code> if the move was successful (the move succeeded by <code>inCycle</code>, <code>containRoot</code>, available edge to make the move (more details in <code>proposedTop</code>)). If <code>flag=false</code>, then <code>newT</code> is cleaned, except for the case of multiple alleles. The function <code>proposedTop</code> keeps count of <code>movescount</code> (successful move), <code>movesfail</code> (unsuccessful move),</p><p>Options:</p><p><code>random=true</code>: moves major/minor hybrid edge with prob h,1-h, respectively</p><p><code>N=10</code>: number of trials for NNI edge.</p></li><li><p>if(flag) Optimize branch lengths with <code>optBL</code></p><p>If <code>newT.loglik</code> is better than <code>currT.loglik</code> by <code>liktolAbs</code>, jump to <code>newT</code> (<code>accepted=true</code>) and fix <code>gamma=0, t=0</code> problems (more info on <code>afterOptBL</code>)</p><p>If(accepted)   <code>failures=0</code>, <code>movesfail=zeros</code>, <code>movescount</code> for successful move +1</p></li></ul><p>end while</p><p>After choosing the best network <code>newT</code>, we do one last more thorough optimization of branch lengths with <code>optBL</code>, we change non identifiable branch lengths to -1 and return <code>newT</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L1148-L1203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.optTopRun1!-Tuple{HybridNetwork,Any,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,IO,Bool,Float64}" href="#PhyloNetworks.optTopRun1!-Tuple{HybridNetwork,Any,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,IO,Bool,Float64}"><code>PhyloNetworks.optTopRun1!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">optTopRun1!(net, liktolAbs, Nfail, d::DataCF, hmax, etc.)</code></pre><p>The function will run 1 run by modifying the starting topology and calling <code>optTopLevel</code>. See <a href="#PhyloNetworks.optTopRuns!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,AbstractString,AbstractString,Integer,Float64}"><code>optTopRuns!</code></a> for a roadmap.</p><p><code>probST</code> (default in snaq is 0.3) is the probability of starting one run at the same input tree. So, with probability <code>1-probST</code>, we will change the topology by a NNI move on a tree edge without neighbor hybrid. If the starting topology is a network, then with probability <code>1-probST</code> it will also modify one randomly chosen hybrid edge: with prob 0.5, the function will move origin, with prob 0.5 will do move target.</p><p>If there are multiple alleles (<code>d.repSpecies</code> not empty), then the function has to check that the starting topology does not violate the multiple alleles condition.</p><p>After modifying the starting topology with NNI and/or move origin/target, <code>optTopLevel</code> is called.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L1708-L1727">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.optTopRuns!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,AbstractString,AbstractString,Integer,Float64}" href="#PhyloNetworks.optTopRuns!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,AbstractString,AbstractString,Integer,Float64}"><code>PhyloNetworks.optTopRuns!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Road map for various functions behind <a href="../public/#PhyloNetworks.snaq!"><code>snaq!</code></a></p><pre><code class="language-none">snaq!
optTopRuns!
optTopRun1!
optTopLevel!
optBL!</code></pre><p>All return their optimized network.</p><ul><li><a href="../public/#PhyloNetworks.snaq!"><code>snaq!</code></a> calls <code>optTopRuns!</code> once, after a deep copy of the starting network. If the data contain multiple alleles from a given species, <code>snaq!</code> first expands the leaf for that species into 2 separate leaves, and merges them back into a single leaf after calling <code>optTopRuns!</code>.</li><li><code>optTopRuns!</code> calls <a href="#PhyloNetworks.optTopRun1!-Tuple{HybridNetwork,Any,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,IO,Bool,Float64}"><code>optTopRun1!</code></a> several (<code>nrun</code>) times. assumes level-1 network with &gt;0 branch lengths. assumes same tips in network as in data: i.e. 2 separate tips per species                                          that has multiple alleles. each call to <code>optTopRun1!</code> gets the same starting network.</li><li><code>optTopRun1!</code> calls <code>optTopLevel!</code> once, after deep copying + changing the starting network slightly.</li><li><code>optTopLevel!</code> calls <code>optBL!</code> various times and proposes new network with various moves.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L1478-L1501">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.pairwiseTaxonDistanceGrad-Tuple{HybridNetwork}" href="#PhyloNetworks.pairwiseTaxonDistanceGrad-Tuple{HybridNetwork}"><code>PhyloNetworks.pairwiseTaxonDistanceGrad</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pairwiseTaxonDistanceGrad(net; checkEdgeNumber=true, nodeAges=[])</code></pre><p>3-dim array: gradient of pairwise distances between all nodes. (internal and leaves); gradient with respect to edge lengths if <code>nodeAges</code> is empty; with respect to node ages otherwise. Assume correct <code>net.nodes_changed</code> (preorder).   This gradient depends on the network&#39;s topology and γ&#39;s only, not on branch lengths or node ages (distances are linear in either).</p><p>WARNING: edge numbers need to range between 1 and #edges.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/pairwiseDistanceLS.jl#L146-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parseEdgeData!-Tuple{IO,PhyloNetworks.Edge,PhyloNetworks.Node,Array{Int64,1}}" href="#PhyloNetworks.parseEdgeData!-Tuple{IO,PhyloNetworks.Edge,PhyloNetworks.Node,Array{Int64,1}}"><code>PhyloNetworks.parseEdgeData!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parseEdgeData!(s::IO, edge, node, numberOfLeftParentheses::Array{Int,1})</code></pre><p>Helper function for readSubtree!, fixes a bug from using setGamma Modifies <code>e</code> according to the specified edge length and gamma values in the tree topology. Advances the stream <code>s</code> past any existing edge data. Edges in a topology may optionally be followed by &quot;:edgeLen:bootstrap:gamma&quot; where edgeLen, bootstrap, and gamma are decimal values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L275-L283">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parseHybridNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,String,HybridNetwork,Array{String,1}}" href="#PhyloNetworks.parseHybridNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,String,HybridNetwork,Array{String,1}}"><code>PhyloNetworks.parseHybridNode!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parseHybridNode!(node, parentNode, hybridName, net, hybrids)</code></pre><p>Helper function for <code>readSubtree!</code>. Create the parent edge for <code>node</code>. Return this edge, and the hybrid node retained (<code>node</code> or its clone in the newick string). Insert new edge and appropriate node into <code>net</code> and <code>hybrids</code> accordingly. Handles any type of given hybrid node. Called after a <code>#</code> has been found in a tree topology.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L147-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parseRemainingSubtree!-Tuple{IO,Array{Int64,1},HybridNetwork,Array{String,1}}" href="#PhyloNetworks.parseRemainingSubtree!-Tuple{IO,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>PhyloNetworks.parseRemainingSubtree!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parseRemainingSubtree!(s::IO, numLeft, net, hybrids)</code></pre><p>Create internal node. Helper for <a href="#PhyloNetworks.readSubtree!-Tuple{IO,PhyloNetworks.Node,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>readSubtree!</code></a>, which creates the parent edge of the node created by <code>parseRemainingSubtree!</code>: <code>readSubtree!</code> calls <code>parseRemainingSubtree!</code>, and vice versa. Called once a <code>(</code> has been read in a tree topology and reads until the corresponding <code>)</code> has been found. This function performs the recursive step for <code>readSubtree!</code>. Advances <code>s</code> past the subtree, adds discovered nodes and edges to <code>net</code>, and <code>hybrids</code>.</p><p>Does <em>not</em> read the node name and the edge information of the subtree root: this is done by <a href="#PhyloNetworks.readSubtree!-Tuple{IO,PhyloNetworks.Node,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>readSubtree!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L114-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parseTreeNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,HybridNetwork}" href="#PhyloNetworks.parseTreeNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.parseTreeNode!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parseTreeNode!(node, parentNode, net)</code></pre><p>Helper function for <code>readSubtree!</code>. Insert the input tree node and associated edge (created here) into <code>net</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L231-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parsimonyBottomUpFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}},Array{Int64,1}}} where T" href="#PhyloNetworks.parsimonyBottomUpFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}},Array{Int64,1}}} where T"><code>PhyloNetworks.parsimonyBottomUpFitch!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>parsimonyBottomUpFitch!(node, states, score)</code></p><p>Bottom-up phase (from tips to root) of the Fitch algorithm: assign sets of character states to internal nodes based on character states at tips. Polytomies okay. Assumes a <em>tree</em> (no reticulation) and correct isChild1 attribute.</p><p>output: dictionary with state sets and most parsimonious score</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L2-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parsimonyBottomUpGF!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray,AbstractArray,AbstractArray}" href="#PhyloNetworks.parsimonyBottomUpGF!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray,AbstractArray,AbstractArray}"><code>PhyloNetworks.parsimonyBottomUpGF!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`parsimonyBottomUpGF!(node, blobroot, nchar, w, scores,
    costmatrix1, costmatrix2)`</code></pre><p>Compute the MP scores (one for each assignment of the blob root state) given the descendants of a blob, conditional on the states at predefined parents of hybrids in the blobs (one parent per hybrid) as described in</p><p>Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).</p><p>Assumes a set of state <em>guesses</em>, ie correct initialization of <code>w</code> for predefined hybrid parents, and correct <code>fromBadDiamondI</code> field for the children edges of these predefined parents. <code>fromBadDiamondI</code> is true for edges that are cut.</p><p>The field <code>isExtBadTriangle</code> is used to know which nodes are at the root of a blob. The field <code>isChild1</code> is used (and assumed correct). Field <code>inCycle</code> is assumed to store the # of detached parents (with guessed states)</p><ul><li><code>nchar</code>: number of characters considered at internal lineages. For softwired parsimony, this is # states + 1, because characters at internal nodes are ∅, {1}, {2}, etc. For parental parsimony, this is 2^#states -1, because characters are all sets on {1,2,...} except for the empty set ∅.</li><li><code>costmatrix1</code>[i,j] and <code>costmatrix2</code>[k][i,j]: 2d array and vector of 2d arrays containing the cost of going to character j starting from character i when the end node has a single parent, or the cost of a child node having character j when its parents have characters k and i. These cost matrices are pre-computed depending on the parsimony criterion (softwired, hardwired, parental etc.)</li></ul><p>used by <a href="../public/#PhyloNetworks.parsimonyGF"><code>parsimonyGF</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L826-L860">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parsimonyBottomUpSoftwired!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray}" href="#PhyloNetworks.parsimonyBottomUpSoftwired!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray}"><code>PhyloNetworks.parsimonyBottomUpSoftwired!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>parsimonyBottomUpSoftwired!(node, blobroot, states, w, scores)</code></p><p>Computing the MP scores (one for each assignment of the root state) of a swicthing as described in Algorithm 1 in the following paper:</p><p>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</p><p>Assumes a <em>switching</em> (ie correct <code>fromBadDiamondI</code> field) and correct isChild1 field. The field <code>isExtBadTriangle</code> is used to know which nodes are at the root of a blob.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L160-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parsimonyDiscreteFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{String,T}}} where T" href="#PhyloNetworks.parsimonyDiscreteFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{String,T}}} where T"><code>PhyloNetworks.parsimonyDiscreteFitch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parsimonyDiscreteFitch(net, tipdata)</code></pre><p>Calculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network. Tip data can be given in a data frame, in which case the taxon names are to appear in column 1 or in a column named &quot;taxon&quot; or &quot;species&quot;, and trait values are to appear in column 2 or in a column named &quot;trait&quot;. Alternatively, tip data can be given as a dictionary taxon =&gt; trait.</p><p>also return the union of all optimized character states at each internal node as obtained by Fitch algorithm, where the union is taken over displayed trees with the MP score.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L82-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parsimonySummaryFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{Int64,Set{T}}}} where T" href="#PhyloNetworks.parsimonySummaryFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{Int64,Set{T}}}} where T"><code>PhyloNetworks.parsimonySummaryFitch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>parsimonySummaryFitch(tree, nodestates)</code></p><p>summarize character states at nodes, assuming a <em>tree</em></p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L65-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.parsimonyTopDownFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}}}} where T" href="#PhyloNetworks.parsimonyTopDownFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}}}} where T"><code>PhyloNetworks.parsimonyTopDownFitch!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>parsimonyTopDownFitch!(node, states)</code></p><p>Top-down phase (root to tips) of the Fitch algorithm: constrains character states at internal nodes based on the state of the root. Assumes a <em>tree</em>: no reticulation.</p><p>output: dictionary with state sets</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L42-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.proposedTop!-Tuple{Integer,HybridNetwork,Bool,Integer,Integer,Array{Int64,1},Array{Int64,1},Bool}" href="#PhyloNetworks.proposedTop!-Tuple{Integer,HybridNetwork,Bool,Integer,Integer,Array{Int64,1},Array{Int64,1},Bool}"><code>PhyloNetworks.proposedTop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>proposedTop!(move,newT,random,count,N,movescount,movesfail,multall)</code> road map</p><p>Function to change the current network <code>newT</code> by a given <code>move</code>, and checks that the move was successful (correct attributes). If not successful, <code>newT</code> is changed back to its original state, except for the case of multiple alleles.</p><p><strong>Note</strong> that the update of attributes by each move is not done in all the network, but only in the local edges that were changed by the move. This is efficient (and makes a move easy to undo), but makes the code of each move function very clunky.</p><p>Arguments:</p><ul><li>move chosen from <code>whichMove</code> as described in <code>optTopLevel</code></li><li><code>newT</code> is the topology that will be modified inside with the move</li><li><code>random=true</code>: chooses minor hybrid edge with prob 1-h, and major edge with prob h, if false, always chooses minor hybrid edge</li><li><code>count</code>: simply which likelihood step we are in in the optimization at <code>optTopLevel</code></li><li><code>movescount</code> and <code>movesfail</code>: vector of counts of number of moves proposed</li><li><code>multall=true</code> if multiple alleles case: we need to check if the move did not violate the multiple alleles condition (sister alleles together and no gene flow into the alleles). This is inefficient because we are proposing moves that we can reject later, instead of being smart about the moves we propose: for example, move origin/target could rule out some neighbors that move gene flow into the alleles, the same for add hybridization; nni move can check if it is trying to separate the alleles)</li></ul><p>Moves:</p><ul><li><code>addHybridizationUpdate(newT,N)</code>:</li></ul><p>will choose a partition first (to avoid choosing edges that will create a non level-1 network) will choose two edges from this partition randomly, will not allow two edges in a cherry (non-identifiable), or sister edges that are not identifiable (the blacklist was a way to keep track of &quot;bad edges&quot; were we should not waste time trying to put hybridizations, it has never been used nor tested). Also choose gamma from U(0,0.5). The &quot;Update&quot; in the function name means that it creates the new hybrid, and also updates all the attributes of <code>newT</code></p><ul><li><code>node = chooseHybrid(newT)</code> choose a hybrid randomly for the next moves:</li><li><code>moveOriginUpdateRepeat!(newT,node,random)</code></li></ul><p>will choose randomly the minor/major hybrid edge to move (if <code>random=true</code>); will get the list of all neighbor edges where to move the origin, will move the origin and update all the attributes and check if the move was successful (not conflicting attributes); if not, will undo the move, and try with a different neighbor until it runs out of neighbors. Return true if the move was successful.</p><ul><li><code>moveTargetUpdateRepeat!(newT,node,random)</code></li></ul><p>same as move origin but moving the target</p><ul><li><code>changeDirectionUpdate!(newT,node,random)</code></li></ul><p>chooses minor/major hybrid edge at random (if `random=true), and changes the direction, and updates all the attributes. Checks if the move was successful (returns true), or undoes the change and returns false.</p><ul><li><code>deleteHybridizationUpdate!(newT,node)</code></li></ul><p>removes the hybrid node, updates the attributes, no need to check any attributes, always successful move</p><ul><li>NNIRepeat!(newT,N)</li></ul><p>choose an edge for nni that does not have a neighbor hybrid. It will try to find such an edge N times, and if it fails, it will return false (unsuccessful move). N=10 by default. If N=1, it rarely finds such an edge if the network is small or complex. The function cannot choose an external edge. it will update locally the attributes.</p><p>** Important: ** All the moves undo what they did if the move was not successful, so at the end you either have a <code>newT</code> with a new move and with all good attributes, or the same <code>newT</code> that started. This is important to avoid having to do deepcopy of the network before doing the move. Also, after each move, when we update the attributes, we do not update the attributes of the whole network, we only update the attributes of the edges that were affected by the move. This saves time, but makes the code quite clunky. Only the case of multiple alleles the moves does not undo what it did, because it finds out that it failed after the function is over, so just need to treat this case special.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L1026-L1068">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readCSVtoArray-Tuple{DataFrames.DataFrame}" href="#PhyloNetworks.readCSVtoArray-Tuple{DataFrames.DataFrame}"><code>PhyloNetworks.readCSVtoArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">readCSVtoArray(dat::DataFrame)
readCSVtoArray(filename::String)</code></pre><p>Read a CSV table containing both species names and data, create two separate arrays: one for the species names, a second for the data, in a format that <a href="../public/#PhyloNetworks.parsimonyGF"><code>parsimonyGF</code></a> needs.</p><p>Warning:</p><ul><li>it will try to find a column &#39;taxon&#39; or &#39;species&#39; for the taxon names. If none found, it will assume the taxon names are in column 1.</li><li>will use all other columns as characters</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/parsimony.jl#L453-L465">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readInputData-Tuple{AbstractString,AbstractString,Symbol,Integer,Bool,AbstractString,Bool,Bool}" href="#PhyloNetworks.readInputData-Tuple{AbstractString,AbstractString,Symbol,Integer,Bool,AbstractString,Bool,Bool}"><code>PhyloNetworks.readInputData</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">readInputData(trees, quartetfile, whichQuartets, numQuartets, writetable, tablename, writeQfile, writesummary)
readInputData(trees, whichQuartets, numQuartets, taxonlist,   writetable, tablename, writeQfile, writesummary)</code></pre><p>Read gene trees and calculate the observed quartet concordance factors (CF), that is, the proportion of genes (and the number of genes) that display each quartet for a given list of four-taxon sets.</p><p>Input:</p><ul><li><code>trees</code>: name of a file containing a list of input gene trees, or vector of trees (<code>HybridNetwork</code> objects)</li></ul><p>Optional arguments (defaults):</p><ul><li><code>quartetfile</code>: name of a file containing a list of quartets, or more precisely, a list of four-taxon sets</li><li><code>whichQuartets</code> (<code>:all</code>): which quartets to sample. <code>:all</code> for all of them, <code>:rand</code> for a random sample.</li><li><code>numQuartets</code>: number of quartets in the sample. default: total number of quartets if <code>whichQuartets=:all</code> and 10% of total if <code>whichQuartets=:rand</code></li><li><code>taxonlist</code> (all in the input gene trees): If <code>taxonlist</code> is used, <code>whichQuartets</code> will consist of <em>all</em> sets of 4 taxa in the <code>taxonlist</code>. </li><li><code>writetable</code> (true): write the table of observed CF?</li><li><code>tablename</code> (&quot;tableCF.txt&quot;): if <code>writetable</code> is true, the table of observed CFs is write to file <code>tablename</code></li><li><code>writeQfile</code> (false): write intermediate file with sampled quartets?</li><li><code>writesummary</code> (true): write a summary file? if so, the summary will go in file &quot;summaryTreesQuartets.txt&quot;.</li></ul><p>See also: <a href="../public/#PhyloNetworks.readTrees2CF"><code>readTrees2CF</code></a>, which is basically a re-naming of <code>readInputData</code>, and <a href="../public/#PhyloNetworks.readTableCF"><code>readTableCF</code></a> to read a table of quartet CFs directly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L498-L531">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.readSubtree!-Tuple{IO,PhyloNetworks.Node,Array{Int64,1},HybridNetwork,Array{String,1}}" href="#PhyloNetworks.readSubtree!-Tuple{IO,PhyloNetworks.Node,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>PhyloNetworks.readSubtree!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">readSubtree!(s::IO, parentNode, numLeft, net, hybrids)</code></pre><p>Recursive helper method for <code>readTopology</code>: read a subtree from an extended Newick topology. input <code>s</code>: IOStream/IOBuffer.</p><p>Reads additional info formatted as: <code>:length:bootstrap:gamma</code>. Allows for name of internal nodes without # after closing parenthesis: (1,2)A. Warning if hybrid edge without γ, or if γ (ignored) without hybrid edge</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L379-L389">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.recursionPostOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Any}" href="#PhyloNetworks.recursionPostOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Any}"><code>PhyloNetworks.recursionPostOrder</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">recursionPostOrder(nodes, init_function, tip_function, node_function,
                   parameters)
updatePostOrder(index, nodes, updated_matrix, tip_function, node_function,
                parameters)</code></pre><p>Generic tool to apply a post-order (or topological ordering) algorithm. Used by <code>descendenceMatrix</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L154-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.recursionPreOrder!" href="#PhyloNetworks.recursionPreOrder!"><code>PhyloNetworks.recursionPreOrder!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">recursionPreOrder(nodes, init_function, root_function, tree_node_function,
                  hybrid_node_function, parameters)
recursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,
                   hybrid_node_function, parameters)
updatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,
               hybrid_node_function, parameters)</code></pre><p>Generic tool to apply a pre-order (or topological ordering) algorithm. Used by <code>sharedPathMatrix</code> and by <code>pairwiseTaxonDistanceMatrix</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.recursionPreOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Function,Any}" href="#PhyloNetworks.recursionPreOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Function,Any}"><code>PhyloNetworks.recursionPreOrder</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">recursionPreOrder(nodes, init_function, root_function, tree_node_function,
                  hybrid_node_function, parameters)
recursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,
                   hybrid_node_function, parameters)
updatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,
               hybrid_node_function, parameters)</code></pre><p>Generic tool to apply a pre-order (or topological ordering) algorithm. Used by <code>sharedPathMatrix</code> and by <code>pairwiseTaxonDistanceMatrix</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L74-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network,PhyloNetworks.Node}" href="#PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network,PhyloNetworks.Node}"><code>PhyloNetworks.removeHybrid!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">removeHybrid!(net::Network, n::Node)</code></pre><p>Delete a hybrid node <code>n</code> from <code>net.hybrid</code>, and update <code>net.numHybrid</code>. The actual node <code>n</code> is not deleted. It is kept in the full list <code>net.node</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L508-L513">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.resetEdgeNumbers!-Tuple{HybridNetwork}" href="#PhyloNetworks.resetEdgeNumbers!-Tuple{HybridNetwork}"><code>PhyloNetworks.resetEdgeNumbers!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">resetEdgeNumbers!(net::HybridNetwork; checkPreorder=true, ape=true)</code></pre><p>Check that edge numbers of <code>net</code> are consecutive numbers from 1 to the total number of edges. If not, reset the edge numbers to be so.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L906-L911">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.resetNodeNumbers!-Tuple{HybridNetwork}" href="#PhyloNetworks.resetNodeNumbers!-Tuple{HybridNetwork}"><code>PhyloNetworks.resetNodeNumbers!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">resetNodeNumbers!(net::HybridNetwork; checkPreorder=true, ape=true)</code></pre><p>Change internal node numbers of <code>net</code> to consecutive numbers from 1 to the total number of nodes.</p><p>keyword arguments:</p><ul><li><code>ape</code>: if true, the new numbers satisfy the conditions assumed by the <code>ape</code> R package: leaves are 1 to n, the root is n+1, and internal nodes are higher consecutive integers. If false, nodes are numbered in post-order, with leaves from 1 to n (and the root last).</li><li><code>checkPreorder</code>: if false, the <code>isChild1</code> edge field and the <code>net.nodes_changed</code> network field are supposed to be correct (to get nodes in preorder)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(A,(B,(C,D)));&quot;);
julia&gt; PhyloNetworks.resetNodeNumbers!(net)
julia&gt; printNodes(net)
Node    In Cycle        isHybrid        hasHybEdge      Node label      isLeaf  Edges numbers
1       -1              false           false           A               true    1
2       -1              false           false           B               true    2
3       -1              false           false           C               true    3
4       -1              false           false           D               true    4
7       -1              false           false                           false   3       4       5
6       -1              false           false                           false   2       5       6
5       -1              false           false                           false   1       6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/manipulateNet.jl#L853-L882">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.sameTaxa-Tuple{Quartet,HybridNetwork}" href="#PhyloNetworks.sameTaxa-Tuple{Quartet,HybridNetwork}"><code>PhyloNetworks.sameTaxa</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sameTaxa(Quartet, HybridNetwork)</code></pre><p>Return <code>true</code> if all taxa in the quartet are represented in the network, <code>false</code> if one or more taxa in the quartet does not appear in the network.</p><p>warning: the name can cause confusion. A more appropriate name might be &quot;in&quot;, or &quot;taxain&quot;, or &quot;taxonsubset&quot;, or etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L335-L343">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.sampleBootstrapTrees-Tuple{Array{Array{HybridNetwork,1},1}}" href="#PhyloNetworks.sampleBootstrapTrees-Tuple{Array{Array{HybridNetwork,1},1}}"><code>PhyloNetworks.sampleBootstrapTrees</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sampleBootstrapTrees(vector of tree lists; seed=0::Integer, generesampling=false, row=0)
sampleBootstrapTrees!(tree list, vector of tree lists; seed=0::Integer, generesampling=false, row=0)</code></pre><p>Sample bootstrap gene trees, 1 tree per gene. Set the seed with keyword argument <code>seed</code>, which is 0 by default. When <code>seed=0</code>, the actual seed is set using the clock. Assumes a vector of vectors of networks (see <code>readBootstrapTrees</code>), each one of length 1 or more (error if one vector is empty, tested in <code>bootsnaq</code>).</p><ul><li>site resampling: always, from sampling one bootstrap tree from each given list. This tree is sampled at <strong>random</strong> unless <code>row&gt;0</code> (see below).</li><li>gene resampling: if <code>generesampling=true</code> (default is false), genes (i.e. lists) are sampled with replacement.</li><li><code>row=i</code>: samples the ith bootstrap tree for each gene. <code>row</code> is turned back to 0 if gene resampling is true.</li></ul><p>output: one vector of trees. the modifying function (!) modifies the input tree list and returns it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/bootstrap.jl#L35-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.sampleCFfromCI" href="#PhyloNetworks.sampleCFfromCI"><code>PhyloNetworks.sampleCFfromCI</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sampleCFfromCI(data frame, seed=0)
sampleCFfromCI!(data frame, seed=0)</code></pre><p>Read a data frame containing CFs and their credibility intervals, and sample new obsCF uniformly within the CIs. These CFs are then rescaled to sum up to 1 for each 4-taxon sets. Return a data frame with taxon labels in first 4 columns, sampled obs CFs in columns 5-7 and credibility intervals in columns 8-13.</p><ul><li>The non-modifying function creates a new data frame (with re-ordered columns) and returns it. If <code>seed=-1</code>, the new df is a deep copy of the input df, with no call to the random number generator. Otherwise, <code>seed</code> is passed to the modifying function.</li><li>The modifying function overwrites the input data frame with the sampled CFs and returns it. If <code>seed=0</code>, the random generator is seeded from the clock. Otherwise the random generator is seeded using <code>seed</code>.</li></ul><p>Warning: the modifying version does <em>not</em> check the data frame: assumes correct columns.</p><p>optional argument: <code>delim=&#39;,&#39;</code> by default: how columns are delimited.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/bootstrap.jl#L92-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.setBLGammaParsimony!-Tuple{HybridNetwork}" href="#PhyloNetworks.setBLGammaParsimony!-Tuple{HybridNetwork}"><code>PhyloNetworks.setBLGammaParsimony!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>setBLGammaParsimony!(net::HybridNetwork)</p><p>Maximum parsimony function does not provide estimates for branch lengths, or gamma. But since the <code>maxParsimonyNet</code> function is using snaq move functions, branch lengths and gamma values are set randomly (to initialize optimization). We need to remove these random values before returning the maximum parsimony network.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/descriptive.jl#L111-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.setBranchLength!-Tuple{PhyloNetworks.Edge,Number}" href="#PhyloNetworks.setBranchLength!-Tuple{PhyloNetworks.Edge,Number}"><code>PhyloNetworks.setBranchLength!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>setBranchLength!(Edge,new length)</code></p><p>sets the length of an Edge object. The new length needs to be non-negative, or -1.0 to be interpreted as missing. Example: if net is a HybridNetwork object, do printEdges(net) to see the list of all edges with their lengths. The length of the 3rd edge can be changed to 1.2 with setBranchLength!(net.edge[3],1.2). It can also be set to missing with setBranchLength!(net.edge[3],-1.0)</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L823-L828">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}" href="#PhyloNetworks.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.setGammaBLfromGammaz!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setGammaBLfromGammaz!(node, network)</code></pre><p>Update the γ values of the two sister hybrid edges in a bad diamond I, given the <code>gammaz</code> values of their parent nodes, and update the branch lengths t1 and t2 of their parent edges (those across from the hybrid nodes), in such a way that t1=t2 and that these branch lengths and γ values are consistent with the <code>gammaz</code> values in the network.</p><p>Similar to the first section of <a href="#PhyloNetworks.undoGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}"><code>undoGammaz!</code></a>, but does not update anything else than γ and t&#39;s. Unlike <code>undoGammaz!</code>, no error if non-hybrid <code>node</code> or not at bad diamond I.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/auxiliary.jl#L894-L905">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.setGammas!-Tuple{HybridNetwork,Array{T,1} where T}" href="#PhyloNetworks.setGammas!-Tuple{HybridNetwork,Array{T,1} where T}"><code>PhyloNetworks.setGammas!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setGammas!(net, γ vector)</code></pre><p>Set inheritance γ&#39;s of hybrid edges, using input vector for <em>major</em> edges. Assume pre-order calculated already, with up-to-date field <code>nodes_changed</code>. See <a href="#PhyloNetworks.getGammas-Tuple{HybridNetwork}"><code>getGammas</code></a>.</p><p>Very different from <a href="../public/#PhyloNetworks.setGamma!"><code>setGamma!</code></a>, which focuses on a single hybrid event, updates the field <code>isMajor</code> according to the new γ, and is not used here.</p><p>May assume a tree-child network.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L1262-L1273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.setNonIdBL!-Tuple{HybridNetwork}" href="#PhyloNetworks.setNonIdBL!-Tuple{HybridNetwork}"><code>PhyloNetworks.setNonIdBL!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>setNonIdBL!(net)</code></p><p>Set non-identifiable edge branch lengths to -1.0 (i.e. missing) for a level-1 network <code>net</code>, except for edges in</p><ul><li>a good triangle: the edge below the hybrid is constrained to 0.</li><li>a bad diamond II: the edge below the hybrid is constrained to 0</li><li>a bad diamond I: the edges across from the hybrid node have non identifiable lengths but are kept, because the two γ*(1-exp(-t)) values are identifiable.</li></ul><p>will break if <code>inCycle</code> attributes are not initialized (at -1) or giving a correct node number.</p><p>see <a href="#PhyloNetworks.Node"><code>Node</code></a> for the meaning of boolean attributes <code>isBadTriangle</code> (which corresponds to a &quot;good&quot; triangle above), <code>isBadDiamondI</code> and <code>isBadDiamondII</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/descriptive.jl#L75-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.setalpha!-Tuple{RateVariationAcrossSites,Float64}" href="#PhyloNetworks.setalpha!-Tuple{RateVariationAcrossSites,Float64}"><code>PhyloNetworks.setalpha!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setalpha!(obj, alpha)</code></pre><p>Set the shape parameter <code>alpha</code> in a RateVariationAcrossSites model <code>obj</code>, and update the rate multipliers accordingly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L1025-L1030">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.seteigeninfo!-Tuple{BinaryTraitSubstitutionModel}" href="#PhyloNetworks.seteigeninfo!-Tuple{BinaryTraitSubstitutionModel}"><code>PhyloNetworks.seteigeninfo!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>for a [<code>BinaryTraitSubstitutionModel</code>]: store eigenvalue (q<em>01+q</em>10) and stationary distribution</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L297-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.seteigeninfo!-Tuple{EqualRatesSubstitutionModel}" href="#PhyloNetworks.seteigeninfo!-Tuple{EqualRatesSubstitutionModel}"><code>PhyloNetworks.seteigeninfo!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>for a [<code>EqualRatesSubstitutionModel</code>]: store lambda = k/(k-1), where k is the number of states</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L465-L467">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.seteigeninfo!-Tuple{HKY85}" href="#PhyloNetworks.seteigeninfo!-Tuple{HKY85}"><code>PhyloNetworks.seteigeninfo!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>for <a href="../public/#PhyloNetworks.HKY85"><code>HKY85</code></a>: store piR, piY, the 2 non-zero eigenvalues and a scaling factor</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L805-L807">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.seteigeninfo!-Tuple{JC69}" href="#PhyloNetworks.seteigeninfo!-Tuple{JC69}"><code>PhyloNetworks.seteigeninfo!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>for <a href="../public/#PhyloNetworks.JC69"><code>JC69</code></a>: store lambda = 4/3 (if relative) or rate * 4/3 (absolute).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L705-L707">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.seteigeninfo!-Tuple{PhyloNetworks.SubstitutionModel}" href="#PhyloNetworks.seteigeninfo!-Tuple{PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.seteigeninfo!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">seteigeninfo!(obj)</code></pre><p>Calculate eigenvalue &amp; eigenfector information for a substitution model (SM) object (as needed to calculate transition rate matrices) and store this info within the object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L64-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.setrates!-Tuple{PhyloNetworks.SubstitutionModel,AbstractArray{T,1} where T}" href="#PhyloNetworks.setrates!-Tuple{PhyloNetworks.SubstitutionModel,AbstractArray{T,1} where T}"><code>PhyloNetworks.setrates!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setrates!(model, rates)</code></pre><p>update rates then call <a href="#PhyloNetworks.seteigeninfo!-Tuple{BinaryTraitSubstitutionModel}"><code>seteigeninfo!</code></a> to update a model&#39;s eigeninfo</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L54-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.showQ-Tuple{IO,PhyloNetworks.SubstitutionModel}" href="#PhyloNetworks.showQ-Tuple{IO,PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.showQ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">showQ(IO, model)</code></pre><p>Print the Q matrix to the screen, with trait states as labels on rows and columns. adapted from prettyprint function by mcreel, found 2017/10 at https://discourse.julialang.org/t/display-of-arrays-with-row-and-column-names/1961/6</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/substitutionModels.jl#L149-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.sortUnionTaxa!-Tuple{Any}" href="#PhyloNetworks.sortUnionTaxa!-Tuple{Any}"><code>PhyloNetworks.sortUnionTaxa!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sortUnionTaxa!(taxa)</code></pre><p>Take a vector of strings <code>taxa</code>, sort it numerically if elements can be parsed as an integer, alphabetically otherwise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L390-L395">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.startingrate-Tuple{HybridNetwork}" href="#PhyloNetworks.startingrate-Tuple{HybridNetwork}"><code>PhyloNetworks.startingrate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">startingrate(net)</code></pre><p>Estimate an evolutionary rate appropriate for the branch lengths in the network, which should be a good starting value before optimization in <code>fitdiscrete</code>, assuming approximately 1 change across the entire tree. If all edge lengths are missing, set starting rate to 1/(number of taxa).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traitsLikDiscrete.jl#L861-L868">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.symmetricNet" href="#PhyloNetworks.symmetricNet"><code>PhyloNetworks.symmetricNet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">symmetricNet(n, h, gamma)</code></pre><p>Create a string with a symmetric net with 2^n tips, numbered from 1 to 2^n The total height of the network is set to 1. Hybrids are added from level h to h-1 symmetrically.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L1458-L1464">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.symmetricNet-Tuple{Int64,Int64,Int64,Real,Real}" href="#PhyloNetworks.symmetricNet-Tuple{Int64,Int64,Int64,Real,Real}"><code>PhyloNetworks.symmetricNet</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">symmetricNet(n, i, j, gamma)</code></pre><p>Create a string with a symmetric net with 2^n tips, numbered from 1 to 2^n All the branch length are set equal to 1. One hybrid branch, going from level i to level j is added, with weigth gamma. The tree can be created with function readTopology.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L1421-L1428">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.symmetricTree" href="#PhyloNetworks.symmetricTree"><code>PhyloNetworks.symmetricTree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">symmetricTree(n, i=1)</code></pre><p>Create a string with a symmetric tree with 2^n tips, numbered from i to i+2^n-1. All the branch length are set equal to 1. The tree can be created with function readTopology.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L1399-L1405">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.synchronizePartnersData!-Tuple{PhyloNetworks.Edge,PhyloNetworks.Node}" href="#PhyloNetworks.synchronizePartnersData!-Tuple{PhyloNetworks.Edge,PhyloNetworks.Node}"><code>PhyloNetworks.synchronizePartnersData!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">synchronizePartnersData!(e::Edge, n::Node)</code></pre><p>Synchronize γ and isMajor for edges <code>e</code> and its partner, both hybrid edges with the same child <code>n</code>:</p><ul><li>if one γ is missing and the other is not: set the missing γ to 1 - the other</li><li>γ&#39;s should sum up to 1.0</li><li>update <code>isMajor</code> to match the γ information: the major edge is the one with γ &gt; 0.5.</li></ul><p><strong>Warnings</strong>: does not check that <code>e</code> is a hybrid edge, nor that <code>n</code> is the child of <code>e</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L303-L315">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.taxadiff-Tuple{Array{Quartet,1},HybridNetwork}" href="#PhyloNetworks.taxadiff-Tuple{Array{Quartet,1},HybridNetwork}"><code>PhyloNetworks.taxadiff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">taxadiff(Vector{Quartet}, network; multiplealleles=true)
taxadiff(DataCF, network; multiplealleles=true)</code></pre><p>Return 2 vectors:</p><ul><li>taxa in at least 1 of the quartets but not in the network, and</li><li>taxa in the network but in none of the quartets.</li></ul><p>When <code>multiplealleles</code> is true, the taxon names that end with &quot;__2&quot; are ignored in the quartets: they are not expected to appear in the networks that users give as input, or get as output.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L351-L363">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.ticr_optimalpha-Tuple{DataCF}" href="#PhyloNetworks.ticr_optimalpha-Tuple{DataCF}"><code>PhyloNetworks.ticr_optimalpha</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ticr_optimalpha(D::DataCF)</code></pre><p>Find the concentration parameter α by maximizing the pseudo-log-likelihood of observed quartet concordance factors. The model assumes a Dirichlet distribution with mean equal to the expected concordance factors calculated from a phylogenetic network (under ILS and reticulation). These expected CFs are assumed to be already calculated, and stored in D.</p><p>When calculating the pseudo-log-likelihood, this function will check the observed concordance factors for any values equal to zero: they cause a problem because the Dirichlet density is 0 at 0 (for concentrations &gt; 1). Those 0.0 observed CF values are re-set to the minimum of:</p><ul><li>the minimum of all expected concordance factors, and</li><li>the minimum of all nonzero observed concordance factors.</li></ul><p>output:</p><ul><li>maximized pseudo-loglikelihood</li><li>value of α where the pseudo-loglikelihood is maximized</li><li>return code of the optimization</li></ul><p>The optimization uses NLOpt, with the <code>:LN_BOBYQA</code> method. Optional arguments can tune the optimization differently: <code>NLoptMethod</code>, <code>xtol_rel</code> (1e-6 by default), starting α value <code>x_start</code> (1.0 by default).</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/ticr.jl#L113-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.traitlabels2indices-Tuple{AbstractArray{T,1} where T,PhyloNetworks.SubstitutionModel}" href="#PhyloNetworks.traitlabels2indices-Tuple{AbstractArray{T,1} where T,PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.traitlabels2indices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">traitlabels2indices(data, model::SubstitutionModel)</code></pre><p>Check that the character states in <code>data</code> are compatible with (i.e. subset of) the trait labels in <code>model</code>. All columns are used. <code>data</code> can be a DataFrame or a Matrix (multiple traits), or a Vector (one trait). Return a vector of vectors (one per species) with integer entries, where each state (label) is replaced by its index in <code>model</code>.  For DNA data, any ambiguous site is treated as missing.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traitsLikDiscrete.jl#L586-L595">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.traverseContainRoot!-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge,Array{PhyloNetworks.Edge,1},Array{Bool,1}}" href="#PhyloNetworks.traverseContainRoot!-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge,Array{PhyloNetworks.Edge,1},Array{Bool,1}}"><code>PhyloNetworks.traverseContainRoot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">updateContainRoot!(HybridNetwork, Node)
traverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})</code></pre><p>The input <code>node</code> to <code>updateContainRoot!</code> must be a hybrid node (can come from searchHybridNode). <code>updateContainRoot!</code> starts at the input node and calls <code>traverseContainRoot!</code>, which traverses the network recursively. By default, containRoot attributes of edges are true. Changes <code>containRoot</code> to false for all the visited edges: those below the input node, but not beyond any other hybrid node.</p><p><code>updateContainRoot!</code> Returns a <code>flag</code> and an array of edges whose containRoot has been changed from true to false. <code>flag</code> is false if the set of edges to place the root is empty</p><p>In <code>traverseContainRoot!</code>, <code>rightDir</code> turns false if hybridizations have incompatible directions (vector of length 1, to be modified).</p><p>Warning:</p><ul><li>does <em>not</em> update <code>containRoot</code> of minor hybrid edges.</li><li>assumes correct <code>isMajor</code> attributes: to stop the recursion at minor hybrid edges.</li><li>assumes correct hybrid attributes of both nodes &amp; edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).</li></ul><p><code>rightDir</code>: vector of length 1 boolean, to be mutable and modified by the function</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/update.jl#L115-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.undoGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}" href="#PhyloNetworks.undoGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.undoGammaz!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">undoGammaz!(node, network)</code></pre><p>Undo <code>updateGammaz!</code> for the 2 cases: bad diamond I,II. <code>node</code> should be a hybrid node. Set length to edges that were not identifiable and change edges&#39; <code>gammaz</code> attribute to -1.0. Recalculate branch lengths in terms of <code>gammaz</code>.   <em>warning</em>: needs to know <code>incycle</code> attributes</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/undo.jl#L40-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.updateBL!-Tuple{HybridNetwork,DataCF}" href="#PhyloNetworks.updateBL!-Tuple{HybridNetwork,DataCF}"><code>PhyloNetworks.updateBL!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">updateBL!(net::HybridNetwork, d::DataCF)</code></pre><p>Update internal branch lengths of <code>net</code> based on the average quartet concordance factor (CF) across all quartets that exactly correspond to a given branch: new branch length = <code>-log(3/2(1-mean(CF observed in d)))</code>. <code>net</code> is assumed to be a tree, such that the above equation holds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readData.jl#L787-L794">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.updateContainRoot!" href="#PhyloNetworks.updateContainRoot!"><code>PhyloNetworks.updateContainRoot!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">updateContainRoot!(HybridNetwork, Node)
traverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})</code></pre><p>The input <code>node</code> to <code>updateContainRoot!</code> must be a hybrid node (can come from searchHybridNode). <code>updateContainRoot!</code> starts at the input node and calls <code>traverseContainRoot!</code>, which traverses the network recursively. By default, containRoot attributes of edges are true. Changes <code>containRoot</code> to false for all the visited edges: those below the input node, but not beyond any other hybrid node.</p><p><code>updateContainRoot!</code> Returns a <code>flag</code> and an array of edges whose containRoot has been changed from true to false. <code>flag</code> is false if the set of edges to place the root is empty</p><p>In <code>traverseContainRoot!</code>, <code>rightDir</code> turns false if hybridizations have incompatible directions (vector of length 1, to be modified).</p><p>Warning:</p><ul><li>does <em>not</em> update <code>containRoot</code> of minor hybrid edges.</li><li>assumes correct <code>isMajor</code> attributes: to stop the recursion at minor hybrid edges.</li><li>assumes correct hybrid attributes of both nodes &amp; edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).</li></ul><p><code>rightDir</code>: vector of length 1 boolean, to be mutable and modified by the function</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/update.jl#L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.updatePostOrder!" href="#PhyloNetworks.updatePostOrder!"><code>PhyloNetworks.updatePostOrder!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">recursionPostOrder(nodes, init_function, tip_function, node_function,
                   parameters)
updatePostOrder(index, nodes, updated_matrix, tip_function, node_function,
                parameters)</code></pre><p>Generic tool to apply a post-order (or topological ordering) algorithm. Used by <code>descendenceMatrix</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.updatePreOrder!" href="#PhyloNetworks.updatePreOrder!"><code>PhyloNetworks.updatePreOrder!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">recursionPreOrder(nodes, init_function, root_function, tree_node_function,
                  hybrid_node_function, parameters)
recursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,
                   hybrid_node_function, parameters)
updatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,
               hybrid_node_function, parameters)</code></pre><p>Generic tool to apply a pre-order (or topological ordering) algorithm. Used by <code>sharedPathMatrix</code> and by <code>pairwiseTaxonDistanceMatrix</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traits.jl#L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.writeTopologyLevel1-Tuple{HybridNetwork}" href="#PhyloNetworks.writeTopologyLevel1-Tuple{HybridNetwork}"><code>PhyloNetworks.writeTopologyLevel1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>writeTopologyLevel1(net::HybridNetwork)</code></p><p>Write the extended Newick parenthetical format of a level-1 network object with many optional arguments (see below). Makes a deep copy of net: does <em>not</em> modify <code>net</code>.</p><ul><li>di=true: write in format for Dendroscope (default false)</li><li>namelabel=true: If <code>namelabel</code> is true, taxa are labelled by their names;</li></ul><p>otherwise taxa are labelled by their numbers (unique identifiers).</p><ul><li>outgroup (string): name of outgroup to root the tree/network. if &quot;none&quot; is given, the root is placed wherever possible.</li><li>printID=true, only print branch lengths for identifiable egdes according to the snaq estimation procedure (default false) (true inside of <code>snaq!</code>.)</li><li>round: rounds branch lengths and heritabilities γ (default: true)</li><li>digits: digits after the decimal place for rounding (defult: 3)</li><li>string: if true (default), returns a string, otherwise returns an IOBuffer object.</li><li>multall: (default false). set to true when there are multiple alleles per population.</li></ul><p>The topology may be written using a root different than net.root, if net.root is incompatible with one of more hybrid node. Missing hybrid names are written as &quot;#Hi&quot; where &quot;i&quot; is the hybrid node number if possible.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/readwrite.jl#L1076-L1101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Tuple{Type{PhyloNetworks.StatisticalSubstitutionModel},HybridNetwork,PhyloNetworks.SubstitutionModel,RateVariationAcrossSites,AbstractArray{T,1} where T}" href="#StatsBase.fit-Tuple{Type{PhyloNetworks.StatisticalSubstitutionModel},HybridNetwork,PhyloNetworks.SubstitutionModel,RateVariationAcrossSites,AbstractArray{T,1} where T}"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(StatisticalSubstitutionModel, net, model, traits; kwargs...)
fit!(StatisticalSubstitutionModel; kwargs...)</code></pre><p>Internal function called by <a href="../public/#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a>: with same key word arguments <code>kwargs</code>. But dangerous: <code>traits</code> should be a vector of vectors as for <a href="../public/#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a> <strong>but</strong> here <code>traits</code> need to contain the <em>indices</em> of trait values corresponding to the indices in <code>getlabels(model)</code>, and species should appear in <code>traits</code> in the order corresponding to the node numbers in <code>net</code>. See <a href="#PhyloNetworks.traitlabels2indices-Tuple{AbstractArray{T,1} where T,PhyloNetworks.SubstitutionModel}"><code>traitlabels2indices</code></a> to convert trait labels to trait indices. <strong>Warning</strong>: does <em>not</em> perform checks. <a href="../public/#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a> calls this function after doing checks, preordering nodes in the network, making sure nodes have consecutive numbers, species are matched between data and network etc. Like, snaq!(), we estimate the network starting from tree (or network) <code>astraltree</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/traitsLikDiscrete.jl#L340-L354">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhyloNetworks.fAbs" href="#PhyloNetworks.fAbs"><code>PhyloNetworks.fAbs</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>default values for tolerance parameters, used in the optimization of branch lengths (fAbs, fRel, xAbs, xRel) and in the acceptance of topologies (likAbs, numFails).</p><p>if changes are made here, <strong>make the same</strong> in the docstring for snaq! below</p><table><tr><th style="text-align: right">version</th><th style="text-align: right">fAbs</th><th style="text-align: right">fRel</th><th style="text-align: right">xAbs</th><th style="text-align: right">xRel</th><th style="text-align: right">numFails</th><th style="text-align: right">likAbs</th><th style="text-align: right">multiplier</th></tr><tr><td style="text-align: right">v0.5.1</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-3</td><td style="text-align: right">1e-2</td><td style="text-align: right">75</td><td style="text-align: right">1e-6</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">v0.3.0</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-5</td><td style="text-align: right">1e-4</td><td style="text-align: right">1e-3</td><td style="text-align: right">100</td><td style="text-align: right">0.01</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">v0.0.1</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-5</td><td style="text-align: right">1e-4</td><td style="text-align: right">1e-3</td><td style="text-align: right">100</td><td style="text-align: right"></td><td style="text-align: right">10000</td></tr><tr><td style="text-align: right">older</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-12</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><p>v0.5.1: based on Nan Ji&#39;s work. same xAbs and xRel as in phylonet (as of 2015). earlier: multiplier was used; later: likAbs = multiplier*fAbs) &quot;older&quot;: values from GLM.jl, Prof Bates</p><p>default values used on a single topology, to optimize branch lengths and gammas, at the very end of snaq!, and by topologyMaxQPseudolik! since v0.5.1.</p><table><tr><th style="text-align: right">version</th><th style="text-align: right">fAbsBL</th><th style="text-align: right">fRelBL</th><th style="text-align: right">xAbsBL</th><th style="text-align: right">xRelBL</th></tr><tr><td style="text-align: right">v0.0.1</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-12</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td></tr></table></div></div><a class="source-link" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/bcaebd05b2e89a52ab4a0377377c6f7f93cee9eb/src/optimization.jl#L8-L33">source</a></section><footer><hr/><a class="previous" href="../public/"><span class="direction">Previous</span><span class="title">Public</span></a></footer></article></body></html>
