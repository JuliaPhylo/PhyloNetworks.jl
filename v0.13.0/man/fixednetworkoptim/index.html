<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Candidate Networks · PhyloNetworks.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PhyloNetworks.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PhyloNetworks.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../inputdata/">Input Data for SNaQ</a></li><li><a class="tocitem" href="../ticr_howtogetQuartetCFs/">TICR pipeline</a></li><li><a class="tocitem" href="../snaq_plot/">Network estimation and display</a></li><li><a class="tocitem" href="../dist_reroot/">Network comparison and manipulation</a></li><li class="is-active"><a class="tocitem" href>Candidate Networks</a><ul class="internal"><li><a class="tocitem" href="#Optimizing-parameters-for-a-given-network"><span>Optimizing parameters for a given network</span></a></li><li><a class="tocitem" href="#Network-Score-with-no-optimization"><span>Network Score with no optimization</span></a></li><li><a class="tocitem" href="#Candidate-networks-compatible-with-a-known-outgroup"><span>Candidate networks compatible with a known outgroup</span></a></li></ul></li><li><a class="tocitem" href="../expectedCFs/">Extract Expected CFs</a></li><li><a class="tocitem" href="../bootstrap/">Bootstrap</a></li><li><a class="tocitem" href="../multiplealleles/">Multiple Alleles</a></li><li><a class="tocitem" href="../trait_tree/">Continuous Trait Evolution</a></li><li><a class="tocitem" href="../parsimony/">Parsimony on networks</a></li><li><a class="tocitem" href="../fitDiscrete/">Discrete Trait Evolution</a></li><li><a class="tocitem" href="../nj/">Neighbour Joining</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Candidate Networks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Candidate Networks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/crsl4/PhyloNetworks.jl/blob/master/docs/src/man/fixednetworkoptim.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Candidate-Networks"><a class="docs-heading-anchor" href="#Candidate-Networks">Candidate Networks</a><a id="Candidate-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Candidate-Networks" title="Permalink"></a></h1><h2 id="Optimizing-parameters-for-a-given-network"><a class="docs-heading-anchor" href="#Optimizing-parameters-for-a-given-network">Optimizing parameters for a given network</a><a id="Optimizing-parameters-for-a-given-network-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-parameters-for-a-given-network" title="Permalink"></a></h2><p>For a given network topology, we can optimize the branch lengths and inheritance probabilities (γ) with the pseudolikelihood. This is useful if we have a few candidate networks to compare. Each network can be optimized individually, and the network with the best pseudolikelihood can be chosen.</p><p>The score being optimized is a pseudo-deviance, i.e. a multiple of the negative log pseudo-likelihood up to an additive constant (the lower the better; a pseudo-deviance of 0 corresponds to a perfect fit).</p><p>Following our example in <a href="../snaq_plot/#Getting-a-Network">Getting a Network</a>, we can optimize parameters on the true network (the one originally used to simulate the data):</p><pre><code class="language-julia-repl">julia&gt; truenet = readTopology(&quot;((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);&quot;);

julia&gt; net1alt = topologyMaxQPseudolik!(truenet, raxmlCF);

julia&gt; writeTopology(net1alt, round=true)
&quot;(D,C,(((A,B):0.984)#H1:7.643::0.72,((#H1:0.008::0.28,E):1.277,O):1.174):8.171);&quot;

julia&gt; net1alt.loglik # pseudo deviance actually: the lower the better
29.894966124051514</code></pre><pre><code class="language-julia">using PhyloPlots, RCall
R&quot;par&quot;(mar=[0,0,0,0])
plot(net1alt, :R, showGamma=true);</code></pre><p><img src="../../assets/figures/truenet_opt.svg" alt="truenet_opt"/></p><p>We get a score of 29.941, which is comparable to the score of the SNaQ network (net1: 28.315), especially compared to the score of the best tree (net0: 53.532). This begs the question: is the true network within the &quot;range&quot; of uncertainty? We can run a <a href="../bootstrap/#Bootstrap">Bootstrap</a> analysis to measure uncertainty in our network inference.</p><p>For a more thorough optimization, we may increase the requirements before the search stops (but the optimization will take longer). It makes no difference on this small data set.</p><pre><code class="language-julia">net1par = topologyMaxQPseudolik!(truenet, raxmlCF, ftolRel=1e-10, xtolAbs=1e-10)
net1par.loglik # pseudo deviance, actually: the lower the better</code></pre><h2 id="Network-Score-with-no-optimization"><a class="docs-heading-anchor" href="#Network-Score-with-no-optimization">Network Score with no optimization</a><a id="Network-Score-with-no-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Score-with-no-optimization" title="Permalink"></a></h2><p>For a network with given branch lengths and γ heritabilies, we can compute the pseudolikelihood (well, a pseudo-deviance) with:</p><pre><code class="language-julia-repl">julia&gt; topologyQPseudolik!(truenet,raxmlCF);

julia&gt; truenet.loglik # again, pseudo deviance
153.53102953930053</code></pre><p>This function is not maximizing the pseudolikelihood, it is simply computing the pseudolikelihood (or deviance) for the given branch lengths and probabilities of inheritance. At the moment, both of these functions require that the given network is of level 1 (cycles don&#39;t overlap).</p><h2 id="Candidate-networks-compatible-with-a-known-outgroup"><a class="docs-heading-anchor" href="#Candidate-networks-compatible-with-a-known-outgroup">Candidate networks compatible with a known outgroup</a><a id="Candidate-networks-compatible-with-a-known-outgroup-1"></a><a class="docs-heading-anchor-permalink" href="#Candidate-networks-compatible-with-a-known-outgroup" title="Permalink"></a></h2><p>If the network was estimated via <code>snaq!</code>, it might turn out to be impossible to root our estimated network with a known outgroup (see section <a href="../dist_reroot/#What-if-the-root-conflicts-with-the-direction-of-a-reticulation?">What if the root conflicts with the direction of a reticulation?</a>.) At this time, <code>snaq!</code> does not impose any rooting constraint on the network: the search for the lowest score considers all level-1 networks, including those that are incompatible with a known outgroup. (The monophyly of outgroups is not imposed either, like in many other methods.)</p><p>If the estimated network cannot be rooted with the known outgroup, we can check the <code>.networks</code> output file. It has a list of networks that are slight modifications of the best network, where the modifications changed the direction of one reticulation at a time. For each modified network, the score was calculated. So if we find in this list a modified network that has a score close to that of the best network, and that can be re-rooted with our known root position, then this modified network is a better candidate than the network with the best score.</p><p>Below is what the <code>net1.networks</code> file looks like, after performing the analysis in the section <a href="../snaq_plot/#Network-Estimation">Network Estimation</a>. Scroll to the right to see the scores.</p><pre><code class="language-none">(C,D,((O,(E,#H7:::0.19558838614943078):0.31352437658618976):0.6640664399202987,(B,(A)#H7:::0.8044116138505693):10.0):10.0);, with -loglik 28.31506721890958 (best network found, remaining sorted by log-pseudolik; the smaller, the better)
(C,D,((O,(E)#H7:::0.8150784689693145):0.9336405757682176,(B,(A,#H7:::0.18492153103068557):0.25386142779877724):1.8758156446611114):10.0);, with -loglik 31.535560380783814
(B,#H7:9.90999345612101::0.2555404440833535,(A,(E,(O,((C,D):10.0)#H7:0.3419231810962026::0.7444595559166465):0.19994859441332047):2.5014911511063644):0.7957621793330066);, with -loglik 56.64548310161462
(C,D,((O,(E,((B)#H7:::0.7957543284159452,A):4.786202415937916):0.004527712280136759):1.7952610454570868,#H7:::0.20424567158405482):10.0);, with -loglik 67.17775727492258
(C,D,(#H7:::0.32947301811471164,(B,(A,(E,(O)#H7:::0.6705269818852884):1.371799259141243):0.0):6.397073999864152):7.677245926003807);, with -loglik 199.11401961057143</code></pre><p>We can read this file and look at its list of networks like this:</p><pre><code class="language-julia-repl">julia&gt; file = &quot;net1.networks&quot;;

julia&gt; # or use the example file available with the package:
       file = joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;,&quot;examples&quot;,&quot;net1.networks&quot;);

julia&gt; netlist = readMultiTopology(file) # read the full list of networks in that file
5-element Array{HybridNetwork,1}:
 HybridNetwork, Rooted Network
12 edges
12 nodes: 6 tips, 1 hybrid nodes, 5 internal tree nodes.
tip labels: C, D, O, E, ...
(C,D,((O,(E,#H7:::0.196):0.314):0.664,(B,(A)#H7:::0.804):10.0):10.0);

 HybridNetwork, Rooted Network
12 edges
12 nodes: 6 tips, 1 hybrid nodes, 5 internal tree nodes.
tip labels: C, D, O, E, ...
(C,D,((O,(E)#H7:::0.815):0.934,(B,(A,#H7:::0.185):0.254):1.876):10.0);

 HybridNetwork, Rooted Network
12 edges
12 nodes: 6 tips, 1 hybrid nodes, 5 internal tree nodes.
tip labels: B, A, E, O, ...
(B,#H7:9.91::0.256,(A,(E,(O,((C,D):10.0)#H7:0.342::0.744):0.2):2.501):0.796);

 HybridNetwork, Rooted Network
12 edges
12 nodes: 6 tips, 1 hybrid nodes, 5 internal tree nodes.
tip labels: C, D, O, E, ...
(C,D,((O,(E,((B)#H7:::0.796,A):4.786):0.005):1.795,#H7:::0.204):10.0);

 HybridNetwork, Rooted Network
12 edges
12 nodes: 6 tips, 1 hybrid nodes, 5 internal tree nodes.
tip labels: C, D, B, A, ...
(C,D,(#H7:::0.329,(B,(A,(E,(O)#H7:::0.671):1.372):0.0):6.397):7.677);</code></pre><p>Next, we would like to extract the network scores from the file. Below is a one-liner to do this (we make Julia send a <code>sed</code> command to the shell –sorry, Mac or Linux for this.)</p><pre><code class="language-julia-repl">julia&gt; scoresInString = read(`sed -E &#39;s/.+with -loglik ([0-9]+.[0-9]+).+/\1/&#39; $file`, String)
&quot;28.31506721890958\n31.53556038078381\n56.6454831016146\n67.1777572749225\n199.1140196105714\n&quot;

julia&gt; scores = parse.(Float64, split(scoresInString))
5-element Array{Float64,1}:
  28.31506721890958
  31.53556038078381
  56.6454831016146
  67.1777572749225
 199.1140196105714

julia&gt; # next: update the &quot;loglik&quot; of each network with the score read from the file
       for i in eachindex(netlist)
          netlist[i].loglik = scores[i]
          println(&quot;net $i in the list: score = &quot;,scores[i])
       end
net 1 in the list: score = 28.31506721890958
net 2 in the list: score = 31.53556038078381
net 3 in the list: score = 56.6454831016146
net 4 in the list: score = 67.1777572749225
net 5 in the list: score = 199.1140196105714</code></pre><p>The first network in the list is the best network returned by <code>snaq!</code>. We see that the second network has a score that&#39;s not too far, but the other networks have worse scores. The best network and its best modification (second network in the list) are shown below. We chose to show edge numbers, to use them later to re-root the networks.</p><pre><code class="language-julia">plot(netlist[1], :R, showGamma=true, showEdgeNumber=true, tipOffset=0.1);
R&quot;mtext&quot;(&quot;best net, score=28.3&quot;, line=-1);
plot(netlist[2], :R, showGamma=true, showEdgeNumber=true, tipOffset=0.1);
R&quot;mtext&quot;(&quot;direction modified, score=31.5&quot;, line=-1);</code></pre><p><img src="../../assets/figures/fixednetworkoptim_othernets1.svg" alt="othernets before reroot"/></p><p>Now imagine that our outgroup is taxon A.</p><ul><li>best network: we would get a &quot;RootMismatch&quot; error if we tried to set the root on the external edge 9 to A, with <code>rootatnode!(netlist[1], &quot;A&quot;)</code> (see section <a href="../dist_reroot/#What-if-the-root-conflicts-with-the-direction-of-a-reticulation?">What if the root conflicts with the direction of a reticulation?</a>). But we could root the best network on the major parent edge to A, edge 10 (rooted network on the left below).</li><li>For the second best network in our list, there are 2 ways to root it with A: on the external edge 8 to A (top right), or on its parent edge 10 (bottom right). These 2 options give quite different rooted versions of the network, one of which requires the existence of an unsampled taxon, sister to BOECD, that would have contributed to introgression into an ancestor of E. The second rooted version says that an ancestor of (or sister to) A contributed to the introgression into the ancestor of E. A is an outgroup in both cases, but the second case is more parsimonious, in the sense that it does not require the existence of an unsampled taxon.</li></ul><pre><code class="language-julia">rootonedge!(netlist[1], 10); # root best net to make A outgroup
rotate!(netlist[1], -4); # to &#39;un-cross&#39; edges
rotate!(netlist[1], -6);
plot(netlist[1], :R, showGamma=true, tipOffset=0.1);
R&quot;mtext&quot;(&quot;best net, score=28.3&quot;, line=-1);
rootatnode!(netlist[2], &quot;A&quot;); # net with modified direction: first way to make A outgroup
plot(netlist[2], :R, showGamma=true, tipOffset=0.1);
R&quot;mtext&quot;(&quot;second best in list, score=31.5\nrequires unsampled population&quot;, line=-2);
rootonedge!(netlist[2], 10) # net with modified direction: second way to make A outgroup
plot(netlist[2], :R, showGamma=true, tipOffset=0.1);
R&quot;mtext&quot;(&quot;second best in list, score=31.5\ndifferent root position&quot;, line=-2);</code></pre><p><img src="../../assets/figures/fixednetworkoptim_othernets2.svg" alt="othernets after reroot"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dist_reroot/">« Network comparison and manipulation</a><a class="docs-footer-nextpage" href="../expectedCFs/">Extract Expected CFs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 12 March 2021 22:49">Friday 12 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
