<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Network estimation and display · PhyloNetworks.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PhyloNetworks.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PhyloNetworks.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../inputdata/">Input Data for SNaQ</a></li><li><a class="tocitem" href="../ticr_howtogetQuartetCFs/">TICR pipeline</a></li><li class="is-active"><a class="tocitem" href>Network estimation and display</a><ul class="internal"><li><a class="tocitem" href="#Network-Estimation"><span>Network Estimation</span></a></li><li><a class="tocitem" href="#parallel-computations"><span>parallel computations</span></a></li><li><a class="tocitem" href="#choosing-the-number-of-hybridizations"><span>choosing the number of hybridizations</span></a></li><li><a class="tocitem" href="#Network-Visualization"><span>Network Visualization</span></a></li><li><a class="tocitem" href="#Re-rooting-networks"><span>Re-rooting networks</span></a></li><li><a class="tocitem" href="#Candidate-Network-Evaluation"><span>Candidate Network Evaluation</span></a></li><li><a class="tocitem" href="#SNaQ-error-reporting"><span>SNaQ error reporting</span></a></li></ul></li><li><a class="tocitem" href="../dist_reroot/">Network comparison and manipulation</a></li><li><a class="tocitem" href="../fixednetworkoptim/">Candidate Networks</a></li><li><a class="tocitem" href="../expectedCFs/">Extract Expected CFs</a></li><li><a class="tocitem" href="../bootstrap/">Bootstrap</a></li><li><a class="tocitem" href="../multiplealleles/">Multiple Alleles</a></li><li><a class="tocitem" href="../trait_tree/">Continuous Trait Evolution</a></li><li><a class="tocitem" href="../parsimony/">Parsimony on networks</a></li><li><a class="tocitem" href="../fitDiscrete/">Discrete Trait Evolution</a></li><li><a class="tocitem" href="../nj/">Neighbour Joining</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Network estimation and display</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Network estimation and display</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/crsl4/PhyloNetworks.jl/blob/master/docs/src/man/snaq_plot.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-a-Network"><a class="docs-heading-anchor" href="#Getting-a-Network">Getting a Network</a><a id="Getting-a-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-a-Network" title="Permalink"></a></h1><h2 id="Network-Estimation"><a class="docs-heading-anchor" href="#Network-Estimation">Network Estimation</a><a id="Network-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Estimation" title="Permalink"></a></h2><p>SNaQ implements the statistical inference method in <a href="http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1005896">Solís-Lemus &amp; Ané 2016</a>. The procedure involves a numerical optimization of branch lengths and inheritance probabilities and a heuristic search in the space of phylogenetic networks.</p><p>After <a href="../inputdata/#Input-for-SNaQ">Input for SNaQ</a>, we can estimate the network using the input data <code>raxmlCF</code> and starting from tree (or network) <code>astraltree</code>. We first impose the constraint of at most 0 hybrid node, that is, we ask for a tree.</p><pre><code class="language-julia">net0 = snaq!(astraltree,raxmlCF, hmax=0, filename=&quot;net0&quot;, seed=1234)</code></pre><p>Part of the screen output shows this:</p><pre><code class="language-none">MaxNet is (C,D,((B,A):1.395762055180493,(O,E):0.48453400554506426):10.0);
with -loglik 53.53150526187732</code></pre><p>This parenthetical (extended Newick) description is not very human-friendly, so we plot the tree (more about plotting networks below: <a href="#Network-Visualization">Network Visualization</a> ).</p><pre><code class="language-julia">using PhyloPlots
plot(net0, :R);</code></pre><p><img src="../../assets/figures/snaqplot_net0_1.svg" alt="net0_1"/></p><p>We can use this tree as a starting point to search for the best network allowing for at most <code>hmax=1</code> hybrid node (which is the default).</p><pre><code class="language-julia">net1 = snaq!(net0, raxmlCF, hmax=1, filename=&quot;net1&quot;, seed=2345)</code></pre><p>part of screen output:</p><pre><code class="language-none">best network and networks with different hybrid/gene flow directions printed to .networks file
MaxNet is (C,D,((O,(E,#H7:::0.19558838614943078):0.31352437658618976):0.6640664399202987,(B,(A)#H7:::0.8044116138505693):10.0):10.0);
with -loglik 28.31506721890958</code></pre><p>We can visualize the estimated network and its inheritance values γ, which measure the proportion of genes inherited via each parent at a reticulation event (e.g. proportion of genes inherited via gene flow).</p><pre><code class="language-julia">plot(net1, :R, showGamma=true);</code></pre><p><img src="../../assets/figures/snaqplot_net1_1.svg" alt="net1_1"/></p><p>This network has A as a hybrid, 80.4% sister to B, and 19.6% sister to E (which is otherwise sister to O). C &amp; D are sister to each other. We can also check the output files created by <code>snaq!</code>:</p><pre><code class="language-julia">less(&quot;net1.err&quot;) # would provide info about errors, if any
less(&quot;net1.out&quot;) # main output file with the estimated network from each run
less(&quot;net1.networks&quot;) # extra info</code></pre><p>when viewing these result files with <code>less</code> within Julia, use arrows to scroll down and type <code>q</code> to quit viewing the files. The file <code>net1.networks</code> contains a list of networks that are slight modifications of the best (estimated) network <code>net1</code>. The modifications changed the direction of one reticulation at a time, by moving the placement of one hybrid node to another node inside the same cycle. For each modified network, the pseudolikelihood score was calculated (the <code>loglik</code> or <code>-Ploglik</code> values give a pseudo deviance actually).</p><p>The function name <code>snaq!</code> ends with ! because it modifies the argument <code>raxmlCF</code> by including the expected CF. Type <code>?</code> then <code>snaq!</code> to get help on that function.</p><p>The main output file, here <code>net1.out</code> (or <code>snaq.out</code> by default) has the estimated network in parenthetical format, but we can also print it directly to the screen:</p><pre><code class="language-julia-repl">julia&gt; net1
HybridNetwork, Rooted Network
12 edges
12 nodes: 6 tips, 1 hybrid nodes, 5 internal tree nodes.
tip labels: C, D, O, E, ...
(C,D,((O,(E,#H7:::0.196):0.314):0.664,(B,(A)#H7:::0.804):10.0):10.0);

julia&gt; writeTopology(net1)  # writes to screen, full precision for branch lengths and γ
&quot;(C,D,((O,(E,#H7:::0.19558838614943078):0.31352437658618976):0.6640664399202987,(B,(A)#H7:::0.8044116138505693):10.0):10.0);&quot;

julia&gt; writeTopology(net1, round=true, digits=2)
&quot;(C,D,((O,(E,#H7:::0.2):0.31):0.66,(B,(A)#H7:::0.8):10.0):10.0);&quot;

julia&gt; writeTopology(net1,di=true) # γ omitted: for dendroscope
&quot;(C,D,((O,(E,#H7):0.31352437658618976):0.6640664399202987,(B,(A)#H7):10.0):10.0);&quot;

julia&gt; writeTopology(net1, &quot;bestnet_h1.tre&quot;) # writes to file: creates or overwrites file</code></pre><p>The option <code>di=true</code> is for the parenthetical format used by <a href="http://dendroscope.org/">Dendroscope</a> (without reticulation heritabilities). Copy this parenthetical description and paste it into Dendroscope, or use the plotting function described below.</p><p>We can go on and let the network have up to 2 or 3 hybrid nodes:</p><pre><code class="language-julia">net2 = snaq!(net1,raxmlCF, hmax=2, filename=&quot;net2&quot;, seed=3456)
net3 = snaq!(net0,raxmlCF, hmax=3, filename=&quot;net3&quot;, seed=4567)</code></pre><p>and plot them (they are identical and they both have a single reticulation):</p><pre><code class="language-julia">using RCall                  # to be able to tweak our plot within R
R&quot;layout(matrix(1:2, 1, 2))&quot; # to get 2 plots into a single figure: 1 row, 2 columns
R&quot;par&quot;(mar=[0,0,1,0])        # for smaller margins
plot(net2, :R, showGamma=true);
R&quot;mtext&quot;(&quot;hmax=2&quot;)           # add text annotation: title here
plot(net3, :R, showGamma=true);
R&quot;mtext&quot;(&quot;hmax=3&quot;)</code></pre><p><img src="../../assets/figures/snaqplot_net23.svg" alt="net23"/></p><p>with this screen output for net2 (only 1 hybrid node found):</p><pre><code class="language-none">MaxNet is (C,D,((B,(A)#H7:::0.804411606649347):10.0,(O,(#H7:::0.19558839335065303,E):0.3135243143217013):0.664066456871298):10.0);
with -loglik 28.31506721890957</code></pre><p>and this output for net3 (again, only 1 hybrid found):</p><pre><code class="language-none">MaxNet is (D,C,((O,(E,#H7:::0.19558839257941849):0.3135243301652981):0.6640664138384673,(B,(A)#H7:::0.8044116074205815):10.0):10.0);
with -loglik 28.315067218909626</code></pre><h2 id="parallel-computations"><a class="docs-heading-anchor" href="#parallel-computations">parallel computations</a><a id="parallel-computations-1"></a><a class="docs-heading-anchor-permalink" href="#parallel-computations" title="Permalink"></a></h2><p>For network estimation, multiple runs can done in parallel. For example, if your machine has 4 or more processors (or cores), you can tell julia to use 4 processors by starting julia with <code>julia -p 4</code>, or by starting julia the usual way (<code>julia</code>) and then adding processors with:</p><pre><code class="language-julia">using Distributed
addprocs(4)</code></pre><p>If we load a package (<code>using PhyloNetworks</code>) before adding processors, then we need to re-load it again so that all processors have access to it:</p><pre><code class="language-julia">@everywhere using PhyloNetworks</code></pre><p>After that, running any of the <code>snaq!(...)</code> command will use different cores for different runs, as processors become available. Fewer details are printed to the log file when multiple cores are used in parallel.</p><p>When running <code>bootsnaq</code>, the analysis of each bootstrap replicate will use multiple cores to parallelize separate runs of that particular bootstrap replicate. You may parallelize things further by running <code>bootsnaq</code> multiple times (on separate machines for instance), each time for a small subset of bootstrap replicates, and with a different seed each time.</p><p>We may tell julia to add more processors than our machine has, but we will not receive any performance benefits. At any time during the julia session, <code>nworkers()</code> tells us how many worker processors julia has access to.</p><p>Below is an example of how to use a cluster, to run many independent <code>snaq!</code> searches in parallel on a cluster running the <a href="https://slurm.schedmd.com">slurm</a> job manager (other managers would require a different, but similar submit file). This example uses 2 files:</p><ol><li>a julia script file, to do many runs of <code>snaq!</code> in parallel, asking for many cores (default: 10 runs, asking for 10 cores). This julia script can take arguments: the maximum allowed number of hybridizations <code>hmax</code>, and the number of runs (to run 50 runs instead of 10, say).</li><li>a submit file, to launch the julia script.</li></ol><p><strong>First</strong>: the example julia script, below, is assumed (by the submit file) to be called <code>runSNaQ.jl</code>. It uses a starting tree that is assumed to be available in a file named <code>astraltree.tre</code>, but that could be modified (to use a network with h=1 to start the search with hmax=2 for instance). It also assumes that the quartet concordance factor data are in file <code>tableCF_speciesNames.csv</code>. Again, this file name should be adjusted. To run this julia script for 50 runs and hmax=3, do <code>julia runSNaQ.jl 3 50</code>.</p><pre><code class="language-julia">#!/usr/bin/env julia

# file &quot;runSNaQ.jl&quot;. run in the shell like this in general:
# julia runSNaQ.jl hvalue nruns
# example for h=2 and default 10 runs:
# julia runSNaQ.jl 2
# or example for h=3 and 50 runs:
# julia runSNaQ.jl 3 50

length(ARGS) &gt; 0 ||
    error(&quot;need 1 or 2 arguments: # reticulations (h) and # runs (optional, 10 by default)&quot;)
h = parse(Int, ARGS[1])
nruns = 10
if length(ARGS) &gt; 1
    nruns = parse(Int, ARGS[2])
end
outputfile = string(&quot;net&quot;, h, &quot;_&quot;, nruns, &quot;runs&quot;) # example: &quot;net2_10runs&quot;
seed = 1234 + h # change as desired! Best to have it different for different h
@info &quot;will run SNaQ with h=$h, # of runs=$nruns, seed=$seed, output will go to: $outputfile&quot;

using Distributed
addprocs(nruns)
@everywhere using PhyloNetworks
net0 = readTopology(&quot;astraltree.tre&quot;);
using DataFrames, CSV
df_sp = DataFrame!(CSV.File(&quot;tableCF_speciesNames.csv&quot;, pool=false));
d_sp = readTableCF!(df_sp);
net = snaq!(net0, d_sp, hmax=h, filename=outputfile, seed=seed, runs=nruns)</code></pre><p>When julia is called on a script, whatever comes after &quot;julia scriptname&quot; is given to julia in an array of values. This array is called <code>ARGS</code>. So if we call a script like this: <code>julia runSNaQ.jl 2</code> then the script will know the arguments through <code>ARGS</code>, which would contain a single element, <code>&quot;2&quot;</code>. This first element is just a string, at this stage. We want to use it as a number, so we ask julia to parse the string into an integer.</p><p><strong>Second</strong>: we need a &quot;submit&quot; file to ask a job scheduler like <a href="https://slurm.schedmd.com">slurm</a> to submit our julia script to a cluster. In the submit file below, the first 5 lines set things up for slurm. They are most likely to be specific to your cluster. The main idea here is to use a slurm &quot;array&quot; from 0 to 3, to run our julia script multiple times, 4 times actually: from hmax=0 to hmax=3. Each would do 30 runs (and each would be allocated 30 cores in the submit script below). Then log out of the cluster and go for coffee.</p><pre><code class="language-bash">#!/bin/bash
#SBATCH -o path/to/slurm/log/file/runsnaq_slurm%a.log
#SBATCH -J runsnaq
#SBATCH --array=0-3
#SBATCH -c 30
## --array: to run multiple instances of this script,
##          one for each value in the array.
##          1 instance = 1 task
## -J job name
## -c number of cores (CPUs) per task

echo &quot;slurm task ID = $SLURM_ARRAY_TASK_ID used as hmax&quot;
echo &quot;start of SNaQ parallel runs on $(hostname)&quot;
# finally: launch the julia script, using Julia executable appropriate for slurm, with full paths:
/workspace/software/bin/julia --history-file=no -- runSNaQ.jl $SLURM_ARRAY_TASK_ID 30 &gt; net$SLURM_ARRAY_TASK_ID_30runs.screenlog 2&gt;&amp;1
echo &quot;end of SNaQ run ...&quot;</code></pre><h2 id="choosing-the-number-of-hybridizations"><a class="docs-heading-anchor" href="#choosing-the-number-of-hybridizations">choosing the number of hybridizations</a><a id="choosing-the-number-of-hybridizations-1"></a><a class="docs-heading-anchor-permalink" href="#choosing-the-number-of-hybridizations" title="Permalink"></a></h2><p>Each network has a <code>loglik</code> attribute, which is its pseudo deviance: a multiple of the negative log-likelihood up to a constant (the constant is such that the score is 0 if the network fits the data perfectly). The lower the better. We can plot these scores across hybrid values:</p><pre><code class="language-julia">scores = [net0.loglik, net1.loglik, net2.loglik, net3.loglik]
R&quot;plot&quot;(scores, type=&quot;b&quot;, ylab=&quot;network score&quot;, xlab=&quot;hmax&quot;, col=&quot;blue&quot;);</code></pre><p><img src="../../assets/figures/snaqplot_scores_heuristic.svg" alt="scores_heuristic"/></p><p>Here the slope heuristic suggests a single hybrid node: the score does not get much better beyond h=1.</p><p>We made the plot via R above. A more Julian way would use a Julia plotting package such as <a href="http://gadflyjl.org/stable/">Gadfly</a> or <a href="http://docs.juliaplots.org/latest/ecosystem/">Plots</a>, like this for instance:</p><pre><code class="language-julia">using Gadfly
plot(x=collect(0:3), y=scores, Geom.point, Geom.line)</code></pre><p>(btw, cool <a href="http://avt.im/blog/2018/03/23/R-packages-ggplot-in-julia">blog</a> about using ggplot within julia)</p><h2 id="Network-Visualization"><a class="docs-heading-anchor" href="#Network-Visualization">Network Visualization</a><a id="Network-Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Visualization" title="Permalink"></a></h2><p>To visualize the estimated network, we can use the companion package <a href="https://github.com/cecileane/PhyloPlots.jl">PhyloPlots</a>. In the example below, julia creates and sends the plot to R via <a href="https://github.com/JuliaInterop/RCall.jl">RCall</a>, so we can tweak the plot in various ways via commands sent to R. To save the plot in a file: we first tell R to create an image file, then we send the plot of the network, then we tell R to wrap up and save its image file.</p><pre><code class="language-julia">using PhyloPlots # to visualize networks
using RCall      # to send additional commands to R like this: R&quot;...&quot;
R&quot;name = function(x) file.path(&#39;..&#39;, &#39;assets&#39;, &#39;figures&#39;, x)&quot; # function to create file name in appropriate folder
R&quot;svg(name(&#39;snaqplot_net1_2.svg&#39;), width=4, height=3)&quot; # starts image file
R&quot;par&quot;(mar=[0,0,0,0]) # to reduce margins (no margins at all here)
plot(net1, :R, showGamma=true, showEdgeNumber=true); # network is plotted &amp; sent to file
R&quot;dev.off()&quot;; # wrap up and save image file</code></pre><p><img src="../../assets/figures/snaqplot_net1_2.svg" alt="net1_2"/></p><p>The plot function has many options, to annotate nodes and edges. In the example above, hybrid edges were annotated with their γ inheritance values (in blue: light blue for the minor edge with γ&lt;0.5, and dark blue for the major edge with γ&gt;0.5), and edges were annotated with their internal numbers.</p><p>Type <code>?</code> to switch to the help mode of Julia, then type the name of the function, here <code>plot</code>. Edge colors can be modified, for instance.</p><pre><code class="language-julia">plot(net1, :R, showEdgeLength=true, minorHybridEdgeColor=&quot;tan&quot;)</code></pre><p><img src="../../assets/figures/snaqplot_net1_3.svg" alt="net1_3"/></p><p>(for a Gadfly-based plot, do <code>using Colors</code> and change the color option to <code>minorHybridEdgeColor=colorant&quot;tan&quot;</code>)</p><p>Edge lengths are shown, too. They were estimated in coalescent units: number of generations / effective population size. Some edge lengths are not identifiable, hence not shown.</p><p>Below is another example, where space was added between the network and the taxon names via the <code>tipOffset</code> option. Also, edge colors were changed, and the nodes numbers are shown (used internally)</p><pre><code class="language-julia">plot(net1,:R, tipOffset=0.5, showNodeNumber=true, edgeColor=&quot;tomato4&quot;,
     minorHybridEdgeColor=&quot;skyblue&quot;, majorHybridEdgeColor=&quot;tan&quot;);</code></pre><p><img src="../../assets/figures/snaqplot_net1_4.svg" alt="net1_4"/></p><p>Without the <code>:R</code> argument, a Gadly-based plot will be produced: would open a browser where the plot will appear (unless you use <a href="http://junolab.org">Juno</a>, which would capture and display the plot). To get a pdf version for instance (see <a href="http://gadflyjl.org/">Gadfly tutorial</a> for other formats) <code>using Gadfly; p=pdf(...); draw(PDF(&quot;bestnet_h1.pdf&quot;, 4inch, 4inch),p)</code>.</p><h2 id="Re-rooting-networks"><a class="docs-heading-anchor" href="#Re-rooting-networks">Re-rooting networks</a><a id="Re-rooting-networks-1"></a><a class="docs-heading-anchor-permalink" href="#Re-rooting-networks" title="Permalink"></a></h2><p>SNaQ infers an unrooted semi-directed network. The direction of hybrid edges can be inferred, but the direction of tree edges cannot be inferred. To obtain a representative visualization, it is best to root the network first, using one or more outgroup. Go to <a href="../dist_reroot/#Re-rooting-trees-and-networks">Re-rooting trees and networks</a> for this. If your outgroup conflicts with the direction of reticulations in the estimated network, see section <a href="../fixednetworkoptim/#Candidate-networks-compatible-with-a-known-outgroup">Candidate networks compatible with a known outgroup</a>.</p><h2 id="Candidate-Network-Evaluation"><a class="docs-heading-anchor" href="#Candidate-Network-Evaluation">Candidate Network Evaluation</a><a id="Candidate-Network-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Candidate-Network-Evaluation" title="Permalink"></a></h2><p>From a set of candidate networks, one might simply need to score of each network to pick the best. Here, the score is the negative log pseudo-likelihood, and the lower the better. See the section to get the score of <a href="../fixednetworkoptim/#Candidate-Networks">Candidate Networks</a>.</p><h2 id="SNaQ-error-reporting"><a class="docs-heading-anchor" href="#SNaQ-error-reporting">SNaQ error reporting</a><a id="SNaQ-error-reporting-1"></a><a class="docs-heading-anchor-permalink" href="#SNaQ-error-reporting" title="Permalink"></a></h2><p>Please report any bugs and errors by opening an <a href="https://github.com/crsl4/PhyloNetworks.jl/issues/new">issue</a>. The easiest way to provide information on the error is by checking the <code>.err</code> file, which will show the number of runs that failed and the corresponding seed to replicate the run. In case of an error, the <code>.err</code> file might look like: <code>Total errors: 1 in seeds [4545]</code>. This file and any information that will help replicating the error will be immensely helpful to fix the error/bug.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ticr_howtogetQuartetCFs/">« TICR pipeline</a><a class="docs-footer-nextpage" href="../dist_reroot/">Network comparison and manipulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 10 November 2020 17:03">Tuesday 10 November 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
