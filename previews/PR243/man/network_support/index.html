<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Network support · PhyloNetworks.jl</title><meta name="title" content="Network support · PhyloNetworks.jl"/><meta property="og:title" content="Network support · PhyloNetworks.jl"/><meta property="twitter:title" content="Network support · PhyloNetworks.jl"/><meta name="description" content="Documentation for PhyloNetworks.jl."/><meta property="og:description" content="Documentation for PhyloNetworks.jl."/><meta property="twitter:description" content="Documentation for PhyloNetworks.jl."/><meta property="og:url" content="https://juliaphylo.github.io/PhyloNetworks.jl/stable/man/network_support/"/><meta property="twitter:url" content="https://juliaphylo.github.io/PhyloNetworks.jl/stable/man/network_support/"/><link rel="canonical" href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/man/network_support/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="PhyloNetworks.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="PhyloNetworks.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PhyloNetworks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../netmanipulation/">Network manipulation</a></li><li><a class="tocitem" href="../net_plot/">Network visualization</a></li><li><a class="tocitem" href="../dist_reroot/">Network comparison and manipulation</a></li><li class="is-active"><a class="tocitem" href>Network support</a><ul class="internal"><li><a class="tocitem" href="#support-for-tree-edges"><span>support for tree edges</span></a></li><li><a class="tocitem" href="#support-for-hybrid-edges"><span>support for hybrid edges</span></a></li><li><a class="tocitem" href="#support-for-hybrid-clades"><span>support for hybrid clades</span></a></li><li><a class="tocitem" href="#support-for-the-origin-of-gene-flow"><span>support for the origin of gene flow</span></a></li><li><a class="tocitem" href="#summarizing-heritabilities-in-a-network-sample"><span>summarizing heritabilities in a network sample</span></a></li></ul></li><li><a class="tocitem" href="../parsimony/">Parsimony on networks</a></li><li><a class="tocitem" href="../nj/">Neighbour Joining</a></li><li><a class="tocitem" href="../expecteddata/">Pairwise and quartet data</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Network support</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Network support</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/PhyloNetworks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/master/docs/src/man/network_support.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Network-support"><a class="docs-heading-anchor" href="#Network-support">Network support</a><a id="Network-support-1"></a><a class="docs-heading-anchor-permalink" href="#Network-support" title="Permalink"></a></h1><p>We show here how to summarize a sample of networks. This may be used to get bootstrap support or posterior probabilities for network features, if the sample of networks comes from a bootstrap analysis (as possible with <a href="https://juliaphylo.github.io/SNaQ.jl/stable/man/bootstrap/#Bootstrap">SNaQ</a>) or if it&#39;s a posterior sample of networks from a Bayesian analysis.</p><p>To demonstrate summarizing a sample of networks, we use here a sample of 100 networks, obtained by running 100 bootstrap replicates of SNaQ. The file containing the 100 networks comes with the package:</p><pre><code class="language-julia hljs">bootnet = readmultinewick(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;,&quot;examples&quot;,&quot;bootsnaq.out&quot;));
length(bootnet)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100</code></pre><p>We seek to summarize what these 100 networks have in common (highly supported features) and what they don&#39;t (areas of uncertainty). Unlike for trees, there are a variety of features that we may summarize in a network. Below we show how to calculate support for <em>tree edges</em>, for a clade to be of <em>hybrid origin</em>, or for a clade to be <em>sister</em> to a hybrid clade, or combinations.</p><p>We also assume that we have a reference network, such as the best-fitting network on the original (non-bootstrapped) data, or some other &quot;consensus&quot; network. We focus on features (tree edges and clades) in this reference network and quantify the support for these features in the sample of networks.</p><h2 id="support-for-tree-edges"><a class="docs-heading-anchor" href="#support-for-tree-edges">support for tree edges</a><a id="support-for-tree-edges-1"></a><a class="docs-heading-anchor-permalink" href="#support-for-tree-edges" title="Permalink"></a></h2><p>To summarize our sample of 100 networks on our reference network, it is best to re-read this network to get a reproducible internal numbering of its nodes and edges, used later for mapping support to edges. As our reference network, we use here a network with 1 reticulation (best-fitting network on the original data):</p><pre><code class="language-julia hljs">net1 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;,&quot;examples&quot;,&quot;net1.out&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HybridNetwork, Rooted Network
12 edges
12 nodes: 6 tips, 1 hybrid nodes, 5 internal tree nodes.
tip labels: C, D, O, E, ...
(C,D,((O,(E,#H7:::0.196):0.314):0.664,(B,(A)#H7:::0.804):10.0):10.0);
</code></pre><p>It turns out that the direction of gene flow is quite uncertain in this example (see below) with a wrong direction inferred sometimes, so we re-root our reference network <code>net1</code> to the base of O,E, for the figures to be less confusing later.</p><pre><code class="language-julia hljs">using PhyloPlots, RCall
plot(net1, showedgenumber=true); # edge 7 leads to O+E
rootonedge!(net1, 7) # makes (O,E) outgroup clade
plot(net1, shownodenumber=true);</code></pre><p><img src="../../assets/figures/net1_rotate1_1.svg" alt="net1_rotate1 1"/> <img src="../../assets/figures/net1_rotate1_2.svg" alt="net1_rotate1 2"/></p><p>Edges cross: but rotating at node -6 should remove this crossing of edges</p><pre><code class="language-julia hljs">rotate!(net1, -6)</code></pre><pre><code class="language-julia hljs">plot(net1, showgamma=true);</code></pre><p><img src="../../assets/figures/net1_rotate2.svg" alt="net1_rotate2"/></p><p>We can now summarize our sample of networks. The functions <code>treeedges_support</code> and <code>hybridclades_support</code> read all networks in the sample and map the edges / nodes onto a reference network, here <code>net1</code>.</p><pre><code class="language-julia hljs">BSe_tree, tree1 = treeedges_support(bootnet,net1);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(<span class="sgr1">3×2 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> edgeNumber  proportion </span>
<span class="sgr1">     </span>│<span class="sgr90"> Int64       Float64    </span>
─────┼────────────────────────
   1 │         13       100.0
   2 │         11       100.0
   3 │         12       100.0, HybridNetwork, Rooted Network
10 edges
11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.
tip labels: C, D, O, E, ...
((O,E):0.166,((B,A):10.0,(C,D):10.0):0.498);
)</code></pre><p>This calculates the major tree <code>tree1</code> displayed in <code>net1</code>, that is, the tree obtained by following the major parent (γ&gt;0.5) of each hybrid node. This tree can be visualized like this, with edge numbers shown for later use.</p><pre><code class="language-julia hljs">plot(tree1, showedgenumber=true);</code></pre><p><img src="../../assets/figures/major_tree.svg" alt="major_tree"/></p><p>Next, we can look at the support table <code>BSe_tree</code>, which has one row for each tree edge in <code>net1</code>. One column contains the edge number (same as shown in the plot) and another column contains the edge (bootstrap) support: the proportion of sample networks in which this edge was found in the major tree of that network. We can see the full support table and see which tree edges have support lower than 100% (none here) with</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using DataFrames # for showall() below</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(BSe_tree, allrows=true, allcols=true)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">3×2 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> edgeNumber  proportion </span>
<span class="sgr1">     </span>│<span class="sgr90"> Int64       Float64    </span>
─────┼────────────────────────
   1 │         13       100.0
   2 │         11       100.0
   3 │         12       100.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; filter(row -&gt; row[:proportion] &lt; 100, BSe_tree)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">0×2 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> edgeNumber  proportion </span>
<span class="sgr1">     </span>│<span class="sgr90"> Int64       Float64    </span>
─────┴────────────────────────</code></pre><p>Finally, we can map the support values onto the reference network or its main tree by passing the support table to the <code>edgelabel</code> option of <code>plot</code>:</p><pre><code class="language-julia hljs">plot(tree1, edgelabel=BSe_tree);
plot(net1, edgelabel=BSe_tree);</code></pre><p><img src="../../assets/figures/boot_tree_net_1.svg" alt="boot_tree_net 1"/> <img src="../../assets/figures/boot_tree_net_2.svg" alt="boot_tree_net 2"/></p><p>(Here, it is important that the numbers assigned to edges when building the boostrap table –those in <code>net1</code> at the time– correspond to the current edge numbers in <code>tree1</code> and <code>net1</code>. That was the purpose of reading the network from the output file of <code>snaq!</code> earlier, for consistency across different Julia sessions.)</p><p>If we wanted to plot only certain support values, like those below 100% (1.0), we could do this:</p><pre><code class="language-julia hljs">plot(net1, edgelabel=filter(row -&gt; row[:proportion] &lt; 100, BSe_tree));</code></pre><h2 id="support-for-hybrid-edges"><a class="docs-heading-anchor" href="#support-for-hybrid-edges">support for hybrid edges</a><a id="support-for-hybrid-edges-1"></a><a class="docs-heading-anchor-permalink" href="#support-for-hybrid-edges" title="Permalink"></a></h2><p>Summarizing the placement of reticulations is not standard. The function <code>hybridclades_support</code> attempts to do so.</p><ul><li>The descendants of a given hybrid node form the &quot;recipient&quot; or <strong>&quot;hybrid&quot; clade</strong>, and is obtained <em>after removing all other reticulations</em>.</li><li>To remove the reticulations other than one of interest, their minor hybrid parent edge (with γ&lt;0.5) is removed. If a reticulation is due to introgression, this minor edge may be interpreted as the &quot;gene flow&quot; edge.</li><li>The descendants of the lineage from which gene flow originated is then a second &quot;sister&quot; of the hybrid clade.   Because of the reticulation event, the hybrid clade has 2 <strong>sister clades</strong>, not 1: the major sister (through the major hybrid edge with γ&gt;0.5) and the minor sister (through the minor hybrid edge with γ&lt;0.5).</li></ul><p>Note that the network says <em>nothing</em> about the process: its shows the <em>relationships</em> only. We can calculate the frequency that each clade is a hybrid clade, or a major or minor sister for some other hybrid, in the sample of networks:</p><pre><code class="language-julia hljs">BSn, BSe, BSc, BSgam, BSedgenum = hybridclades_support(bootnet, net1);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(<span class="sgr1">7×9 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> clade     node    hybridnode  edge    BS_hybrid  BS_sister  BS_major_sister  BS_m</span> ⋯
<span class="sgr1">     </span>│<span class="sgr90"> String    Int64?  Int64?      Int64?  Float64    Float64    Float64          Floa</span> ⋯
─────┼────────────────────────────────────────────────────────────────────────────────────
   1 │ H7             7           5       9       33.0       51.0              2.0       ⋯
   2 │ c_minus2      -2          -2      12        0.0       55.0             53.0
   3 │ E              4           4       4       12.0       41.0              0.0
   4 │ c_minus4      -4          -4       7       44.0        0.0              0.0
   5 │ B              6           6       8        2.0       33.0             33.0       ⋯
   6 │ c_minus6      -6          -6      11        9.0        7.0              0.0
   7 │ O              3           3       3        0.0       13.0             12.0
<span class="sgr36">                                                                         2 columns omitted</span>, <span class="sgr1">12×8 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> edge     hybrid_clade  hybrid  sister_clade  sister  BS_hybrid_edge  BS_major  BS</span> ⋯
<span class="sgr1">     </span>│<span class="sgr90"> Int64?   String        Int64?  String        Int64?  Float64         Float64   Fl</span> ⋯
─────┼────────────────────────────────────────────────────────────────────────────────────
   1 │      10  H7                 5  B                  6            33.0      33.0     ⋯
   2 │       5  H7                 5  E                  4            32.0       0.0
   3 │<span class="sgr90"> missing </span> c_minus4          -4  c_minus2          -2            44.0      44.0
   4 │<span class="sgr90"> missing </span> c_minus4          -4  H7                 7            44.0       0.0
   5 │<span class="sgr90"> missing </span> E                  4  O                  3            12.0      12.0     ⋯
   6 │<span class="sgr90"> missing </span> c_minus6          -6  c_minus2          -2             9.0       9.0
   7 │<span class="sgr90"> missing </span> c_minus6          -6  E                  4             9.0       0.0
   8 │<span class="sgr90"> missing </span> E                  4  c_minus6          -6             7.0       0.0
   9 │<span class="sgr90"> missing </span> E                  4  H7                 7             5.0       0.0     ⋯
  10 │<span class="sgr90"> missing </span> B                  6  H7                 7             2.0       2.0
  11 │<span class="sgr90"> missing </span> B                  6  c_minus2          -2             2.0       0.0
  12 │<span class="sgr90"> missing </span> H7                 5  O                  3             1.0       0.0
<span class="sgr36">                                                                          1 column omitted</span>, <span class="sgr1">6×8 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> taxa    O      E      c_minus4  B      H7     c_minus6  c_minus2 </span>
<span class="sgr1">     </span>│<span class="sgr90"> String  Bool   Bool   Bool      Bool   Bool   Bool      Bool     </span>
─────┼──────────────────────────────────────────────────────────────────
   1 │ C       false  false     false  false  false     false      true
   2 │ D       false  false     false  false  false     false      true
   3 │ O        true  false      true  false  false     false     false
   4 │ E       false   true      true  false  false     false     false
   5 │ B       false  false     false   true  false      true     false
   6 │ A       false  false     false  false   true      true     false, [0.7678332804427751 0.2321667195572249; 0.0 0.0; … ; 0.8302741620426417 0.16972583795735827; 0.8140813408679294 0.18591865913207065], [10, 5])</code></pre><p>Let&#39;s look at the results. We can list all the clades and the percentage of sample networks (support) in which each clade is a hybrid or sister to a hybrid:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BSn</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">7×9 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> clade     node    hybridnode  edge    BS_hybrid  BS_sister  BS_major_sister  BS_m</span> ⋯
<span class="sgr1">     </span>│<span class="sgr90"> String    Int64?  Int64?      Int64?  Float64    Float64    Float64          Floa</span> ⋯
─────┼────────────────────────────────────────────────────────────────────────────────────
   1 │ H7             7           5       9       33.0       51.0              2.0       ⋯
   2 │ c_minus2      -2          -2      12        0.0       55.0             53.0
   3 │ E              4           4       4       12.0       41.0              0.0
   4 │ c_minus4      -4          -4       7       44.0        0.0              0.0
   5 │ B              6           6       8        2.0       33.0             33.0       ⋯
   6 │ c_minus6      -6          -6      11        9.0        7.0              0.0
   7 │ O              3           3       3        0.0       13.0             12.0
<span class="sgr36">                                                                         2 columns omitted</span></code></pre><p>If a clade contains a single taxon, it is listed with its taxon name. The clade found in the best network is listed with its tag, starting with H (e.g. &quot;H7&quot;). The name of other clades start with &quot;c_&quot; followed by their number in the best network, if they do appear in the best network. The node numbers, as used internally in the best network, are listed in a separate column. They can be used later to display the support values onto the network. Various columns give the support that each clade is a hybrid, or a (major/minor) sister to a hybrid. The last column gives the support for the full relationship in the best network: same hybrid with same two sisters. These support values are associated with nodes (or possibly, their parent edges).</p><p>To see what is the clade named &quot;H7&quot;, for instance:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BSc # this might be too big</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">6×8 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> taxa    O      E      c_minus4  B      H7     c_minus6  c_minus2 </span>
<span class="sgr1">     </span>│<span class="sgr90"> String  Bool   Bool   Bool      Bool   Bool   Bool      Bool     </span>
─────┼──────────────────────────────────────────────────────────────────
   1 │ C       false  false     false  false  false     false      true
   2 │ D       false  false     false  false  false     false      true
   3 │ O        true  false      true  false  false     false     false
   4 │ E       false   true      true  false  false     false     false
   5 │ B       false  false     false   true  false      true     false
   6 │ A       false  false     false  false   true      true     false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(BSc, allrows=true, allcols=true)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">6×8 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> taxa    O      E      c_minus4  B      H7     c_minus6  c_minus2 </span>
<span class="sgr1">     </span>│<span class="sgr90"> String  Bool   Bool   Bool      Bool   Bool   Bool      Bool     </span>
─────┼──────────────────────────────────────────────────────────────────
   1 │ C       false  false     false  false  false     false      true
   2 │ D       false  false     false  false  false     false      true
   3 │ O        true  false      true  false  false     false     false
   4 │ E       false   true      true  false  false     false     false
   5 │ B       false  false     false   true  false      true     false
   6 │ A       false  false     false  false   true      true     false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # BSc[BSc[!,:H7], :taxa] # just a different syntax to subset the data in the same way
       filter(row -&gt; row[:H7], BSc).taxa</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{String}:
 &quot;A&quot;</code></pre><p>We can also get support values associated with edges, to describe the support that a given hybrid clade has a given sister clade.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BSe</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">12×8 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> edge     hybrid_clade  hybrid  sister_clade  sister  BS_hybrid_edge  BS_major  BS</span> ⋯
<span class="sgr1">     </span>│<span class="sgr90"> Int64?   String        Int64?  String        Int64?  Float64         Float64   Fl</span> ⋯
─────┼────────────────────────────────────────────────────────────────────────────────────
   1 │      10  H7                 5  B                  6            33.0      33.0     ⋯
   2 │       5  H7                 5  E                  4            32.0       0.0
   3 │<span class="sgr90"> missing </span> c_minus4          -4  c_minus2          -2            44.0      44.0
   4 │<span class="sgr90"> missing </span> c_minus4          -4  H7                 7            44.0       0.0
   5 │<span class="sgr90"> missing </span> E                  4  O                  3            12.0      12.0     ⋯
   6 │<span class="sgr90"> missing </span> c_minus6          -6  c_minus2          -2             9.0       9.0
   7 │<span class="sgr90"> missing </span> c_minus6          -6  E                  4             9.0       0.0
   8 │<span class="sgr90"> missing </span> E                  4  c_minus6          -6             7.0       0.0
   9 │<span class="sgr90"> missing </span> E                  4  H7                 7             5.0       0.0     ⋯
  10 │<span class="sgr90"> missing </span> B                  6  H7                 7             2.0       2.0
  11 │<span class="sgr90"> missing </span> B                  6  c_minus2          -2             2.0       0.0
  12 │<span class="sgr90"> missing </span> H7                 5  O                  3             1.0       0.0
<span class="sgr36">                                                                          1 column omitted</span></code></pre><p>Here, each row describes a pair of 2 clades: one being the hybrid, the other being its sister, connected by a hybrid edge. The first rows corresponds to hybrid edges in the best network. Other rows correspond to edges seen in the sample of networks but not in the reference network.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BSedgenum</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 10
  5</code></pre><p>lists all the hybrid edges in the best network, two for each hybrid node: the major parent edge and then the minor parent edge. In our case, there is only one reticulation, so only 2 hybrid edges.</p><p>We can plot the support values of the 2 hybrid edges in the best network:</p><pre><code class="language-julia hljs">plot(net1, edgelabel=BSe[:,[:edge,:BS_hybrid_edge]]);</code></pre><p><img src="../../assets/figures/boot_net_net.svg" alt="boot_net_net"/></p><p>This is showing the support for each hybrid edge: the percentage of networks in the sample, with an edge from the same sister clade to the same hybrid clade. Alternatively, we could show the support for the full reticulation relationships in the network, one at each hybrid node (support for same hybrid with same sister clades). Here, we find that A received gene flow from E (and is sister to B otherwise) in just 32% of sampled networks. In another 1% of sampled networks, A received gene flow from another source.</p><pre><code class="language-julia hljs">plot(net1, nodelabel=BSn[!,[:hybridnode,:BS_hybrid_samesisters]]);</code></pre><p><img src="../../assets/figures/boot_net_ret.svg" alt="boot_net_ret"/></p><p>Below is example code to place tree edge support and hybrid edge support on the same plot.</p><pre><code class="language-julia hljs">tmp = filter(row -&gt; !ismissing(row[:edge]), BSe) # filter rows
select!(tmp, [:edge,:BS_hybrid_edge])            # select 2 columns only
rename!(tmp, :BS_hybrid_edge =&gt; :proportion)     # rename those columns, to match names in BSe_tree
rename!(tmp, :edge =&gt; :edgeNumber)
tmp = vcat(BSe_tree, tmp)
plot(net1, edgelabel=tmp, nodelabel=BSn[:, [:hybridnode,:BS_hybrid_samesisters]])</code></pre><h2 id="support-for-hybrid-clades"><a class="docs-heading-anchor" href="#support-for-hybrid-clades">support for hybrid clades</a><a id="support-for-hybrid-clades-1"></a><a class="docs-heading-anchor-permalink" href="#support-for-hybrid-clades" title="Permalink"></a></h2><p>On a different plot, we can show the support for hybrid clades, first mapped to each node with positive hybrid support, and then mapped on the parent edge of these nodes. A is estimated as a hybrid in only 33% of our sampled networks. In another 44%, it is the lineage to (E,O) that is estimated as being of hybrid origin.</p><pre><code class="language-julia hljs">plot(net1, nodelabel=filter(row-&gt;row[:BS_hybrid]&gt;0, BSn)[!,[:hybridnode,:BS_hybrid]]);
plot(net1, edgelabel=filter(row-&gt;row[:BS_hybrid]&gt;0, BSn)[!,[:edge,:BS_hybrid]]);</code></pre><p><img src="../../assets/figures/boot_net_hyb_1.svg" alt="boot_net_hyb 1"/> <img src="../../assets/figures/boot_net_hyb_2.svg" alt="boot_net_hyb 2"/></p><h2 id="support-for-the-origin-of-gene-flow"><a class="docs-heading-anchor" href="#support-for-the-origin-of-gene-flow">support for the origin of gene flow</a><a id="support-for-the-origin-of-gene-flow-1"></a><a class="docs-heading-anchor-permalink" href="#support-for-the-origin-of-gene-flow" title="Permalink"></a></h2><p>We can plot the support for the various placements of the gene flow origin (minor sister clade), first mapped to each node with positive support for being the origin of gene flow, and then mapped along the parent edge of these nodes. We filtered clades to show those with sister support &gt; 5%:</p><pre><code class="language-julia hljs">plot(net1, nodelabel=filter(r-&gt;r[:BS_minor_sister]&gt;5, BSn)[!,[:node,:BS_minor_sister]]);
plot(net1, edgelabel=filter(r-&gt;r[:BS_minor_sister]&gt;5, BSn)[!,[:edge,:BS_minor_sister]]);</code></pre><p><img src="../../assets/figures/boot_net_clade_1.svg" alt="boot_net_clade 1"/> <img src="../../assets/figures/boot_net_clade_2.svg" alt="boot_net_clade 2"/></p><p>In our best network, the lineage to E is estimated as the origin of gene flow, but this is recovered in only 41% of our sampled networks. In another 49%, it is the lineage to A that is the <em>origin</em> of gene flow: in these networks, gene flow is in the opposite direction compared to our reference network. In this example, there is support for gene flow between (A,B) and (E,O), but there is much uncertainty about its exact placement and about its direction.</p><p>Mapping the support for major sister clades might be interesting too:</p><pre><code class="language-julia hljs">plot(net1, nodelabel=filter(r-&gt;r[:BS_major_sister]&gt;5, BSn)[!,[:node,:BS_major_sister]])</code></pre><h2 id="summarizing-heritabilities-in-a-network-sample"><a class="docs-heading-anchor" href="#summarizing-heritabilities-in-a-network-sample">summarizing heritabilities in a network sample</a><a id="summarizing-heritabilities-in-a-network-sample-1"></a><a class="docs-heading-anchor-permalink" href="#summarizing-heritabilities-in-a-network-sample" title="Permalink"></a></h2><p>For each hybrid edge in the reference network, when present in a sampled network, its heritability γ in the sampled network was also extracted:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BSgam[1:3,:] # first 3 rows only</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 0.767833  0.232167
 0.0       0.0
 0.804412  0.195588</code></pre><p>γ=0 values are for sampled networks that did not have the edge. Basic summaries on γ values for a given edge, say the minor parent, could be obtained like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; minimum(BSgam[:,2])</code><code class="nohighlight hljs ansi" style="display:block;">0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; maximum(BSgam[:,2])</code><code class="nohighlight hljs ansi" style="display:block;">0.2321667195572249</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Statistics # for functions like mean and std (standard deviation)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mean(BSgam[:,2])</code><code class="nohighlight hljs ansi" style="display:block;">0.062201290198789325</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; std(BSgam[:,2])</code><code class="nohighlight hljs ansi" style="display:block;">0.09131993802196253</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dist_reroot/">« Network comparison and manipulation</a><a class="docs-footer-nextpage" href="../parsimony/">Parsimony on networks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 4 December 2025 15:50">Thursday 4 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
