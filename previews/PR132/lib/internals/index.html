<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · PhyloNetworks.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PhyloNetworks.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PhyloNetworks.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/installation/">Installation</a></li><li><a class="tocitem" href="../../man/inputdata/">Input Data for SNaQ</a></li><li><a class="tocitem" href="../../man/ticr_howtogetQuartetCFs/">TICR pipeline</a></li><li><a class="tocitem" href="../../man/snaq_plot/">Network estimation and display</a></li><li><a class="tocitem" href="../../man/dist_reroot/">Network comparison and manipulation</a></li><li><a class="tocitem" href="../../man/fixednetworkoptim/">Candidate Networks</a></li><li><a class="tocitem" href="../../man/expectedCFs/">Extract Expected CFs</a></li><li><a class="tocitem" href="../../man/bootstrap/">Bootstrap</a></li><li><a class="tocitem" href="../../man/multiplealleles/">Multiple Alleles</a></li><li><a class="tocitem" href="../../man/trait_tree/">Continuous Trait Evolution</a></li><li><a class="tocitem" href="../../man/parsimony/">Parsimony on networks</a></li><li><a class="tocitem" href="../../man/fitDiscrete/">Discrete Trait Evolution</a></li><li><a class="tocitem" href="../../man/nj/">Neighbour Joining</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../public/">Public</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Contents-1"><span>Contents</span></a></li><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li><li><a class="tocitem" href="#types-1"><span>types</span></a></li><li><a class="tocitem" href="#functions-1"><span>functions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/crsl4/PhyloNetworks.jl/blob/master/docs/src/lib/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-Documentation-1"><a class="docs-heading-anchor" href="#Internal-Documentation-1">Internal Documentation</a><a class="docs-heading-anchor-permalink" href="#Internal-Documentation-1" title="Permalink"></a></h1><h2 id="Contents-1"><a class="docs-heading-anchor" href="#Contents-1">Contents</a><a class="docs-heading-anchor-permalink" href="#Contents-1" title="Permalink"></a></h2><ul><li><a href="#Internal-Documentation-1">Internal Documentation</a></li><ul><li><a href="#Contents-1">Contents</a></li><li><a href="#Index-1">Index</a></li><li><a href="#types-1">types</a></li><li><a href="#functions-1">functions</a></li></ul></ul><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#PhyloNetworks.fAbs"><code>PhyloNetworks.fAbs</code></a></li><li><a href="#PhyloNetworks.ANode"><code>PhyloNetworks.ANode</code></a></li><li><a href="#PhyloNetworks.CacheGammaLiNC"><code>PhyloNetworks.CacheGammaLiNC</code></a></li><li><a href="#PhyloNetworks.CacheLengthLiNC"><code>PhyloNetworks.CacheLengthLiNC</code></a></li><li><a href="#PhyloNetworks.CacheLengthLiNC-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,Float64,Float64,Float64,Int64}"><code>PhyloNetworks.CacheLengthLiNC</code></a></li><li><a href="#PhyloNetworks.Edge"><code>PhyloNetworks.Edge</code></a></li><li><a href="#PhyloNetworks.MatrixTopologicalOrder"><code>PhyloNetworks.MatrixTopologicalOrder</code></a></li><li><a href="#PhyloNetworks.Node"><code>PhyloNetworks.Node</code></a></li><li><a href="#PhyloNetworks.NucleicAcidSubstitutionModel"><code>PhyloNetworks.NucleicAcidSubstitutionModel</code></a></li><li><a href="#PhyloNetworks.QuartetNetwork"><code>PhyloNetworks.QuartetNetwork</code></a></li><li><a href="#PhyloNetworks.QuartetT"><code>PhyloNetworks.QuartetT</code></a></li><li><a href="#PhyloNetworks.StatisticalSubstitutionModel"><code>PhyloNetworks.StatisticalSubstitutionModel</code></a></li><li><a href="#PhyloNetworks.SubstitutionModel"><code>PhyloNetworks.SubstitutionModel</code></a></li><li><a href="#PhyloNetworks.TopologyConstraint"><code>PhyloNetworks.TopologyConstraint</code></a></li><li><a href="#PhyloNetworks.TopologyConstraint-Tuple{UInt8,Array{String,1},HybridNetwork}"><code>PhyloNetworks.TopologyConstraint</code></a></li><li><a href="#Base.getindex"><code>Base.getindex</code></a></li><li><a href="#Base.getindex"><code>Base.getindex</code></a></li><li><a href="#PhyloNetworks.P-Tuple{PhyloNetworks.SubstitutionModel,Float64}"><code>PhyloNetworks.P</code></a></li><li><a href="#PhyloNetworks.P!-Tuple{AbstractArray{T,2} where T,PhyloNetworks.SubstitutionModel,Float64}"><code>PhyloNetworks.P!</code></a></li><li><a href="#PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork,DataFrames.DataFrame}"><code>PhyloNetworks.addAlternativeHybridizations!</code></a></li><li><a href="#PhyloNetworks.addhybridedge!"><code>PhyloNetworks.addhybridedge!</code></a></li><li><a href="#PhyloNetworks.addhybridedge!"><code>PhyloNetworks.addhybridedge!</code></a></li><li><a href="#PhyloNetworks.addhybridedgeLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,Bool,Bool,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.addhybridedgeLiNC!</code></a></li><li><a href="#PhyloNetworks.addindividuals!-Tuple{HybridNetwork,AbstractString,Array{String,1}}"><code>PhyloNetworks.addindividuals!</code></a></li><li><a href="#PhyloNetworks.addleaf!"><code>PhyloNetworks.addleaf!</code></a></li><li><a href="#PhyloNetworks.adjacentedges-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.adjacentedges</code></a></li><li><a href="#PhyloNetworks.afterOptBL!-Tuple{HybridNetwork,DataCF,Bool,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.afterOptBL!</code></a></li><li><a href="#PhyloNetworks.afterOptBLAll!-Tuple{HybridNetwork,DataCF,Integer,Bool,Float64,Float64,Bool,Array{Int64,1},Float64,Float64,Float64}"><code>PhyloNetworks.afterOptBLAll!</code></a></li><li><a href="#PhyloNetworks.afterOptBLRepeat!-Tuple{HybridNetwork,DataCF,Integer,Bool,Bool,Bool,Array{Int64,1}}"><code>PhyloNetworks.afterOptBLRepeat!</code></a></li><li><a href="#PhyloNetworks.allowrootbelow!-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.allowrootbelow!</code></a></li><li><a href="#PhyloNetworks.anova-Union{Tuple{Vararg{StatsModels.TableRegressionModel{PhyloNetworkLinearModel,T},N} where N}, Tuple{T}} where T"><code>PhyloNetworks.anova</code></a></li><li><a href="#PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}"><code>PhyloNetworks.assignhybridnames!</code></a></li><li><a href="#PhyloNetworks.blobInfo"><code>PhyloNetworks.blobInfo</code></a></li><li><a href="#PhyloNetworks.breakedge!-Tuple{PhyloNetworks.Edge,HybridNetwork}"><code>PhyloNetworks.breakedge!</code></a></li><li><a href="#PhyloNetworks.calculateObsCFAll!-Tuple{DataCF,Union{Array{Int64,1}, Array{String,1}}}"><code>PhyloNetworks.calculateObsCFAll!</code></a></li><li><a href="#PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}"><code>PhyloNetworks.checkNumHybEdges!</code></a></li><li><a href="#PhyloNetworks.check_matchtaxonnames!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,HybridNetwork}"><code>PhyloNetworks.check_matchtaxonnames!</code></a></li><li><a href="#PhyloNetworks.checknetwork_LiNC!"><code>PhyloNetworks.checknetwork_LiNC!</code></a></li><li><a href="#PhyloNetworks.checkspeciesnetwork!-Tuple{HybridNetwork,Array{PhyloNetworks.TopologyConstraint,1}}"><code>PhyloNetworks.checkspeciesnetwork!</code></a></li><li><a href="#PhyloNetworks.cleantaxonname-Tuple{AbstractString}"><code>PhyloNetworks.cleantaxonname</code></a></li><li><a href="#PhyloNetworks.constraintviolated-Tuple{HybridNetwork,Array{PhyloNetworks.TopologyConstraint,1}}"><code>PhyloNetworks.constraintviolated</code></a></li><li><a href="#PhyloNetworks.defaultsubstitutionmodel"><code>PhyloNetworks.defaultsubstitutionmodel</code></a></li><li><a href="#PhyloNetworks.deleteEdge!-Tuple{HybridNetwork,PhyloNetworks.Edge}"><code>PhyloNetworks.deleteEdge!</code></a></li><li><a href="#PhyloNetworks.deleteLeaf!-Tuple{PhyloNetworks.Network,AbstractString}"><code>PhyloNetworks.deleteLeaf!</code></a></li><li><a href="#PhyloNetworks.deleteNode!-Tuple{HybridNetwork,PhyloNetworks.Node}"><code>PhyloNetworks.deleteNode!</code></a></li><li><a href="#PhyloNetworks.deletehybridedge!"><code>PhyloNetworks.deletehybridedge!</code></a></li><li><a href="#PhyloNetworks.deletehybridedgeLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,Bool,Array{PhyloNetworks.TopologyConstraint,1},PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.deletehybridedgeLiNC!</code></a></li><li><a href="#PhyloNetworks.descendants"><code>PhyloNetworks.descendants</code></a></li><li><a href="#PhyloNetworks.directionalconflict-Tuple{HybridNetwork,PhyloNetworks.Node,PhyloNetworks.Edge,Bool}"><code>PhyloNetworks.directionalconflict</code></a></li><li><a href="#PhyloNetworks.discrete_backwardlikelihood_trait!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer}"><code>PhyloNetworks.discrete_backwardlikelihood_trait!</code></a></li><li><a href="#PhyloNetworks.discrete_corelikelihood!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}"><code>PhyloNetworks.discrete_corelikelihood!</code></a></li><li><a href="#PhyloNetworks.discrete_corelikelihood_trait!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer,Integer}"><code>PhyloNetworks.discrete_corelikelihood_trait!</code></a></li><li><a href="#PhyloNetworks.displayedNetworks!"><code>PhyloNetworks.displayedNetworks!</code></a></li><li><a href="#PhyloNetworks.edgerelation-Tuple{PhyloNetworks.Edge,PhyloNetworks.Node,PhyloNetworks.Edge}"><code>PhyloNetworks.edgerelation</code></a></li><li><a href="#PhyloNetworks.fuseedgesat!"><code>PhyloNetworks.fuseedgesat!</code></a></li><li><a href="#PhyloNetworks.gammaZero!-Tuple{HybridNetwork,DataCF,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.gammaZero!</code></a></li><li><a href="#PhyloNetworks.getChild-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.getChild</code></a></li><li><a href="#PhyloNetworks.getChildEdge-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getChildEdge</code></a></li><li><a href="#PhyloNetworks.getChildren-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getChildren</code></a></li><li><a href="#PhyloNetworks.getDataValue!-Tuple{IO,Int64,Array{Int64,1}}"><code>PhyloNetworks.getDataValue!</code></a></li><li><a href="#PhyloNetworks.getGammas-Tuple{HybridNetwork}"><code>PhyloNetworks.getGammas</code></a></li><li><a href="#PhyloNetworks.getHeights-Tuple{HybridNetwork}"><code>PhyloNetworks.getHeights</code></a></li><li><a href="#PhyloNetworks.getMajorParent-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getMajorParent</code></a></li><li><a href="#PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getMajorParentEdge</code></a></li><li><a href="#PhyloNetworks.getMinorParent"><code>PhyloNetworks.getMinorParent</code></a></li><li><a href="#PhyloNetworks.getMinorParentEdge"><code>PhyloNetworks.getMinorParentEdge</code></a></li><li><a href="#PhyloNetworks.getParent-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.getParent</code></a></li><li><a href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getParents</code></a></li><li><a href="#PhyloNetworks.getPartner-Tuple{Any}"><code>PhyloNetworks.getPartner</code></a></li><li><a href="#PhyloNetworks.getTipSubmatrix-Tuple{Array{T,2} where T,HybridNetwork}"><code>PhyloNetworks.getTipSubmatrix</code></a></li><li><a href="#PhyloNetworks.getlengths-Tuple{Array{PhyloNetworks.Edge,1}}"><code>PhyloNetworks.getlengths</code></a></li><li><a href="#PhyloNetworks.getparameters-Tuple{PhyloNetworks.RVASInv}"><code>PhyloNetworks.getparameters</code></a></li><li><a href="#PhyloNetworks.getparamindex-Tuple{PhyloNetworks.RVASInv}"><code>PhyloNetworks.getparamindex</code></a></li><li><a href="#PhyloNetworks.hardwiredClusterDistance_unrooted-Tuple{HybridNetwork,HybridNetwork}"><code>PhyloNetworks.hardwiredClusterDistance_unrooted</code></a></li><li><a href="#PhyloNetworks.hashybridladder-Tuple{HybridNetwork}"><code>PhyloNetworks.hashybridladder</code></a></li><li><a href="#PhyloNetworks.hybrid3cycle-Tuple{PhyloNetworks.Edge,PhyloNetworks.Edge}"><code>PhyloNetworks.hybrid3cycle</code></a></li><li><a href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.hybridEdges</code></a></li><li><a href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge}"><code>PhyloNetworks.hybridEdges</code></a></li><li><a href="#PhyloNetworks.hybridatnode"><code>PhyloNetworks.hybridatnode</code></a></li><li><a href="#PhyloNetworks.inheritanceWeight-Tuple{HybridNetwork}"><code>PhyloNetworks.inheritanceWeight</code></a></li><li><a href="#PhyloNetworks.initializeWeightsFromLeaves!-Tuple{AbstractArray,HybridNetwork,Any,Any,Symbol}"><code>PhyloNetworks.initializeWeightsFromLeaves!</code></a></li><li><a href="#PhyloNetworks.initializeWeightsFromLeavesSoftwired!-Tuple{AbstractArray,HybridNetwork,Any,Any}"><code>PhyloNetworks.initializeWeightsFromLeavesSoftwired!</code></a></li><li><a href="#PhyloNetworks.isconnected-Tuple{Any,Any}"><code>PhyloNetworks.isconnected</code></a></li><li><a href="#PhyloNetworks.isdescendant-Tuple{PhyloNetworks.Node,PhyloNetworks.Node}"><code>PhyloNetworks.isdescendant</code></a></li><li><a href="#PhyloNetworks.isdescendant_undirected-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,PhyloNetworks.Edge}"><code>PhyloNetworks.isdescendant_undirected</code></a></li><li><a href="#PhyloNetworks.ladderpartition-Tuple{HybridNetwork}"><code>PhyloNetworks.ladderpartition</code></a></li><li><a href="#PhyloNetworks.learnlabels-Tuple{Symbol,DataFrames.AbstractDataFrame}"><code>PhyloNetworks.learnlabels</code></a></li><li><a href="#PhyloNetworks.majoredgelength-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgelength</code></a></li><li><a href="#PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgematrix</code></a></li><li><a href="#PhyloNetworks.makemissing!-Tuple{AbstractArray{T,1} where T}"><code>PhyloNetworks.makemissing!</code></a></li><li><a href="#PhyloNetworks.mapAllelesCFtable!-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Array{Int64,1},Bool,AbstractString}"><code>PhyloNetworks.mapAllelesCFtable!</code></a></li><li><a href="#PhyloNetworks.maxParsimonyNetRun1"><code>PhyloNetworks.maxParsimonyNetRun1</code></a></li><li><a href="#PhyloNetworks.maxParsimonyNetRun1!"><code>PhyloNetworks.maxParsimonyNetRun1!</code></a></li><li><a href="#PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationgamma</code></a></li><li><a href="#PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationlength</code></a></li><li><a href="#PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationmatrix</code></a></li><li><a href="#PhyloNetworks.moveHybrid!-Tuple{HybridNetwork,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.moveHybrid!</code></a></li><li><a href="#PhyloNetworks.moveroot!"><code>PhyloNetworks.moveroot!</code></a></li><li><a href="#PhyloNetworks.nameinternalnodes!-Tuple{HybridNetwork,Any}"><code>PhyloNetworks.nameinternalnodes!</code></a></li><li><a href="#PhyloNetworks.nchoose1234-Tuple{Int64}"><code>PhyloNetworks.nchoose1234</code></a></li><li><a href="#PhyloNetworks.nj!"><code>PhyloNetworks.nj!</code></a></li><li><a href="#PhyloNetworks.nni_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Bool,Bool,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.nni_LiNC!</code></a></li><li><a href="#PhyloNetworks.nnimax-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.nnimax</code></a></li><li><a href="#PhyloNetworks.norootbelow!-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.norootbelow!</code></a></li><li><a href="#PhyloNetworks.optBL!-Tuple{HybridNetwork,DataCF,Bool,Float64,Float64,Float64,Float64}"><code>PhyloNetworks.optBL!</code></a></li><li><a href="#PhyloNetworks.optTopLevel!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},IO,Bool}"><code>PhyloNetworks.optTopLevel!</code></a></li><li><a href="#PhyloNetworks.optTopRun1!-Tuple{HybridNetwork,Any,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,IO,Bool,Float64}"><code>PhyloNetworks.optTopRun1!</code></a></li><li><a href="#PhyloNetworks.optTopRuns!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,AbstractString,AbstractString,Integer,Float64}"><code>PhyloNetworks.optTopRuns!</code></a></li><li><a href="#PhyloNetworks.optimizeallgammas_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,PhyloNetworks.CacheGammaLiNC,Int64}"><code>PhyloNetworks.optimizeallgammas_LiNC!</code></a></li><li><a href="#PhyloNetworks.optimizealllengths_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.optimizealllengths_LiNC!</code></a></li><li><a href="#PhyloNetworks.optimizegamma_LiNC!"><code>PhyloNetworks.optimizegamma_LiNC!</code></a></li><li><a href="#PhyloNetworks.optimizelength_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.Edge,PhyloNetworks.CacheLengthLiNC,Any}"><code>PhyloNetworks.optimizelength_LiNC!</code></a></li><li><a href="#PhyloNetworks.optimizelocalBL_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.Edge,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.optimizelocalBL_LiNC!</code></a></li><li><a href="#PhyloNetworks.optimizelocalgammas_LiNC!"><code>PhyloNetworks.optimizelocalgammas_LiNC!</code></a></li><li><a href="#PhyloNetworks.optimizestructure!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer,Bool,Bool,Integer,Integer,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.optimizestructure!</code></a></li><li><a href="#PhyloNetworks.pairwiseTaxonDistanceGrad-Tuple{HybridNetwork}"><code>PhyloNetworks.pairwiseTaxonDistanceGrad</code></a></li><li><a href="#PhyloNetworks.parseEdgeData!-Tuple{IO,PhyloNetworks.Edge,Array{Int64,1}}"><code>PhyloNetworks.parseEdgeData!</code></a></li><li><a href="#PhyloNetworks.parseHybridNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,String,HybridNetwork,Array{String,1}}"><code>PhyloNetworks.parseHybridNode!</code></a></li><li><a href="#PhyloNetworks.parseRemainingSubtree!-Tuple{IO,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>PhyloNetworks.parseRemainingSubtree!</code></a></li><li><a href="#PhyloNetworks.parseTreeNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.parseTreeNode!</code></a></li><li><a href="#PhyloNetworks.parsimonyBottomUpFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}},Array{Int64,1}}} where T"><code>PhyloNetworks.parsimonyBottomUpFitch!</code></a></li><li><a href="#PhyloNetworks.parsimonyBottomUpGF!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray,AbstractArray,AbstractArray}"><code>PhyloNetworks.parsimonyBottomUpGF!</code></a></li><li><a href="#PhyloNetworks.parsimonyBottomUpSoftwired!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray}"><code>PhyloNetworks.parsimonyBottomUpSoftwired!</code></a></li><li><a href="#PhyloNetworks.parsimonyDiscreteFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{String,T}}} where T"><code>PhyloNetworks.parsimonyDiscreteFitch</code></a></li><li><a href="#PhyloNetworks.parsimonySummaryFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{Int64,Set{T}}}} where T"><code>PhyloNetworks.parsimonySummaryFitch</code></a></li><li><a href="#PhyloNetworks.parsimonyTopDownFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}}}} where T"><code>PhyloNetworks.parsimonyTopDownFitch!</code></a></li><li><a href="#PhyloNetworks.phyLiNCone!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Int64,Bool,Bool,Int64,Int64,Bool,Bool,IO,Int64,Float64,Array{PhyloNetworks.TopologyConstraint,1},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.phyLiNCone!</code></a></li><li><a href="#PhyloNetworks.posterior_logtreeweight"><code>PhyloNetworks.posterior_logtreeweight</code></a></li><li><a href="#PhyloNetworks.problem4cycle-NTuple{4,PhyloNetworks.Node}"><code>PhyloNetworks.problem4cycle</code></a></li><li><a href="#PhyloNetworks.proposedTop!-Tuple{Integer,HybridNetwork,Bool,Integer,Integer,Array{Int64,1},Array{Int64,1},Bool}"><code>PhyloNetworks.proposedTop!</code></a></li><li><a href="#PhyloNetworks.quartetrank-Tuple{AbstractArray{T,1} where T,Array{T,2} where T}"><code>PhyloNetworks.quartetrank</code></a></li><li><a href="#PhyloNetworks.readCSVtoArray-Tuple{DataFrames.DataFrame}"><code>PhyloNetworks.readCSVtoArray</code></a></li><li><a href="#PhyloNetworks.readInputData-Tuple{AbstractString,AbstractString,Symbol,Integer,Bool,AbstractString,Bool,Bool}"><code>PhyloNetworks.readInputData</code></a></li><li><a href="#PhyloNetworks.readSubtree!-Tuple{IO,PhyloNetworks.Node,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>PhyloNetworks.readSubtree!</code></a></li><li><a href="#PhyloNetworks.recursionPostOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Any}"><code>PhyloNetworks.recursionPostOrder</code></a></li><li><a href="#PhyloNetworks.recursionPreOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Function,Any}"><code>PhyloNetworks.recursionPreOrder</code></a></li><li><a href="#PhyloNetworks.recursionPreOrder!"><code>PhyloNetworks.recursionPreOrder!</code></a></li><li><a href="#PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network,PhyloNetworks.Node}"><code>PhyloNetworks.removeHybrid!</code></a></li><li><a href="#PhyloNetworks.removedegree2nodes!-Tuple{HybridNetwork}"><code>PhyloNetworks.removedegree2nodes!</code></a></li><li><a href="#PhyloNetworks.resetEdgeNumbers!"><code>PhyloNetworks.resetEdgeNumbers!</code></a></li><li><a href="#PhyloNetworks.resetNodeNumbers!-Tuple{HybridNetwork}"><code>PhyloNetworks.resetNodeNumbers!</code></a></li><li><a href="#PhyloNetworks.rezip_canonical!-Tuple{Array{PhyloNetworks.Node,1},Array{PhyloNetworks.Edge,1},Array{Float64,1}}"><code>PhyloNetworks.rezip_canonical!</code></a></li><li><a href="#PhyloNetworks.sameTaxa-Tuple{Quartet,HybridNetwork}"><code>PhyloNetworks.sameTaxa</code></a></li><li><a href="#PhyloNetworks.sampleBootstrapTrees-Tuple{Array{Array{HybridNetwork,1},1}}"><code>PhyloNetworks.sampleBootstrapTrees</code></a></li><li><a href="#PhyloNetworks.sampleCFfromCI"><code>PhyloNetworks.sampleCFfromCI</code></a></li><li><a href="#PhyloNetworks.setBLGammaParsimony!-Tuple{HybridNetwork}"><code>PhyloNetworks.setBLGammaParsimony!</code></a></li><li><a href="#PhyloNetworks.setBranchLength!-Tuple{PhyloNetworks.Edge,Number}"><code>PhyloNetworks.setBranchLength!</code></a></li><li><a href="#PhyloNetworks.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.setGammaBLfromGammaz!</code></a></li><li><a href="#PhyloNetworks.setGammas!-Tuple{HybridNetwork,Array{T,1} where T}"><code>PhyloNetworks.setGammas!</code></a></li><li><a href="#PhyloNetworks.setNonIdBL!-Tuple{HybridNetwork}"><code>PhyloNetworks.setNonIdBL!</code></a></li><li><a href="#PhyloNetworks.setalpha!-Union{Tuple{S}, Tuple{PhyloNetworks.RVASGamma{S},Float64}} where S"><code>PhyloNetworks.setalpha!</code></a></li><li><a href="#PhyloNetworks.seteigeninfo!-Tuple{HKY85}"><code>PhyloNetworks.seteigeninfo!</code></a></li><li><a href="#PhyloNetworks.seteigeninfo!-Tuple{PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.seteigeninfo!</code></a></li><li><a href="#PhyloNetworks.seteigeninfo!-Tuple{BinaryTraitSubstitutionModel{T} where T}"><code>PhyloNetworks.seteigeninfo!</code></a></li><li><a href="#PhyloNetworks.seteigeninfo!-Tuple{EqualRatesSubstitutionModel{T} where T}"><code>PhyloNetworks.seteigeninfo!</code></a></li><li><a href="#PhyloNetworks.seteigeninfo!-Tuple{JC69}"><code>PhyloNetworks.seteigeninfo!</code></a></li><li><a href="#PhyloNetworks.setlengths!-Tuple{Array{PhyloNetworks.Edge,1},Array{Float64,1}}"><code>PhyloNetworks.setlengths!</code></a></li><li><a href="#PhyloNetworks.setparameters!-Tuple{PhyloNetworks.RVASInv,AbstractArray{T,1} where T}"><code>PhyloNetworks.setparameters!</code></a></li><li><a href="#PhyloNetworks.setpinv!-Tuple{PhyloNetworks.RVASInv,Float64}"><code>PhyloNetworks.setpinv!</code></a></li><li><a href="#PhyloNetworks.setpinvalpha!-Union{Tuple{S}, Tuple{PhyloNetworks.RVASGammaInv{S},Float64,Float64}} where S"><code>PhyloNetworks.setpinvalpha!</code></a></li><li><a href="#PhyloNetworks.setrates!-Tuple{PhyloNetworks.SubstitutionModel,AbstractArray{T,1} where T}"><code>PhyloNetworks.setrates!</code></a></li><li><a href="#PhyloNetworks.showQ-Tuple{IO,PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.showQ</code></a></li><li><a href="#PhyloNetworks.shrink2cycleat!-Tuple{HybridNetwork,PhyloNetworks.Edge,PhyloNetworks.Edge,Bool}"><code>PhyloNetworks.shrink2cycleat!</code></a></li><li><a href="#PhyloNetworks.shrink2cycles!"><code>PhyloNetworks.shrink2cycles!</code></a></li><li><a href="#PhyloNetworks.shrink3cycleat!-Tuple{HybridNetwork,PhyloNetworks.Node,PhyloNetworks.Edge,PhyloNetworks.Edge,PhyloNetworks.Node,PhyloNetworks.Node,Bool}"><code>PhyloNetworks.shrink3cycleat!</code></a></li><li><a href="#PhyloNetworks.shrink3cycles!"><code>PhyloNetworks.shrink3cycles!</code></a></li><li><a href="#PhyloNetworks.sort_stringasinteger!-Tuple{Any}"><code>PhyloNetworks.sort_stringasinteger!</code></a></li><li><a href="#PhyloNetworks.startingBL!"><code>PhyloNetworks.startingBL!</code></a></li><li><a href="#PhyloNetworks.startingrate-Tuple{HybridNetwork}"><code>PhyloNetworks.startingrate</code></a></li><li><a href="#PhyloNetworks.symmetricNet-Tuple{Int64,Int64,Int64,Real,Real}"><code>PhyloNetworks.symmetricNet</code></a></li><li><a href="#PhyloNetworks.symmetricNet"><code>PhyloNetworks.symmetricNet</code></a></li><li><a href="#PhyloNetworks.symmetricTree"><code>PhyloNetworks.symmetricTree</code></a></li><li><a href="#PhyloNetworks.synchronizePartnersData!-Tuple{PhyloNetworks.Edge,PhyloNetworks.Node}"><code>PhyloNetworks.synchronizePartnersData!</code></a></li><li><a href="#PhyloNetworks.taxadiff-Tuple{Array{Quartet,1},HybridNetwork}"><code>PhyloNetworks.taxadiff</code></a></li><li><a href="#PhyloNetworks.traitlabels2indices-Tuple{AbstractArray{T,1} where T,PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.traitlabels2indices</code></a></li><li><a href="#PhyloNetworks.traverseContainRoot!-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge,Array{PhyloNetworks.Edge,1},Array{Bool,1}}"><code>PhyloNetworks.traverseContainRoot!</code></a></li><li><a href="#PhyloNetworks.undoGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.undoGammaz!</code></a></li><li><a href="#PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}"><code>PhyloNetworks.unzip_canonical!</code></a></li><li><a href="#PhyloNetworks.unzipat_canonical!-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge}"><code>PhyloNetworks.unzipat_canonical!</code></a></li><li><a href="#PhyloNetworks.updateBL!-Tuple{HybridNetwork,DataCF}"><code>PhyloNetworks.updateBL!</code></a></li><li><a href="#PhyloNetworks.updateContainRoot!"><code>PhyloNetworks.updateContainRoot!</code></a></li><li><a href="#PhyloNetworks.updatePostOrder!"><code>PhyloNetworks.updatePostOrder!</code></a></li><li><a href="#PhyloNetworks.updatePreOrder!"><code>PhyloNetworks.updatePreOrder!</code></a></li><li><a href="#PhyloNetworks.updateSSM!"><code>PhyloNetworks.updateSSM!</code></a></li><li><a href="#PhyloNetworks.updateSSM_root!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}"><code>PhyloNetworks.updateSSM_root!</code></a></li><li><a href="#PhyloNetworks.update_logtrans-Tuple{PhyloNetworks.StatisticalSubstitutionModel}"><code>PhyloNetworks.update_logtrans</code></a></li><li><a href="#PhyloNetworks.update_logtrans-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.Edge}"><code>PhyloNetworks.update_logtrans</code></a></li><li><a href="#PhyloNetworks.updatecache_edge!-Tuple{PhyloNetworks.CacheLengthLiNC,PhyloNetworks.StatisticalSubstitutionModel,Any}"><code>PhyloNetworks.updatecache_edge!</code></a></li><li><a href="#PhyloNetworks.updateconstraintfields!-Tuple{Array{PhyloNetworks.TopologyConstraint,1},HybridNetwork}"><code>PhyloNetworks.updateconstraintfields!</code></a></li><li><a href="#PhyloNetworks.updateconstraints!-Tuple{Array{PhyloNetworks.TopologyConstraint,1},HybridNetwork}"><code>PhyloNetworks.updateconstraints!</code></a></li><li><a href="#PhyloNetworks.writeTopologyLevel1-Tuple{HybridNetwork}"><code>PhyloNetworks.writeTopologyLevel1</code></a></li><li><a href="#StatsBase.fit-Tuple{Type{PhyloNetworks.StatisticalSubstitutionModel},HybridNetwork,PhyloNetworks.SubstitutionModel,RateVariationAcrossSites,AbstractArray{T,1} where T}"><code>StatsBase.fit</code></a></li></ul><h2 id="types-1"><a class="docs-heading-anchor" href="#types-1">types</a><a class="docs-heading-anchor-permalink" href="#types-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.ANode" href="#PhyloNetworks.ANode"><code>PhyloNetworks.ANode</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ANode</code></p><p>Abstract node. An object of type <a href="#PhyloNetworks.Edge"><code>Edge</code></a> has a <code>node</code> attribute, which is an vector of 2 <code>ANode</code> objects. The object of type <a href="#PhyloNetworks.Node"><code>Node</code></a> is an <code>ANode</code>, and has an <code>edge</code> attribute, which is vector of <code>Edge</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/types.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.CacheGammaLiNC" href="#PhyloNetworks.CacheGammaLiNC"><code>PhyloNetworks.CacheGammaLiNC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CacheGammaLiNC</code></pre><p>Type to store intermediate values during γ optimization, to limit time spent on garbage collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.CacheLengthLiNC" href="#PhyloNetworks.CacheLengthLiNC"><code>PhyloNetworks.CacheLengthLiNC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CacheLengthLiNC</code></pre><p>Type to store intermediate values during optimization of one branch length, to limit time spent on garbage collection. Re-used across branches. See constructor below, from a <code>StatisticalSubstitutionModel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.CacheLengthLiNC-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,Float64,Float64,Float64,Int64}" href="#PhyloNetworks.CacheLengthLiNC-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,Float64,Float64,Float64,Int64}"><code>PhyloNetworks.CacheLengthLiNC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CacheLengthLiNC(obj::SSM,
    ftolRel::Float64, ftolAbs::Float64, xtolRel::Float64, xtolAbs::Float64,
    maxeval::Int)</code></pre><p>Constructor from a <code>StatisticalSubstitutionModel</code> object, with tolerance values and parameters controlling the search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L1126-L1133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.Edge" href="#PhyloNetworks.Edge"><code>PhyloNetworks.Edge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Edge(number)</code></pre><p>Data structure for an edge and its various attributes. Most notably:</p><ul><li><code>number</code> (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example</li><li><code>node</code>: a vector of [<code>Node</code>]s, normally just 2 of them</li><li><code>isChild1</code> (boolean): <code>true</code> if <code>node[1]</code> is the child node of the edge, false if <code>node[1]</code> is the parent node of the edge</li><li><code>length</code>: branch length</li><li><code>hybrid</code> (boolean): whether the edge is a tree edge or a hybrid edge (in which case <code>isChild1</code> is important, even if the network is semi-directed)</li><li><code>gamma</code>: proportion of genetic material inherited by the child node via the edge; 1.0 for a tree edge</li><li><code>isMajor</code> (boolean): whether the edge is the major path to the child node; <code>true</code> for tree edges, since a tree edge is the only path to its child node; normally true if <code>gamma&gt;0.5</code>.</li></ul><p>and other fields, used very internally</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/types.jl#L27-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.MatrixTopologicalOrder" href="#PhyloNetworks.MatrixTopologicalOrder"><code>PhyloNetworks.MatrixTopologicalOrder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MatrixTopologicalOrder</code></pre><p>Matrix associated to an <a href="../public/#PhyloNetworks.HybridNetwork"><code>HybridNetwork</code></a> sorted in topological order.</p><p>The following functions and extractors can be applied to it: <a href="../public/#PhyloNetworks.tipLabels"><code>tipLabels</code></a>, <code>obj[:Tips]</code>, <code>obj[:InternalNodes]</code>, <code>obj[:TipsNodes]</code> (see documentation for function <a href="#Base.getindex"><code>getindex(::MatrixTopologicalOrder, ::Symbol)</code></a>).</p><p>Functions <a href="../public/#PhyloNetworks.sharedPathMatrix"><code>sharedPathMatrix</code></a> and <a href="../public/#PhyloNetworks.simulate"><code>simulate</code></a> return objects of this type.</p><p>The <code>MatrixTopologicalOrder</code> object has fields: <code>V</code>, <code>nodeNumbersTopOrder</code>, <code>internalNodeNumbers</code>, <code>tipNumbers</code>, <code>tipNames</code>, <code>indexation</code>. Type in &quot;?MatrixTopologicalOrder.field&quot; to get documentation on a specific field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L11-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.Node" href="#PhyloNetworks.Node"><code>PhyloNetworks.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Node(number, leaf)
Node(number, leaf, hybrid)</code></pre><p>Data structure for a node and its various attributes. Most notably:</p><ul><li><code>number</code> (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example</li><li><code>leaf</code> (boolean): whether the node is a leaf (with data typically) or an internal node (no data typically)</li><li><code>name</code> (string): taxon name for leaves; internal node may or may not have a name</li><li><code>edge</code>: vector of <a href="#PhyloNetworks.Edge"><code>Edge</code></a>s that the node is attached to; 1 if the node is a leaf, 2 if the node is the root, 3 otherwise, and potentially more if the node has a polytomy</li><li><code>hybrid</code> (boolean): whether the node is a hybrid node (with 2 or more parents) or a tree node (with a single parent)</li></ul><p>Other more internal attributes include:</p><ul><li><code>isBadDiamondI</code> and <code>isBadDiamondII</code> (booleans): whether the node is a hybrid node where the reticulation forms a cycle of 4 nodes (diamond), and where both parents of the hybrid nodes are connected to a leaf. In a bad diamond of type I, the hybrid node itself is also connected to a leaf but the common neighbor of the 2 hybrid&#39;s parents is not connected to a leaf. In a bad diamond of type II, the hybrid node has an internal node as child, and the common neighbor of the 2 hybrid&#39;s parents is connected to a leaf.</li><li><code>isBadTriangle</code>, <code>isVeryBadTriangle</code> and <code>isExtBadTriangle</code> (booleans): true if the reticulation forms a cycle of 3 nodes (triangle) and depending on the number of leaves attached these 3 nodes. The triangle means that the 2 parents of the hybrid node are directly related: one is the child of the other. <code>isBadTriangle</code> is true if the triangle is &quot;good&quot;, as per Solís-Lemus &amp; Ané (2016), that is, if all 3 nodes in the cycle are not connected to any leaves (the reticulation is detectable from quartet concordance factors, even though all branch lengths are not identifiable). <code>isVeryBadTriangle</code> is true if 2 (or all) of the 3 nodes are connected to a leaf, in which case the reticulation is undetectable from unrooted gene tree topologies (thus it&#39;s best to exclude these reticulations from a search). <code>isBadTriangle</code> is true if exactly 1 of the 3 nodes is connected to a leaf.</li></ul><p>For details see Solís-Lemus &amp; Ané (2016, doi:10.1371/journal.pgen.1005896)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/types.jl#L90-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.NucleicAcidSubstitutionModel" href="#PhyloNetworks.NucleicAcidSubstitutionModel"><code>PhyloNetworks.NucleicAcidSubstitutionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NucleicAcidSubstitutionModel</code></pre><p>Adapted from <a href="https://github.com/BioJulia/SubstitutionModels.jl/">SubstitutionModels.jl</a> in BioJulia. The same <a href="../public/#PhyloNetworks.Q"><code>Q</code></a> and <a href="#PhyloNetworks.P-Tuple{PhyloNetworks.SubstitutionModel,Float64}"><code>P</code></a> function names are used for the transition rates and probabilities.</p><p>For subtypes, see <a href="../public/#PhyloNetworks.JC69"><code>JC69</code></a>, <a href="../public/#PhyloNetworks.HKY85"><code>HKY85</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L31-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.QuartetNetwork" href="#PhyloNetworks.QuartetNetwork"><code>PhyloNetworks.QuartetNetwork</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuartetNetwork(net::HybridNetwork)</code></pre><p>Subtype of <code>Network</code> abstract type. need documentation!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/types.jl#L232-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.QuartetT" href="#PhyloNetworks.QuartetT"><code>PhyloNetworks.QuartetT</code></a> — <span class="docstring-category">Type</span></header><section><div><p>QuartetT{T}</p><p>Generic type for 4-taxon sets. Fields:</p><ul><li><code>number</code>: rank of the 4-taxon set</li><li><code>taxonnumber</code>: static vector of 4 integers, assumed to be distinct and sorted</li><li><code>data</code>: object of type <code>T</code></li></ul><p>For easier look-up, a unique mapping is used between the rank (<code>number</code>) of a 4-taxon set and its 4 taxa (see <a href="#PhyloNetworks.quartetrank-Tuple{AbstractArray{T,1} where T,Array{T,2} where T}"><code>quartetrank</code></a> and <a href="#PhyloNetworks.nchoose1234-Tuple{Int64}"><code>nchoose1234</code></a>):</p><p>rank-1 = (t1-1) choose 1 + (t2-1) choose 2 + (t3-1) choose 3 + (t4-1) choose 4</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; nCk = PhyloNetworks.nchoose1234(5)
6×4 Array{Int64,2}:
 0   0   0  0
 1   0   0  0
 2   1   0  0
 3   3   1  0
 4   6   4  1
 5  10  10  5

julia&gt; PhyloNetworks.QuartetT(1,3,4,6, [.92,.04,.04, 100], nCk)
4-taxon set number 8; taxon numbers: 1,3,4,6
data: [0.92, 0.04, 0.04, 100.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/types.jl#L311-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.StatisticalSubstitutionModel" href="#PhyloNetworks.StatisticalSubstitutionModel"><code>PhyloNetworks.StatisticalSubstitutionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StatisticalSubstitutionModel</code></pre><p>Subtype of <code>StatsBase.StatisticalModel</code>, to fit discrete data to a model of trait substitution along a network. See <a href="../public/#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a> to fit a trait substitution model to discrete data. It returns an object of type <code>StatisticalSubstitutionModel</code>, to which standard functions can be applied, like <code>loglikelihood(object)</code>, <code>aic(object)</code> etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.SubstitutionModel" href="#PhyloNetworks.SubstitutionModel"><code>PhyloNetworks.SubstitutionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SubstitutionModel</code></pre><p>Abstract type for substitution models, using a continous time Markov model on a phylogeny. Adapted from <a href="https://github.com/BioJulia/SubstitutionModels.jl/">SubstitutionModels.jl</a> in BioJulia.</p><p>For variable rates, see <a href="../public/#PhyloNetworks.RateVariationAcrossSites"><code>RateVariationAcrossSites</code></a></p><p>For sub types, see <a href="#PhyloNetworks.NucleicAcidSubstitutionModel"><code>NucleicAcidSubstitutionModel</code></a>, <a href="../public/#PhyloNetworks.TraitSubstitutionModel"><code>TraitSubstitutionModel</code></a></p><p>All these models are supposed to have fields <code>rate</code> and <code>eigeninfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.TopologyConstraint" href="#PhyloNetworks.TopologyConstraint"><code>PhyloNetworks.TopologyConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for various topological constraints, such as:</p><ol><li>a set of taxa forming a clade in the major tree</li><li>a set of individuals belonging to the same species</li><li>a set of taxa forming a clade in any one of the displayed trees</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/moves_semidirected.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.TopologyConstraint-Tuple{UInt8,Array{String,1},HybridNetwork}" href="#PhyloNetworks.TopologyConstraint-Tuple{UInt8,Array{String,1},HybridNetwork}"><code>PhyloNetworks.TopologyConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TopologyConstraint(type::UInt8, taxonnames::Vector{String}, net::HybridNetwork)</code></pre><p>Create a topology constraint from user-given type, taxon names, and network. There are 3 types of constraints:</p><ul><li>type 1: A set of tips that forms a species.</li><li>type 2: A set of tips that forms a clade in the major tree. Note that the root matters. Constraining a set of species to be an outgroup is equivalent to constraining the ingroup to form a clade.</li><li>type 3: A set of tips that forms a clade in any one of the displayed trees.</li></ul><p>Note: currently, with type-1 constraints, hybridizations are prevented from coming into or going out of a species group.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((2a,2b),(((((1a,1b,1c),4),(5)#H1),(#H1,(6,7))))#H2),(#H2,10));&quot;);

julia&gt; c_species1 = PhyloNetworks.TopologyConstraint(0x01, [&quot;1a&quot;,&quot;1b&quot;,&quot;1c&quot;], net)
Species constraint, on tips: 1a, 1b, 1c
 stem edge number 7
 crown node number -9

julia&gt; c_species2 = PhyloNetworks.TopologyConstraint(0x01, [&quot;2a&quot;,&quot;2b&quot;], net)
Species constraint, on tips: 2a, 2b
 stem edge number 3
 crown node number -4

julia&gt; nni!(net , net.edge[3], true, true, [c_species2]) === nothing # we get nothing: would break species 2
true

julia&gt; # the following gives an error, because 4,5 do not form a clade in &quot;net&quot;
       # PhyloNetworks.TopologyConstraint(0x02, [&quot;4&quot;,&quot;5&quot;], net)

julia&gt; c_clade145 = PhyloNetworks.TopologyConstraint(0x02, [&quot;1a&quot;,&quot;1b&quot;,&quot;1c&quot;,&quot;4&quot;,&quot;5&quot;], net)
Clade constraint, on tips: 1a, 1b, 1c, 4, 5
 stem edge number 12
 crown node number -7

julia&gt; nni!(net , net.edge[12], true, true, [c_species1, c_clade145]) # we get nothing (failed NNI): would break the clade</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/moves_semidirected.jl#L50-L93">source</a></section></article><h2 id="functions-1"><a class="docs-heading-anchor" href="#functions-1">functions</a><a class="docs-heading-anchor-permalink" href="#functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getindex(obj, d)</code></pre><p>Getting submatrices of an object of type <a href="../public/#PhyloNetworks.TraitSimulation"><code>TraitSimulation</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>obj::TraitSimulation</code>: the matrix from which to extract.</li><li><code>d::Symbol</code>: a symbol precising which sub-matrix to extract. Can be:<ul><li><code>:Tips</code> columns and/or rows corresponding to the tips</li><li><code>:InternalNodes</code> columns and/or rows corresponding to the internal nodes</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L1515-L1525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getindex(obj, d,[ indTips, nonmissing])</code></pre><p>Getting submatrices of an object of type <a href="#PhyloNetworks.MatrixTopologicalOrder"><code>MatrixTopologicalOrder</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>obj::MatrixTopologicalOrder</code>: the matrix from which to extract.</li><li><code>d::Symbol</code>: a symbol precising which sub-matrix to extract. Can be:<ul><li><code>:Tips</code> columns and/or rows corresponding to the tips</li><li><code>:InternalNodes</code> columns and/or rows corresponding to the internal nodes</li><li><code>:TipsNodes</code> columns corresponding to internal nodes, and row to tips (works only is indexation=&quot;b&quot;)</li></ul></li><li><code>indTips::Vector{Int}</code>: optional argument precising a specific order for the tips (internal use).</li><li><code>nonmissing::BitArray{1}</code>: optional argument saying which tips have data (internal use).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L223-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.P!-Tuple{AbstractArray{T,2} where T,PhyloNetworks.SubstitutionModel,Float64}" href="#PhyloNetworks.P!-Tuple{AbstractArray{T,2} where T,PhyloNetworks.SubstitutionModel,Float64}"><code>PhyloNetworks.P!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">P!(Pmat::AbstractMatrix, obj::SM, t::Float64)</code></pre><p>Fill in the input matrix <code>Pmat</code> with the transition rates to go from each state to another in time <code>t</code>, according to rates in <code>Q</code>. see also: <a href="#PhyloNetworks.P-Tuple{PhyloNetworks.SubstitutionModel,Float64}"><code>P</code></a>.</p><pre><code class="language-julia-repl">julia&gt; m1 = BinaryTraitSubstitutionModel([1.0,2.0], [&quot;low&quot;,&quot;high&quot;])
Binary Trait Substitution Model:
rate low→high α=1.0
rate high→low β=2.0

julia&gt; PhyloNetworks.P!(Matrix{Float64}(undef,2,2), m1, 0.3) # fills an uninitialized 2x2 matrix of floats
2×2 Array{Float64,2}:
 0.80219  0.19781
 0.39562  0.60438

julia&gt; m2 = JC69([1.]);

julia&gt; PhyloNetworks.P!(Matrix{Float64}(undef,4,4), m2, 0.2)
4×4 Array{Float64,2}:
 0.824446   0.0585179  0.0585179  0.0585179
 0.0585179  0.824446   0.0585179  0.0585179
 0.0585179  0.0585179  0.824446   0.0585179
 0.0585179  0.0585179  0.0585179  0.824446 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L229-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.P-Tuple{PhyloNetworks.SubstitutionModel,Float64}" href="#PhyloNetworks.P-Tuple{PhyloNetworks.SubstitutionModel,Float64}"><code>PhyloNetworks.P</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">P(obj, t)</code></pre><p>Probability transition matrix for a <a href="../public/#PhyloNetworks.TraitSubstitutionModel"><code>TraitSubstitutionModel</code></a>, of the form</p><pre><code class="language-none">P[1,1] ... P[1,k]
   .          .
   .          .
P[k,1] ... P[k,k]</code></pre><p>where P[i,j] is the probability of ending in state j after time t, given that the process started in state i. see also: <a href="#PhyloNetworks.P!-Tuple{AbstractArray{T,2} where T,PhyloNetworks.SubstitutionModel,Float64}"><code>P!</code></a>.</p><p>HKY example:</p><pre><code class="language-julia-repl">julia&gt; m1 = HKY85([0.5], [0.20, 0.30, 0.30, 0.20])
HKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]
relative rate version with transition/tranversion ratio kappa = 0.5,
 scaled so that there is one substitution per unit time
rate matrix Q:
               A       C       G       T
       A       *  0.4839  0.2419  0.3226
       C  0.3226       *  0.4839  0.1613
       G  0.1613  0.4839       *  0.3226
       T  0.3226  0.2419  0.4839       *

julia&gt; PhyloNetworks.P(m1, 0.2)
4×4 StaticArrays.MArray{Tuple{4,4},Float64,2,16} with indices SOneTo(4)×SOneTo(4):
 0.81592    0.0827167  0.0462192  0.0551445
 0.0551445  0.831326   0.0827167  0.0308128
 0.0308128  0.0827167  0.831326   0.0551445
 0.0551445  0.0462192  0.0827167  0.81592  </code></pre><p>Juke-Cantor example:</p><pre><code class="language-julia-repl">julia&gt; m1 = JC69([1.]);

julia&gt; PhyloNetworks.P(m1, 0.2)
4×4 StaticArrays.MArray{Tuple{4,4},Float64,2,16} with indices SOneTo(4)×SOneTo(4):
 0.824446   0.0585179  0.0585179  0.0585179
 0.0585179  0.824446   0.0585179  0.0585179
 0.0585179  0.0585179  0.824446   0.0585179
 0.0585179  0.0585179  0.0585179  0.824446 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L175-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork,DataFrames.DataFrame}" href="#PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork,DataFrames.DataFrame}"><code>PhyloNetworks.addAlternativeHybridizations!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addAlternativeHybridizations!(net::HybridNetwork, BSe::DataFrame;
                              cutoff=10::Number, top=3::Int)</code></pre><p>Modify the network <code>net</code> (the best network estimated with snaq) by adding other hybridizations that are present in the bootstrap networks. By default, it will only consider hybrid edges with more than 10% bootstrap support (<code>cutoff</code>) and it will only include the three top hybridizations (<code>top</code>) sorted by bootstrap support. The function also modifies the dataframe <code>BSe</code> obtained with <code>hybridBootstrapSupport</code>. In the original <code>BSe</code> dataframe, hybrid edges that do not appear in the best network have a missing number. After the hybrid edges are added with <code>addAlternativeHybridizations</code>, <code>BSe</code> is modified to include the edge numbers of the newly added hybrid edges. Note that the function only adds the hybrid edges as minor to keep the underlying tree topology.</p><p><strong>example</strong></p><pre><code class="language-julia">bootnet = readMultiTopology(&quot;bootstrap-networks.txt&quot;)
bestnet = readTopology(&quot;best.tre&quot;)
BSn, BSe, BSc, BSgam, BSedgenum = hybridBootstrapSupport(bootnet, bestnet);
addAlternativeHybridizations!(bestnet,BSe)
using PhyloPlots
plot(bestnet, edgeLabel=BSe[[:edge,:BS_hybrid_edge]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/addHybrid_snaq.jl#L355-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.addhybridedge!" href="#PhyloNetworks.addhybridedge!"><code>PhyloNetworks.addhybridedge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">addhybridedge!(net::HybridNetwork, edge1::Edge, edge2::Edge, hybridpartnernew::Bool,
               edgelength=-1.0::Float64, gamma=-1.0::Float64)</code></pre><p>Add hybridization to <code>net</code> coming from <code>edge1</code> going into <code>edge2</code>. 2 new nodes and 3 new edges are created: <code>edge1</code> are <code>edge2</code> are both cut into 2 edges, and a new edge is created linking the 2 new &quot;middle&quot; nodes, pointing from <code>edge1</code> to <code>edge2</code>. The new node in the middle of <code>edge1</code> is a tree node. The new node in the middle of <code>edge2</code> is a hybrid node. Its parent edges are the newly created hybrid edge (with γ = gamma, missing by default), and either the newly edge &quot;above&quot; <code>edge2</code> if <code>hybridpartnernew=true</code>, or the old <code>edge2</code> otherwise (which would reverse the direction of <code>edge2</code> and others).</p><p>Should be called from the other method, which performs a bunch of checks. Updates <code>containRoot</code> attributes for edges below the new hybrid node.</p><p>Output: new hybrid node (middle of the old <code>edge2</code>) and new hybrid edge.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;((S8,(((S1,(S5)#H1),(#H1,S6)))#H2),(#H2,S10));&quot;);

julia&gt; hybnode, hybedge = PhyloNetworks.addhybridedge!(net, net.edge[13], net.edge[8], true, 0.0, 0.2)
(PhyloNetworks.Node:
 number:9
 name:H3
 hybrid node
 attached to 3 edges, numbered: 8 16 17
, PhyloNetworks.Edge:
 number:17
 length:0.0
 minor hybrid edge with gamma=0.2
 attached to 2 node(s) (parent first): 8 9
)


julia&gt; writeTopology(net)
&quot;((S8,(((S1,(S5)#H1),((#H1,S6))#H3:::0.8))#H2),(#H2,(S10,#H3:0.0::0.2)));&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/addHybrid.jl#L125-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.addhybridedge!" href="#PhyloNetworks.addhybridedge!"><code>PhyloNetworks.addhybridedge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">addhybridedge!(net::HybridNetwork, nohybridladder::Bool, no3cycle::Bool,
               constraints=TopologyConstraint[]::Vector{TopologyConstraint};
               maxattempts=10::Int, fixroot=false::Bool)</code></pre><p>Randomly choose two edges in <code>net</code> then: add hybrid edge from edge 1 to edge 2 of length 0.01. The two halves of edge 1 (and of edge 2) have equal lengths. The hybrid partner edge (top half of edge 2, if fixroot is true) will point towards the newly-created node on the middle of the original edge 2.</p><p>If the resulting network is a DAG, satisfies the constraint(s), does not contain any 3-cycle (if <code>no3cycle=true</code>), and does not have a hybrid ladder (if <code>nohybridladder=true</code>) then the proposal is successful: <code>net</code> is modified, and the function returns the newly created hybrid node and newly created hybrid edge.</p><p>If the resulting network is not acceptable, then a new set of edges is proposed (using a blacklist) until one is found acceptable, or until a maximum number of attempts have been made (<code>maxattempts</code>). If none of the attempted proposals are successful, <code>nothing</code> is returned (without causing an error).</p><p>After a pair of edges is picked, the &quot;top&quot; half of edge2 is proposed as the partner hybrid edge with probability 0.8 if <code>fixroot</code> is false, (to avoid changing the direction of edge2 with more than 50% chance) and with probability 1.0 if <code>fixroot</code> is true. If this choice does not work and if <code>fixroot</code> is false, the other half of edge2 is proposed as the partner hybrid edge. Note that choosing the &quot;bottom&quot; half of edge2 as the partner edge requires to flip the direction of edge 2, and to move the root accordingly (to the original child of edge2).</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));&quot;);

julia&gt; using Random

julia&gt; Random.seed!(134);

julia&gt; PhyloNetworks.addhybridedge!(net, true, true)
(PhyloNetworks.Node:
 number:9
 name:H3
 hybrid node
 attached to 3 edges, numbered: 5 16 17
, PhyloNetworks.Edge:
 number:17
 length:0.01
 minor hybrid edge with gamma=0.028819678088948808
 attached to 2 node(s) (parent first): 8 9
)

julia&gt; writeTopology(net, round=true)
&quot;((S1,((((#H1,S4),((S2,(S3)#H1))#H3:::0.971))#H2,#H3:0.01::0.029)),(#H2,S5));&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/addHybrid.jl#L4-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.addhybridedgeLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,Bool,Bool,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}" href="#PhyloNetworks.addhybridedgeLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,Bool,Bool,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.addhybridedgeLiNC!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addhybridedgeLiNC!(obj::SSM, currLik::Float64,
    no3cycle::Bool, nohybridladder::Bool,
    constraints::Vector{TopologyConstraint},
    ftolAbs::Float64,
    γcache::CacheGammaLiNC, lcache::CacheLengthLiNC)</code></pre><p>Completes checks, adds hybrid in a random location, updates SSM object, and optimizes branch lengths and gammas locally as part of PhyLiNC optimization.</p><p>Return true if accepted add hybrid move. If move not accepted, return false. If cannot add a hybrid, return nothing.</p><p>For arguments, see <a href="../public/#PhyloNetworks.phyLiNC!"><code>phyLiNC!</code></a>. Called by <a href="#PhyloNetworks.optimizestructure!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer,Bool,Bool,Integer,Integer,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>optimizestructure!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L750-L765">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.addindividuals!-Tuple{HybridNetwork,AbstractString,Array{String,1}}" href="#PhyloNetworks.addindividuals!-Tuple{HybridNetwork,AbstractString,Array{String,1}}"><code>PhyloNetworks.addindividuals!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addindividuals!(net::HybridNetwork, species::AbstractString, individuals::Vector)</code></pre><p>Add individuals to their species leaf as a star, and return the corresponding species constraint. <code>nothing</code> is returned in 2 cases:</p><ul><li>if <code>individuals</code> contains only 1 individual, in which case the name of the leaf for that species is replaced by the name of its one individual representative</li><li>if <code>species</code> is not found in the network</li></ul><p>Spaces in individuals&#39; names are eliminated, see <a href="#PhyloNetworks.cleantaxonname-Tuple{AbstractString}"><code>cleantaxonname</code></a>.</p><p>Called by <a href="../public/#PhyloNetworks.mapindividuals"><code>mapindividuals</code></a>.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(S8,(((S1,S4),(S5)#H1),(#H1,S6)));&quot;);

julia&gt; PhyloNetworks.addindividuals!(net, &quot;S1&quot;, [&quot;S1A&quot;, &quot;S1B&quot;, &quot;S1C&quot;])
Species constraint, on tips: S1A, S1B, S1C
 stem edge number 2
 crown node number 2

julia&gt; writeTopology(net) # 3 new nodes, S1 now internal: not a tip
&quot;(S8,((((S1A,S1B,S1C)S1,S4),(S5)#H1),(#H1,S6)));&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/moves_semidirected.jl#L791-L819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.addleaf!" href="#PhyloNetworks.addleaf!"><code>PhyloNetworks.addleaf!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">addleaf!(net::HybridNetwork, node::Node, leafname::String, edgelength::Float64=-1.0)
addleaf!(net::HybridNetwork, edge::Edge, leafname::String, edgelength::Float64=-1.0)</code></pre><p>Add a new external edge between <code>node</code> or between the &quot;middle&quot; of <code>edge</code> and a newly-created leaf, of name <code>leafname</code>. By default, the new edge length is missing (-1).</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));&quot;);

julia&gt; net.node[6].name # leaf S4
&quot;S4&quot;

julia&gt; PhyloNetworks.addleaf!(net, net.node[6], &quot;4a&quot;); # adding leaf to a node

julia&gt; writeTopology(net, internallabel=true)
&quot;((S1,(((S2,(S3)#H1),(#H1,(4a)S4)))#H2),(#H2,S5));&quot;

julia&gt; PhyloNetworks.addleaf!(net, net.node[6], &quot;4b&quot;);

julia&gt; writeTopology(net, internallabel=true)
&quot;((S1,(((S2,(S3)#H1),(#H1,(4a,4b)S4)))#H2),(#H2,S5));&quot;</code></pre><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));&quot;);

julia&gt; [n.name for n in net.edge[7].node] # external edge to S4
2-element Array{String,1}:
 &quot;S4&quot;
 &quot;&quot;  

julia&gt; PhyloNetworks.addleaf!(net, net.edge[7], &quot;4a&quot;); # adding leaf to an edge

julia&gt; writeTopology(net, internallabel=true)
&quot;((S1,(((S2,(S3)#H1),(#H1,(S4,4a))))#H2),(#H2,S5));&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L533-L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.adjacentedges-Tuple{PhyloNetworks.Edge}" href="#PhyloNetworks.adjacentedges-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.adjacentedges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjacentedges(centeredge::Edge)</code></pre><p>Vector of all edges that share a node with <code>centeredge</code>. Warning: assumes that there aren&#39;t &quot;duplicated&quot; edges, that is, no 2-cycles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L1690-L1695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.afterOptBL!-Tuple{HybridNetwork,DataCF,Bool,Bool,Bool,Integer,Array{Int64,1}}" href="#PhyloNetworks.afterOptBL!-Tuple{HybridNetwork,DataCF,Bool,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.afterOptBL!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>afterOptBL</code> road map</p><p>Function that will check if there are <code>h==0,1;t==0,hz==0,1</code> cases in a network after calling <code>optBL!</code>.</p><p>Arguments:</p><ul><li><code>closeN=true</code> will move origin/target, if false, add/delete N times before giving up (we have only tested <code>closeN=true</code>)</li><li><code>origin=true</code> will move origin, false will move target. We added this to avoid going back and forth between the same networks</li><li><code>movesgamma</code> vector of counts of number of times each move is proposed to fix a gamma zero problem: <code>(add,mvorigin,mvtarget,chdir,delete,nni)</code></li></ul><p>Procedure:</p><ul><li><p>First we split the <code>ht</code> vector in <code>nh,nt,nhz</code> (gammas, lengths, gammaz)</p></li><li><p>If we find a <code>h==0,1</code>, we loop through <code>nh</code> to find a hybrid edge with h==0 or 1 and want to try to fix this by doing:</p><ul><li><code>gammaZero!(currT,d,edge,closeN,origin,N,movesgamma)</code> which returns true if there was a successful change, and we stop the loop</li></ul></li><li><p>If we find a <code>t==0</code>, we loop through all <code>nt</code> to find such edge, and do NNI move on this edge; return true if change successful and we stop the loop</p></li><li><p>If we find a <code>hz==0,1</code>, we loop through <code>nhz</code> to find such hybrid edge and call <code>gammaZero</code> again</p></li><li><p>If we did a successful change, we run <code>optBL</code> again, and recheck if there are no more problems.</p></li><li><p>Returns successchange, flagh, flagt,flaghz (flag=true means no problems)</p></li><li><p>If it is the multiple alleles case, it will not try to fix <code>h==0,1;hz==0,1</code> because it can reach a case that violates the multiple alleles condition. If we add a check here, things become horribly slow and inefficient, so we just delete a hybridization that has <code>h==0,1;hz==0,1</code></p></li></ul><p>** Important: ** <code>afterOptBL</code> is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call <code>afterOptBLRepeat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/snaq_optimization.jl#L572-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.afterOptBLAll!-Tuple{HybridNetwork,DataCF,Integer,Bool,Float64,Float64,Bool,Array{Int64,1},Float64,Float64,Float64}" href="#PhyloNetworks.afterOptBLAll!-Tuple{HybridNetwork,DataCF,Integer,Bool,Float64,Float64,Bool,Array{Int64,1},Float64,Float64,Float64}"><code>PhyloNetworks.afterOptBLAll!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>afterOptBLAll</code> road map</p><p>After <code>optBL</code>, we want to call <code>afterOptBLAll</code> (or <code>afterOptBLAllMultipleAlleles</code>) to check if there are <code>h==0,1</code>; <code>t==0</code>; <code>hz==0,1</code>. This function will try to fix the gamma zero problem, but if it cannot, it will call <code>moveDownLevel</code>, to delete the hybridization from the network.</p><p>Procedure:</p><p>While <code>startover=true</code> and <code>tries&lt;N</code></p><ul><li>While <code>badliks &lt; N2</code> (number of bad pseudolikelihoods are less than <code>N2</code>)<ul><li>Run <code>success = afterOptBLRepeat</code></li><li>If <code>success = true</code> (it changed something):<ul><li>If worse pseudolik, then go back to original topology <code>currT</code>, set <code>startover=true</code> and <code>badliks++</code></li><li>If better pseudolik, then check flags. If all good, then <code>startover=false</code>; otherwise <code>startover = true</code></li></ul></li><li>If <code>success = false</code> (nothing changed), then set <code>badliks=N2+1</code> (to end the while on <code>currT</code>)<ul><li>If all flags are ok, then <code>startover = false</code></li><li>If bad h or hz, then call <code>moveDownLevel</code> (delete one hybridization), and set <code>startover = true</code> (maybe deleting that hybridization did not fix other gamma zero problems)</li><li>If bad t, then set <code>startover = false</code></li></ul></li></ul></li><li>If left second while by back to original <code>currT</code>, and still bad h/hz, then move down one level, and <code>startover=true</code>; otherwise <code>startover=false</code></li></ul><p>If first while ends by <code>tries&gt;N</code>, then it checks one last time the flags, if bad h/hz will move down one level, and exit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/snaq_optimization.jl#L757-L776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.afterOptBLRepeat!-Tuple{HybridNetwork,DataCF,Integer,Bool,Bool,Bool,Array{Int64,1}}" href="#PhyloNetworks.afterOptBLRepeat!-Tuple{HybridNetwork,DataCF,Integer,Bool,Bool,Bool,Array{Int64,1}}"><code>PhyloNetworks.afterOptBLRepeat!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>afterOptBLRepeat</code> road map</p><p><code>afterOptBL</code> is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call <code>afterOptBLRepeat</code>. This function will repeat <code>afterOptBL</code> every time a successful change happened; this is done only if <code>closeN=false</code>, because we would delete/add hybridizations and need to stop after tried N times. If <code>closeN=true</code> (default), then <code>afterOptBLRepeat</code> only does one <code>afterOptBL</code>, because in this case, only the neighbor edges need to be tested, and this would have been done already in <code>gammaZero</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/snaq_optimization.jl#L689-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.allowrootbelow!-Tuple{PhyloNetworks.Edge}" href="#PhyloNetworks.allowrootbelow!-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.allowrootbelow!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allowrootbelow!(e::Edge)
allowrootbelow!(n::Node, parent_edge_of_n::Edge)</code></pre><p>Set <code>containRoot</code> to <code>true</code> for edge <code>e</code> and all edges below, recursively. The traversal stops whenever a hybrid node is encountered: if the child of <code>e</code> is a hybrid node (that is, if <code>e</code> is a hybrid edge) or if <code>n</code> is a hybrid node, then the edges below <code>e</code> or <code>n</code> are <em>not</em> traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L1176-L1184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.anova-Union{Tuple{Vararg{StatsModels.TableRegressionModel{PhyloNetworkLinearModel,T},N} where N}, Tuple{T}} where T" href="#PhyloNetworks.anova-Union{Tuple{Vararg{StatsModels.TableRegressionModel{PhyloNetworkLinearModel,T},N} where N}, Tuple{T}} where T"><code>PhyloNetworks.anova</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">anova(objs::PhyloNetworkLinearModel...)</code></pre><p>Takes several nested fits of the same data, and computes the F statistic for each pair of models.</p><p>The fits must be results of function <a href="../public/#PhyloNetworks.phyloNetworklm"><code>phyloNetworklm</code></a> called on the same data, for models that have more and more effects.</p><p>Returns a DataFrame object with the anova table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L2324-L2334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}" href="#PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}"><code>PhyloNetworks.assignhybridnames!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assignhybridnames!(net)</code></pre><p>Assign names to hybrid nodes in the network <code>net</code>. Hybrid nodes with an empty <code>name</code> field (&quot;&quot;) are modified with a name that does not conflict with other hybrid names in the network. The preferred name is &quot;H3&quot; if the node number is 3 or -3, but an index other than 3 would be used if &quot;H3&quot; were the name of another node already.</p><p>If two hybrid nodes have non-empty and equal names, the name of one of them is changed and re-assigned as described above (with a warning).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L1205-L1216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.blobInfo" href="#PhyloNetworks.blobInfo"><code>PhyloNetworks.blobInfo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">blobInfo(network, ignoreTrivial=true)</code></pre><p>Calculate the biconnected components (blobs) using function <a href="../public/#PhyloNetworks.biconnectedComponents"><code>biconnectedComponents</code></a> then:</p><ul><li>set node field <code>isExtBadTriangle</code> to true at the root of each non-trivial blob (and at the network root), false otherwise. (a better name for the field would be something like &quot;isBlobRoot&quot;.)</li><li>output:<ol><li>array of nodes that are the roots of each non-trivial blob, and the network root. If the root of the full network is not part of a non-trivial blob, a corresponding blob is added to the list.</li><li>array of arrays: for each non-trivial blob, array of major hybrid edges in that blob.</li><li>array of arrays: same as #2 but for minor hybrid edges, with hybrids listed in the same order, for each blob.</li></ol></li></ul><p>Blobs are ordered in reverse topological ordering (aka post order). If <code>ignoreTrivial</code> is true, trivial components are ignored.</p><p>keyword argument: <code>checkPreorder</code>, true by default. If false, the <code>isChild1</code> edge field and the <code>net.nodes_changed</code> network field are supposed to be correct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/biconnectedComponents.jl#L115-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.breakedge!-Tuple{PhyloNetworks.Edge,HybridNetwork}" href="#PhyloNetworks.breakedge!-Tuple{PhyloNetworks.Edge,HybridNetwork}"><code>PhyloNetworks.breakedge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">breakedge!(edge::Edge, net::HybridNetwork)</code></pre><p>Break an edge into 2 edges, each of length half that of original edge, creating a new node of degree 2. Useful to root network along an edge. Return the new node and the new edge, which is the &quot;top&quot; half of the original starting edge. These new node &amp; edge are pushed last in <code>net.node</code> and <code>net.edge</code>.</p><p>If the starting edge was:</p><pre><code class="language-none">n1  --edge--&gt;  n2</code></pre><p>then we get this:</p><pre><code class="language-none">n1  --newedge--&gt;  newnode  --edge--&gt;  n2</code></pre><p><code>isChild1</code> and <code>containRoot</code> are updated, but not fields for level-1 networks like <code>inCycle</code>, <code>partition</code>, <code>gammaz</code>, etc.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((S8,S9),((((S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));&quot;);

julia&gt; length(net.node)
19

julia&gt; net.edge[4] # edge 4 goes from node -8 to 3
PhyloNetworks.Edge:
 number:4
 length:-1.0
 attached to 2 node(s) (parent first): -8 3


julia&gt; newnode, newedge = PhyloNetworks.breakedge!(net.edge[4], net);

julia&gt; length(net.node) # one more than before
20

julia&gt; newedge # new edge 21 goes from node -8 and 11 (new)
PhyloNetworks.Edge:
 number:21
 length:-1.0
 attached to 2 node(s) (parent first): -8 11


julia&gt; net.edge[4] # original edge 4 now goes from node 11 (new) to 3
PhyloNetworks.Edge:
 number:4
 length:-1.0
 attached to 2 node(s) (parent first): 11 3


julia&gt; writeTopology(net) # note extra pair of parentheses around S1
&quot;(((S8,S9),((((S4,(S1)),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L356-L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.calculateObsCFAll!-Tuple{DataCF,Union{Array{Int64,1}, Array{String,1}}}" href="#PhyloNetworks.calculateObsCFAll!-Tuple{DataCF,Union{Array{Int64,1}, Array{String,1}}}"><code>PhyloNetworks.calculateObsCFAll!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calculateObsCFAll!(DataCF, taxa::Union{Vector{String}, Vector{Int}})</code></pre><p>Calculate observed concordance factors: update the <code>.quartet[i].obsCF</code> values of the <code>DataCF</code> object based on its .tree vector.</p><pre><code class="language-none">calculateObsCFAll!(vector of quartets, vector of trees, taxa)</code></pre><p>Calculate observed concordance factors: update the <code>.obsCF</code> values of the quartets, based on the trees, and returns a new <code>DataCF</code> object with these updated quartets and trees.</p><pre><code class="language-none">calculateObsCFAll_noDataCF!(vector of quartets, vector of trees, taxa)</code></pre><p>update the <code>.obsCF</code> values of the quartets based on the trees, but returns nothing.</p><p>Warning: all these functions need input trees (without any reticulations: h=0).</p><p>See also: <a href="../public/#PhyloNetworks.countquartetsintrees"><code>countquartetsintrees</code></a>, which uses a faster algorithm, processing each input tree only once. <code>calculateObsCFAll_noDataCF!</code> processes each input tree <code># quartet</code> times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readData.jl#L439-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}" href="#PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}"><code>PhyloNetworks.checkNumHybEdges!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">checkNumHybEdges!(net)</code></pre><p>Check for consistency between hybrid-related attributes in the network:</p><ul><li>for each hybrid node: 2 or more hybrid edges</li><li>exception: allows for a leaf to be attached to a single hybrid edge</li><li>exactly 2 incoming parent hybrid edges</li></ul><p>Run after <code>storeHybrids!</code>. See also <code>check2HybEdges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L535-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.check_matchtaxonnames!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,HybridNetwork}" href="#PhyloNetworks.check_matchtaxonnames!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,HybridNetwork}"><code>PhyloNetworks.check_matchtaxonnames!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_matchtaxonnames!(species, data, net)</code></pre><p>Modify <code>species</code> and <code>dat</code> by removing the species (rows) absent from the network. Return a new network (<code>net</code> is <em>not</em> modified) with tips matching those in species: if some species in <code>net</code> have no data, these species are pruned from the network. The network also has its node names reset, such that leaves have nodes have consecutive numbers starting at 1, with leaves first. Used by <a href="../public/#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a> to build a new <a href="#PhyloNetworks.StatisticalSubstitutionModel"><code>StatisticalSubstitutionModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L820-L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.checknetwork_LiNC!" href="#PhyloNetworks.checknetwork_LiNC!"><code>PhyloNetworks.checknetwork_LiNC!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">checknetwork_LiNC!(net::HybridNetwork, maxhybrid::Int, no3cycle::Bool,
    nohybridladder::Bool,
    constraints=TopologyConstraint[]::Vector{TopologyConstraint},
    verbose::Bool=false)</code></pre><p>Check that <code>net</code> is an adequate starting network before phyLiNC: remove nodes of degree 2 (possibly including the root); check that <code>net</code> meets the topological <code>constraints</code>, has no polytomies (except at species constraints), and <code>maxhybrid</code> of fewer reticulations. According to user-given options, also check for the absence of 3-cycles and/or hybrid ladders.</p><pre><code class="language-julia-repl">julia&gt; maxhybrid = 3;

julia&gt; net = readTopology(&quot;(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);&quot;);

julia&gt; preorder!(net) # for correct unzipping in checknetwork_LiNC!

julia&gt; PhyloNetworks.checknetwork_LiNC!(net, maxhybrid, true, true)
HybridNetwork, Rooted Network
8 edges
8 nodes: 4 tips, 1 hybrid nodes, 3 internal tree nodes.
tip labels: A, B, C, D
((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0,D:2.5);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L508-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.checkspeciesnetwork!-Tuple{HybridNetwork,Array{PhyloNetworks.TopologyConstraint,1}}" href="#PhyloNetworks.checkspeciesnetwork!-Tuple{HybridNetwork,Array{PhyloNetworks.TopologyConstraint,1}}"><code>PhyloNetworks.checkspeciesnetwork!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">checkspeciesnetwork!(network::HybridNetwork,
                     constraints::Vector{TopologyConstraint})</code></pre><p>Check that the network satisfies a number of requirements:</p><ul><li>no polytomies, other than at species constraints: throws an error otherwise</li><li>no unnecessary nodes: fuse edges at nodes with degree two, including at the root (hence the bang: <code>net</code> may be modified)</li><li>topology constraints are met.</li></ul><p>Output: true if all is good, false if one or more clades are violated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/moves_semidirected.jl#L709-L720">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.cleantaxonname-Tuple{AbstractString}" href="#PhyloNetworks.cleantaxonname-Tuple{AbstractString}"><code>PhyloNetworks.cleantaxonname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cleantaxonname(taxonname::AbstractString)</code></pre><p>Return a String with leading and trailing spaces removed, and interior spaces replaced by underscores: good for using as tip names in a network without causing future error when reading the newick description of the network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/moves_semidirected.jl#L840-L846">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.constraintviolated-Tuple{HybridNetwork,Array{PhyloNetworks.TopologyConstraint,1}}" href="#PhyloNetworks.constraintviolated-Tuple{HybridNetwork,Array{PhyloNetworks.TopologyConstraint,1}}"><code>PhyloNetworks.constraintviolated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraintviolated(network::HybridNetwork,
                   constraints::Vector{TopologyConstraint})</code></pre><p>True if <code>network</code> violates one (or more) of the constraints of type 1 (individuals in a species group) or type 2 (must be clades in the major tree). Warning: constraints of type 3 are not implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/moves_semidirected.jl#L145-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.defaultsubstitutionmodel" href="#PhyloNetworks.defaultsubstitutionmodel"><code>PhyloNetworks.defaultsubstitutionmodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">defaultsubstitutionmodel(network, modsymbol::Symbol, data::DataFrame,
              siteweights::Vector)</code></pre><p>Return a statistical substitution model (SSM) with appropriate state labels and a rate appropriate for the branch lengths in <code>net</code> (see <a href="#PhyloNetworks.startingrate-Tuple{HybridNetwork}"><code>startingrate</code></a>). The <code>data</code> frame must have the actual trait/site data in columns 2 and up, as when the species names are in column 1. For DNA data, the relative rate model is returned, with a stationary distribution equal to the empirical frequencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L1085-L1096">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.deleteEdge!-Tuple{HybridNetwork,PhyloNetworks.Edge}" href="#PhyloNetworks.deleteEdge!-Tuple{HybridNetwork,PhyloNetworks.Edge}"><code>PhyloNetworks.deleteEdge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deleteEdge!(net::HybridNetwork,  e::Edge, part=true)
deleteEdge!(net::QuartetNetwork, e::Edge)</code></pre><p>Delete edge <code>e</code> from <code>net.edge</code> and update <code>net.numEdges</code>. If <code>part</code> is true, update the network&#39;s partition field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L515-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.deleteLeaf!-Tuple{PhyloNetworks.Network,AbstractString}" href="#PhyloNetworks.deleteLeaf!-Tuple{PhyloNetworks.Network,AbstractString}"><code>PhyloNetworks.deleteLeaf!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>deleteLeaf!(net::HybridNetwork, leaf::AbstractString)</code> <code>deleteLeaf!(net::Network, leaf::Node)</code></p><p>Deletes the leaf taxon from the network. The leaf argument is the name of the taxon to delete.</p><p>Warnings:</p><ul><li>requires a level-1 network with up-to-date attributes for snaq! (e.g. non-missing branch lengths, gammaz, etc.)</li><li>does not care where the root is and does not update it to a sensible location if the root is affected by the leaf removal.</li><li>does not merge edges, i.e. does not remove all nodes of degree 2. Within snaq!, this is used to extract quartets and to keep track of which edge lengths in the original network map to the quartet network.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/pseudolik.jl#L349-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.deleteNode!-Tuple{HybridNetwork,PhyloNetworks.Node}" href="#PhyloNetworks.deleteNode!-Tuple{HybridNetwork,PhyloNetworks.Node}"><code>PhyloNetworks.deleteNode!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deleteNode!(net::HybridNetwork, n::Node)</code></pre><p>Delete node <code>n</code> from a network, i.e. removes it from net.node, and from net.hybrid or net.leaf as appropriate. Update attributes <code>numNodes</code>, <code>numTaxa</code>, <code>numHybrids</code>. Warning: <code>net.names</code> is <em>not</em> updated.</p><p>Warning: if the root is deleted, the new root is arbitrarily set to the first node in the list. This is intentional to save time because this function is used frequently in snaq!, which handles semi-directed (unrooted) networks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L459-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.deletehybridedge!" href="#PhyloNetworks.deletehybridedge!"><code>PhyloNetworks.deletehybridedge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deletehybridedge!(net::HybridNetwork, edge::Edge,
                  nofuse=false, unroot=false,
                  multgammas=false, simplify=true, keeporiginalroot=false)</code></pre><p>Delete a hybrid <code>edge</code> from <code>net</code> and return the network. The network does not have to be of level 1 and may contain polytomies, although each hybrid node must have exactly 2 parents. Branch lengths are updated, allowing for missing values.</p><p>If <code>nofuse</code> is false, when <code>edge</code> is removed, its child (hybrid) node is removed and its partner hybrid edge is removed. Its child edge is retained (below the hybrid node), fused with the former partner, with new length: old length + length of <code>edge</code>&#39;s old partner. Any 2-cycle is simplified into a single edge, unless <code>simplify</code> is false.</p><p>If <code>nofuse</code> is true, edges with descendant leaves are kept as is, and are not fused. Nodes are retained during edge removal, provided that they have at least one descendant leaf. The hybrid edge that is partner to <code>edge</code> becomes a tree edge, but has its γ value unchanged (it is not set to 1), since it is not merged with its child edge after removal of the reticulation.   Also, 2-cycles are not simplified if <code>nofuse</code> is true. That is, if we get 2 hybrid edges both from the same parent to the same child, these hybrid edges are retained without being fused into a single tree edge.</p><p>If <code>unroot</code> is false and if the root is up for deletion during the process, it will be kept if it&#39;s of degree 2 or more. A root node of degree 1 will be deleted unless <code>keeporiginalroot</code> is true.</p><p>If <code>multgammas</code> is true: inheritance weights are kept by multiplying together the inheritance γ&#39;s of edges that are merged. For example, if there is a hybrid ladder, the partner hybrid edge remains a hybrid edge (with a new partner), and its γ is the product of the two hybrid edges that have been fused. So it won&#39;t add up to 1 with its new partner&#39;s γ.</p><p>If <code>keeporiginalroot</code> is true, a root of degree one will not be deleted.</p><p>Warnings:</p><ul><li><code>containRoot</code> is updated, but this requires correct <code>isChild1</code> fields</li><li>if the parent of <code>edge</code> is the root and if <code>nofuse</code> is false, the root is moved to keep the network unrooted with a root of degree two.</li><li>does <em>not</em> update attributes needed for snaq! (like inCycle, edge.z, edge.y etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/deleteHybrid.jl#L296-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.deletehybridedgeLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,Bool,Array{PhyloNetworks.TopologyConstraint,1},PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}" href="#PhyloNetworks.deletehybridedgeLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,Bool,Array{PhyloNetworks.TopologyConstraint,1},PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.deletehybridedgeLiNC!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deletehybridedgeLiNC!(obj::SSM, currLik::Float64,
    no3cycle::Bool,
    constraints::Vector{TopologyConstraint},
    γcache::CacheGammaLiNC, lcache::CacheLengthLiNC)</code></pre><p>Deletes a random hybrid edge and updates SSM object as part of PhyLiNC optimization. Return true if the move is accepted, false if not.</p><p>Note: if net is tree-child and a hybrid edge is deleted, then the resulting network is still tree-child. But: if <code>net</code> has no hybrid ladders, deleting an existing reticulation may create a hybrid ladder. It happens if there is a reticulation above a W structure (tree node whose children are both hybrid nodes). This creates a problem if the user asked for <code>nohybridladder</code>: this request may not be met. fixit: In future, we could check for this case and prevent it.</p><p>For a description of arguments, see <a href="../public/#PhyloNetworks.phyLiNC!"><code>phyLiNC!</code></a>. Called by <a href="#PhyloNetworks.optimizestructure!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer,Bool,Bool,Integer,Integer,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>optimizestructure!</code></a>, which does some checks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L840-L861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.descendants" href="#PhyloNetworks.descendants"><code>PhyloNetworks.descendants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">descendants(edge::Edge, internal::Bool=false)</code></pre><p>Return the node numbers of the descendants of a given edge: all descendant nodes if <code>internal</code> is true (internal nodes and tips), or descendant tips only otherwise (defaults).</p><p><code>edge</code> should belong in a rooted network for which <code>isChild1</code> is up-to-date. Run <code>directEdges!</code> beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net5 = &quot;(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));&quot; |&gt; readTopology |&gt; directEdges! ;

julia&gt; PhyloNetworks.descendants(net5.edge[12], true) # descendants of 12th edge: all of them
7-element Array{Int64,1}:
 -6
 -7
  4
  6
  5
 -9
  7

julia&gt; PhyloNetworks.descendants(net5.edge[12]) # descendant leaves only
3-element Array{Int64,1}:
 4
 5
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/compareNetworks.jl#L204-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.directionalconflict-Tuple{HybridNetwork,PhyloNetworks.Node,PhyloNetworks.Edge,Bool}" href="#PhyloNetworks.directionalconflict-Tuple{HybridNetwork,PhyloNetworks.Node,PhyloNetworks.Edge,Bool}"><code>PhyloNetworks.directionalconflict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">directionalconflict(net::HybridNetwork, parent::Node, edge::Edge,
                    hybridpartnernew::Bool)</code></pre><p>Check if creating a hybrid edge down of <code>parent</code> node into the middle of <code>edge</code> would create a directed cycle in <code>net</code>, i.e. not a DAG. The proposed hybrid would go in the direction of <code>edge</code> down its child node if <code>hybridpartnernew</code> is true. Otherwise, both halves of <code>edge</code> would have their direction reversed, for the hybrid to go towards the original parent node of <code>edge</code>. Does <em>not</em> modify the network.</p><p>Output: <code>true</code> if a conflict would arise (non-DAG), <code>false</code> if no conflict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/addHybrid.jl#L233-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.discrete_backwardlikelihood_trait!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer}" href="#PhyloNetworks.discrete_backwardlikelihood_trait!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer}"><code>PhyloNetworks.discrete_backwardlikelihood_trait!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discrete_backwardlikelihood_trait!(obj::SSM, tree::Integer, ri::Integer)</code></pre><p>Update and return the backward likelihood (last argument <code>backwardlik</code>) assuming rate category <code>ri</code> and tree index <code>tree</code>, using current forward and backwards likelihoods in <code>obj</code>: these depend on the trait (or site) given to the last call to <code>discrete_corelikelihood_trait!</code>. Used by <code>ancestralStateReconstruction</code>.</p><p><strong>warning</strong>: assume correct transition probabilities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L976-L987">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.discrete_corelikelihood!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}" href="#PhyloNetworks.discrete_corelikelihood!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}"><code>PhyloNetworks.discrete_corelikelihood!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discrete_corelikelihood!(obj::StatisticalSubstitutionModel;
                         whichtrait::AbstractVector{Int} = 1:obj.nsites)</code></pre><p>Calculate the likelihood and update <code>obj.loglik</code> for discrete characters on a network, calling <a href="#PhyloNetworks.discrete_corelikelihood_trait!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer,Integer}"><code>discrete_corelikelihood_trait!</code></a>. The algorithm extracts all displayed trees and weighs the likelihood under all these trees. The object&#39;s partial likelihoods are updated:</p><ul><li>forward and direct partial likelihoods are re-used, one trait at a time,</li><li>overall likelihoods on each displayed tree, given each rate category and for each given site/trait: are cached in <code>_loglikcache</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L609-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.discrete_corelikelihood_trait!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer,Integer}" href="#PhyloNetworks.discrete_corelikelihood_trait!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer,Integer}"><code>PhyloNetworks.discrete_corelikelihood_trait!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discrete_corelikelihood_trait!(obj::SSM, t::Integer, ci::Integer, ri::Integer)</code></pre><p>Return the likelihood for tree <code>t</code>, trait (character/site) index <code>ci</code> and rate category <code>ri</code>. Update &amp; modify the forward &amp; directional log-likelihoods <code>obj.forwardlik</code> and <code>obj.directlik</code>, which are indexed by [state, node<em>number or edge</em>number]. Used by <a href="#PhyloNetworks.discrete_corelikelihood!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}"><code>discrete_corelikelihood!</code></a>.</p><p><strong>Preconditions</strong>: <code>obj.logtrans</code> updated, edges directed, nodes/edges preordered</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L655-L664">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.displayedNetworks!" href="#PhyloNetworks.displayedNetworks!"><code>PhyloNetworks.displayedNetworks!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">displayedNetworks!(net::HybridNetwork, node::Node, keepNode=false,
                   unroot=false, multgammas=false, keeporiginalroot=false)</code></pre><p>Extracts the two networks that simplify a given network at a given hybrid node: deleting either one or the other parent hybrid edge. If <code>nofuse</code> is true, the original edges (and nodes) are kept in both networks, provided that they have one or more descendant leaves. If <code>unroot</code> is true, the root will be deleted if it becomes of degree 2. If <code>keeporiginalroot</code> is true, the root is retained even if it is of degree 1.</p><ul><li>the original network is modified: the minor edge removed.</li><li>returns one HybridNetwork object: the network with the major edge removed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/compareNetworks.jl#L491-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.edgerelation-Tuple{PhyloNetworks.Edge,PhyloNetworks.Node,PhyloNetworks.Edge}" href="#PhyloNetworks.edgerelation-Tuple{PhyloNetworks.Edge,PhyloNetworks.Node,PhyloNetworks.Edge}"><code>PhyloNetworks.edgerelation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">edgerelation(e::Edge, node::Node, origin::Edge)</code></pre><p>Return a symbol:</p><ul><li><code>:origin</code> if <code>e</code> is equal to <code>origin</code>, and otherwise:</li><li><code>:parent</code> if <code>e</code> is a parent of <code>node</code>,</li><li><code>:child</code> if <code>e</code> is a child of <code>node</code></li></ul><p>using the <code>isChild1</code> attribute of edges. Useful when <code>e</code> iterates over all edges adjacent to <code>node</code> and when <code>origin</code> is one of the edges adjacent to <code>node</code>, to known the order in which these edges come.</p><p>example:</p><pre><code class="language-julia">labs = [edgerelation(e, u, uv) for e in u.edge] # assuming u is a node of edge uv
parentindex = findfirst(isequal(:parent), labs) # could be &#39;nothing&#39; if no parent
childindices = findall( isequal(:child), labs)  # vector. could be empty</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L196-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.fuseedgesat!" href="#PhyloNetworks.fuseedgesat!"><code>PhyloNetworks.fuseedgesat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fuseedgesat!(i::Integer,net::HybridNetwork, multgammas=false::Bool)</code></pre><p>Removes <code>i</code>th node in net.node, if it is of degree 2. The parent and child edges of this node are fused. Reverts the action of breakedge!.</p><p>returns the fused edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L442-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.gammaZero!-Tuple{HybridNetwork,DataCF,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}" href="#PhyloNetworks.gammaZero!-Tuple{HybridNetwork,DataCF,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.gammaZero!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>gammaZero</code> road map</p><p>Function that tries to fix a gamma zero problem (<code>h==0,1; t==0; hz==0,1</code>)</p><ol><li>First tries to do <code>changeDirection</code></li><li>If not successful from start, we call <code>moveHybrid</code></li><li>If successful move (change direction), we call <code>optBL</code> and check if we fixed the problem</li><li>If problem fixed and we do not have worse pseudolik, we return <code>success=true</code></li><li>If still problem or worse pseudolik, we call <code>moveHybrid</code></li></ol><p>** Important: ** Any function (<code>afterOptBL</code>) calling <code>gammaZero</code> is assuming that it only made a change, so if the returned value is true, then a change was made, and the other function needs to run <code>optBL</code> and check that all parameters are &#39;valid&#39;. If the returned value is false, then no change was possible and we need to remove a hybridization if the problem is h==0,1; hz==0,1. If the problem is t==0, we ignore this problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/snaq_optimization.jl#L517-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getChild-Tuple{PhyloNetworks.Edge}" href="#PhyloNetworks.getChild-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.getChild</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getChild(edge::Edge)</code></pre><p>Return child node using the <code>isChild1</code> attribute of the edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getChildEdge-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.getChildEdge-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getChildEdge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getChildEdge(node::Node)</code></pre><p>Return child edge below a hybrid node.</p><p>Warning: Does not check that the node is a hybrid. If not a hybrid, returns the first child edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L258-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getChildren-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.getChildren-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getChildren</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getChildren(node)</code></pre><p>return a vector with all children <em>nodes</em> of <code>node</code>. <strong>warning</strong>: assume <code>isChild1</code> field (for edges) are correct</p><p>To get all parent <em>nodes</em>: see <a href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>getParents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L735-L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getDataValue!-Tuple{IO,Int64,Array{Int64,1}}" href="#PhyloNetworks.getDataValue!-Tuple{IO,Int64,Array{Int64,1}}"><code>PhyloNetworks.getDataValue!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getdataValue!(s::IO, int, numLeft::Array{Int,1})</code></pre><p>Helper function for <code>parseEdgeData!</code>. Read a single floating point edge data value in a tree topology. Return -1.0 if no value exists before the next colon, return the value as a float otherwise. Modifies s by advancing past the next colon character. Only call this function to read a value when you know a numerical value exists!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L247-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getGammas-Tuple{HybridNetwork}" href="#PhyloNetworks.getGammas-Tuple{HybridNetwork}"><code>PhyloNetworks.getGammas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getGammas(net)</code></pre><p>Get inheritance γ&#39;s of major hybrid edges. Assume pre-order calculated already (with up-to-date field <code>nodes_changed</code>). See <a href="#PhyloNetworks.setGammas!-Tuple{HybridNetwork,Array{T,1} where T}"><code>setGammas!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L1690-L1695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getHeights-Tuple{HybridNetwork}" href="#PhyloNetworks.getHeights-Tuple{HybridNetwork}"><code>PhyloNetworks.getHeights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getHeights(net)</code></pre><p>Return the height (distance to the root) of all nodes, assuming a time-consistent network (where all paths from the root to a given hybrid node have the same length). Also assumes that the network has been preordered, because it uses <a href="#PhyloNetworks.getGammas-Tuple{HybridNetwork}"><code>getGammas</code></a> and <a href="#PhyloNetworks.setGammas!-Tuple{HybridNetwork,Array{T,1} where T}"><code>setGammas!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L1739-L1746">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getMajorParent-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.getMajorParent-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getMajorParent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getMajorParent(node)
getMinorParent(node)</code></pre><p>Return major or minor parent of a node using the <code>isChild1</code> field of edges (and assuming correct <code>isMajor</code> field). See also <a href="#PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}"><code>getMajorParentEdge</code></a> and <a href="#PhyloNetworks.getMinorParentEdge"><code>getMinorParentEdge</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L233-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getMajorParentEdge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getMajorParentEdge(node)
getMinorParentEdge(node)</code></pre><p>return the parent edge of a given node: the major / minor if hybrid. <strong>warning</strong>: assume isChild1 and isMajor attributes are correct</p><p>To get all parent <em>nodes</em>: see <a href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>getParents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L708-L716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getMinorParent" href="#PhyloNetworks.getMinorParent"><code>PhyloNetworks.getMinorParent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getMajorParent(node)
getMinorParent(node)</code></pre><p>Return major or minor parent of a node using the <code>isChild1</code> field of edges (and assuming correct <code>isMajor</code> field). See also <a href="#PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}"><code>getMajorParentEdge</code></a> and <a href="#PhyloNetworks.getMinorParentEdge"><code>getMinorParentEdge</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getMinorParentEdge" href="#PhyloNetworks.getMinorParentEdge"><code>PhyloNetworks.getMinorParentEdge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getMajorParentEdge(node)
getMinorParentEdge(node)</code></pre><p>return the parent edge of a given node: the major / minor if hybrid. <strong>warning</strong>: assume isChild1 and isMajor attributes are correct</p><p>To get all parent <em>nodes</em>: see <a href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>getParents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getParent-Tuple{PhyloNetworks.Edge}" href="#PhyloNetworks.getParent-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.getParent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getParent(e::Edge)</code></pre><p>Return parent node of edge <code>e</code> using the <code>isChild1</code> attribute of the edge. To get parents of nodes: see <a href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>getParents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.getParents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getParents(node)</code></pre><p>Get vector of all parent nodes of <code>n</code>, based on <code>isChild1</code> field (for edges). To get the parent node of an edge: see <a href="#PhyloNetworks.getParent-Tuple{PhyloNetworks.Edge}"><code>getParent</code></a>. To get individual parent edges (rather than all parent <em>nodes</em>): see <a href="#PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}"><code>getMajorParentEdge</code></a> and <code>getMinorParentEdge</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L688-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getPartner-Tuple{Any}" href="#PhyloNetworks.getPartner-Tuple{Any}"><code>PhyloNetworks.getPartner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getPartner(edge::Edge)
getPartner(edge::Edge, node::Node)</code></pre><p>Return hybrid partner of edge, that is, hybrid edge pointing to the same child as <code>edge</code>. Assumptions (not checked):</p><ul><li>correct <code>isChild1</code> field for <code>edge</code> and for hybrid edges</li><li>no in-coming polytomy: a node has 0, 1 or 2 parents, no more</li></ul><p>When <code>node</code> is given, it is assumed to be the child of <code>edge</code> (the first form calls the second).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L170-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getTipSubmatrix-Tuple{Array{T,2} where T,HybridNetwork}" href="#PhyloNetworks.getTipSubmatrix-Tuple{Array{T,2} where T,HybridNetwork}"><code>PhyloNetworks.getTipSubmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getTipSubmatrix(M, net; indexation=:both)</code></pre><p>Extract submatrix of M, with rows and/or columns corresponding to tips in the network, ordered like in <code>net.leaf</code>. In M, rows and/or columns are assumed ordered as in <code>net.nodes_changed</code>.</p><p>indexation: one of <code>:rows</code>, <code>:cols</code> or <code>:both</code>: are nodes numbers indexed in the matrix by rows, by columns, or both? Subsetting is taken accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/pairwiseDistanceLS.jl#L80-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getlengths-Tuple{Array{PhyloNetworks.Edge,1}}" href="#PhyloNetworks.getlengths-Tuple{Array{PhyloNetworks.Edge,1}}"><code>PhyloNetworks.getlengths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getlengths(edges::Vector{Edge})</code></pre><p>Vector of edge lengths for a vector of <code>edges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L1438-L1442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getparameters-Tuple{PhyloNetworks.RVASInv}" href="#PhyloNetworks.getparameters-Tuple{PhyloNetworks.RVASInv}"><code>PhyloNetworks.getparameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getparameters(obj::RateVariationAcrossSites)</code></pre><p>Return a copy of the alpha and/or pinv parameters of model <code>obj</code>, in a single vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L1287-L1292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getparamindex-Tuple{PhyloNetworks.RVASInv}" href="#PhyloNetworks.getparamindex-Tuple{PhyloNetworks.RVASInv}"><code>PhyloNetworks.getparamindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getparamindex(obj::RateVariationAcrossSites)</code></pre><p>Indices of parameters in (p_invariable, alpha).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L1309-L1313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hardwiredClusterDistance_unrooted-Tuple{HybridNetwork,HybridNetwork}" href="#PhyloNetworks.hardwiredClusterDistance_unrooted-Tuple{HybridNetwork,HybridNetwork}"><code>PhyloNetworks.hardwiredClusterDistance_unrooted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hardwiredClusterDistance_unrooted(net1::HybridNetwork, net2::HybridNetwork)</code></pre><p>Miminum hardwired cluster dissimilarity between the two networks, considered as unrooted (or semi-directed). This dissimilarity is defined as the minimum rooted distance, over all root positions that are compatible with the direction of hybrid edges. Called by <a href="../public/#PhyloNetworks.hardwiredClusterDistance"><code>hardwiredClusterDistance</code></a>.</p><p>To avoid repeating identical clusters, all degree-2 nodes are deleted before starting the comparison. Since rooting the network at a leaf creates a root node of degree 2 and an extra cluster, leaves are excluded from possible rooting positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/compareNetworks.jl#L732-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hashybridladder-Tuple{HybridNetwork}" href="#PhyloNetworks.hashybridladder-Tuple{HybridNetwork}"><code>PhyloNetworks.hashybridladder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hashybridladder(net::HybridNetwork)</code></pre><p>Return true if <code>net</code> contains a hybrid ladder: where a hybrid node&#39;s child is itself a hybrid node. This makes the network not treechild, assuming it is fully resolved. (One of the nodes does not have any tree-node child).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L1445-L1452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hybrid3cycle-Tuple{PhyloNetworks.Edge,PhyloNetworks.Edge}" href="#PhyloNetworks.hybrid3cycle-Tuple{PhyloNetworks.Edge,PhyloNetworks.Edge}"><code>PhyloNetworks.hybrid3cycle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hybrid3cycle(edge1::Edge, edge2::Edge)</code></pre><p>Check if proposed hybrid edge from <code>edge1</code> into <code>edge2</code> would create a 3 cycle, that is, if <code>edge1</code> and <code>edge2</code> have a node in common. (This move cannot create a 2-cycles because new nodes would be created in the middle of edges 1 and 2.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/addHybrid.jl#L221-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge}" href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge}"><code>PhyloNetworks.hybridEdges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hybridEdges(node::Node, e::Edge)</code></pre><p>Return the 2 edges connected to <code>node</code> other than <code>e</code>, in the same order as <code>node.edge</code>, except that <code>e</code> absent from the list.</p><p>Despite what the name suggest, <code>node</code> need not be a hybrid node! <code>node</code> is assumed to have 3 edges, though.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L763-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.hybridEdges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hybridEdges(node::Node)</code></pre><p>Return the 3 edges attached to <code>node</code> in a specific order [e1,e2,e3]. <strong>Warning</strong>: assume a level-1 network with node field <code>hasHybEdge</code> and edge field <code>inCycle</code> up-to-date.</p><p>If <code>node</code> is a hybrid node:</p><ul><li>e1 is the major hybrid parent edge of <code>node</code></li><li>e2 is the minor hybrid parent edge</li><li>e3 is the tree edge, child of <code>node</code>.</li></ul><p>If <code>node</code> is a tree node parent of one child edge:</p><ul><li>e1 is the hybrid edge, child of <code>node</code></li><li>e2 is the tree edge that belongs to the cycle created by e1</li><li>e3 is the other tree edge attached to <code>node</code> (not in a cycle)</li></ul><p>Otherwise:</p><ul><li>e3 is an external edge from <code>node</code> to a leaf, if one exists.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L689-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hybridatnode" href="#PhyloNetworks.hybridatnode"><code>PhyloNetworks.hybridatnode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hybridatnode!(net::HybridNetwork, nodeNumber::Integer)</code></pre><p>Change the status of edges in network <code>net</code>, to move the hybrid node in a cycle to the node with number <code>nodeNumber</code>. This node must be in one (and only one) cycle, otherwise an error will be thrown.</p><p><code>net</code> is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. Check and update the nodes&#39; field <code>inCycle</code>.</p><p><strong>example</strong></p><pre><code class="language-julia">net = readTopology(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
using PhyloPlots
plot(net, :R, showNodeNumber=true); # to locate nodes and their numbers. D of hybrid origin
hybridatnode!(net, -4)
plot(net, :R, showNodeNumber=true); # hybrid direction reversed: now 2B of hybrid origin</code></pre><pre><code class="language-none">hybridatnode!(net::HybridNetwork, hybrid::Node, newNode::Node)</code></pre><p>Move the reticulation from <code>hybrid</code> to <code>newNode</code>, which must in the same cycle. <code>net</code> is assumed to be of level 1, but <strong>no checks</strong> are made and fields are supposed up-to-date.</p><p>Called by <code>hybridatnode!(net, node number)</code>, which is itself called by <a href="../public/#PhyloNetworks.undirectedOtherNetworks"><code>undirectedOtherNetworks</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.inheritanceWeight-Tuple{HybridNetwork}" href="#PhyloNetworks.inheritanceWeight-Tuple{HybridNetwork}"><code>PhyloNetworks.inheritanceWeight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inheritanceWeight(tree::HybridNetwork)</code></pre><p>Return the <em>log</em> inheritance weight of a network or tree (as provided by <a href="../public/#PhyloNetworks.displayedTrees"><code>displayedTrees</code></a> with <code>nofuse</code> = true for instance). For a tree displayed in a network, its inheritance weight is the log of the product of γ&#39;s of all edges retained in the tree. To avoid underflow, the log is calculated: i.e. sum of log(γ) across retained edges.</p><p>If any edge has a negative γ, it is assumed to mean that its γ is missing, and the function returns <code>missing</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;);

julia&gt; trees = displayedTrees(net,0.0; nofuse=true);

julia&gt; PhyloNetworks.inheritanceWeight.(trees)
2-element Array{Float64,1}:
 -0.105361
 -2.30259 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/compareNetworks.jl#L556-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.initializeWeightsFromLeaves!-Tuple{AbstractArray,HybridNetwork,Any,Any,Symbol}" href="#PhyloNetworks.initializeWeightsFromLeaves!-Tuple{AbstractArray,HybridNetwork,Any,Any,Symbol}"><code>PhyloNetworks.initializeWeightsFromLeaves!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initializeWeightsFromLeaves!(w, net, tips, stateset, criterion)</code></pre><p>Modify weight in w: to Inf for w[n, i] if the &quot;tips&quot; data has a state different from the lineage state of index i at node number n. Assumes that w was initialized to 0 for the leaves.</p><p>criterion: should be one of <code>:softwired</code>, <code>:parental</code> or <code>:hardwired</code>.</p><ul><li>softwired parsimony: lineage states are in this order: ∅,{1},{2},{3},...,{nstates}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/parsimony.jl#L793-L802">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.initializeWeightsFromLeavesSoftwired!-Tuple{AbstractArray,HybridNetwork,Any,Any}" href="#PhyloNetworks.initializeWeightsFromLeavesSoftwired!-Tuple{AbstractArray,HybridNetwork,Any,Any}"><code>PhyloNetworks.initializeWeightsFromLeavesSoftwired!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initializeWeightsFromLeavesSoftwired!(w, net, tips, charset)</code></pre><p>Modify weight in w: to Inf for w[n, s] if the &quot;tips&quot; data has a state different from s at node number n. Assumes that w was initialized to 0 for the leaves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/parsimony.jl#L352-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.isconnected-Tuple{Any,Any}" href="#PhyloNetworks.isconnected-Tuple{Any,Any}"><code>PhyloNetworks.isconnected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isconnected(node1::Node, node2::Node)</code></pre><p>Check if two nodes are connected by an edge. Return true if connected, false if not connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L396-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.isdescendant-Tuple{PhyloNetworks.Node,PhyloNetworks.Node}" href="#PhyloNetworks.isdescendant-Tuple{PhyloNetworks.Node,PhyloNetworks.Node}"><code>PhyloNetworks.isdescendant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isdescendant(des:Node, anc::Node)</code></pre><p>Return true if <code>des</code> is a strict descendant of <code>anc</code>, using <code>isChild1</code> fields to determine the direction of edges. See <a href="#PhyloNetworks.isdescendant_undirected-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,PhyloNetworks.Edge}"><code>isdescendant_undirected</code></a> for a version that does not use <code>isChild1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/compareNetworks.jl#L260-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.isdescendant_undirected-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,PhyloNetworks.Edge}" href="#PhyloNetworks.isdescendant_undirected-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,PhyloNetworks.Edge}"><code>PhyloNetworks.isdescendant_undirected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isdescendant_undirected(des:Node, ancestor::Node, parentedge)</code></pre><p>Return <code>true</code> if <code>des</code> is a strict descendant of <code>ancestor</code> when starting from edge <code>parentedge</code> and going towards <code>ancestor</code> onward, regardless of the field <code>isChild1</code> of tree edges; <code>false</code> otherwise.</p><p>This is useful to know how descendant relationships would change as a result of reverting the direction of a tree edge, without actually modifying the direction (<code>isChild1</code>) of any edge.</p><p><code>parentedge</code> should be connected to <code>ancestor</code> (not checked). The direction of hybrid edges is respected (via <code>isChild1</code>), that is, the traversal does not go from the child to the parent of a hybrid edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/compareNetworks.jl#L296-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.ladderpartition-Tuple{HybridNetwork}" href="#PhyloNetworks.ladderpartition-Tuple{HybridNetwork}"><code>PhyloNetworks.ladderpartition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ladderpartition(tree::HybridNetwork)</code></pre><p>For each node in <code>tree</code>, calculate the clade below each child edge of the node, and each clade moving up the &quot;ladder&quot; from the node to the root. The output is a tuple of 2 vectors (node) of vector (clade) of vectors (taxon in clade): <code>below,above</code>. More specifically, for node number <code>n</code>, <code>below[n]</code> is generally of vector of 2 clades: one for the left child and one for the right child of the node (unless the node is of degree 2 or is a polytomy). <code>above[n]</code> contains the grade of clades above node number <code>n</code>.</p><p>WARNING: assumes that</p><ol><li>node numbers and edge numbers can be used as indices, that is, be all distinct, positive, covering exactly 1:#nodes and 1:#edges.</li><li>edges are corrected directed (<code>isChild1</code> is up-to-date) and nodes have been pre-ordered already (field <code>nodes_changed</code> up-to-date).</li></ol><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; tree = readTopology(&quot;(O,A,((B1,B2),(E,(C,D))));&quot;);

julia&gt; PhyloNetworks.resetNodeNumbers!(tree; checkPreorder=true, type=:postorder)

julia&gt; printNodes(tree)
node leaf  hybrid hasHybEdge name inCycle edges&#39;numbers
1    true  false  false      O    -1      1   
2    true  false  false      A    -1      2   
3    true  false  false      B1   -1      3   
4    true  false  false      B2   -1      4   
8    false false  false           -1      3    4    5   
5    true  false  false      E    -1      6   
6    true  false  false      C    -1      7   
7    true  false  false      D    -1      8   
9    false false  false           -1      7    8    9   
10   false false  false           -1      6    9    10  
11   false false  false           -1      5    10   11  
12   false false  false           -1      1    2    11  

julia&gt; below, above = PhyloNetworks.ladderpartition(tree);

julia&gt; below
12-element Array{Array{Array{Int64,1},1},1}:
 [[1]]                      
 [[2]]                      
 [[3]]                      
 [[4]]                      
 [[5]]                      
 [[6]]                      
 [[7]]                      
 [[3], [4]]                 
 [[6], [7]]                 
 [[5], [6, 7]]              
 [[3, 4], [5, 6, 7]]        
 [[1], [2], [3, 4, 5, 6, 7]]

julia&gt; for n in 8:12
         println(&quot;clades below node &quot;, n, &quot;: &quot;, join(below[n], &quot; &quot;))
       end
clades below node 8: [3] [4]
clades below node 9: [6] [7]
clades below node 10: [5] [6, 7]
clades below node 11: [3, 4] [5, 6, 7]
clades below node 12: [1] [2] [3, 4, 5, 6, 7]

julia&gt; above[8:12] # clades sister to and above nodes 8 through 12:
5-element Array{Array{Array{Int64,1},1},1}:
 [[5, 6, 7], [1], [2]]
 [[5], [3, 4], [1], [2]]
 [[3, 4], [1], [2]]     
 [[1], [2]]             
 []                     </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/compareNetworks.jl#L335-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.learnlabels-Tuple{Symbol,DataFrames.AbstractDataFrame}" href="#PhyloNetworks.learnlabels-Tuple{Symbol,DataFrames.AbstractDataFrame}"><code>PhyloNetworks.learnlabels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">learnlabels(model::Symbol, dat::DataFrame)</code></pre><p>Return unique non-missing values in <code>dat</code>, and check that these labels can be used to construct of substitution model of type <code>model</code>.</p><p><strong>examples:</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; dat = DataFrame(trait1 = [&quot;A&quot;, &quot;C&quot;, &quot;A&quot;, missing]); # 4×1 DataFrame

julia&gt; PhyloNetworks.learnlabels(:BTSM, dat)
2-element Array{String,1}:
 &quot;A&quot;
 &quot;C&quot;

julia&gt; PhyloNetworks.learnlabels(:JC69, dat)
2-element Array{String,1}:
 &quot;A&quot;
 &quot;C&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L1023-L1046">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.majoredgelength-Tuple{HybridNetwork}" href="#PhyloNetworks.majoredgelength-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgelength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">majoredgelength(net::HybridNetwork)</code></pre><p>Generate vector of edge lengths of major <code>net</code> edges organized in the same order as the <code>edge</code> matrix created via <code>majoredgematrix</code>. Considers values of <code>-1.0</code> as missing values, recognized as NA in <code>R</code>. Output: vector allowing for missing values.</p><p>Assume <code>nodes_changed</code> was updated, to list nodes in pre-order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A:3.1,(B:0.2)#H1:0.3::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);&quot;);

julia&gt; directEdges!(net); preorder!(net);

julia&gt; PhyloNetworks.majoredgelength(net)
8-element Array{Union{Missing, Float64},1}:
  missing
 0.7     
  missing
 1.1     
  missing
 3.1     
 0.3     
 0.2     </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/interop.jl#L60-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}" href="#PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgematrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">majoredgematrix(net::HybridNetwork)</code></pre><p>Matrix of major edges from <code>net</code> where edge[i,1] is the number of the parent node of edge i and edge[i,2] is the number of the child node of edge i. Assume <code>nodes_changed</code> was updated, to list nodes in pre-order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(A,(B,(C,D)));&quot;);

julia&gt; PhyloNetworks.resetNodeNumbers!(net);

julia&gt; PhyloNetworks.majoredgematrix(net)
6×2 Array{Int64,2}:
 5  1
 5  6
 6  2
 6  7
 7  3
 7  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/interop.jl#L19-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.makemissing!-Tuple{AbstractArray{T,1} where T}" href="#PhyloNetworks.makemissing!-Tuple{AbstractArray{T,1} where T}"><code>PhyloNetworks.makemissing!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makemissing!(x::AbstractVector)</code></pre><p>Turn to <code>missing</code> any element of <code>x</code> exactly equal to -1.0. Used for branch lengths and γs. <code>x</code> needs to accept missing values. If not, this can be done with <code>allowmissing(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/interop.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.mapAllelesCFtable!-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Array{Int64,1},Bool,AbstractString}" href="#PhyloNetworks.mapAllelesCFtable!-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Array{Int64,1},Bool,AbstractString}"><code>PhyloNetworks.mapAllelesCFtable!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mapAllelesCFtable!(quartet CF DataFrame, mapping DataFrame, columns, write?, filename)</code></pre><p>Modify (and return) the quartet concordance factor (CF) DataFrame: replace each allele name by the species name that the allele maps onto based on the mapping data frame. This mapping data frame should have columns named &quot;allele&quot; and &quot;species&quot; (see <code>rename!</code> to change column names if need be).</p><p>If <code>write?</code> is <code>true</code>, the modified data frame is written to a file named &quot;filename&quot;.</p><p>Warning: <a href="../public/#PhyloNetworks.mapAllelesCFtable"><code>mapAllelesCFtable</code></a> takes the quartet data file as its second argument, while <code>mapAllelesCFtable!</code> takes the quartet data (which it modifies) as its first argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/multipleAlleles.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.maxParsimonyNetRun1" href="#PhyloNetworks.maxParsimonyNetRun1"><code>PhyloNetworks.maxParsimonyNetRun1</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Road map for various functions behind maxParsimonyNet</p><pre><code class="language-none">maxParsimonyNet
maxParsimonyNetRun1
maxParsimonyNetRun1!</code></pre><p>All return their optimized network. Only maxParsimonyNet returns a rooted network (though all functions guarantee that the returned networks agree with the outgroup).</p><ul><li>maxParsimonyNet calls maxParsimonyNetRun1 per run, after a read(write(.)) of the starting network (to ensure level-1 and semi-directedness).</li><li>maxParsimonyNetRun1 will make a copy of the topology, and will call findStartingTopology! to modify the topology according to random NNI/move origin/move target moves. It then calls maxParsimonyNetRun1! on the modified network</li><li>maxParsimonyNetRun1! proposes new network with various moves (same moves as snaq), and stops when it finds the most parsimonious network, using <a href="../public/#PhyloNetworks.parsimonyGF"><code>parsimonyGF</code></a>.</li></ul><p>None of these functions allow for multiple alleles yet.</p><p>Note that the search algorithm keeps two HybridNetworks at a time: currT (current topology) and newT (proposed topology). Both are kept unrooted (semi-directed), otherwise the moves in proposedTop! function fail. We only root the topologies to calculate the parsimony, so we create a rooted copy (currTr, newTr) to compute parsimony score in this copied topology. We do not root and calculate parsimony score in the original HybridNetworks objects (currT,newT) because the computation of the parsimony score overwrites the inCycle attribute of the Nodes, which messes with the search moves.</p><p>Extensions:</p><ul><li>other criteria: hardwired, parental (only softwired implemented now)</li><li>remove level-1 restriction: this will involve changing the proposedTop! function to use rSPR or rNNI moves (instead of the level-1 moves coded for snaq!). We need:<ul><li>functions for rSPR and rNNI moves</li><li>create new proposedTop! function (proposedRootedTop?) to choose from the rSPR/rNNI/other moves</li><li>have the search in maxParsimonuNetRun1! to have rooted currT and rooted newT, instead of keeping semi-directed objects (currT, newT), only to root for the parsimony score (currTr, newTr)</li></ul></li><li>outgroup is currently String or Node number, but it would be good if it allowed Edge number as an option too. Not sure best way to distinguish between Node number and Edge number, which is why left as Node number for now.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/parsimony.jl#L1095">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.maxParsimonyNetRun1!" href="#PhyloNetworks.maxParsimonyNetRun1!"><code>PhyloNetworks.maxParsimonyNetRun1!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Road map for various functions behind maxParsimonyNet</p><pre><code class="language-none">maxParsimonyNet
maxParsimonyNetRun1
maxParsimonyNetRun1!</code></pre><p>All return their optimized network. Only maxParsimonyNet returns a rooted network (though all functions guarantee that the returned networks agree with the outgroup).</p><ul><li>maxParsimonyNet calls maxParsimonyNetRun1 per run, after a read(write(.)) of the starting network (to ensure level-1 and semi-directedness).</li><li>maxParsimonyNetRun1 will make a copy of the topology, and will call findStartingTopology! to modify the topology according to random NNI/move origin/move target moves. It then calls maxParsimonyNetRun1! on the modified network</li><li>maxParsimonyNetRun1! proposes new network with various moves (same moves as snaq), and stops when it finds the most parsimonious network, using <a href="public/#PhyloNetworks.parsimonyGF"><code>parsimonyGF</code></a>.</li></ul><p>None of these functions allow for multiple alleles yet.</p><p>Note that the search algorithm keeps two HybridNetworks at a time: currT (current topology) and newT (proposed topology). Both are kept unrooted (semi-directed), otherwise the moves in proposedTop! function fail. We only root the topologies to calculate the parsimony, so we create a rooted copy (currTr, newTr) to compute parsimony score in this copied topology. We do not root and calculate parsimony score in the original HybridNetworks objects (currT,newT) because the computation of the parsimony score overwrites the inCycle attribute of the Nodes, which messes with the search moves.</p><p>Extensions:</p><ul><li>other criteria: hardwired, parental (only softwired implemented now)</li><li>remove level-1 restriction: this will involve changing the proposedTop! function to use rSPR or rNNI moves (instead of the level-1 moves coded for snaq!). We need:<ul><li>functions for rSPR and rNNI moves</li><li>create new proposedTop! function (proposedRootedTop?) to choose from the rSPR/rNNI/other moves</li><li>have the search in maxParsimonuNetRun1! to have rooted currT and rooted newT, instead of keeping semi-directed objects (currT, newT), only to root for the parsimony score (currTr, newTr)</li></ul></li><li>outgroup is currently String or Node number, but it would be good if it allowed Edge number as an option too. Not sure best way to distinguish between Node number and Edge number, which is why left as Node number for now.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/parsimony.jl#L979-L1017">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}" href="#PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationgamma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minorreticulationgamma(net::HybridNetwork)</code></pre><p>Vector of minor edge gammas (inheritance probabilities) organized in the same order as in the matrix created via <code>minorreticulationmatrix</code>. Considers values of <code>-1.0</code> as missing values, recognized as NA in <code>R</code>. Output: vector allowing for missing values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;);

julia&gt; PhyloNetworks.minorreticulationgamma(net)
1-element Array{Union{Float64, Missings.Missing},1}:
 0.1</code></pre><pre><code class="language-none"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/interop.jl#L167-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}" href="#PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationlength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minorreticulationlength(net::HybridNetwork)</code></pre><p>Vector of lengths for the minor hybrid edges, organized in the same order as in the matrix created via <code>minorreticulationmatrix</code>. Replace values of <code>-1.0</code> with missing values recognized by <code>R</code>. Output: vector allowing for missing values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A:3.1,(B:0.2)#H1:0.4::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);&quot;);

julia&gt; PhyloNetworks.minorreticulationlength(net)
1-element Array{Union{Missing, Float64},1}:
 0.3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/interop.jl#L138-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}" href="#PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minorreticulationmatrix(net::HybridNetwork)</code></pre><p>Matrix of integers, representing the minor hybrid edges in <code>net</code>. edge[i,1] is the number of the parent node of the ith minor hybrid edge, and edge[i,2] is the number of its child node. Node numbers may be negative, unless they were modified by <code>resetNodeNumbers!</code>. Assumes correct <code>isChild1</code> fields.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;);
julia&gt; PhyloNetworks.minorreticulationmatrix(net)
1×2 Array{Int64,2}:
 -6  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/interop.jl#L107-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.moveHybrid!-Tuple{HybridNetwork,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}" href="#PhyloNetworks.moveHybrid!-Tuple{HybridNetwork,PhyloNetworks.Edge,Bool,Bool,Integer,Array{Int64,1}}"><code>PhyloNetworks.moveHybrid!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>moveHybrid</code> road map</p><p>Function that tries to fix a gamma zero problem (<code>h==0,1; t==0; hz==0,1</code>) after changing direction of hybrid edge failed. This function is called in <code>gammaZero</code>.</p><p>Arguments:</p><ul><li><code>closeN=true</code> will try move origin/target on all neighbors (first choose minor/major edge at random, then make list of all neighbor edges and tries to put the hybrid node in all the neighbors until successful move); if false, will delete and add hybrid until successful move up to N times (this is never tested)</li></ul><p>Returns true if change was successful (not testing <code>optBL</code> again), and false if we could not move anything</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/snaq_optimization.jl#L472-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.moveroot!" href="#PhyloNetworks.moveroot!"><code>PhyloNetworks.moveroot!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">moveroot!(net::HybridNetwork, constraints=TopologyConstraint[]::Vector{TopologyConstraint})</code></pre><p>Move the root to a randomly chosen non-leaf node that is different from the current root, and not within a constraint clade or species. Output: <code>true</code> if successul, <code>nothing</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/moves_semidirected.jl#L858-L864">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.nameinternalnodes!-Tuple{HybridNetwork,Any}" href="#PhyloNetworks.nameinternalnodes!-Tuple{HybridNetwork,Any}"><code>PhyloNetworks.nameinternalnodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nameinternalnodes!(net::HybridNetwork, prefix)</code></pre><p>Add names to nodes in <code>net</code> that don&#39;t already have a name. Leaves already have names; but if not, they will be give names as well. New node names will be of the form &quot;prefixI&quot; where I is an integer.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;((a:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);&quot;);

julia&gt; PhyloNetworks.nameinternalnodes!(net, &quot;I&quot;) # by default, shown without internal node names
HybridNetwork, Rooted Network
7 edges
7 nodes: 3 tips, 1 hybrid nodes, 3 internal tree nodes.
tip labels: a, b, c
((a:1.0,(b:1.0)#H1:1.0::0.8):5.0,(#H1:0.0::0.2,c:1.0):1.0);

julia&gt; writeTopology(net) # by default, writeTopology shows internal names if they exist
&quot;((a:1.0,(b:1.0)#H1:1.0::0.8)I1:5.0,(#H1:0.0::0.2,c:1.0)I2:1.0)I3;&quot;

julia&gt; net = readTopology(&quot;((int5:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);&quot;); # one taxon name starts with &quot;int&quot;

julia&gt; PhyloNetworks.nameinternalnodes!(net, &quot;int&quot;);

julia&gt; writeTopology(net)
&quot;((int5:1.0,(b:1.0)#H1:1.0::0.8)int6:5.0,(#H1:0.0::0.2,c:1.0)int7:1.0)int8;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L1464-L1492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.nchoose1234-Tuple{Int64}" href="#PhyloNetworks.nchoose1234-Tuple{Int64}"><code>PhyloNetworks.nchoose1234</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nchoose1234(nmax)</code></pre><p><code>nmax+1 x 4</code> matrix containing the binomial coefficient &quot;n choose k&quot; in row <code>n+1</code> and column <code>k</code>. In other words, <code>M[i,k]</code> gives &quot;i-1 choose k&quot;. It is useful to store these values and look them up to rank (a large number of) 4-taxon sets: see <a href="#PhyloNetworks.quartetrank-Tuple{AbstractArray{T,1} where T,Array{T,2} where T}"><code>quartetrank</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/types.jl#L397-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.nj!" href="#PhyloNetworks.nj!"><code>PhyloNetworks.nj!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nj!(D::Matrix{Float64}, names::AbstractVector{String}=String[];
    force_nonnegative_edges::Bool=false)</code></pre><p>Construct a phylogenetic tree from the input distance matrix and vector of names (as strings), using the Neighbour-Joinging algorithm (<a href="https://doi.org/10.1093/oxfordjournals.molbev.a040454">Satou &amp; Nei 1987</a>). The order of the <code>names</code> argument should match that of the row (and column) of the matrix <code>D</code>. With <code>force_nonnegative_edges</code> being <code>true</code>, any negative edge length is changed to 0.0 (with a message).</p><p>Warning: <code>D</code> is modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/nj.jl#L12-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.nni_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Bool,Bool,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}" href="#PhyloNetworks.nni_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Bool,Bool,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.nni_LiNC!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nni_LiNC!(obj::SSM, no3cycle::Bool, nohybridladder::Bool,
          constraints::Vector{TopologyConstraint},
          ftolAbs::Float64,
          γcache::CacheGammaLiNC, lcache::CacheLengthLiNC)</code></pre><p>Loop over possible edges for a nearest-neighbor interchange move until one is found. Performs move and compares the original and modified likelihoods. If the modified likelihood is greater than the original by <code>likAbs</code>, the move is accepted.</p><p>Return true if move accepted, false if move rejected. Return nothing if there are no nni moves possible in the network.</p><p>For arguments, see <a href="../public/#PhyloNetworks.phyLiNC!"><code>phyLiNC!</code></a>.</p><p>Called by <a href="#PhyloNetworks.optimizestructure!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer,Bool,Bool,Integer,Integer,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>optimizestructure!</code></a>, which is called by <a href="../public/#PhyloNetworks.phyLiNC!"><code>phyLiNC!</code></a>.</p><p>Note: an RR move does not change the best likelihood. RR means that there&#39;s a hybrid ladder, so it looks like a hard polytomy at the reticulation after unzipping. Theoretically, we could avoid the re-optimizing the likelihood accept the move: just change inheritance values to get same likelihood, and update the tree priors. <em>Not</em> done.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L680-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.nnimax-Tuple{PhyloNetworks.Edge}" href="#PhyloNetworks.nnimax-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.nnimax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nnimax(e::Edge)</code></pre><p>Return the number of NNI moves around edge <code>e</code>, assuming that the network is semi-directed. Return 0 if <code>e</code> is not internal, and more generally if either node attached to <code>e</code> does not have 3 edges.</p><p>Output: UInt8 (e.g. <code>0x02</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/moves_semidirected.jl#L347-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.norootbelow!-Tuple{PhyloNetworks.Edge}" href="#PhyloNetworks.norootbelow!-Tuple{PhyloNetworks.Edge}"><code>PhyloNetworks.norootbelow!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norootbelow!(e::Edge)</code></pre><p>Set <code>containRoot</code> to <code>false</code> for edge <code>e</code> and all edges below, recursively. The traversal stops if <code>e.containRoot</code> is already <code>false</code>, assuming that <code>containRoot</code> is already false all the way below down that edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L1156-L1162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.optBL!-Tuple{HybridNetwork,DataCF,Bool,Float64,Float64,Float64,Float64}" href="#PhyloNetworks.optBL!-Tuple{HybridNetwork,DataCF,Bool,Float64,Float64,Float64,Float64}"><code>PhyloNetworks.optBL!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>optBL</code> road map</p><p>Function that optimizes the numerical parameters (branch lengths and inheritance probabilities) for a given network. This function is called multiple times inside <code>optTopLevel!</code>.</p><ul><li>Input: network <code>net</code>, data <code>d</code></li><li>Numerical tolerances: <code>ftolAbs, ftolRel, xtolAbs, xtolRel</code></li><li>Function based on <code>MixedModels</code> <code>fit</code> function</li><li>The function assumes <code>net</code> has all the right attributes, and cannot check this inside because it would be inefficient</li></ul><p>Procedure:</p><ul><li><code>ht = parameters!(net)</code> extracts the vector of parameters to estimate <code>(h,t,gammaz)</code>, and sets as <code>net.ht</code>; identifies a bad diamond I, sets <code>net.numht</code> (vector of hybrid node numbers for h, edge numbers for t, hybrid node numbers for gammaz), and <code>net.index</code> to keep track of the vector of parameters to estimate</li><li><code>extractQuartet!(net,d)</code> does the following for all quartets in <code>d.quartet</code>:<ul><li>Extract quartet by deleting all leaves not in q -&gt; create <code>QuartetNetwork</code> object saved in <code>q.qnet</code></li><li>This network is ugly and does not have edges collapsed. This is done to keep a one-to-one correspondence between the edges in <code>q.qnet</code> and the edges in <code>net</code> (if we remove nodes with only two edges, we will lose this correspondence)</li><li>Calculate expected CF with <code>calculateExpCFAll</code> for a copy of <code>q.qnet</code>. We do this copy because we want to keep <code>q.qnet</code> as it is (without collapsed edges into one). The function will then save the <code>expCF</code> in <code>q.qnet.expCF</code></li></ul></li><li><code>calculateExpCFAll!(qnet)</code> will<ul><li>identify the type of quartet as type 1 (equivalent to a tree) or type 2 (minor CF different). Here the code will first clean up any hybrid node by removing nodes with only two edges before identifying the <code>qnet</code> (because identification depends on neighbor nodes to hybrid node); later, set <code>qnet.which</code> (1 or 2), <code>node.prev</code> (neighbor node to hybrid node), updates <code>node.k</code> (number of nodes in hybridization cycle, this can change after deleting the nodes with only two edges), <code>node.typeHyb</code> (1,2,3,4,5 depending on the number of nodes in the hybridization cycle and the origin/target of the minor hybrid edge; this attribute is never used).</li><li>eliminate hybridization: this will remove type 1 hybridizations first. If <code>qnet.which=1</code>, then the <code>qnet</code> is similar to a tree quartet, so it will calculate the internal length of the tree quartet: <code>qnet.t1</code>.</li><li>update split for <code>qnet.which=1</code>, to determine which taxa are together. For example, for the quartet 12|34, the split is [1,1,2,2] or [2,2,1,1], that is, taxon 1 and 2 are on the same side of the split. This will update <code>qnet.split</code></li><li>update formula for <code>qnet.which=1</code> to know the order of minorCF and majorCF in the vector <code>qnet.expCF</code>. That is, if the quartet is 1342 (order in <code>qnet.quartet.taxon</code>), then the expected CF should match the observed CF in 13|42, 14|32, 12|34 and the <code>qnet</code> is 12|34 (given by <code>qnet.split</code>), <code>qnet.formula</code> will be [2,2,1] minor, minor, major</li><li><code>calculateExpCF!(qnet)</code> for <code>qnet.which=1</code>, it will do <code>1-2/3exp(-qnet.t1)</code> if <code>qnet.formula[i]==1</code>, and <code>1/3exp(qnet.t1)</code> if <code>qnet.formula[i]==2</code>. For <code>qnet.which=2</code>, we need to make sure that there is only one hybrid node, and compute the major, minor1,minor2 expected CF in the order 12|34, 13|24, 14|23 of the taxa in <code>qnet.quartet.taxon</code></li></ul></li></ul><p>Then we create a <code>NLopt</code> object with algorithm BOBYQA and k parameters (length of ht). We define upper and lower bounds and define the objective function that should only depend on <code>x=(h,t,gz)</code> and g (gradient, which we do not have, but still need to put as argument).</p><p>The objective function <code>obj(x,g)</code> calls</p><ul><li><code>calculateExpCFAll!(d,x,net)</code> needs to be run after <code>extractQuartet(net,d)</code> that will update <code>q.qnet</code> for all quartet.  Assumes that <code>qnet.indexht</code> is updated already: we only need to do this at the beginning of <code>optBL!</code> because the topology is fixed at this point)<ul><li>First it will update the edge lengths according to x</li><li>If the <code>q.qnet.changed=true</code> (that is, any of <code>qnet</code> branches changed value), we need to call <code>calculateExpCFAll!(qnet)</code> on a copy of <code>q.qnet</code> (again because we want to leave <code>q.qnet</code> with the edge correspondence to <code>net</code>)</li></ul></li><li><code>update!(net,x)</code> simply saves the new x in <code>net.ht</code></li></ul><p>Finally, we call <code>NLopt.optimize</code>, and we update the <code>net.loglik</code> and <code>net.ht</code> at the end. After <code>optBL</code>, we want to call <code>afterOptBLAll</code> (or <code>afterOptBLAllMultipleAlleles</code>) to check if there are <code>h==0,1</code>; <code>t==0</code>; <code>hz==0,1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/snaq_optimization.jl#L297-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.optTopLevel!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},IO,Bool}" href="#PhyloNetworks.optTopLevel!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},IO,Bool}"><code>PhyloNetworks.optTopLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>optTopLevel</code> road map</p><p>Function that does most of the heavy-lifting of <code>snaq</code>. It optimizes the pseudolikelihood for a given starting topology, and returns the best network. Assumes that the starting topology is level-1 network, and has all the attributes correctly updated.</p><p>Input parameters:</p><ul><li>Starting topology <code>currT</code>, input data <code>DataCF</code> <code>d</code>, maximum number of hybridizations <code>hmax</code></li><li>Numerical optimization parameters: <code>liktolAbs, Nfail, ftolRel, ftolAbs, xtolRel, xtolAbs</code></li><li>Print parameters: <code>verbose, logfile, writelog</code></li><li>Parameters to tune the search in space of networks: <code>closeN=true</code> only propose move origin/target to neighbor edges (coded, but not tested with <code>closeN=false</code>), <code>Nmov0</code> vector with maximum number of trials allowed per type of move <code>(add, mvorigin, mvtarget, chdir, delete, nni)</code>, by default computed inside with coupon’s collector formulas</li></ul><p>The optimization procedure keeps track of</p><ul><li><code>movescount</code>: count of proposed moves,</li><li><code>movesgamma</code>: count of proposed moves to fix a gamma zero situation (see below for definition of this situation),</li><li><code>movesfail</code>: count of failed moves by violation of level-1 network (<code>inCycle</code> attribute) or worse pseudolikelihood than current,</li><li><code>failures</code>: number of failed proposals that had a worse pseudolikelihood</li></ul><p>Optimization procedure:</p><p>While the difference between current loglik and proposed loglik is greater than <code>liktolAbs</code>, or <code>failures&lt;Nfail</code>, or <code>stillmoves=true</code>:</p><ul><li><p><code>Nmov</code> is updated based on <code>newT</code>. The type of move proposed will depend on <code>newT</code> (which is the same as <code>currT</code> at this point). For example, if <code>currT</code> is a tree, we cannot propose move origin/target.</p></li><li><p><code>move = whichMove</code> selects randomly a type of move, depending on <code>Nmov,movesfail,hmax,newT</code> with weights 1/5 by default for all, and 0 for delete. These weights are adjusted depending on <code>newT.numHybrids</code> and <code>hmax</code>. If <code>newT.numHybrids</code> is far from <code>hmax</code>, we give higher probability to adding a new hybrid (we want to reach the <code>hmax</code> sooner, maybe not the best strategy, easy to change).  Later, we adjust the weights by <code>movesfail</code> (first, give weight of 0 if <code>movesfail[i]&gt;Nmov[i]</code>, that is, if we reached the maximum possible number of moves allowed for a certain type) and then increase the probability of the other moves.  So, unless one move has <code>w=0</code>, nothing changes. This could be improved by using the outlier quartets to guide the proposal of moves.</p></li><li><p><code>whichMove</code> will choose a move randomly from the weights, it will return <code>none</code> if no more moves allowed, in which case, the optimization ends</p></li><li><p><code>flag=proposedTop!(move, newT)</code> will modify <code>newT</code> based on <code>move</code>. The function <code>proposedTop</code> will return <code>flag=true</code> if the move was successful (the move succeeded by <code>inCycle</code>, <code>containRoot</code>, available edge to make the move (more details in <code>proposedTop</code>)). If <code>flag=false</code>, then <code>newT</code> is cleaned, except for the case of multiple alleles. The function <code>proposedTop</code> keeps count of <code>movescount</code> (successful move), <code>movesfail</code> (unsuccessful move),</p><p>Options:</p><p><code>random=true</code>: moves major/minor hybrid edge with prob h,1-h, respectively</p><p><code>N=10</code>: number of trials for NNI edge.</p></li><li><p>if(flag) Optimize branch lengths with <code>optBL</code></p><p>If <code>newT.loglik</code> is better than <code>currT.loglik</code> by <code>liktolAbs</code>, jump to <code>newT</code> (<code>accepted=true</code>) and fix <code>gamma=0, t=0</code> problems (more info on <code>afterOptBL</code>)</p><p>If(accepted)   <code>failures=0</code>, <code>movesfail=zeros</code>, <code>movescount</code> for successful move +1</p></li></ul><p>end while</p><p>After choosing the best network <code>newT</code>, we do one last more thorough optimization of branch lengths with <code>optBL</code>, we change non identifiable branch lengths to -1 and return <code>newT</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/snaq_optimization.jl#L1148-L1203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.optTopRun1!-Tuple{HybridNetwork,Any,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,IO,Bool,Float64}" href="#PhyloNetworks.optTopRun1!-Tuple{HybridNetwork,Any,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,IO,Bool,Float64}"><code>PhyloNetworks.optTopRun1!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optTopRun1!(net, liktolAbs, Nfail, d::DataCF, hmax, etc.)</code></pre><p>The function will run 1 run by modifying the starting topology and calling <code>optTopLevel</code>. See <a href="#PhyloNetworks.optTopRuns!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,AbstractString,AbstractString,Integer,Float64}"><code>optTopRuns!</code></a> for a roadmap.</p><p><code>probST</code> (default in snaq is 0.3) is the probability of starting one run at the same input tree. So, with probability <code>1-probST</code>, we will change the topology by a NNI move on a tree edge without neighbor hybrid. If the starting topology is a network, then with probability <code>1-probST</code> it will also modify one randomly chosen hybrid edge: with prob 0.5, the function will move origin, with prob 0.5 will do move target.</p><p>If there are multiple alleles (<code>d.repSpecies</code> not empty), then the function has to check that the starting topology does not violate the multiple alleles condition.</p><p>After modifying the starting topology with NNI and/or move origin/target, <code>optTopLevel</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/snaq_optimization.jl#L1708-L1727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.optTopRuns!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,AbstractString,AbstractString,Integer,Float64}" href="#PhyloNetworks.optTopRuns!-Tuple{HybridNetwork,Float64,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,AbstractString,AbstractString,Integer,Float64}"><code>PhyloNetworks.optTopRuns!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Road map for various functions behind <a href="../public/#PhyloNetworks.snaq!"><code>snaq!</code></a></p><pre><code class="language-none">snaq!
optTopRuns!
optTopRun1!
optTopLevel!
optBL!</code></pre><p>All return their optimized network.</p><ul><li><a href="../public/#PhyloNetworks.snaq!"><code>snaq!</code></a> calls <code>optTopRuns!</code> once, after a deep copy of the starting network. If the data contain multiple alleles from a given species, <code>snaq!</code> first expands the leaf for that species into 2 separate leaves, and merges them back into a single leaf after calling <code>optTopRuns!</code>.</li><li><code>optTopRuns!</code> calls <a href="#PhyloNetworks.optTopRun1!-Tuple{HybridNetwork,Any,Integer,DataCF,Integer,Float64,Float64,Float64,Float64,Bool,Bool,Array{Int64,1},Integer,IO,Bool,Float64}"><code>optTopRun1!</code></a> several (<code>nrun</code>) times. assumes level-1 network with &gt;0 branch lengths. assumes same tips in network as in data: i.e. 2 separate tips per species                                          that has multiple alleles. each call to <code>optTopRun1!</code> gets the same starting network.</li><li><code>optTopRun1!</code> calls <code>optTopLevel!</code> once, after deep copying + changing the starting network slightly.</li><li><code>optTopLevel!</code> calls <code>optBL!</code> various times and proposes new network with various moves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/snaq_optimization.jl#L1478-L1501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.optimizeallgammas_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,PhyloNetworks.CacheGammaLiNC,Int64}" href="#PhyloNetworks.optimizeallgammas_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,PhyloNetworks.CacheGammaLiNC,Int64}"><code>PhyloNetworks.optimizeallgammas_LiNC!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizeallgammas_LiNC!(obj::SSM, ftolAbs::Float64,
                        γcache::CacheGammaLiNC, maxeval=1000::Int)</code></pre><p>Optimize all γ&#39;s in a network, one by one using [<code>optimizegamma_LiNC!</code>] until <code>maxeval</code> γ&#39;s have been optimized or until the difference in log-likelihood falls below <code>ftolAbs</code>.</p><p>At the end: hybrid edges with γ=0 are deleted (if any).</p><p>Output: true if reticulations have been deleted, false otherwise. If true, <code>updateSSM!</code> needs to be called afterwards, with constraints if any. (Constraints are not known here). Before updating the displayed trees in the SSM, <a href="#PhyloNetworks.shrink2cycles!"><code>shrink2cycles!</code></a> or <a href="#PhyloNetworks.shrink3cycles!"><code>shrink3cycles!</code></a> could be called, if desired, despite the (slight?) change in likelihood that this shrinking would cause. 2/3-cycles are <em>not</em> shrunk here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L1470-L1487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.optimizealllengths_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.CacheLengthLiNC}" href="#PhyloNetworks.optimizealllengths_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.optimizealllengths_LiNC!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizealllengths_LiNC!(obj::SSM, lcache::CacheLengthLiNC)</code></pre><p>Optimize all branch lengths, except those below hybrid edges (whose lengths are not identifiable). Same assumptions as in <a href="#PhyloNetworks.optimizelocalBL_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.Edge,PhyloNetworks.CacheLengthLiNC}"><code>optimizelocalBL_LiNC!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L1255-L1261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.optimizegamma_LiNC!" href="#PhyloNetworks.optimizegamma_LiNC!"><code>PhyloNetworks.optimizegamma_LiNC!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimizegamma_LiNC!(obj::SSM, focusedge::Edge,
                ftolAbs::Float64, cache::CacheGammaLiNC, maxNR=10::Int)</code></pre><p>Optimize γ on a single hybrid <code>edge</code> using the Newton-Raphson method (the log-likelihood is concave). The new log-likelihood is returned after updating <code>obj</code> and its fields with the new γ.</p><p>The search stops if the absolute difference in log-likelihood between two consecutive iterations is below <code>ftolAbs</code>, or after <code>maxNR</code> Newton-Raphson iterations.</p><p>Warnings:</p><ul><li>no check that <code>edge</code> is hybrid</li><li><code>obj._loglikcache</code> and displayed trees (etc.) are assumed to be up-to-date, and is updated alongside the new γ.</li></ul><p>Used by <a href="#PhyloNetworks.optimizelocalgammas_LiNC!"><code>optimizelocalgammas_LiNC!</code></a> and <a href="#PhyloNetworks.optimizeallgammas_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,PhyloNetworks.CacheGammaLiNC,Int64}"><code>optimizeallgammas_LiNC!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L1604-L1624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.optimizelength_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.Edge,PhyloNetworks.CacheLengthLiNC,Any}" href="#PhyloNetworks.optimizelength_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.Edge,PhyloNetworks.CacheLengthLiNC,Any}"><code>PhyloNetworks.optimizelength_LiNC!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizelength_LiNC!(obj::SSM, edge::Edge, cache::CacheLengthLiNC, Qmatrix)</code></pre><p>Optimize the length of a single <code>edge</code> using a gradient method, if <code>edge</code> is not below a reticulation (the unzipped canonical version should have a length of 0 below reticulations). Output: nothing.</p><p>Warning: displayed trees are assumed up-to-date, with nodes preordered</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L1353-L1362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.optimizelocalBL_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.Edge,PhyloNetworks.CacheLengthLiNC}" href="#PhyloNetworks.optimizelocalBL_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.Edge,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.optimizelocalBL_LiNC!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizelocalBL_LiNC!(obj::SSM, edge::Edge, lcache::CacheLengthLiNC)</code></pre><p>Optimize branch lengths in <code>net</code> locally around <code>edge</code>. Update all edges that share a node with <code>edge</code> (including itself). Constrains branch lengths to zero below hybrid nodes. Return vector of updated <code>edges</code> (excluding constrained edges). The tolerance values and parameters controlling the search are set in <code>lcache</code>.</p><p>Used after <code>nni!</code> or <code>addhybridedge!</code> moves to update local branch lengths. See <a href="../public/#PhyloNetworks.phyLiNC!"><code>phyLiNC!</code></a>.</p><p>Assumptions:</p><ul><li>displayed trees in <code>obj</code> are up-to-date with nodes preordered, and <code>obj.priorltw</code> are up-to-date.</li><li>branch lengths are at or above the lower bound, and definitely non-negative.</li></ul><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A:2.0,(B:0.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);&quot;);

julia&gt; fastafile = abspath(joinpath(dirname(Base.find_package(&quot;PhyloNetworks&quot;)), &quot;..&quot;, &quot;examples&quot;, &quot;simple.aln&quot;));

julia&gt; obj = PhyloNetworks.StatisticalSubstitutionModel(net, fastafile, :JC69);

julia&gt; obj.loglik = -Inf64; # not calculated yet

julia&gt; e = obj.net.edge[4];

julia&gt; e.length
1.5

julia&gt; using Random; Random.seed!(1234);

julia&gt; PhyloNetworks.optimizelocalBL_LiNC!(obj, e, PhyloNetworks.CacheLengthLiNC(obj, 1e-6,1e-6,1e-2,1e-2, 10));

julia&gt; round(e.length, sigdigits=6) # we get the lower bound from PhyLiNC in this case
1.0e-8

julia&gt; writeTopology(obj.net; round=true)
&quot;(((A:0.338,(B:0.0)#H1:0.04::0.9):0.0,(C:0.6,#H1:1.0::0.1):0.0):0.0,D:2.0);&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L1286-L1328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.optimizelocalgammas_LiNC!" href="#PhyloNetworks.optimizelocalgammas_LiNC!"><code>PhyloNetworks.optimizelocalgammas_LiNC!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimizelocalgammas_LiNC!(obj::SSM, edge::Edge,
                          ftolAbs::Float64, γcache::CacheGammaLiNC,
                          maxeval=1000::Int)</code></pre><p>Optimize γ&#39;s in <code>net</code> locally around <code>edge</code>. Update all edges adjacent to <code>edge</code> (including itself), one by one using [<code>optimizegamma_LiNC!</code>] until <code>maxeval</code> γ&#39;s have been optimized or until the difference in log-likelihood falls below <code>ftolAbs</code>. <code>nothing</code> is returned.</p><p>Used after <code>nni!</code> or <code>addhybridedge!</code> moves to update local gammas.</p><p>Assumptions:</p><ul><li>correct <code>isChild1</code> field for <code>edge</code> and for hybrid edges</li><li>no in-coming polytomy: a node has 0, 1 or 2 parents, no more</li></ul><p>```jldoctest julia&gt; net = readTopology(&quot;(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);&quot;);</p><p>julia&gt; fastafile = abspath(joinpath(dirname(Base.find_package(&quot;PhyloNetworks&quot;)), &quot;..&quot;, &quot;examples&quot;, &quot;simple.aln&quot;));</p><p>julia&gt; obj = PhyloNetworks.StatisticalSubstitutionModel(net, fastafile, :JC69);</p><p>julia&gt; obj.net.edge[3].gamma 0.9</p><p>julia&gt; using Random; Random.seed!(1234);</p><p>julia&gt; PhyloNetworks.optimizelocalgammas_LiNC!(obj, obj.net.edge[3], 1e-3, PhyloNetworks.CacheGammaLiNC(obj));</p><p>julia&gt; obj.net.edge[3].gamma 0.0 ````</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L1523-L1557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.optimizestructure!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer,Bool,Bool,Integer,Integer,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}" href="#PhyloNetworks.optimizestructure!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Integer,Integer,Bool,Bool,Integer,Integer,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.optimizestructure!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizestructure!(obj::SSM, maxmoves::Integer, maxhybrid::Integer,
                   no3cycle::Bool, nohybridladder::Bool,
                   nreject::Integer, nrejectmax::Integer,
                   constraints::Vector{TopologyConstraint},
                   ftolAbs::Float64,
                   γcache::CacheGammaLiNC, lcache::CacheLengthLiNC)</code></pre><p>Alternate NNI moves, hybrid additions / deletions, and root changes based on their respective weights in <code>moveweights_LiNC</code> ([0.4, 0.2, 0.2, 0.2]). Branch lengths and hybrid γs around the NNI focal edge or around the added / deleted hybrid edge are optimized (roughly) on the proposed network. Each proposed network is accepted –or not– if the likelihood improves (or doesn&#39;t decrease much for hybrid deletion). After adding or removing a hybrid, <code>obj</code> is updated, to have correct displayed <code>trees</code> and node/edge numberings: done by <a href="#PhyloNetworks.nni_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Bool,Bool,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>nni_LiNC!</code></a>, <a href="#PhyloNetworks.addhybridedgeLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,Bool,Bool,Array{PhyloNetworks.TopologyConstraint,1},Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>addhybridedgeLiNC!</code></a> and <a href="#PhyloNetworks.deletehybridedgeLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Float64,Bool,Array{PhyloNetworks.TopologyConstraint,1},PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>deletehybridedgeLiNC!</code></a>.</p><p>Output: number of consecutive rejections so far.</p><p>The percent of nni moves, hybrid additions, hybrid deletions, and root changes to be performed is in <code>PhyloNetworks.moveweights_LiNC</code>.</p><ul><li><code>maxmoves</code>: maximum number of moves to be performed, including root changes, which don&#39;t actually change the semi-directed topology and likelihood.</li><li><code>nreject</code>: number of consecutive rejections (ignoring root changes), prior to starting the search (from a prior function call)</li><li><code>nrejectmax</code>: the search stops when there has been this number of moves that have been rejected in a row (ignoring root changes)</li></ul><p>For a description of other arguments, see <a href="../public/#PhyloNetworks.phyLiNC!"><code>phyLiNC!</code></a>.</p><p>Assumptions:</p><ul><li><code>checknetworkbeforeLiNC</code> and <code>discrete_corelikelihood!</code> have been called on <code>obj.net</code>.</li><li>starting with a network without 2- and 3- cycles (checked by <code>checknetworkbeforeLiNC</code>)</li></ul><p>Note: When removing a hybrid edge, always removes the minor edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L577-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.pairwiseTaxonDistanceGrad-Tuple{HybridNetwork}" href="#PhyloNetworks.pairwiseTaxonDistanceGrad-Tuple{HybridNetwork}"><code>PhyloNetworks.pairwiseTaxonDistanceGrad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pairwiseTaxonDistanceGrad(net; checkEdgeNumber=true, nodeAges=[])</code></pre><p>3-dim array: gradient of pairwise distances between all nodes. (internal and leaves); gradient with respect to edge lengths if <code>nodeAges</code> is empty; with respect to node ages otherwise. Assume correct <code>net.nodes_changed</code> (preorder).   This gradient depends on the network&#39;s topology and γ&#39;s only, not on branch lengths or node ages (distances are linear in either).</p><p>WARNING: edge numbers need to range between 1 and #edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/pairwiseDistanceLS.jl#L146-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parseEdgeData!-Tuple{IO,PhyloNetworks.Edge,Array{Int64,1}}" href="#PhyloNetworks.parseEdgeData!-Tuple{IO,PhyloNetworks.Edge,Array{Int64,1}}"><code>PhyloNetworks.parseEdgeData!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parseEdgeData!(s::IO, edge, numberOfLeftParentheses::Array{Int,1})</code></pre><p>Helper function for readSubtree!, fixes a bug from using setGamma Modifies <code>e</code> according to the specified edge length and gamma values in the tree topology. Advances the stream <code>s</code> past any existing edge data. Edges in a topology may optionally be followed by &quot;:edgeLen:bootstrap:gamma&quot; where edgeLen, bootstrap, and gamma are decimal values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L275-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parseHybridNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,String,HybridNetwork,Array{String,1}}" href="#PhyloNetworks.parseHybridNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,String,HybridNetwork,Array{String,1}}"><code>PhyloNetworks.parseHybridNode!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parseHybridNode!(node, parentNode, hybridName, net, hybrids)</code></pre><p>Helper function for <code>readSubtree!</code>. Create the parent edge for <code>node</code>. Return this edge, and the hybrid node retained (<code>node</code> or its clone in the newick string). Insert new edge and appropriate node into <code>net</code> and <code>hybrids</code> accordingly. Handles any type of given hybrid node. Called after a <code>#</code> has been found in a tree topology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L147-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parseRemainingSubtree!-Tuple{IO,Array{Int64,1},HybridNetwork,Array{String,1}}" href="#PhyloNetworks.parseRemainingSubtree!-Tuple{IO,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>PhyloNetworks.parseRemainingSubtree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parseRemainingSubtree!(s::IO, numLeft, net, hybrids)</code></pre><p>Create internal node. Helper for <a href="#PhyloNetworks.readSubtree!-Tuple{IO,PhyloNetworks.Node,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>readSubtree!</code></a>, which creates the parent edge of the node created by <code>parseRemainingSubtree!</code>: <code>readSubtree!</code> calls <code>parseRemainingSubtree!</code>, and vice versa. Called once a <code>(</code> has been read in a tree topology and reads until the corresponding <code>)</code> has been found. This function performs the recursive step for <code>readSubtree!</code>. Advances <code>s</code> past the subtree, adds discovered nodes and edges to <code>net</code>, and <code>hybrids</code>.</p><p>Does <em>not</em> read the node name and the edge information of the subtree root: this is done by <a href="#PhyloNetworks.readSubtree!-Tuple{IO,PhyloNetworks.Node,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>readSubtree!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L114-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parseTreeNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,HybridNetwork}" href="#PhyloNetworks.parseTreeNode!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.parseTreeNode!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parseTreeNode!(node, parentNode, net)</code></pre><p>Helper function for <code>readSubtree!</code>. Insert the input tree node and associated edge (created here) into <code>net</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parsimonyBottomUpFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}},Array{Int64,1}}} where T" href="#PhyloNetworks.parsimonyBottomUpFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}},Array{Int64,1}}} where T"><code>PhyloNetworks.parsimonyBottomUpFitch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parsimonyBottomUpFitch!(node, states, score)</code></pre><p>Bottom-up phase (from tips to root) of the Fitch algorithm: assign sets of character states to internal nodes based on character states at tips. Polytomies okay. Assumes a <em>tree</em> (no reticulation) and correct isChild1 attribute.</p><p>output: dictionary with state sets and most parsimonious score</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/parsimony.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parsimonyBottomUpGF!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray,AbstractArray,AbstractArray}" href="#PhyloNetworks.parsimonyBottomUpGF!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray,AbstractArray,AbstractArray}"><code>PhyloNetworks.parsimonyBottomUpGF!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parsimonyBottomUpGF!(node, blobroot, nchar, w, scores,
                     costmatrix1, costmatrix2)</code></pre><p>Compute the MP scores (one for each assignment of the blob root state) given the descendants of a blob, conditional on the states at predefined parents of hybrids in the blobs (one parent per hybrid) as described in</p><p>Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).</p><p>Assumes a set of state <em>guesses</em>, ie correct initialization of <code>w</code> for predefined hybrid parents, and correct <code>fromBadDiamondI</code> field for the children edges of these predefined parents. <code>fromBadDiamondI</code> is true for edges that are cut.</p><p>The field <code>isExtBadTriangle</code> is used to know which nodes are at the root of a blob. The field <code>isChild1</code> is used (and assumed correct). Field <code>inCycle</code> is assumed to store the # of detached parents (with guessed states)</p><ul><li><code>nchar</code>: number of characters considered at internal lineages. For softwired parsimony, this is # states + 1, because characters at internal nodes are ∅, {1}, {2}, etc. For parental parsimony, this is 2^#states -1, because characters are all sets on {1,2,...} except for the empty set ∅.</li><li><code>costmatrix1</code>[i,j] and <code>costmatrix2</code>[k][i,j]: 2d array and vector of 2d arrays containing the cost of going to character j starting from character i when the end node has a single parent, or the cost of a child node having character j when its parents have characters k and i. These cost matrices are pre-computed depending on the parsimony criterion (softwired, hardwired, parental etc.)</li></ul><p>used by <a href="../public/#PhyloNetworks.parsimonyGF"><code>parsimonyGF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/parsimony.jl#L827-L861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parsimonyBottomUpSoftwired!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray}" href="#PhyloNetworks.parsimonyBottomUpSoftwired!-Tuple{PhyloNetworks.Node,PhyloNetworks.Node,Integer,AbstractArray,AbstractArray}"><code>PhyloNetworks.parsimonyBottomUpSoftwired!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parsimonyBottomUpSoftwired!(node, blobroot, states, w, scores)</code></pre><p>Computing the MP scores (one for each assignment of the root state) of a swicthing as described in Algorithm 1 in the following paper:</p><p>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</p><p>Assumes a <em>switching</em> (ie correct <code>fromBadDiamondI</code> field) and correct isChild1 field. The field <code>isExtBadTriangle</code> is used to know which nodes are at the root of a blob.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/parsimony.jl#L160-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parsimonyDiscreteFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{String,T}}} where T" href="#PhyloNetworks.parsimonyDiscreteFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{String,T}}} where T"><code>PhyloNetworks.parsimonyDiscreteFitch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parsimonyDiscreteFitch(net, tipdata)</code></pre><p>Calculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network. Tip data can be given in a data frame, in which case the taxon names are to appear in column 1 or in a column named &quot;taxon&quot; or &quot;species&quot;, and trait values are to appear in column 2 or in a column named &quot;trait&quot;. Alternatively, tip data can be given as a dictionary taxon =&gt; trait.</p><p>also return the union of all optimized character states at each internal node as obtained by Fitch algorithm, where the union is taken over displayed trees with the MP score.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/parsimony.jl#L82-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parsimonySummaryFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{Int64,Set{T}}}} where T" href="#PhyloNetworks.parsimonySummaryFitch-Union{Tuple{T}, Tuple{HybridNetwork,Dict{Int64,Set{T}}}} where T"><code>PhyloNetworks.parsimonySummaryFitch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parsimonySummaryFitch(tree, nodestates)</code></pre><p>summarize character states at nodes, assuming a <em>tree</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/parsimony.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parsimonyTopDownFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}}}} where T" href="#PhyloNetworks.parsimonyTopDownFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node,Dict{Int64,Set{T}}}} where T"><code>PhyloNetworks.parsimonyTopDownFitch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parsimonyTopDownFitch!(node, states)</code></pre><p>Top-down phase (root to tips) of the Fitch algorithm: constrains character states at internal nodes based on the state of the root. Assumes a <em>tree</em>: no reticulation.</p><p>output: dictionary with state sets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/parsimony.jl#L42-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.phyLiNCone!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Int64,Bool,Bool,Int64,Int64,Bool,Bool,IO,Int64,Float64,Array{PhyloNetworks.TopologyConstraint,1},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}" href="#PhyloNetworks.phyLiNCone!-Tuple{PhyloNetworks.StatisticalSubstitutionModel,Int64,Bool,Bool,Int64,Int64,Bool,Bool,IO,Int64,Float64,Array{PhyloNetworks.TopologyConstraint,1},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,PhyloNetworks.CacheGammaLiNC,PhyloNetworks.CacheLengthLiNC}"><code>PhyloNetworks.phyLiNCone!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">phyLiNCone!(obj::SSM, maxhybrid::Int, no3cycle::Bool,
            nohybridladder::Bool, maxmoves::Int, nrejectmax::Int,
            verbose::Bool, writelog_1proc::Bool, logfile::IO,
            seed::Int, probST::Float64,
            constraints::Vector{TopologyConstraint},
            ftolRel::Float64, ftolAbs::Float64,
            xtolRel::Float64, xtolAbs::Float64,
            alphamin::Float64, alphamax::Float64,
            pinvmin::Float64, pinvmax::Float64,
            γcache::CacheGammaLiNC)</code></pre><p>Estimate one phylogenetic network (or tree) from concatenated DNA data, like <a href="../public/#PhyloNetworks.phyLiNC!"><code>phyLiNC!</code></a>, but doing one run only, and taking as input an StatisticalSubstitutionModel object <code>obj</code>. The starting network is <code>obj.net</code> and is assumed to meet all the requirements.</p><p><code>writelog_1proc</code> is passed by phyLiNC! an indicates if a log should be written. If the number of processors is &gt; 1, this will be false because workers can&#39;t write on streams opened by master. <code>logfile</code> will be stdout if <code>writelog_1proc</code> is false. Otherwise, it will be the log file created by <code>phyLiNC!</code>.</p><p>See <a href="../public/#PhyloNetworks.phyLiNC!"><code>phyLiNC!</code></a> for other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L412-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.posterior_logtreeweight" href="#PhyloNetworks.posterior_logtreeweight"><code>PhyloNetworks.posterior_logtreeweight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">posterior_logtreeweight(obj::SSM, trait = 1)</code></pre><p>Return an array A such that A[t] = log of P(tree <code>t</code> and trait <code>trait</code>) if a single <code>trait</code> is requested, or A[i,t]= log of P(tree <code>t</code> and trait <code>i</code>) if <code>trait</code> is a vector or range (e.g. <code>trait = 1:obj.nsites</code>). These probabilities are conditional on the model parameters in <code>obj</code>.</p><p><strong>Precondition</strong>: <code>_loglikcache</code> updated by <a href="#PhyloNetworks.discrete_corelikelihood!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}"><code>discrete_corelikelihood!</code></a></p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);&quot;);

julia&gt; m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [&quot;lo&quot;, &quot;hi&quot;]); # arbitrary rates

julia&gt; using DataFrames

julia&gt; dat = DataFrame(species=[&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;D&quot;], trait=[&quot;hi&quot;,&quot;lo&quot;,&quot;lo&quot;,&quot;hi&quot;]);

julia&gt; fit = fitdiscrete(net, m1, dat); # optimized rates: α=0.27 and β=0.35

julia&gt; pltw = PhyloNetworks.posterior_logtreeweight(fit)
2-element Array{Float64,1}:
 -0.08356519024776699
 -2.523619878044531  

julia&gt; exp.(pltw) # posterior trees probabilities (sum up to 1)
2-element Array{Float64,1}:
 0.9198311206979973 
 0.08016887930200293

julia&gt; round.(exp.(fit.priorltw), digits=4) # the prior tree probabilities are similar here (tiny data set!)
2-element Array{Float64,1}:
 0.9
 0.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L709-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.problem4cycle-NTuple{4,PhyloNetworks.Node}" href="#PhyloNetworks.problem4cycle-NTuple{4,PhyloNetworks.Node}"><code>PhyloNetworks.problem4cycle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">problem4cycle(β::Node, δ::Node, α::Node, γ::Node)</code></pre><p>Check if the focus edge uv has a 4 cycle that could lead to a 3 cycle after an chosen NNI. Return true if there is a problem 4 cycle, false if none.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/moves_semidirected.jl#L699-L704">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.proposedTop!-Tuple{Integer,HybridNetwork,Bool,Integer,Integer,Array{Int64,1},Array{Int64,1},Bool}" href="#PhyloNetworks.proposedTop!-Tuple{Integer,HybridNetwork,Bool,Integer,Integer,Array{Int64,1},Array{Int64,1},Bool}"><code>PhyloNetworks.proposedTop!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>proposedTop!(move,newT,random,count,N,movescount,movesfail,multall)</code> road map</p><p>Function to change the current network <code>newT</code> by a given <code>move</code>, and checks that the move was successful (correct attributes). If not successful, <code>newT</code> is changed back to its original state, except for the case of multiple alleles.</p><p><strong>Note</strong> that the update of attributes by each move is not done in all the network, but only in the local edges that were changed by the move. This is efficient (and makes a move easy to undo), but makes the code of each move function very clunky.</p><p>Arguments:</p><ul><li>move chosen from <code>whichMove</code> as described in <code>optTopLevel</code></li><li><code>newT</code> is the topology that will be modified inside with the move</li><li><code>random=true</code>: chooses minor hybrid edge with prob 1-h, and major edge with prob h, if false, always chooses minor hybrid edge</li><li><code>count</code>: simply which likelihood step we are in in the optimization at <code>optTopLevel</code></li><li><code>movescount</code> and <code>movesfail</code>: vector of counts of number of moves proposed</li><li><code>multall=true</code> if multiple alleles case: we need to check if the move did not violate the multiple alleles condition (sister alleles together and no gene flow into the alleles). This is inefficient because we are proposing moves that we can reject later, instead of being smart about the moves we propose: for example, move origin/target could rule out some neighbors that move gene flow into the alleles, the same for add hybridization; nni move can check if it is trying to separate the alleles)</li></ul><p>Moves:</p><ul><li><code>addHybridizationUpdate(newT,N)</code>:</li></ul><p>will choose a partition first (to avoid choosing edges that will create a non level-1 network) will choose two edges from this partition randomly, will not allow two edges in a cherry (non-identifiable), or sister edges that are not identifiable (the blacklist was a way to keep track of &quot;bad edges&quot; were we should not waste time trying to put hybridizations, it has never been used nor tested). Also choose gamma from U(0,0.5). The &quot;Update&quot; in the function name means that it creates the new hybrid, and also updates all the attributes of <code>newT</code></p><ul><li><code>node = chooseHybrid(newT)</code> choose a hybrid randomly for the next moves:</li><li><code>moveOriginUpdateRepeat!(newT,node,random)</code></li></ul><p>will choose randomly the minor/major hybrid edge to move (if <code>random=true</code>); will get the list of all neighbor edges where to move the origin, will move the origin and update all the attributes and check if the move was successful (not conflicting attributes); if not, will undo the move, and try with a different neighbor until it runs out of neighbors. Return true if the move was successful.</p><ul><li><code>moveTargetUpdateRepeat!(newT,node,random)</code></li></ul><p>same as move origin but moving the target</p><ul><li><code>changeDirectionUpdate!(newT,node,random)</code></li></ul><p>chooses minor/major hybrid edge at random (if `random=true), and changes the direction, and updates all the attributes. Checks if the move was successful (returns true), or undoes the change and returns false.</p><ul><li><code>deleteHybridizationUpdate!(newT,node)</code></li></ul><p>removes the hybrid node, updates the attributes, no need to check any attributes, always successful move</p><ul><li>NNIRepeat!(newT,N)</li></ul><p>choose an edge for nni that does not have a neighbor hybrid. It will try to find such an edge N times, and if it fails, it will return false (unsuccessful move). N=10 by default. If N=1, it rarely finds such an edge if the network is small or complex. The function cannot choose an external edge. it will update locally the attributes.</p><p>** Important: ** All the moves undo what they did if the move was not successful, so at the end you either have a <code>newT</code> with a new move and with all good attributes, or the same <code>newT</code> that started. This is important to avoid having to do deepcopy of the network before doing the move. Also, after each move, when we update the attributes, we do not update the attributes of the whole network, we only update the attributes of the edges that were affected by the move. This saves time, but makes the code quite clunky. Only the case of multiple alleles the moves does not undo what it did, because it finds out that it failed after the function is over, so just need to treat this case special.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/snaq_optimization.jl#L1026-L1068">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.quartetrank-Tuple{AbstractArray{T,1} where T,Array{T,2} where T}" href="#PhyloNetworks.quartetrank-Tuple{AbstractArray{T,1} where T,Array{T,2} where T}"><code>PhyloNetworks.quartetrank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quartetrank(t1,t2,t3,t4, nCk::Matrix)
quartetrank([t1,t2,t3,t4], nCk)</code></pre><p>Return the rank of a four-taxon set with taxon numbers <code>t1,t2,t3,t4</code>, assuming that <code>ti</code>s are positive integers such that t1&lt;t2, t2&lt;t3 and t3&lt;t4 (assumptions not checked!). <code>nCk</code> should be a matrix of &quot;n choose k&quot; binomial coefficients: see <a href="#PhyloNetworks.nchoose1234-Tuple{Int64}"><code>nchoose1234</code></a>.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; nCk = PhyloNetworks.nchoose1234(5)
6×4 Array{Int64,2}:
 0   0   0  0
 1   0   0  0
 2   1   0  0
 3   3   1  0
 4   6   4  1
 5  10  10  5

julia&gt; PhyloNetworks.quartetrank([1,2,3,4], nCk)
1

julia&gt; PhyloNetworks.quartetrank([3,4,5,6], nCk)
15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/types.jl#L360-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readCSVtoArray-Tuple{DataFrames.DataFrame}" href="#PhyloNetworks.readCSVtoArray-Tuple{DataFrames.DataFrame}"><code>PhyloNetworks.readCSVtoArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">readCSVtoArray(dat::DataFrame)
readCSVtoArray(filename::String)</code></pre><p>Read a CSV table containing both species names and data, create two separate arrays: one for the species names, a second for the data, in a format that <a href="../public/#PhyloNetworks.parsimonyGF"><code>parsimonyGF</code></a> needs.</p><p>Warning:</p><ul><li>it will try to find a column &#39;taxon&#39; or &#39;species&#39; for the taxon names. If none found, it will assume the taxon names are in column 1.</li><li>will use all other columns as characters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/parsimony.jl#L454-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readInputData-Tuple{AbstractString,AbstractString,Symbol,Integer,Bool,AbstractString,Bool,Bool}" href="#PhyloNetworks.readInputData-Tuple{AbstractString,AbstractString,Symbol,Integer,Bool,AbstractString,Bool,Bool}"><code>PhyloNetworks.readInputData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">readInputData(trees, quartetfile, whichQuartets, numQuartets, writetable, tablename, writeQfile, writesummary)
readInputData(trees, whichQuartets, numQuartets, taxonlist,   writetable, tablename, writeQfile, writesummary)</code></pre><p>Read gene trees and calculate the observed quartet concordance factors (CF), that is, the proportion of genes (and the number of genes) that display each quartet for a given list of four-taxon sets.</p><p>Input:</p><ul><li><code>trees</code>: name of a file containing a list of input gene trees, or vector of trees (<code>HybridNetwork</code> objects)</li></ul><p>Optional arguments (defaults):</p><ul><li><code>quartetfile</code>: name of a file containing a list of quartets, or more precisely, a list of four-taxon sets</li><li><code>whichQuartets</code> (<code>:all</code>): which quartets to sample. <code>:all</code> for all of them, <code>:rand</code> for a random sample.</li><li><code>numQuartets</code>: number of quartets in the sample. default: total number of quartets if <code>whichQuartets=:all</code> and 10% of total if <code>whichQuartets=:rand</code></li><li><code>taxonlist</code> (all in the input gene trees): If <code>taxonlist</code> is used, <code>whichQuartets</code> will consist of <em>all</em> sets of 4 taxa in the <code>taxonlist</code>. </li><li><code>writetable</code> (true): write the table of observed CF?</li><li><code>tablename</code> (&quot;tableCF.txt&quot;): if <code>writetable</code> is true, the table of observed CFs is write to file <code>tablename</code></li><li><code>writeQfile</code> (false): write intermediate file with sampled quartets?</li><li><code>writesummary</code> (true): write a summary file? if so, the summary will go in file &quot;summaryTreesQuartets.txt&quot;.</li></ul><p>Uses <a href="#PhyloNetworks.calculateObsCFAll!-Tuple{DataCF,Union{Array{Int64,1}, Array{String,1}}}"><code>calculateObsCFAll!</code></a>, which implements a slow algorithm.</p><p>See also: <a href="../public/#PhyloNetworks.countquartetsintrees"><code>countquartetsintrees</code></a>, which uses a much faster algorithm; <a href="../public/#PhyloNetworks.readTrees2CF"><code>readTrees2CF</code></a>, which is basically a re-naming of <code>readInputData</code>, and <a href="../public/#PhyloNetworks.readTableCF"><code>readTableCF</code></a> to read a table of quartet CFs directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readData.jl#L786-L822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readSubtree!-Tuple{IO,PhyloNetworks.Node,Array{Int64,1},HybridNetwork,Array{String,1}}" href="#PhyloNetworks.readSubtree!-Tuple{IO,PhyloNetworks.Node,Array{Int64,1},HybridNetwork,Array{String,1}}"><code>PhyloNetworks.readSubtree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">readSubtree!(s::IO, parentNode, numLeft, net, hybrids)</code></pre><p>Recursive helper method for <code>readTopology</code>: read a subtree from an extended Newick topology. input <code>s</code>: IOStream/IOBuffer.</p><p>Reads additional info formatted as: <code>:length:bootstrap:gamma</code>. Allows for name of internal nodes without # after closing parenthesis: (1,2)A. Warning if hybrid edge without γ, or if γ (ignored) without hybrid edge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L379-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.recursionPostOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Any}" href="#PhyloNetworks.recursionPostOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Any}"><code>PhyloNetworks.recursionPostOrder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">recursionPostOrder(nodes, init_function, tip_function, node_function,
                   parameters)
updatePostOrder(index, nodes, updated_matrix, tip_function, node_function,
                parameters)</code></pre><p>Generic tool to apply a post-order (or topological ordering) algorithm. Used by <code>descendenceMatrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L154-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.recursionPreOrder!" href="#PhyloNetworks.recursionPreOrder!"><code>PhyloNetworks.recursionPreOrder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">recursionPreOrder(nodes, init_function, root_function, tree_node_function,
                  hybrid_node_function, parameters)
recursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,
                   hybrid_node_function, parameters)
updatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,
               hybrid_node_function, parameters)</code></pre><p>Generic tool to apply a pre-order (or topological ordering) algorithm. Used by <code>sharedPathMatrix</code> and by <code>pairwiseTaxonDistanceMatrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.recursionPreOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Function,Any}" href="#PhyloNetworks.recursionPreOrder-Tuple{Array{PhyloNetworks.Node,1},Function,Function,Function,Function,Any}"><code>PhyloNetworks.recursionPreOrder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">recursionPreOrder(nodes, init_function, root_function, tree_node_function,
                  hybrid_node_function, parameters)
recursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,
                   hybrid_node_function, parameters)
updatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,
               hybrid_node_function, parameters)</code></pre><p>Generic tool to apply a pre-order (or topological ordering) algorithm. Used by <code>sharedPathMatrix</code> and by <code>pairwiseTaxonDistanceMatrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L74-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network,PhyloNetworks.Node}" href="#PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network,PhyloNetworks.Node}"><code>PhyloNetworks.removeHybrid!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">removeHybrid!(net::Network, n::Node)</code></pre><p>Delete a hybrid node <code>n</code> from <code>net.hybrid</code>, and update <code>net.numHybrid</code>. The actual node <code>n</code> is not deleted. It is kept in the full list <code>net.node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L547-L552">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.removedegree2nodes!-Tuple{HybridNetwork}" href="#PhyloNetworks.removedegree2nodes!-Tuple{HybridNetwork}"><code>PhyloNetworks.removedegree2nodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">removedegree2nodes!(net::HybridNetwork)</code></pre><p>Delete <em>all</em> nodes of degree two in <code>net</code>, fusing the two adjacent edges together each time, and return the network. If the network has a degree-2 root, then the root is eliminated as well, leaving the network unrooted.</p><p>See <a href="#PhyloNetworks.fuseedgesat!"><code>fuseedgesat!</code></a>.</p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((((S1,(S2)#H1),(#H1,S3)))#H2),(#H2,S4));&quot;);

julia&gt; PhyloNetworks.breakedge!(net.edge[3], net); # create a degree-2 node along hybrid edge

julia&gt; PhyloNetworks.breakedge!(net.edge[3], net); # another one: 2 in a row

julia&gt; PhyloNetworks.breakedge!(net.edge[10], net); # another one, elsewhere

julia&gt; writeTopology(net) # extra pairs of parentheses
&quot;((#H2,S4),(((((S1,(((S2)#H1))),(#H1,S3)))#H2)));&quot;

julia&gt; PhyloNetworks.removedegree2nodes!(net);

julia&gt; writeTopology(net) # even the root is gone
&quot;(#H2,S4,(((S1,(S2)#H1),(#H1,S3)))#H2);&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L493-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.resetEdgeNumbers!" href="#PhyloNetworks.resetEdgeNumbers!"><code>PhyloNetworks.resetEdgeNumbers!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resetEdgeNumbers!(net::HybridNetwork, verbose=true)</code></pre><p>Check that edge numbers of <code>net</code> are consecutive numbers from 1 to the total number of edges. If not, reset the edge numbers to be so.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L1134-L1139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.resetNodeNumbers!-Tuple{HybridNetwork}" href="#PhyloNetworks.resetNodeNumbers!-Tuple{HybridNetwork}"><code>PhyloNetworks.resetNodeNumbers!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">resetNodeNumbers!(net::HybridNetwork; checkPreorder=true, type=:ape)</code></pre><p>Change internal node numbers of <code>net</code> to consecutive numbers from 1 to the total number of nodes.</p><p>keyword arguments:</p><ul><li><code>type</code>: default is <code>:ape</code>, to get numbers that satisfy the conditions assumed by the <code>ape</code> R package: leaves are 1 to n, the root is n+1, and internal nodes are higher consecutive integers. If <code>:postorder</code>, nodes are numbered in post-order, with leaves from 1 to n (and the root last). If <code>:internalonly</code>, leaves are unchanged. Only internal nodes are modified, to take consecutive numbers from (max leaf number)+1 and up. With this last option, the post-ordering of nodes is by-passed.</li><li><code>checkPreorder</code>: if false, the <code>isChild1</code> edge field and the <code>net.nodes_changed</code> network field are supposed to be correct (to get nodes in preorder). This is not needed when <code>type=:internalonly</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(A,(B,(C,D)));&quot;);

julia&gt; PhyloNetworks.resetNodeNumbers!(net)

julia&gt; printNodes(net) # first column &quot;node&quot;: root is 5
node leaf  hybrid hasHybEdge name inCycle edges&#39;numbers
1    true  false  false      A    -1      1   
2    true  false  false      B    -1      2   
3    true  false  false      C    -1      3   
4    true  false  false      D    -1      4   
7    false false  false           -1      3    4    5   
6    false false  false           -1      2    5    6   
5    false false  false           -1      1    6   

julia&gt; net = readTopology(&quot;(A,(B,(C,D)));&quot;);

julia&gt; PhyloNetworks.resetNodeNumbers!(net; type=:postorder)

julia&gt; printNodes(net) # first column &quot;node&quot;: root is 7
node leaf  hybrid hasHybEdge name inCycle edges&#39;numbers
1    true  false  false      A    -1      1   
2    true  false  false      B    -1      2   
3    true  false  false      C    -1      3   
4    true  false  false      D    -1      4   
5    false false  false           -1      3    4    5   
6    false false  false           -1      2    5    6   
7    false false  false           -1      1    6   </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L1050-L1100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.rezip_canonical!-Tuple{Array{PhyloNetworks.Node,1},Array{PhyloNetworks.Edge,1},Array{Float64,1}}" href="#PhyloNetworks.rezip_canonical!-Tuple{Array{PhyloNetworks.Node,1},Array{PhyloNetworks.Edge,1},Array{Float64,1}}"><code>PhyloNetworks.rezip_canonical!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rezip_canonical!(hybridnodes::Vector{Node}, childedges::Vector{Edge},
                 originallengths::Vector{Float64})</code></pre><p>Undo <a href="#PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}"><code>unzip_canonical!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L1273-L1278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.sameTaxa-Tuple{Quartet,HybridNetwork}" href="#PhyloNetworks.sameTaxa-Tuple{Quartet,HybridNetwork}"><code>PhyloNetworks.sameTaxa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sameTaxa(Quartet, HybridNetwork)</code></pre><p>Return <code>true</code> if all taxa in the quartet are represented in the network, <code>false</code> if one or more taxa in the quartet does not appear in the network.</p><p>warning: the name can cause confusion. A more appropriate name might be &quot;in&quot;, or &quot;taxain&quot;, or &quot;taxonsubset&quot;, or etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readData.jl#L355-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.sampleBootstrapTrees-Tuple{Array{Array{HybridNetwork,1},1}}" href="#PhyloNetworks.sampleBootstrapTrees-Tuple{Array{Array{HybridNetwork,1},1}}"><code>PhyloNetworks.sampleBootstrapTrees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sampleBootstrapTrees(vector of tree lists; seed=0::Integer, generesampling=false, row=0)
sampleBootstrapTrees!(tree list, vector of tree lists; seed=0::Integer, generesampling=false, row=0)</code></pre><p>Sample bootstrap gene trees, 1 tree per gene. Set the seed with keyword argument <code>seed</code>, which is 0 by default. When <code>seed=0</code>, the actual seed is set using the clock. Assumes a vector of vectors of networks (see <code>readBootstrapTrees</code>), each one of length 1 or more (error if one vector is empty, tested in <code>bootsnaq</code>).</p><ul><li>site resampling: always, from sampling one bootstrap tree from each given list. This tree is sampled at <strong>random</strong> unless <code>row&gt;0</code> (see below).</li><li>gene resampling: if <code>generesampling=true</code> (default is false), genes (i.e. lists) are sampled with replacement.</li><li><code>row=i</code>: samples the ith bootstrap tree for each gene. <code>row</code> is turned back to 0 if gene resampling is true.</li></ul><p>output: one vector of trees. the modifying function (!) modifies the input tree list and returns it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/bootstrap.jl#L35-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.sampleCFfromCI" href="#PhyloNetworks.sampleCFfromCI"><code>PhyloNetworks.sampleCFfromCI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sampleCFfromCI(data frame, seed=0)
sampleCFfromCI!(data frame, seed=0)</code></pre><p>Read a data frame containing CFs and their credibility intervals, and sample new obsCF uniformly within the CIs. These CFs are then rescaled to sum up to 1 for each 4-taxon sets. Return a data frame with taxon labels in first 4 columns, sampled obs CFs in columns 5-7 and credibility intervals in columns 8-13.</p><ul><li>The non-modifying function creates a new data frame (with re-ordered columns) and returns it. If <code>seed=-1</code>, the new df is a deep copy of the input df, with no call to the random number generator. Otherwise, <code>seed</code> is passed to the modifying function.</li><li>The modifying function overwrites the input data frame with the sampled CFs and returns it. If <code>seed=0</code>, the random generator is seeded from the clock. Otherwise the random generator is seeded using <code>seed</code>.</li></ul><p>Warning: the modifying version does <em>not</em> check the data frame: assumes correct columns.</p><p>optional argument: <code>delim=&#39;,&#39;</code> by default: how columns are delimited.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/bootstrap.jl#L92-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setBLGammaParsimony!-Tuple{HybridNetwork}" href="#PhyloNetworks.setBLGammaParsimony!-Tuple{HybridNetwork}"><code>PhyloNetworks.setBLGammaParsimony!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>setBLGammaParsimony!(net::HybridNetwork)</p><p>Maximum parsimony function does not provide estimates for branch lengths, or gamma. But since the <code>maxParsimonyNet</code> function is using snaq move functions, branch lengths and gamma values are set randomly (to initialize optimization). We need to remove these random values before returning the maximum parsimony network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/descriptive.jl#L111-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setBranchLength!-Tuple{PhyloNetworks.Edge,Number}" href="#PhyloNetworks.setBranchLength!-Tuple{PhyloNetworks.Edge,Number}"><code>PhyloNetworks.setBranchLength!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setBranchLength!(Edge, newlength)</code></pre><p>Set the length of an Edge object. The new length needs to be non-negative, or -1.0 to be interpreted as missing. <code>edge.y</code> and <code>edge.z</code> are updated accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L849-L855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}" href="#PhyloNetworks.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.setGammaBLfromGammaz!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setGammaBLfromGammaz!(node, network)</code></pre><p>Update the γ values of the two sister hybrid edges in a bad diamond I, given the <code>gammaz</code> values of their parent nodes, and update the branch lengths t1 and t2 of their parent edges (those across from the hybrid nodes), in such a way that t1=t2 and that these branch lengths and γ values are consistent with the <code>gammaz</code> values in the network.</p><p>Similar to the first section of <a href="#PhyloNetworks.undoGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}"><code>undoGammaz!</code></a>, but does not update anything else than γ and t&#39;s. Unlike <code>undoGammaz!</code>, no error if non-hybrid <code>node</code> or not at bad diamond I.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L928-L939">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setGammas!-Tuple{HybridNetwork,Array{T,1} where T}" href="#PhyloNetworks.setGammas!-Tuple{HybridNetwork,Array{T,1} where T}"><code>PhyloNetworks.setGammas!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setGammas!(net, γ vector)</code></pre><p>Set inheritance γ&#39;s of hybrid edges, using input vector for <em>major</em> edges. Assume pre-order calculated already, with up-to-date field <code>nodes_changed</code>. See <a href="#PhyloNetworks.getGammas-Tuple{HybridNetwork}"><code>getGammas</code></a>.</p><p>Very different from <a href="../public/#PhyloNetworks.setGamma!"><code>setGamma!</code></a>, which focuses on a single hybrid event, updates the field <code>isMajor</code> according to the new γ, and is not used here.</p><p>May assume a tree-child network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L1708-L1719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setNonIdBL!-Tuple{HybridNetwork}" href="#PhyloNetworks.setNonIdBL!-Tuple{HybridNetwork}"><code>PhyloNetworks.setNonIdBL!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>setNonIdBL!(net)</code></p><p>Set non-identifiable edge branch lengths to -1.0 (i.e. missing) for a level-1 network <code>net</code>, except for edges in</p><ul><li>a good triangle: the edge below the hybrid is constrained to 0.</li><li>a bad diamond II: the edge below the hybrid is constrained to 0</li><li>a bad diamond I: the edges across from the hybrid node have non identifiable lengths but are kept, because the two γ*(1-exp(-t)) values are identifiable.</li></ul><p>will break if <code>inCycle</code> attributes are not initialized (at -1) or giving a correct node number.</p><p>see <a href="#PhyloNetworks.Node"><code>Node</code></a> for the meaning of boolean attributes <code>isBadTriangle</code> (which corresponds to a &quot;good&quot; triangle above), <code>isBadDiamondI</code> and <code>isBadDiamondII</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/descriptive.jl#L75-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setalpha!-Union{Tuple{S}, Tuple{PhyloNetworks.RVASGamma{S},Float64}} where S" href="#PhyloNetworks.setalpha!-Union{Tuple{S}, Tuple{PhyloNetworks.RVASGamma{S},Float64}} where S"><code>PhyloNetworks.setalpha!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setalpha!(obj, alpha)</code></pre><p>Set the shape parameter <code>alpha</code> in a RateVariationAcrossSites model <code>obj</code>, and update the rate multipliers accordingly. Return the modified object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L1160-L1166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.seteigeninfo!-Tuple{BinaryTraitSubstitutionModel{T} where T}" href="#PhyloNetworks.seteigeninfo!-Tuple{BinaryTraitSubstitutionModel{T} where T}"><code>PhyloNetworks.seteigeninfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>for a [<code>BinaryTraitSubstitutionModel</code>]: store eigenvalue (q<em>01+q</em>10) and stationary distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L290-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.seteigeninfo!-Tuple{EqualRatesSubstitutionModel{T} where T}" href="#PhyloNetworks.seteigeninfo!-Tuple{EqualRatesSubstitutionModel{T} where T}"><code>PhyloNetworks.seteigeninfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>for a [<code>EqualRatesSubstitutionModel</code>]: store lambda = k/(k-1), where k is the number of states</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L458-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.seteigeninfo!-Tuple{HKY85}" href="#PhyloNetworks.seteigeninfo!-Tuple{HKY85}"><code>PhyloNetworks.seteigeninfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>for <a href="../public/#PhyloNetworks.HKY85"><code>HKY85</code></a>: store piR, piY, the 2 non-zero eigenvalues and a scaling factor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L793-L795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.seteigeninfo!-Tuple{JC69}" href="#PhyloNetworks.seteigeninfo!-Tuple{JC69}"><code>PhyloNetworks.seteigeninfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>for <a href="../public/#PhyloNetworks.JC69"><code>JC69</code></a>: store lambda = 4/3 (if relative) or rate * 4/3 (absolute).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L695-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.seteigeninfo!-Tuple{PhyloNetworks.SubstitutionModel}" href="#PhyloNetworks.seteigeninfo!-Tuple{PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.seteigeninfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">seteigeninfo!(obj)</code></pre><p>Calculate eigenvalue &amp; eigenfector information for a substitution model (SM) object (as needed to calculate transition rate matrices) and store this info within the object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setlengths!-Tuple{Array{PhyloNetworks.Edge,1},Array{Float64,1}}" href="#PhyloNetworks.setlengths!-Tuple{Array{PhyloNetworks.Edge,1},Array{Float64,1}}"><code>PhyloNetworks.setlengths!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setlengths!(edges::Vector{Edge}, lengths::Vector{Float64})</code></pre><p>Assign new lengths to a vector of <code>edges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L1427-L1431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setparameters!-Tuple{PhyloNetworks.RVASInv,AbstractArray{T,1} where T}" href="#PhyloNetworks.setparameters!-Tuple{PhyloNetworks.RVASInv,AbstractArray{T,1} where T}"><code>PhyloNetworks.setparameters!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setparameters!(obj::RateVariationAcrossSites, par::AbstractVector)</code></pre><p>Set the values of the alpha and/or pinv parameters of model <code>obj</code>. See also <a href="#PhyloNetworks.setalpha!-Union{Tuple{S}, Tuple{PhyloNetworks.RVASGamma{S},Float64}} where S"><code>setalpha!</code></a>, <a href="#PhyloNetworks.setpinv!-Tuple{PhyloNetworks.RVASInv,Float64}"><code>setpinv!</code></a> and <a href="#PhyloNetworks.setpinvalpha!-Union{Tuple{S}, Tuple{PhyloNetworks.RVASGammaInv{S},Float64,Float64}} where S"><code>setpinvalpha!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L1297-L1302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setpinv!-Tuple{PhyloNetworks.RVASInv,Float64}" href="#PhyloNetworks.setpinv!-Tuple{PhyloNetworks.RVASInv,Float64}"><code>PhyloNetworks.setpinv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setpinv!(obj, pinv)</code></pre><p>Set the proportion of invariable sites <code>pinv</code> in a RateVariationAcrossSites model <code>obj</code>, and update the rate multipliers &amp; weights accordingly. For <code>RVASInvGamma</code> objects, the original rate multipliers are assumed correct, according to the original <code>pinv</code> value. Return the modified object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L1194-L1202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setpinvalpha!-Union{Tuple{S}, Tuple{PhyloNetworks.RVASGammaInv{S},Float64,Float64}} where S" href="#PhyloNetworks.setpinvalpha!-Union{Tuple{S}, Tuple{PhyloNetworks.RVASGammaInv{S},Float64,Float64}} where S"><code>PhyloNetworks.setpinvalpha!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setpinvalpha!(obj, pinv, alpha)</code></pre><p>Set the proportion of invariable sites <code>pinv</code> and the <code>alpha</code> parameter for the discretized gamma distribution in a model <code>obj</code> of type <code>RVASGammaInv{S}</code>. Update the rate multipliers &amp; weights accordingly. The mean of the distribution is constrained to 1.</p><p>Return the modified object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L1227-L1236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setrates!-Tuple{PhyloNetworks.SubstitutionModel,AbstractArray{T,1} where T}" href="#PhyloNetworks.setrates!-Tuple{PhyloNetworks.SubstitutionModel,AbstractArray{T,1} where T}"><code>PhyloNetworks.setrates!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setrates!(model, rates)</code></pre><p>update rates then call <a href="#PhyloNetworks.seteigeninfo!-Tuple{BinaryTraitSubstitutionModel{T} where T}"><code>seteigeninfo!</code></a> to update a model&#39;s eigeninfo</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.showQ-Tuple{IO,PhyloNetworks.SubstitutionModel}" href="#PhyloNetworks.showQ-Tuple{IO,PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.showQ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">showQ(IO, model)</code></pre><p>Print the Q matrix to the screen, with trait states as labels on rows and columns. adapted from prettyprint function by mcreel, found 2017/10 at https://discourse.julialang.org/t/display-of-arrays-with-row-and-column-names/1961/6</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/substitutionModels.jl#L146-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.shrink2cycleat!-Tuple{HybridNetwork,PhyloNetworks.Edge,PhyloNetworks.Edge,Bool}" href="#PhyloNetworks.shrink2cycleat!-Tuple{HybridNetwork,PhyloNetworks.Edge,PhyloNetworks.Edge,Bool}"><code>PhyloNetworks.shrink2cycleat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shrink2cycleat!(net::HybridNetwork, minor::Edge, major::Edge, unroot::Bool)</code></pre><p>Remove <code>minor</code> edge then update the branch length of the remaining <code>major</code> edge. Called by <a href="#PhyloNetworks.shrink2cycles!"><code>shrink2cycles!</code></a></p><p>Assumption: <code>minor</code> and <code>major</code> do form a 2-cycle. That is, they start and end at the same node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L1514-L1522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.shrink2cycles!" href="#PhyloNetworks.shrink2cycles!"><code>PhyloNetworks.shrink2cycles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shrink2cycles!(net::HybridNetwork, unroot=false::Bool)</code></pre><p>If <code>net</code> contains a 2-cycle, collapse the cycle into one edge of length tA + γt1+(1-γ)t2 + tB (see below), and return true. Return false otherwise. A 2-cycle is a set of 2 parallel hybrid edges, from the same parent node to the same hybrid child node.</p><pre><code class="language-none">       A                A
       | tA             |
     parent             |
       | \              |
t2,1-γ |  | t1,γ        | tA + γ*t1 + (1-γ)*t2 + tB
       | /              |
     hybrid             |
       | tB             |
       B                B</code></pre><p>If any of the lengths or gammas associated with a 2-cycle are missing, the combined length is missing. If γ is missing, branch lengths are calculated using γ=0.5.</p><p>If <code>unroot</code> is false and the root is up for deletion, it will be kept only if it is has degree 2 or more. If <code>unroot</code> is true and the root is up for deletion, it will be kept only if it has degree 3 or more. A root node with degree 1 will be deleted in both cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L1462-L1489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.shrink3cycleat!-Tuple{HybridNetwork,PhyloNetworks.Node,PhyloNetworks.Edge,PhyloNetworks.Edge,PhyloNetworks.Node,PhyloNetworks.Node,Bool}" href="#PhyloNetworks.shrink3cycleat!-Tuple{HybridNetwork,PhyloNetworks.Node,PhyloNetworks.Edge,PhyloNetworks.Edge,PhyloNetworks.Node,PhyloNetworks.Node,Bool}"><code>PhyloNetworks.shrink3cycleat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shrink3cycleat!(net::HybridNetwork, hybrid::Node, edge1::Edge, edge2::Edge,
                node1::Node, node2::Node, unroot::Bool)</code></pre><p>Replace a 3-cycle at a given <code>hybrid</code> node by a single node, if any. Assumption: <code>edge1</code> (<code>node1</code>) and <code>edge2</code> (<code>node2</code>) are the parent edges (nodes) of <code>hybrid</code>. Return true if a 3-cycle is found and removed, false otherwise. There is a 3-cycle if nodes 1 &amp; 2 are connected, by an edge called <code>e3</code> below.</p><p>There are two cases, with differing effects on the γ inheritance values and branch lengths.</p><p><strong>Hybrid case</strong>: the 3-cycle is shrunk to a hybrid node, which occurs if either node 1 or 2 is a hybrid node (that is, e3 is hybrid). If e3 goes from node 1 to node 2, the 3-cycle (left) is shrunk as on the right:</p><pre><code class="language-none">\eA      /eB           \eA  /eB
 1--e3-&gt;2       γ1+γ2γ3 \  / γ2(1-γ3)
  \    /               hybrid
 γ1\  /γ2
  hybrid</code></pre><p>with new branch lengths: new tA = tA + (γ1.t1 + γ2γ3.(t2+t3))/(γ1+γ2γ3), new tB = tB + t2, provided that γ1, γ2=1-γ1, and γ3 are not missing. If one of them is missing then γ1 and γ2 remain as is, and e3 is deleted naively, such that new tA = tA + t1 and new tB = tB + t2. If γ&#39;s are not missing but one of t1,t2,t3 is missing, then the γ&#39;s are updated to γ1+γ2γ3 and γ2(1-γ3), but t&#39;s are update naively.</p><p><strong>Tree case</strong>: the 3-cycle is shrunk to a tree node, which occurs if node 1 &amp; 2 are both tree nodes (that is, e3 is a tree edge). If eC is the child edge of <code>hybrid</code>, the 3-cycle (left) is shrunk as on the right:</p><pre><code class="language-none">\eA                  \eA
 1--e3--2--eB--       \
  \    /               n--eB--
 γ1\  /γ2              |
  hybrid               |eC
    |
    |eC</code></pre><p>with new branch lengths: new tA = tA + γ2.t3, new tB = tB + γ1.t3, new tC = tC + γ1.t1 + γ2.t2, provided that γ1, γ2=1-γ1, t1, t2 and t3 are not missing. If one is missing, then e1 is deleted naively such that tB is unchanged, new tC = tC + t2 and new tA = tA + t3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L1579-L1629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.shrink3cycles!" href="#PhyloNetworks.shrink3cycles!"><code>PhyloNetworks.shrink3cycles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shrink3cycles!(net::HybridNetwork, unroot=false::Bool)</code></pre><p>Remove all 2- and 3-cycles from a network.</p><p>Return true if <code>net</code> contains a 2-cycle or a 3-cycle; false otherwise. A 3-cycle (2-cycle) is a set of 3 (2) nodes that are all connected. One of them must be a hybrid node, since <code>net</code> is a DAG.</p><p>If <code>unroot</code> is false and the root is up for deletion, it will be kept only if it is has degree 2 or more. If <code>unroot</code> is true and the root is up for deletion, it will be kept only if it has degree 3 or more. A root node with degree 1 will be deleted in both cases.</p><p>See <a href="#PhyloNetworks.shrink3cycleat!-Tuple{HybridNetwork,PhyloNetworks.Node,PhyloNetworks.Edge,PhyloNetworks.Edge,PhyloNetworks.Node,PhyloNetworks.Node,Bool}"><code>shrink3cycleat!</code></a> for details on branch lengths and inheritance values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/auxiliary.jl#L1533-L1549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.sort_stringasinteger!-Tuple{Any}" href="#PhyloNetworks.sort_stringasinteger!-Tuple{Any}"><code>PhyloNetworks.sort_stringasinteger!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_stringasinteger!(taxa)</code></pre><p>Sort a vector of strings <code>taxa</code>, numerically if elements can be parsed as an integer, alphabetically otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readData.jl#L410-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.startingBL!" href="#PhyloNetworks.startingBL!"><code>PhyloNetworks.startingBL!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">startingBL!(net::HybridNetwork,
            trait::AbstractVector{Vector{Union{Missings.Missing,Int}}},
            siteweight=ones(length(trait[1]))::AbstractVector{Float64})</code></pre><p>Calibrate branch lengths in <code>net</code> by minimizing the mean squared error between the JC-adjusted pairwise distance between taxa, and network-predicted pairwise distances, using <a href="../public/#PhyloNetworks.calibrateFromPairwiseDistances!"><code>calibrateFromPairwiseDistances!</code></a>. <code>siteweight[k]</code> gives the weight of site (or site pattern) <code>k</code> (default: all 1s). Note: the network is not &quot;unzipped&quot;. PhyLiNC unzips reticulations later.</p><p>Assumptions:</p><ul><li>all species have the same number of traits (sites): <code>length(trait[i])</code> constant</li><li><code>trait[i]</code> is for leaf with <code>node.number = i</code> in <code>net</code>, and <code>trait[i][j] = k</code> means that leaf number <code>i</code> has state index <code>k</code> for trait <code>j</code>. These indices are those used in a substitution model: kth value of <code>getlabels(model)</code>.</li><li>Hamming distances are &lt; 0.75 with four states, or &lt; (n-1)/n for n states. If not, all pairwise hamming distances are scaled by <code>.75/(m*1.01)</code> where <code>m</code> is the maximum observed hamming distance, to make them all &lt; 0.75.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L1056-L1077">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.startingrate-Tuple{HybridNetwork}" href="#PhyloNetworks.startingrate-Tuple{HybridNetwork}"><code>PhyloNetworks.startingrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">startingrate(net)</code></pre><p>Estimate an evolutionary rate appropriate for the branch lengths in the network, which should be a good starting value before optimization in <code>fitdiscrete</code>, assuming approximately 1 change across the entire tree. If all edge lengths are missing, set starting rate to 1/(number of taxa).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L1064-L1071">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.symmetricNet" href="#PhyloNetworks.symmetricNet"><code>PhyloNetworks.symmetricNet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">symmetricNet(n, h, gamma)</code></pre><p>Create a string with a symmetric net with 2^n tips, numbered from 1 to 2^n The total height of the network is set to 1. Hybrids are added from level h to h-1 symmetrically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L1575-L1581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.symmetricNet-Tuple{Int64,Int64,Int64,Real,Real}" href="#PhyloNetworks.symmetricNet-Tuple{Int64,Int64,Int64,Real,Real}"><code>PhyloNetworks.symmetricNet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symmetricNet(n, i, j, gamma)</code></pre><p>Create a string with a symmetric net with 2^n tips, numbered from 1 to 2^n All the branch length are set equal to 1. One hybrid branch, going from level i to level j is added, with weigth gamma. The tree can be created with function readTopology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L1538-L1545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.symmetricTree" href="#PhyloNetworks.symmetricTree"><code>PhyloNetworks.symmetricTree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">symmetricTree(n, i=1)</code></pre><p>Create a string with a symmetric tree with 2^n tips, numbered from i to i+2^n-1. All the branch length are set equal to 1. The tree can be created with function readTopology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L1516-L1522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.synchronizePartnersData!-Tuple{PhyloNetworks.Edge,PhyloNetworks.Node}" href="#PhyloNetworks.synchronizePartnersData!-Tuple{PhyloNetworks.Edge,PhyloNetworks.Node}"><code>PhyloNetworks.synchronizePartnersData!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">synchronizePartnersData!(e::Edge, n::Node)</code></pre><p>Synchronize γ and isMajor for edges <code>e</code> and its partner, both hybrid edges with the same child <code>n</code>:</p><ul><li>if one γ is missing and the other is not: set the missing γ to 1 - the other</li><li>γ&#39;s should sum up to 1.0</li><li>update <code>isMajor</code> to match the γ information: the major edge is the one with γ &gt; 0.5.</li></ul><p><strong>Warnings</strong>: does not check that <code>e</code> is a hybrid edge, nor that <code>n</code> is the child of <code>e</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L303-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.taxadiff-Tuple{Array{Quartet,1},HybridNetwork}" href="#PhyloNetworks.taxadiff-Tuple{Array{Quartet,1},HybridNetwork}"><code>PhyloNetworks.taxadiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">taxadiff(Vector{Quartet}, network; multiplealleles=true)
taxadiff(DataCF, network; multiplealleles=true)</code></pre><p>Return 2 vectors:</p><ul><li>taxa in at least 1 of the quartets but not in the network, and</li><li>taxa in the network but in none of the quartets.</li></ul><p>When <code>multiplealleles</code> is true, the taxon names that end with &quot;__2&quot; are ignored in the quartets: they are not expected to appear in the networks that users give as input, or get as output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readData.jl#L371-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.traitlabels2indices-Tuple{AbstractArray{T,1} where T,PhyloNetworks.SubstitutionModel}" href="#PhyloNetworks.traitlabels2indices-Tuple{AbstractArray{T,1} where T,PhyloNetworks.SubstitutionModel}"><code>PhyloNetworks.traitlabels2indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">traitlabels2indices(data, model::SubstitutionModel)</code></pre><p>Check that the character states in <code>data</code> are compatible with (i.e. subset of) the trait labels in <code>model</code>. All columns are used. <code>data</code> can be a DataFrame or a Matrix (multiple traits), or a Vector (one trait). Return a vector of vectors (one per species) with integer entries, where each state (label) is replaced by its index in <code>model</code>. For DNA data, any ambiguous site is treated as missing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L759-L768">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.traverseContainRoot!-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge,Array{PhyloNetworks.Edge,1},Array{Bool,1}}" href="#PhyloNetworks.traverseContainRoot!-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge,Array{PhyloNetworks.Edge,1},Array{Bool,1}}"><code>PhyloNetworks.traverseContainRoot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updateContainRoot!(HybridNetwork, Node)
traverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})</code></pre><p>The input <code>node</code> to <code>updateContainRoot!</code> must be a hybrid node (can come from searchHybridNode). <code>updateContainRoot!</code> starts at the input node and calls <code>traverseContainRoot!</code>, which traverses the network recursively. By default, containRoot attributes of edges are true. Changes <code>containRoot</code> to false for all the visited edges: those below the input node, but not beyond any other hybrid node.</p><p><code>updateContainRoot!</code> Returns a <code>flag</code> and an array of edges whose containRoot has been changed from true to false. <code>flag</code> is false if the set of edges to place the root is empty</p><p>In <code>traverseContainRoot!</code>, <code>rightDir</code> turns false if hybridizations have incompatible directions (vector of length 1, to be modified).</p><p>Warning:</p><ul><li>does <em>not</em> update <code>containRoot</code> of minor hybrid edges.</li><li>assumes correct <code>isMajor</code> attributes: to stop the recursion at minor hybrid edges.</li><li>assumes correct hybrid attributes of both nodes &amp; edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).</li></ul><p><code>rightDir</code>: vector of length 1 boolean, to be mutable and modified by the function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/update.jl#L115-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.undoGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}" href="#PhyloNetworks.undoGammaz!-Tuple{PhyloNetworks.Node,HybridNetwork}"><code>PhyloNetworks.undoGammaz!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">undoGammaz!(node, network)</code></pre><p>Undo <code>updateGammaz!</code> for the 2 cases: bad diamond I,II. <code>node</code> should be a hybrid node. Set length to edges that were not identifiable and change edges&#39; <code>gammaz</code> attribute to -1.0. Recalculate branch lengths in terms of <code>gammaz</code>.   <em>warning</em>: needs to know <code>incycle</code> attributes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/undo.jl#L40-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}" href="#PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}"><code>PhyloNetworks.unzip_canonical!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unzip_canonical!(net::HybridNetwork)</code></pre><p>Unzip all reticulations: set the length of child edge to 0, and increase the length of both parent edges by the original child edge&#39;s length, to obtain the canonical version of the network according to Pardi &amp; Scornavacca (2015).</p><p>Output: vector of hybrid node in postorder, vector of child edges whose length is constrained to be 0, and vector of their original branch lengths to re-zip if needed using <a href="#PhyloNetworks.rezip_canonical!-Tuple{Array{PhyloNetworks.Node,1},Array{PhyloNetworks.Edge,1},Array{Float64,1}}"><code>rezip_canonical!</code></a>.</p><p>Assumption: <code>net.hybrid</code> is correct, but a preordering of all nodes is <em>not</em> assumed.</p><p>Note: This unzipping is not as straightforward as it might seem, because of &quot;nested&quot; zippers: when the child of a hybrid node is itself a hybrid node. The unzipping is propagated all the way through.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L1200-L1218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.unzipat_canonical!-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge}" href="#PhyloNetworks.unzipat_canonical!-Tuple{PhyloNetworks.Node,PhyloNetworks.Edge}"><code>PhyloNetworks.unzipat_canonical!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unzipat_canonical!(hybnode::Node, childedge::Edge)</code></pre><p>Unzip the reticulation a node <code>hyb</code>. See <a href="lib/ref"><code>unzip_canonical!</code></a>. Warning: no check that <code>hyb</code> has a single child.</p><p>Output: constrained edge (child of <code>hyb</code>) and its original length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/manipulateNet.jl#L1253-L1260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.updateBL!-Tuple{HybridNetwork,DataCF}" href="#PhyloNetworks.updateBL!-Tuple{HybridNetwork,DataCF}"><code>PhyloNetworks.updateBL!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updateBL!(net::HybridNetwork, d::DataCF)</code></pre><p>Update internal branch lengths of <code>net</code> based on the average quartet concordance factor (CF) across all quartets that exactly correspond to a given branch: new branch length = <code>-log(3/2(1-mean(CF observed in d)))</code>. <code>net</code> is assumed to be a tree, such that the above equation holds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readData.jl#L1081-L1088">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.updateContainRoot!" href="#PhyloNetworks.updateContainRoot!"><code>PhyloNetworks.updateContainRoot!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">updateContainRoot!(HybridNetwork, Node)
traverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})</code></pre><p>The input <code>node</code> to <code>updateContainRoot!</code> must be a hybrid node (can come from searchHybridNode). <code>updateContainRoot!</code> starts at the input node and calls <code>traverseContainRoot!</code>, which traverses the network recursively. By default, containRoot attributes of edges are true. Changes <code>containRoot</code> to false for all the visited edges: those below the input node, but not beyond any other hybrid node.</p><p><code>updateContainRoot!</code> Returns a <code>flag</code> and an array of edges whose containRoot has been changed from true to false. <code>flag</code> is false if the set of edges to place the root is empty</p><p>In <code>traverseContainRoot!</code>, <code>rightDir</code> turns false if hybridizations have incompatible directions (vector of length 1, to be modified).</p><p>Warning:</p><ul><li>does <em>not</em> update <code>containRoot</code> of minor hybrid edges.</li><li>assumes correct <code>isMajor</code> attributes: to stop the recursion at minor hybrid edges.</li><li>assumes correct hybrid attributes of both nodes &amp; edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).</li></ul><p><code>rightDir</code>: vector of length 1 boolean, to be mutable and modified by the function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/update.jl#L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.updatePostOrder!" href="#PhyloNetworks.updatePostOrder!"><code>PhyloNetworks.updatePostOrder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">recursionPostOrder(nodes, init_function, tip_function, node_function,
                   parameters)
updatePostOrder(index, nodes, updated_matrix, tip_function, node_function,
                parameters)</code></pre><p>Generic tool to apply a post-order (or topological ordering) algorithm. Used by <code>descendenceMatrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.updatePreOrder!" href="#PhyloNetworks.updatePreOrder!"><code>PhyloNetworks.updatePreOrder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">recursionPreOrder(nodes, init_function, root_function, tree_node_function,
                  hybrid_node_function, parameters)
recursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,
                   hybrid_node_function, parameters)
updatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,
               hybrid_node_function, parameters)</code></pre><p>Generic tool to apply a pre-order (or topological ordering) algorithm. Used by <code>sharedPathMatrix</code> and by <code>pairwiseTaxonDistanceMatrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traits.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.updateSSM!" href="#PhyloNetworks.updateSSM!"><code>PhyloNetworks.updateSSM!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">updateSSM!(obj::SSM, renumber=false::Bool;
           constraints=TopologyConstraint[]::Vector{TopologyConstraint})</code></pre><p>After adding or removing a hybrid, displayed trees will change. Updates the displayed tree list. Return SSM object.</p><p>if <code>renumber</code>, reorder edge and internal node numbers. Only need to renumber after deleting a hybrid (which could remove edges and nodes from the middle of the edge and node lists).</p><p>Assumptions:</p><ul><li>The SSM object has cache arrays of size large enough, that is, the constructor <a href="#PhyloNetworks.StatisticalSubstitutionModel"><code>StatisticalSubstitutionModel</code></a> was previously called with maxhybrid equal or greater than in <code>obj.net</code>. <code>obj.priorltw</code> is not part of the &quot;cache&quot; arrays.</li></ul><p>Warning: Does not update the likelihood.</p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);&quot;);

julia&gt; fastafile = abspath(joinpath(dirname(Base.find_package(&quot;PhyloNetworks&quot;)), &quot;..&quot;, &quot;examples&quot;, &quot;simple.aln&quot;));

julia&gt; obj = PhyloNetworks.StatisticalSubstitutionModel(net, fastafile, :JC69; maxhybrid=3);

julia&gt; PhyloNetworks.checknetwork_LiNC!(obj.net, 3, true, true);

julia&gt; using Random; Random.seed!(432);

julia&gt; PhyloNetworks.addhybridedge!(obj.net, obj.net.edge[8], obj.net.edge[1], true, 0.0, 0.4);

julia&gt; writeTopology(obj.net)
&quot;(((B:1.0)#H1:0.1::0.9,(A:1.0)#H2:1.0::0.6):1.5,(C:0.6,#H1:1.0::0.1):1.0,(D:1.25,#H2:0.0::0.4):1.25);&quot;

julia&gt; length(obj.displayedtree) # still as if 1 single reticulation
2

julia&gt; PhyloNetworks.updateSSM!(obj);

julia&gt; length(obj.displayedtree) # now correct 4 displayed treess: 2 reticulations
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L929-L973">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.updateSSM_root!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}" href="#PhyloNetworks.updateSSM_root!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}"><code>PhyloNetworks.updateSSM_root!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updateSSM_root!(obj::SSM)</code></pre><p>Update root and direction of edges in displayed trees to match the root in the network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L1022-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.update_logtrans-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.Edge}" href="#PhyloNetworks.update_logtrans-Tuple{PhyloNetworks.StatisticalSubstitutionModel,PhyloNetworks.Edge}"><code>PhyloNetworks.update_logtrans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_logtrans(obj::SSM, edge::Edge)</code></pre><p>Update the log-transition probabilities associates to one particular <code>edge</code> in the network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L593-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.update_logtrans-Tuple{PhyloNetworks.StatisticalSubstitutionModel}" href="#PhyloNetworks.update_logtrans-Tuple{PhyloNetworks.StatisticalSubstitutionModel}"><code>PhyloNetworks.update_logtrans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_logtrans(obj::SSM)</code></pre><p>Initialize and update <code>obj.logtrans</code>, the log transition probabilities along each edge in the full network. They are re-used for each displayed tree, which is why edges are not fused around degree-2 nodes when extracting displayed trees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L572-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.updatecache_edge!-Tuple{PhyloNetworks.CacheLengthLiNC,PhyloNetworks.StatisticalSubstitutionModel,Any}" href="#PhyloNetworks.updatecache_edge!-Tuple{PhyloNetworks.CacheLengthLiNC,PhyloNetworks.StatisticalSubstitutionModel,Any}"><code>PhyloNetworks.updatecache_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updatecache_edge!(lcache::CacheLengthLiNC, obj::SSM, focusedge)</code></pre><p>Update fields in <code>lcache</code>, to correspond to the forward likelihood at the child node of the focus edge, backwards (at parent node) x directional (at sister edges) likelihoods, and keep track of which displayed trees do have the focus edge. These don&#39;t change if the length of the focus edge is modified. These quantities are then rescaled on the log scale (to get a max of 0) and exponentiated to get back to the probability scale.</p><p>Assumptions: the following fields of <code>obj</code> are up-to-date:</p><ul><li>displayed trees, with nodes preordered</li><li>prior log tree weights in <code>.priorltw</code></li><li>log transition probabilities in <code>.logtrans</code></li></ul><p>Output:</p><ul><li>missing, if the edge length does not affect the likelihood,</li><li>constant used to rescale each site on the log scale, otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/phyLiNCoptimization.jl#L1162-L1181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.updateconstraintfields!-Tuple{Array{PhyloNetworks.TopologyConstraint,1},HybridNetwork}" href="#PhyloNetworks.updateconstraintfields!-Tuple{Array{PhyloNetworks.TopologyConstraint,1},HybridNetwork}"><code>PhyloNetworks.updateconstraintfields!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updateconstraintfields!(constraints::Vector{TopologyConstraint}, net::HybridNetwork)</code></pre><p>Update fields stem <code>edge</code> and crown <code>node</code> to match the given <code>net</code>.</p><p>Assumes that the constraints are still met in <code>net</code>, and that nodes &amp; edges are numbered identically in <code>net</code> as in the network used to create all <code>constraints</code>.</p><p>fixit: remove the assumption that constraints are still met, since an NNI near the crown of a constrained clade might change the crown node and / or the stem edge (u and v exchange).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/moves_semidirected.jl#L244-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.updateconstraints!-Tuple{Array{PhyloNetworks.TopologyConstraint,1},HybridNetwork}" href="#PhyloNetworks.updateconstraints!-Tuple{Array{PhyloNetworks.TopologyConstraint,1},HybridNetwork}"><code>PhyloNetworks.updateconstraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updateconstraints!(constraints::Vector{TopologyConstraint}, net::HybridNetwork)</code></pre><p>Update the set <code>taxonnum</code> in each constraint, assuming that the stem edge and the crown node are still correct, and that their descendants are still correct. May be needed if the node and edge numbers were modified by <a href="#PhyloNetworks.resetNodeNumbers!-Tuple{HybridNetwork}"><code>resetNodeNumbers!</code></a> or <a href="#PhyloNetworks.resetEdgeNumbers!"><code>resetEdgeNumbers!</code></a>.</p><p>Warning: does <em>not</em> check that the names of leaves with numbers in <code>taxonnum</code> are <code>taxonnames</code>.</p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((2a,2b),(((((1a,1b,1c),4),(5)#H1),(#H1,(6,7))))#H2),(#H2,10));&quot;);

julia&gt; c_species1 = PhyloNetworks.TopologyConstraint(0x01, [&quot;1a&quot;,&quot;1b&quot;,&quot;1c&quot;], net)
Species constraint, on tips: 1a, 1b, 1c
 stem edge number 7
 crown node number -9

julia&gt; c_species1.taxonnums
Set{Int64} with 3 elements:
  4
  3
  5

julia&gt; c_clade145 = PhyloNetworks.TopologyConstraint(0x02, [&quot;1a&quot;,&quot;1b&quot;,&quot;1c&quot;,&quot;4&quot;,&quot;5&quot;], net)
Clade constraint, on tips: 1a, 1b, 1c, 4, 5
 stem edge number 12
 crown node number -7

julia&gt; PhyloNetworks.resetNodeNumbers!(net)

julia&gt; net.node[4].number = 111;

julia&gt; PhyloNetworks.updateconstraints!([c_species1, c_clade145], net)

julia&gt; c_species1
Species constraint, on tips: 1a, 1b, 1c
 stem edge number 7
 crown node number 21

julia&gt; c_species1.taxonnums
Set{Int64} with 3 elements:
  4
  5
  111</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/moves_semidirected.jl#L174-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.writeTopologyLevel1-Tuple{HybridNetwork}" href="#PhyloNetworks.writeTopologyLevel1-Tuple{HybridNetwork}"><code>PhyloNetworks.writeTopologyLevel1</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>writeTopologyLevel1(net::HybridNetwork)</code></p><p>Write the extended Newick parenthetical format of a level-1 network object with many optional arguments (see below). Makes a deep copy of net: does <em>not</em> modify <code>net</code>.</p><ul><li>di=true: write in format for Dendroscope (default false)</li><li>namelabel=true: If <code>namelabel</code> is true, taxa are labelled by their names;</li></ul><p>otherwise taxa are labelled by their numbers (unique identifiers).</p><ul><li>outgroup (string): name of outgroup to root the tree/network. if &quot;none&quot; is given, the root is placed wherever possible.</li><li>printID=true, only print branch lengths for identifiable egdes according to the snaq estimation procedure (default false) (true inside of <code>snaq!</code>.)</li><li>round: rounds branch lengths and heritabilities γ (default: true)</li><li>digits: digits after the decimal place for rounding (defult: 3)</li><li>string: if true (default), returns a string, otherwise returns an IOBuffer object.</li><li>multall: (default false). set to true when there are multiple alleles per population.</li></ul><p>The topology may be written using a root different than net.root, if net.root is incompatible with one of more hybrid node. Missing hybrid names are written as &quot;#Hi&quot; where &quot;i&quot; is the hybrid node number if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/readwrite.jl#L1076-L1101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fit-Tuple{Type{PhyloNetworks.StatisticalSubstitutionModel},HybridNetwork,PhyloNetworks.SubstitutionModel,RateVariationAcrossSites,AbstractArray{T,1} where T}" href="#StatsBase.fit-Tuple{Type{PhyloNetworks.StatisticalSubstitutionModel},HybridNetwork,PhyloNetworks.SubstitutionModel,RateVariationAcrossSites,AbstractArray{T,1} where T}"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit(StatisticalSubstitutionModel, net, model, traits; kwargs...)
fit!(StatisticalSubstitutionModel; kwargs...)</code></pre><p>Internal function called by <a href="../public/#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a>: with same key word arguments <code>kwargs</code>. But dangerous: <code>traits</code> should be a vector of vectors as for <a href="../public/#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a> <strong>but</strong> here <code>traits</code> need to contain the <em>indices</em> of trait values corresponding to the indices in <code>getlabels(model)</code>, and species should appear in <code>traits</code> in the order corresponding to the node numbers in <code>net</code>. See <a href="#PhyloNetworks.traitlabels2indices-Tuple{AbstractArray{T,1} where T,PhyloNetworks.SubstitutionModel}"><code>traitlabels2indices</code></a> to convert trait labels to trait indices.</p><p><strong>Warning</strong>: does <em>not</em> perform checks. <a href="../public/#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a> calls this function after doing checks, preordering nodes in the network, making sure nodes have consecutive numbers, species are matched between data and network etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/traitsLikDiscrete.jl#L451-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.fAbs" href="#PhyloNetworks.fAbs"><code>PhyloNetworks.fAbs</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>default values for tolerance parameters, used in the optimization of branch lengths (fAbs, fRel, xAbs, xRel) and in the acceptance of topologies (likAbs, numFails).</p><p>if changes are made here, <strong>make the same</strong> in the docstring for snaq! below</p><table><tr><th style="text-align: right">version</th><th style="text-align: right">fAbs</th><th style="text-align: right">fRel</th><th style="text-align: right">xAbs</th><th style="text-align: right">xRel</th><th style="text-align: right">numFails</th><th style="text-align: right">likAbs</th><th style="text-align: right">multiplier</th></tr><tr><td style="text-align: right">v0.5.1</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-3</td><td style="text-align: right">1e-2</td><td style="text-align: right">75</td><td style="text-align: right">1e-6</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">v0.3.0</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-5</td><td style="text-align: right">1e-4</td><td style="text-align: right">1e-3</td><td style="text-align: right">100</td><td style="text-align: right">0.01</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">v0.0.1</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-5</td><td style="text-align: right">1e-4</td><td style="text-align: right">1e-3</td><td style="text-align: right">100</td><td style="text-align: right"></td><td style="text-align: right">10000</td></tr><tr><td style="text-align: right">older</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-12</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><p>v0.5.1: based on Nan Ji&#39;s work. same xAbs and xRel as in phylonet (as of 2015). earlier: multiplier was used; later: likAbs = multiplier*fAbs) &quot;older&quot;: values from GLM.jl, Prof Bates</p><p>default values used on a single topology, to optimize branch lengths and gammas, at the very end of snaq!, and by topologyMaxQPseudolik! since v0.5.1.</p><table><tr><th style="text-align: right">version</th><th style="text-align: right">fAbsBL</th><th style="text-align: right">fRelBL</th><th style="text-align: right">xAbsBL</th><th style="text-align: right">xRelBL</th></tr><tr><td style="text-align: right">v0.0.1</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-12</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/dfbbb3e5c6999b20316667222018a8013a35325e/src/snaq_optimization.jl#L8-L33">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public/">« Public</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 13 July 2020 19:49">Monday 13 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
