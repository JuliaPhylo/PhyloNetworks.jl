var documenterSearchIndex = {"docs":
[{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CurrentModule = PhyloNetworks","category":"page"},{"location":"lib/internals/#Internal-Documentation","page":"Internals","title":"Internal Documentation","text":"","category":"section"},{"location":"lib/internals/#Contents","page":"Internals","title":"Contents","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#types","page":"Internals","title":"types","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [PhyloNetworks]\nPublic = false\nOrder   = [:type]","category":"page"},{"location":"lib/internals/#PhyloNetworks.ANode","page":"Internals","title":"PhyloNetworks.ANode","text":"ANode\n\nAbstract node. An object of type Edge has a node attribute, which is an vector of 2 ANode objects. The object of type Node is an ANode, and has an edge attribute, which is vector of Edge objects.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.BM","page":"Internals","title":"PhyloNetworks.BM","text":"BM(λ)\n\nBrownian Motion, subtype of ContinuousTraitEM, to model the population mean of a trait (or of the residuals from a linear model). Under the BM model, the population (or species) means have a multivariate normal distribution with covariance matrix = σ²λV, where σ² is the between-species variance-rate (to be estimated), and the matrix V is obtained from sharedPathMatrix(net)[:Tips].\n\nλ is set to 1 by default, and is immutable. In future versions, λ may be used to control the scale for σ².\n\nOn a tree, V is the length of shared ancestry. On a network, the BM model assumes that the trait at a hybrid node is the weighted average of its immediate parents (plus possibly a fixed shift). The weights are the proportion of genes inherited from each parent: the γ parameters of hybrid edges.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.CacheGammaLiNC","page":"Internals","title":"PhyloNetworks.CacheGammaLiNC","text":"CacheGammaLiNC\n\nType to store intermediate values during γ optimization, to limit time spent on garbage collection.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.CacheLengthLiNC","page":"Internals","title":"PhyloNetworks.CacheLengthLiNC","text":"CacheLengthLiNC\n\nType to store intermediate values during optimization of one branch length, to limit time spent on garbage collection. Re-used across branches. See constructor below, from a StatisticalSubstitutionModel.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.CacheLengthLiNC-Tuple{PhyloNetworks.StatisticalSubstitutionModel, Float64, Float64, Float64, Float64, Int64}","page":"Internals","title":"PhyloNetworks.CacheLengthLiNC","text":"CacheLengthLiNC(obj::SSM,\n    ftolRel::Float64, ftolAbs::Float64, xtolRel::Float64, xtolAbs::Float64,\n    maxeval::Int)\n\nConstructor from a StatisticalSubstitutionModel object, with tolerance values and parameters controlling the search.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.ContinuousTraitEM","page":"Internals","title":"PhyloNetworks.ContinuousTraitEM","text":"ContinuousTraitEM\n\nAbstract type for evolutionary models for continuous traits, using a continuous-time stochastic process on a phylogeny.\n\nFor subtypes, see BM, PagelLambda, ScalingHybrid.\n\nEach of these subtypes/models has the field lambda, whose default value is 1.0. However, the interpretation of this field differs across models.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.Edge","page":"Internals","title":"PhyloNetworks.Edge","text":"Edge(number)\n\nData structure for an edge and its various attributes. Most notably:\n\nnumber (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example\nnode: a vector of [Node]s, normally just 2 of them\nisChild1 (boolean): true if node[1] is the child node of the edge, false if node[1] is the parent node of the edge\nlength: branch length\nhybrid (boolean): whether the edge is a tree edge or a hybrid edge (in which case isChild1 is important, even if the network is semi-directed)\ngamma: proportion of genetic material inherited by the child node via the edge; 1.0 for a tree edge\nisMajor (boolean): whether the edge is the major path to the child node; true for tree edges, since a tree edge is the only path to its child node; normally true if gamma>0.5.\n\nand other fields, used very internally\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.MatrixTopologicalOrder","page":"Internals","title":"PhyloNetworks.MatrixTopologicalOrder","text":"MatrixTopologicalOrder\n\nMatrix associated to an HybridNetwork in which rows/columns correspond to nodes in the network, sorted in topological order.\n\nThe following functions and extractors can be applied to it: tipLabels, obj[:Tips], obj[:InternalNodes], obj[:TipsNodes] (see documentation for function getindex(::MatrixTopologicalOrder, ::Symbol)).\n\nFunctions sharedPathMatrix and simulate return objects of this type.\n\nThe MatrixTopologicalOrder object has fields: V, nodeNumbersTopOrder, internalNodeNumbers, tipNumbers, tipNames, indexation. Type in \"?MatrixTopologicalOrder.field\" to get documentation on a specific field.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.Node","page":"Internals","title":"PhyloNetworks.Node","text":"Node(number, leaf)\nNode(number, leaf, hybrid)\n\nData structure for a node and its various attributes. Most notably:\n\nnumber (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example\nleaf (boolean): whether the node is a leaf (with data typically) or an internal node (no data typically)\nname (string): taxon name for leaves; internal node may or may not have a name\nedge: vector of Edges that the node is attached to; 1 if the node is a leaf, 2 if the node is the root, 3 otherwise, and potentially more if the node has a polytomy\nhybrid (boolean): whether the node is a hybrid node (with 2 or more parents) or a tree node (with a single parent)\n\nOther more internal attributes include:\n\nisBadDiamondI and isBadDiamondII (booleans): whether the node is a hybrid node where the reticulation forms a cycle of 4 nodes (diamond), and where both parents of the hybrid nodes are connected to a leaf. In a bad diamond of type I, the hybrid node itself is also connected to a leaf but the common neighbor of the 2 hybrid's parents is not connected to a leaf. In a bad diamond of type II, the hybrid node has an internal node as child, and the common neighbor of the 2 hybrid's parents is connected to a leaf.\nisBadTriangle, isVeryBadTriangle and isExtBadTriangle (booleans): true if the reticulation forms a cycle of 3 nodes (triangle) and depending on the number of leaves attached these 3 nodes. The triangle means that the 2 parents of the hybrid node are directly related: one is the child of the other. isBadTriangle is true if the triangle is \"good\", as per Solís-Lemus & Ané (2016), that is, if all 3 nodes in the cycle are not connected to any leaves (the reticulation is detectable from quartet concordance factors, even though all branch lengths are not identifiable). isVeryBadTriangle is true if 2 (or all) of the 3 nodes are connected to a leaf, in which case the reticulation is undetectable from unrooted gene tree topologies (thus it's best to exclude these reticulations from a search). isBadTriangle is true if exactly 1 of the 3 nodes is connected to a leaf.\n\nFor details see Solís-Lemus & Ané (2016, doi:10.1371/journal.pgen.1005896)\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.NucleicAcidSubstitutionModel","page":"Internals","title":"PhyloNetworks.NucleicAcidSubstitutionModel","text":"NucleicAcidSubstitutionModel\n\nAdapted from SubstitutionModels.jl in BioJulia. The same Q and P function names are used for the transition rates and probabilities.\n\nFor subtypes, see JC69, HKY85\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.OptSummary","page":"Internals","title":"PhyloNetworks.OptSummary","text":"OptSummary{T<:AbstractFloat}\n\nSummary of an NLopt optimization. Idea and code taken from MixedModels. T is the type of the function argument(s) and of the function value.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.PagelLambda","page":"Internals","title":"PhyloNetworks.PagelLambda","text":"PagelLambda(λ)\n\nPagel's λ model, subtype of ContinuousTraitEM, with covariance matrix σ²V(λ). σ² is the between-species variance-rate (to be estimated), and V(λ) = λV + (1-λ)T, where V is the covariance under a Brownian motion BM and T is a diagonal matrix containing the total branch length elapsed from the root to each leaf (if the phylogeny is a tree, or more generally if the network is time consistent: the time from the root to a given node does not depend on the path).\n\nλ ∈ [0,1] is mutable and may be optimized. It is a measure of phylogenetic signal, that is, how important the given network is for explaining variation in the response. When λ=1, the PagelLambda model reduces to the BM model.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.QuartetNetwork","page":"Internals","title":"PhyloNetworks.QuartetNetwork","text":"QuartetNetwork(net::HybridNetwork)\n\nSubtype of Network abstract type. A QuartetNetwork object is an internal type used to calculate the expected CFs of quartets on a given network. Attributes of the QuartetNetwork objects need not be updated at a given time (see below).\n\nThe procedure to calculate expected CFs for a given network is as follows:\n\nA QuartetNetwork object is created for each Quartet using extractQuartet!(net,d) for net::HybridNetwork and d::DataCF\nThe vector d.quartet has all the Quartet objects, each with a QuartetNetwork object (q.qnet). Attibutes in QuartetNetwork are not updated at this point\nAttributes in QuartetNetwork are partially updated when calculating the expected CF (calculateExpCFAll!). To calculate the expected CF for this quartet, we need to update the attributes: which, typeHyb, t1, split, formula, expCF. To do this, we need to modify the QuartetNetwork object (i.e. merge edges,...). But we do not want to modify it directly because it is connected to the original net via a map of the edges and nodes, so we use a deep copy: qnet=deepcopy(q.qnet) and then calculateExpCFAll!(qnet). Attributes that are updated on the original QuartetNetwork object q.qnet are:\nq.qnet.hasEdge: array of booleans of length equal to net.edge that shows which identifiable edges and gammas of net (net.ht) are in qnet (and still identifiable). Note that the first elements of the vector correspond to the gammas.\nq.qnet.index: length should match the number of trues in qnet.hasEdge. It has the indexes in qnet.edge from the edges in qnet.hasEdge. Note that the first elements of the vector correspond to the gammas.\nq.qnet.edge: list of edges in QuartetNetwork. Note that external edges in net are collapsed when they appear in QuartetNetwork, so only internal edges map directly to edges in net\nq.qnet.expCF: expected CF for this Quartet\n\nWhy not modify the original QuartetNetwork? We wanted to keep the original QuartetNetwork stored in DataCF with all the identifiable edges, to be able to determine if this object had been changed or not after a certain optimization.\n\nThe process is:\n\nDeep copy of full network to create q.qnet for Quartet q. This QuartetNetwork object has only 4 leaves now, but does not have merged edges (the identifiable ones) so that we can correspond to the edges in net. This QuartetNetwork does not have other attributes updated.\nFor the current set of branch lengths and gammas, we can update the attributes in q.qnet to compute the expected CF. The functions that do this will \"destroy\" the QuartetNetwork object by merging edges, removing nodes, etc... So, we do this process in qnet=deepcopy(q.qnet), and at the end, only update q.qnet.expCF.\nAfter we optimize branch lengths in the full network, we want to update the branch lengths in q.qnet. The edges need to be there (which is why we do not want to modify this QuartetNetwork object by merging edges), and we do not do a deep-copy of the full network again. We only change the values of branch lengths and gammas in q.qnet, and we can re-calculate the expCF by creating a deep copy qnet=deepcopy(q.qnet) and run the other functions (which merge edges, etc) to get the expCF.\n\nFuture work: there are definitely more efficient ways to do this (without the deep copies). In addition, currently edges that are no longer identifiable in QuartetNetwork do not appear in hasEdge nor index. Need to study this.\n\njulia> net0 = readTopology(\"(s17:13.76,(((s3:10.98,(s4:8.99,s5:8.99)I1:1.99)I2:0.47,(((s6:2.31,s7:2.31)I3:4.02,(s8:4.97,#H24:0.0::0.279)I4:1.36)I5:3.64,((s9:8.29,((s10:2.37,s11:2.37)I6:3.02,(s12:2.67,s13:2.67)I7:2.72)I8:2.89)I9:0.21,((s14:2.83,(s15:1.06,s16:1.06)I10:1.78)I11:2.14)#H24:3.52::0.72)I12:1.47)I13:1.48)I14:1.26,(((s18:5.46,s19:5.46)I15:0.59,(s20:4.72,(s21:2.40,s22:2.40)I16:2.32)I17:1.32)I18:2.68,(s23:8.56,(s1:4.64,s2:4.64)I19:3.92)I20:0.16)I21:3.98)I22:1.05);\");\n\njulia> net = readTopologyLevel1(writeTopology(net0)) ## need level1 attributes for functions below\nHybridNetwork, Un-rooted Network\n46 edges\n46 nodes: 23 tips, 1 hybrid nodes, 22 internal tree nodes.\ntip labels: s17, s3, s4, s5, ...\n(s4:8.99,s5:8.99,(s3:10.0,((((s6:2.31,s7:2.31)I3:4.02,(s8:4.97,#H24:0.0::0.279)I4:1.36)I5:3.64,((s9:8.29,((s10:2.37,s11:2.37)I6:3.02,(s12:2.67,s13:2.67)I7:2.72)I8:2.89)I9:0.21,((s14:2.83,(s15:1.06,s16:1.06)I10:1.78)I11:2.14)#H24:3.52::0.721)I12:1.47)I13:1.48,((((s18:5.46,s19:5.46)I15:0.59,(s20:4.72,(s21:2.4,s22:2.4)I16:2.32)I17:1.32)I18:2.68,(s23:8.56,(s1:4.64,s2:4.64)I19:3.92)I20:0.16)I21:3.98,s17:10.0)I22:1.26)I14:0.47)I2:1.99)I1;\n\njulia> q1 = Quartet(1,[\"s1\", \"s16\", \"s18\", \"s23\"],[0.296,0.306,0.398])\nnumber: 1\ntaxon names: [\"s1\", \"s16\", \"s18\", \"s23\"]\nobserved CF: [0.296, 0.306, 0.398]\npseudo-deviance under last used network: 0.0 (meaningless before estimation)\nexpected CF under last used network: Float64[] (meaningless before estimation)\n\njulia> qnet = PhyloNetworks.extractQuartet!(net,q1)\ntaxa: [\"s1\", \"s16\", \"s18\", \"s23\"]\nnumber of hybrid nodes: 1\n\njulia> sum([e.istIdentifiable for e in net.edge]) ## 23 identifiable edges in net\n23\n\njulia> idedges = [ee.number for ee in net.edge[[e.istIdentifiable for e in net.edge]]];\n\njulia> print(idedges)\n[5, 6, 9, 11, 12, 13, 17, 20, 21, 22, 26, 27, 28, 29, 30, 31, 34, 38, 39, 40, 44, 45, 46]\n\njulia> length(qnet.hasEdge) ## 24 = 1 gamma + 23 identifiable edges\n24\n\njulia> sum(qnet.hasEdge) ## 8 = 1 gamma + 7 identifiable edges in qnet\n8\n\njulia> print(idedges[qnet.hasEdge[2:end]]) ## 7 id. edges: [12, 13, 29, 30, 31, 45, 46]\n[12, 13, 29, 30, 31, 45, 46]\n\njulia> qnet.edge[qnet.index[1]].number ## 11 = minor hybrid edge\n11\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.QuartetT","page":"Internals","title":"PhyloNetworks.QuartetT","text":"QuartetT{T}\n\nGeneric type for 4-taxon sets. Fields:\n\nnumber: rank of the 4-taxon set\ntaxonnumber: static vector of 4 integers, assumed to be distinct and sorted\ndata: object of type T\n\nFor easier look-up, a unique mapping is used between the rank (number) of a 4-taxon set and its 4 taxa (see quartetrank and nchoose1234):\n\nrank-1 = (t1-1) choose 1 + (t2-1) choose 2 + (t3-1) choose 3 + (t4-1) choose 4\n\nexamples\n\njulia> nCk = PhyloNetworks.nchoose1234(5)\n6×4 Matrix{Int64}:\n 0   0   0  0\n 1   0   0  0\n 2   1   0  0\n 3   3   1  0\n 4   6   4  1\n 5  10  10  5\n\njulia> PhyloNetworks.QuartetT(1,3,4,6, [.92,.04,.04, 100], nCk)\n4-taxon set number 8; taxon numbers: 1,3,4,6\ndata: [0.92, 0.04, 0.04, 100.0]\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.ScalingHybrid","page":"Internals","title":"PhyloNetworks.ScalingHybrid","text":"ScalingHybrid(λ)\n\nScaling Hybrid model, subtype of ContinuousTraitEM, with covariance matrix σ²V(N(λ)). σ² is the between-species variance-rate (to be estimated), V(N) is the Brownian motion BM covariance obtained from network N, and N(λ) is a obtained from the input network by rescaling the inheritance parameter γ of all minor edges by the same λ: a minor edge has its original γ changed to λγ, using the same λ at all reticulations. Note that for a major edge with original inheritance γ, the partner minor edge has inheritance γminor = 1-γ, so the major edge's inheritance is changed to 1-λγminor = λγ+1-λ.\n\nFor more information: see Bastide (2017) dissertation, section 4.3.2 p.175, available at https://tel.archives-ouvertes.fr/tel-01629648\n\nλ ∈ [0,1] is mutable and may be optimized. It is a measure of how important the reticulations are for explaining variation in the response. When λ=1, the ScalingHybrid model reduces to the BM model.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.StatisticalSubstitutionModel","page":"Internals","title":"PhyloNetworks.StatisticalSubstitutionModel","text":"StatisticalSubstitutionModel\n\nSubtype of StatsBase.StatisticalModel, to fit discrete data to a model of trait substitution along a network. See fitdiscrete to fit a trait substitution model to discrete data. It returns an object of type StatisticalSubstitutionModel, to which standard functions can be applied, like loglikelihood(object), aic(object) etc.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.StatisticalSubstitutionModel-2","page":"Internals","title":"PhyloNetworks.StatisticalSubstitutionModel","text":"StatisticalSubstitutionModel(model::SubstitutionModel,\n        ratemodel::RateVariationAcrossSites,\n        net::HybridNetwork, trait::AbstractVector,\n        siteweight=nothing::Union{Nothing, Vector{Float64}},\n        maxhybrid=length(net.hybrid)::Int)\n\nInner constructor. Makes a deep copy of the input model, rate model. Warning: does not make a deep copy of the network: modification of the object.net would modify the input net. Assumes that the network has valid gamma values (to extract displayed trees).\n\nStatisticalSubstitutionModel(net::HybridNetwork, fastafile::String,\n        modsymbol::Symbol, rvsymbol=:noRV::Symbol,\n        ratecategories=4::Int;\n        maxhybrid=length(net.hybrid)::Int)\n\nConstructor from a network and a fasta file. The model symbol should be one of :JC69, :HKY85, :ERSM or :BTSM. The rvsymbol should be as required by RateVariationAcrossSites.\n\nThe network's gamma values are modified if they are missing. After that, a deep copy of the network is passed to the inner constructor.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.SubstitutionModel","page":"Internals","title":"PhyloNetworks.SubstitutionModel","text":"SubstitutionModel\n\nAbstract type for substitution models, using a continous time Markov model on a phylogeny. Adapted from SubstitutionModels.jl in BioJulia.\n\nFor variable rates, see RateVariationAcrossSites\n\nFor sub types, see NucleicAcidSubstitutionModel, TraitSubstitutionModel\n\nAll these models are supposed to have fields rate and eigeninfo.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.TopologyConstraint","page":"Internals","title":"PhyloNetworks.TopologyConstraint","text":"Type for various topological constraints, such as:\n\na set of taxa forming a clade in the major tree\na set of individuals belonging to the same species\na set of taxa forming a clade in any one of the displayed trees\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.TopologyConstraint-Tuple{UInt8, Vector{String}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.TopologyConstraint","text":"TopologyConstraint(type::UInt8, taxonnames::Vector{String}, net::HybridNetwork)\n\nCreate a topology constraint from user-given type, taxon names, and network. There are 3 types of constraints:\n\ntype 1: A set of tips that forms a species.\ntype 2: A set of tips that forms a clade in the major tree. Note that the root matters. Constraining a set of species to be an outgroup is equivalent to constraining the ingroup to form a clade.\ntype 3: A set of tips that forms a clade in any one of the displayed trees.\n\nNote: currently, with type-1 constraints, hybridizations are prevented from coming into or going out of a species group.\n\nexamples\n\njulia> net = readTopology(\"(((2a,2b),(((((1a,1b,1c),4),(5)#H1),(#H1,(6,7))))#H2),(#H2,10));\");\n\njulia> c_species1 = PhyloNetworks.TopologyConstraint(0x01, [\"1a\",\"1b\",\"1c\"], net)\nSpecies constraint, on tips: 1a, 1b, 1c\n stem edge number 7\n crown node number -9\n\njulia> c_species2 = PhyloNetworks.TopologyConstraint(0x01, [\"2a\",\"2b\"], net)\nSpecies constraint, on tips: 2a, 2b\n stem edge number 3\n crown node number -4\n\njulia> nni!(net , net.edge[3], true, true, [c_species2]) === nothing # we get nothing: would break species 2\ntrue\n\njulia> # the following gives an error, because 4,5 do not form a clade in \"net\"\n       # PhyloNetworks.TopologyConstraint(0x02, [\"4\",\"5\"], net)\n\njulia> c_clade145 = PhyloNetworks.TopologyConstraint(0x02, [\"1a\",\"1b\",\"1c\",\"4\",\"5\"], net)\nClade constraint, on tips: 1a, 1b, 1c, 4, 5\n stem edge number 12\n crown node number -7\n\njulia> nni!(net , net.edge[12], true, true, [c_species1, c_clade145]) # we get nothing (failed NNI): would break the clade\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.WithinSpeciesCTM","page":"Internals","title":"PhyloNetworks.WithinSpeciesCTM","text":"WithinSpeciesCTM\n\nCTM stands for \"continuous trait model\". Contains the estimated variance components (between-species phylogenetic variance rate and within-species variance) and output from the NLopt optimization used in the estimation.\n\nFields\n\nwsp_var: intra/within-species variance.\nbsp_var: inter/between-species variance-rate.\nwsp_ninv: vector of the inverse sample-sizes (e.g. [1/n₁, ..., 1/nₖ], where data from k species was used to fit the model and nᵢ is the no. of observations for the ith species).\nrss: within-species sum of squares\noptsum: an OptSummary object.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#functions","page":"Internals","title":"functions","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [PhyloNetworks]\nPublic = false\nOrder   = [:function, :constant]","category":"page"},{"location":"lib/internals/#Base.getindex","page":"Internals","title":"Base.getindex","text":"getindex(obj, d,[ indTips, nonmissing])\n\nGetting submatrices of an object of type MatrixTopologicalOrder.\n\nArguments\n\nobj::MatrixTopologicalOrder: the matrix from which to extract.\nd::Symbol: a symbol precising which sub-matrix to extract. Can be:\n:Tips columns and/or rows corresponding to the tips\n:InternalNodes columns and/or rows corresponding to the internal nodes Includes tips not listed in indTips or missing data according to nonmissing.\n:TipsNodes columns corresponding to internal nodes, and row to tips (works only is indexation=\"b\")\nindTips::Vector{Int}: optional argument precising a specific order for the tips (internal use).\nnonmissing::BitArray{1}: optional argument saying which tips have data (internal use).  Tips with missing data are treated as internal nodes.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Base.getindex-2","page":"Internals","title":"Base.getindex","text":"getindex(obj, d)\n\nGetting submatrices of an object of type TraitSimulation.\n\nArguments\n\nobj::TraitSimulation: the matrix from which to extract.\nd::Symbol: a symbol precising which sub-matrix to extract. Can be:\n:Tips columns and/or rows corresponding to the tips\n:InternalNodes columns and/or rows corresponding to the internal nodes\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.P!-Tuple{AbstractMatrix{T} where T, PhyloNetworks.SubstitutionModel, Float64}","page":"Internals","title":"PhyloNetworks.P!","text":"P!(Pmat::AbstractMatrix, obj::SM, t::Float64)\n\nFill in the input matrix Pmat with the transition rates to go from each state to another in time t, according to rates in Q. see also: P.\n\njulia> m1 = BinaryTraitSubstitutionModel([1.0,2.0], [\"low\",\"high\"])\nBinary Trait Substitution Model:\nrate low→high α=1.0\nrate high→low β=2.0\n\njulia> PhyloNetworks.P!(Matrix{Float64}(undef,2,2), m1, 0.3) # fills an uninitialized 2x2 matrix of floats\n2×2 Matrix{Float64}:\n 0.80219  0.19781\n 0.39562  0.60438\n\njulia> m2 = JC69([1.]);\n\njulia> PhyloNetworks.P!(Matrix{Float64}(undef,4,4), m2, 0.2)\n4×4 Matrix{Float64}:\n 0.824446   0.0585179  0.0585179  0.0585179\n 0.0585179  0.824446   0.0585179  0.0585179\n 0.0585179  0.0585179  0.824446   0.0585179\n 0.0585179  0.0585179  0.0585179  0.824446 \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.P-Tuple{PhyloNetworks.SubstitutionModel, Float64}","page":"Internals","title":"PhyloNetworks.P","text":"P(obj, t)\n\nProbability transition matrix for a TraitSubstitutionModel, of the form\n\nP[1,1] ... P[1,k]\n   .          .\n   .          .\nP[k,1] ... P[k,k]\n\nwhere P[i,j] is the probability of ending in state j after time t, given that the process started in state i. see also: P!.\n\nHKY example:\n\njulia> m1 = HKY85([0.5], [0.20, 0.30, 0.30, 0.20])\nHKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]\nrelative rate version with transition/tranversion ratio kappa = 0.5,\n scaled so that there is one substitution per unit time\nrate matrix Q:\n               A       C       G       T\n       A       *  0.4839  0.2419  0.3226\n       C  0.3226       *  0.4839  0.1613\n       G  0.1613  0.4839       *  0.3226\n       T  0.3226  0.2419  0.4839       *\n\njulia> PhyloNetworks.P(m1, 0.2)\n4×4 StaticArrays.MMatrix{4, 4, Float64, 16} with indices SOneTo(4)×SOneTo(4):\n 0.81592    0.0827167  0.0462192  0.0551445\n 0.0551445  0.831326   0.0827167  0.0308128\n 0.0308128  0.0827167  0.831326   0.0551445\n 0.0551445  0.0462192  0.0827167  0.81592  \n\nJuke-Cantor example:\n\njulia> m1 = JC69([1.]);\n\njulia> PhyloNetworks.P(m1, 0.2)\n4×4 StaticArrays.MMatrix{4, 4, Float64, 16} with indices SOneTo(4)×SOneTo(4):\n 0.824446   0.0585179  0.0585179  0.0585179\n 0.0585179  0.824446   0.0585179  0.0585179\n 0.0585179  0.0585179  0.824446   0.0585179\n 0.0585179  0.0585179  0.0585179  0.824446 \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork, DataFrames.DataFrame}","page":"Internals","title":"PhyloNetworks.addAlternativeHybridizations!","text":"addAlternativeHybridizations!(net::HybridNetwork, BSe::DataFrame;\n                              cutoff=10::Number, top=3::Int)\n\nModify the network net (the best network estimated with snaq) by adding other hybridizations that are present in the bootstrap networks. By default, it will only consider hybrid edges with more than 10% bootstrap support (cutoff) and it will only include the three top hybridizations (top) sorted by bootstrap support. The function also modifies the dataframe BSe obtained with hybridBootstrapSupport. In the original BSe dataframe, hybrid edges that do not appear in the best network have a missing number. After the hybrid edges are added with addAlternativeHybridizations, BSe is modified to include the edge numbers of the newly added hybrid edges. Note that the function only adds the hybrid edges as minor to keep the underlying tree topology.\n\nexample\n\nbootnet = readMultiTopology(\"bootstrap-networks.txt\")\nbestnet = readTopology(\"best.tre\")\nBSn, BSe, BSc, BSgam, BSedgenum = hybridBootstrapSupport(bootnet, bestnet);\naddAlternativeHybridizations!(bestnet,BSe)\nusing PhyloPlots\nplot(bestnet, edgeLabel=BSe[[:edge,:BS_hybrid_edge]])\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addhybridedge!","page":"Internals","title":"PhyloNetworks.addhybridedge!","text":"addhybridedge!(net::HybridNetwork, nohybridladder::Bool, no3cycle::Bool,\n               constraints=TopologyConstraint[]::Vector{TopologyConstraint};\n               maxattempts=10::Int, fixroot=false::Bool)\n\nRandomly choose two edges in net then: add hybrid edge from edge 1 to edge 2 of length 0.01. The two halves of edge 1 (and of edge 2) have equal lengths. The hybrid partner edge (top half of edge 2, if fixroot is true) will point towards the newly-created node on the middle of the original edge 2.\n\nIf the resulting network is a DAG, satisfies the constraint(s), does not contain any 3-cycle (if no3cycle=true), and does not have a hybrid ladder (if nohybridladder=true) then the proposal is successful: net is modified, and the function returns the newly created hybrid node and newly created hybrid edge.\n\nIf the resulting network is not acceptable, then a new set of edges is proposed (using a blacklist) until one is found acceptable, or until a maximum number of attempts have been made (maxattempts). If none of the attempted proposals are successful, nothing is returned (without causing an error).\n\nAfter a pair of edges is picked, the \"top\" half of edge2 is proposed as the partner hybrid edge with probability 0.8 if fixroot is false, (to avoid changing the direction of edge2 with more than 50% chance) and with probability 1.0 if fixroot is true. If this choice does not work and if fixroot is false, the other half of edge2 is proposed as the partner hybrid edge. Note that choosing the \"bottom\" half of edge2 as the partner edge requires to flip the direction of edge 2, and to move the root accordingly (to the original child of edge2).\n\nexamples\n\njulia> net = readTopology(\"((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));\");\n\njulia> using Random\n\njulia> Random.seed!(75);\n\njulia> PhyloNetworks.addhybridedge!(net, true, true)\n(PhyloNetworks.Node:\n number:9\n name:H3\n hybrid node\n attached to 3 edges, numbered: 5 16 17\n, PhyloNetworks.Edge:\n number:17\n length:0.01\n minor hybrid edge with gamma=0.32946795808423734\n attached to 2 node(s) (parent first): 8 9\n)\n\njulia> writeTopology(net, round=true, digits=2)\n\"((S1,(((#H1,S4),((S2,(S3)#H1))#H3:::0.67))#H2),((#H2,S5),#H3:0.01::0.33));\"\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.addhybridedge!-2","page":"Internals","title":"PhyloNetworks.addhybridedge!","text":"addhybridedge!(net::HybridNetwork, edge1::Edge, edge2::Edge, hybridpartnernew::Bool,\n               edgelength=-1.0::Float64, gamma=-1.0::Float64)\n\nAdd hybridization to net coming from edge1 going into edge2. 2 new nodes and 3 new edges are created: edge1 are edge2 are both cut into 2 edges, and a new edge is created linking the 2 new \"middle\" nodes, pointing from edge1 to edge2. The new node in the middle of edge1 is a tree node. The new node in the middle of edge2 is a hybrid node. Its parent edges are the newly created hybrid edge (with γ = gamma, missing by default), and either the newly edge \"above\" edge2 if hybridpartnernew=true, or the old edge2 otherwise (which would reverse the direction of edge2 and others).\n\nShould be called from the other method, which performs a bunch of checks. Updates containRoot attributes for edges below the new hybrid node.\n\nOutput: new hybrid node (middle of the old edge2) and new hybrid edge.\n\nexamples\n\njulia> net = readTopology(\"((S8,(((S1,(S5)#H1),(#H1,S6)))#H2),(#H2,S10));\");\n\njulia> hybnode, hybedge = PhyloNetworks.addhybridedge!(net, net.edge[13], net.edge[8], true, 0.0, 0.2)\n(PhyloNetworks.Node:\n number:9\n name:H3\n hybrid node\n attached to 3 edges, numbered: 8 16 17\n, PhyloNetworks.Edge:\n number:17\n length:0.0\n minor hybrid edge with gamma=0.2\n attached to 2 node(s) (parent first): 8 9\n)\n\n\njulia> writeTopology(net)\n\"((S8,(((S1,(S5)#H1),((#H1,S6))#H3:::0.8))#H2),(#H2,(S10,#H3:0.0::0.2)));\"\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.addhybridedgeLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, Float64, Bool, Bool, Vector{PhyloNetworks.TopologyConstraint}, Float64, PhyloNetworks.CacheGammaLiNC, PhyloNetworks.CacheLengthLiNC}","page":"Internals","title":"PhyloNetworks.addhybridedgeLiNC!","text":"addhybridedgeLiNC!(obj::SSM, currLik::Float64,\n    no3cycle::Bool, nohybridladder::Bool,\n    constraints::Vector{TopologyConstraint},\n    ftolAbs::Float64,\n    γcache::CacheGammaLiNC, lcache::CacheLengthLiNC)\n\nCompletes checks, adds hybrid in a random location, updates SSM object, and optimizes branch lengths and gammas locally as part of PhyLiNC optimization.\n\nReturn true if accepted add hybrid move. If move not accepted, return false. If cannot add a hybrid, return nothing.\n\nFor arguments, see phyLiNC. Called by optimizestructure!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addindividuals!-Tuple{HybridNetwork, AbstractString, Vector{String}}","page":"Internals","title":"PhyloNetworks.addindividuals!","text":"addindividuals!(net::HybridNetwork, species::AbstractString, individuals::Vector)\n\nAdd individuals to their species leaf as a star, and return the corresponding species constraint. nothing is returned in 2 cases:\n\nif individuals contains only 1 individual, in which case the name of the leaf for that species is replaced by the name of its one individual representative\nif species is not found in the network\n\nSpaces in individuals' names are eliminated, see cleantaxonname.\n\nCalled by mapindividuals.\n\nexamples\n\njulia> net = readTopology(\"(S8,(((S1,S4),(S5)#H1),(#H1,S6)));\");\n\njulia> PhyloNetworks.addindividuals!(net, \"S1\", [\"S1A\", \"S1B\", \"S1C\"])\nSpecies constraint, on tips: S1A, S1B, S1C\n stem edge number 2\n crown node number 2\n\njulia> writeTopology(net) # 3 new nodes, S1 now internal: not a tip\n\"(S8,((((S1A,S1B,S1C)S1,S4),(S5)#H1),(#H1,S6)));\"\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addleaf!","page":"Internals","title":"PhyloNetworks.addleaf!","text":"addleaf!(net::HybridNetwork, node::Node, leafname::String, edgelength::Float64=-1.0)\naddleaf!(net::HybridNetwork, edge::Edge, leafname::String, edgelength::Float64=-1.0)\n\nAdd a new external edge between node or between the \"middle\" of edge and a newly-created leaf, of name leafname. By default, the new edge length is missing (-1).\n\nexamples\n\njulia> net = readTopology(\"((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));\");\n\njulia> net.node[6].name # leaf S4\n\"S4\"\n\njulia> PhyloNetworks.addleaf!(net, net.node[6], \"4a\"); # adding leaf to a node\n\njulia> writeTopology(net, internallabel=true)\n\"((S1,(((S2,(S3)#H1),(#H1,(4a)S4)))#H2),(#H2,S5));\"\n\njulia> PhyloNetworks.addleaf!(net, net.node[6], \"4b\");\n\njulia> writeTopology(net, internallabel=true)\n\"((S1,(((S2,(S3)#H1),(#H1,(4a,4b)S4)))#H2),(#H2,S5));\"\n\njulia> net = readTopology(\"((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));\");\n\njulia> [n.name for n in net.edge[7].node] # external edge to S4\n2-element Vector{String}:\n \"S4\"\n \"\"  \n\njulia> PhyloNetworks.addleaf!(net, net.edge[7], \"4a\"); # adding leaf to an edge\n\njulia> writeTopology(net, internallabel=true)\n\"((S1,(((S2,(S3)#H1),(#H1,(S4,4a))))#H2),(#H2,S5));\"\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.adjacentedges-Tuple{PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.adjacentedges","text":"adjacentedges(centeredge::Edge)\n\nVector of all edges that share a node with centeredge. Warning: assumes that there aren't \"duplicated\" edges, that is, no 2-cycles.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.afterOptBL!-Tuple{HybridNetwork, DataCF, Bool, Bool, Bool, Integer, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.afterOptBL!","text":"afterOptBL road map\n\nFunction that will check if there are h==0,1;t==0,hz==0,1 cases in a network after calling optBL!.\n\nArguments:\n\ncloseN=true will move origin/target, if false, add/delete N times before giving up (we have only tested closeN=true)\norigin=true will move origin, false will move target. We added this to avoid going back and forth between the same networks\nmovesgamma vector of counts of number of times each move is proposed to fix a gamma zero problem: (add,mvorigin,mvtarget,chdir,delete,nni)\n\nProcedure:\n\nFirst we split the ht vector in nh,nt,nhz (gammas, lengths, gammaz)\nIf we find a h==0,1, we loop through nh to find a hybrid edge with h==0 or 1 and want to try to fix this by doing:\ngammaZero!(currT,d,edge,closeN,origin,N,movesgamma) which returns true if there was a successful change, and we stop the loop\nIf we find a t==0, we loop through all nt to find such edge, and do NNI move on this edge; return true if change successful and we stop the loop\nIf we find a hz==0,1, we loop through nhz to find such hybrid edge and call gammaZero again\nIf we did a successful change, we run optBL again, and recheck if there are no more problems.\nReturns successchange, flagh, flagt,flaghz (flag=true means no problems)\nIf it is the multiple alleles case, it will not try to fix h==0,1;hz==0,1 because it can reach a case that violates the multiple alleles condition. If we add a check here, things become horribly slow and inefficient, so we just delete a hybridization that has h==0,1;hz==0,1\n\n** Important: ** afterOptBL is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call afterOptBLRepeat\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.afterOptBLAll!-Tuple{HybridNetwork, DataCF, Integer, Bool, Float64, Float64, Bool, Vector{Int64}, Float64, Float64, Float64}","page":"Internals","title":"PhyloNetworks.afterOptBLAll!","text":"afterOptBLAll road map\n\nAfter optBL, we want to call afterOptBLAll (or afterOptBLAllMultipleAlleles) to check if there are h==0,1; t==0; hz==0,1. This function will try to fix the gamma zero problem, but if it cannot, it will call moveDownLevel, to delete the hybridization from the network.\n\nProcedure:\n\nWhile startover=true and tries<N\n\nWhile badliks < N2 (number of bad pseudolikelihoods are less than N2)\nRun success = afterOptBLRepeat\nIf success = true (it changed something):\nIf worse pseudolik, then go back to original topology currT, set startover=true and badliks++\nIf better pseudolik, then check flags. If all good, then startover=false; otherwise startover = true\nIf success = false (nothing changed), then set badliks=N2+1 (to end the while on currT)\nIf all flags are ok, then startover = false\nIf bad h or hz, then call moveDownLevel (delete one hybridization), and set startover = true (maybe deleting that hybridization did not fix other gamma zero problems)\nIf bad t, then set startover = false\nIf left second while by back to original currT, and still bad h/hz, then move down one level, and startover=true; otherwise startover=false\n\nIf first while ends by tries>N, then it checks one last time the flags, if bad h/hz will move down one level, and exit\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.afterOptBLRepeat!-Tuple{HybridNetwork, DataCF, Integer, Bool, Bool, Bool, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.afterOptBLRepeat!","text":"afterOptBLRepeat road map\n\nafterOptBL is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call afterOptBLRepeat. This function will repeat afterOptBL every time a successful change happened; this is done only if closeN=false, because we would delete/add hybridizations and need to stop after tried N times. If closeN=true (default), then afterOptBLRepeat only does one afterOptBL, because in this case, only the neighbor edges need to be tested, and this would have been done already in gammaZero.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.allowrootbelow!-Tuple{PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.allowrootbelow!","text":"allowrootbelow!(e::Edge)\nallowrootbelow!(n::Node, parent_edge_of_n::Edge)\n\nSet containRoot to true for edge e and all edges below, recursively. The traversal stops whenever a hybrid node is encountered: if the child of e is a hybrid node (that is, if e is a hybrid edge) or if n is a hybrid node, then the edges below e or n are not traversed.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.anova-Union{Tuple{Vararg{StatsModels.TableRegressionModel{PhyloNetworkLinearModel, T}, N} where N}, Tuple{T}} where T","page":"Internals","title":"PhyloNetworks.anova","text":"anova(objs::PhyloNetworkLinearModel...)\n\nTakes several nested fits of the same data, and computes the F statistic for each pair of models.\n\nThe fits must be results of function phylolm called on the same data, for models that have more and more effects.\n\nReturns a DataFrame object with the anova table.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.assignhybridnames!","text":"assignhybridnames!(net)\n\nAssign names to hybrid nodes in the network net. Hybrid nodes with an empty name field (\"\") are modified with a name that does not conflict with other hybrid names in the network. The preferred name is \"H3\" if the node number is 3 or -3, but an index other than 3 would be used if \"H3\" were the name of another node already.\n\nIf two hybrid nodes have non-empty and equal names, the name of one of them is changed and re-assigned as described above (with a warning).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.blobInfo","page":"Internals","title":"PhyloNetworks.blobInfo","text":"blobInfo(network, ignoreTrivial=true)\n\nCalculate the biconnected components (blobs) using function biconnectedComponents then:\n\nset node field isExtBadTriangle to true at the root of each non-trivial blob (and at the network root), false otherwise. (a better name for the field would be something like \"isBlobRoot\".)\noutput:\narray of nodes that are the roots of each non-trivial blob, and the network root. If the root of the full network is not part of a non-trivial blob, a corresponding blob is added to the list.\narray of arrays: for each non-trivial blob, array of major hybrid edges in that blob.\narray of arrays: same as #2 but for minor hybrid edges, with hybrids listed in the same order, for each blob.\n\nBlobs are ordered in reverse topological ordering (aka post order). If ignoreTrivial is true, trivial components are ignored.\n\nkeyword argument: checkPreorder, true by default. If false, the isChild1 edge field and the net.nodes_changed network field are supposed to be correct.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.breakedge!-Tuple{PhyloNetworks.Edge, HybridNetwork}","page":"Internals","title":"PhyloNetworks.breakedge!","text":"breakedge!(edge::Edge, net::HybridNetwork)\n\nBreak an edge into 2 edges, each of length half that of original edge, creating a new node of degree 2. Useful to root network along an edge. Return the new node and the new edge, which is the \"top\" half of the original starting edge. These new node & edge are pushed last in net.node and net.edge.\n\nIf the starting edge was:\n\nn1  --edge-->  n2\n\nthen we get this:\n\nn1  --newedge-->  newnode  --edge-->  n2\n\nisChild1 and containRoot are updated, but not fields for level-1 networks like inCycle, partition, gammaz, etc.\n\nexamples\n\njulia> net = readTopology(\"(((S8,S9),((((S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\");\n\njulia> length(net.node)\n19\n\njulia> net.edge[4] # edge 4 goes from node -8 to 3\nPhyloNetworks.Edge:\n number:4\n length:-1.0\n attached to 2 node(s) (parent first): -8 3\n\n\njulia> newnode, newedge = PhyloNetworks.breakedge!(net.edge[4], net);\n\njulia> length(net.node) # one more than before\n20\n\njulia> newedge # new edge 21 goes from node -8 and 11 (new)\nPhyloNetworks.Edge:\n number:21\n length:-1.0\n attached to 2 node(s) (parent first): -8 11\n\n\njulia> net.edge[4] # original edge 4 now goes from node 11 (new) to 3\nPhyloNetworks.Edge:\n number:4\n length:-1.0\n attached to 2 node(s) (parent first): 11 3\n\n\njulia> writeTopology(net) # note extra pair of parentheses around S1\n\"(((S8,S9),((((S4,(S1)),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\"\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.calculateObsCFAll!-Tuple{DataCF, Union{Vector{Int64}, Vector{String}}}","page":"Internals","title":"PhyloNetworks.calculateObsCFAll!","text":"calculateObsCFAll!(DataCF, taxa::Union{Vector{String}, Vector{Int}})\n\nCalculate observed concordance factors: update the .quartet[i].obsCF values of the DataCF object based on its .tree vector.\n\ncalculateObsCFAll!(vector of quartets, vector of trees, taxa)\n\nCalculate observed concordance factors: update the .obsCF values of the quartets, based on the trees, and returns a new DataCF object with these updated quartets and trees.\n\ncalculateObsCFAll_noDataCF!(vector of quartets, vector of trees, taxa)\n\nupdate the .obsCF values of the quartets based on the trees, but returns nothing.\n\nWarning: all these functions need input trees (without any reticulations: h=0).\n\nSee also: countquartetsintrees, which uses a faster algorithm, processing each input tree only once. calculateObsCFAll_noDataCF! processes each input tree # quartet times.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.checkNumHybEdges!","text":"checkNumHybEdges!(net)\n\nCheck for consistency between hybrid-related attributes in the network:\n\nfor each hybrid node: 2 or more hybrid edges\nexception: allows for a leaf to be attached to a single hybrid edge\nexactly 2 incoming parent hybrid edges\n\nRun after storeHybrids!. See also check2HybEdges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.check_matchtaxonnames!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, HybridNetwork}","page":"Internals","title":"PhyloNetworks.check_matchtaxonnames!","text":"check_matchtaxonnames!(species, data, net)\n\nModify species and dat by removing the species (rows) absent from the network. Return a new network (net is not modified) with tips matching those in species: if some species in net have no data, these species are pruned from the network. The network also has its node names reset, such that leaves have nodes have consecutive numbers starting at 1, with leaves first. Used by fitdiscrete to build a new StatisticalSubstitutionModel.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.checknetwork_LiNC!","page":"Internals","title":"PhyloNetworks.checknetwork_LiNC!","text":"checknetwork_LiNC!(net::HybridNetwork, maxhybrid::Int, no3cycle::Bool,\n    nohybridladder::Bool,\n    constraints=TopologyConstraint[]::Vector{TopologyConstraint},\n    verbose::Bool=false)\n\nCheck that net is an adequate starting network before phyLiNC!: remove nodes of degree 2 (possibly including the root); check that net meets the topological constraints, has no polytomies (except at species constraints), and maxhybrid of fewer reticulations. According to user-given options, also check for the absence of 3-cycles and/or hybrid ladders.\n\njulia> maxhybrid = 3;\n\njulia> net = readTopology(\"(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\");\n\njulia> preorder!(net) # for correct unzipping in checknetwork_LiNC!\n\njulia> PhyloNetworks.checknetwork_LiNC!(net, maxhybrid, true, true)\nHybridNetwork, Rooted Network\n8 edges\n8 nodes: 4 tips, 1 hybrid nodes, 3 internal tree nodes.\ntip labels: A, B, C, D\n((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0,D:2.5);\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.checkspeciesnetwork!-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}","page":"Internals","title":"PhyloNetworks.checkspeciesnetwork!","text":"checkspeciesnetwork!(network::HybridNetwork,\n                     constraints::Vector{TopologyConstraint})\n\nCheck that the network satisfies a number of requirements:\n\nno polytomies, other than at species constraints: throws an error otherwise\nno unnecessary nodes: fuse edges at nodes with degree two, including at the root (hence the bang: net may be modified)\ntopology constraints are met.\n\nOutput: true if all is good, false if one or more clades are violated.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.cleantaxonname-Tuple{AbstractString}","page":"Internals","title":"PhyloNetworks.cleantaxonname","text":"cleantaxonname(taxonname::AbstractString)\n\nReturn a String with leading and trailing spaces removed, and interior spaces replaced by underscores: good for using as tip names in a network without causing future error when reading the newick description of the network.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.constraintviolated-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}","page":"Internals","title":"PhyloNetworks.constraintviolated","text":"constraintviolated(network::HybridNetwork,\n                   constraints::Vector{TopologyConstraint})\n\nTrue if network violates one (or more) of the constraints of type 1 (individuals in a species group) or type 2 (must be clades in the major tree). Warning: constraints of type 3 are not implemented.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.defaultsubstitutionmodel","page":"Internals","title":"PhyloNetworks.defaultsubstitutionmodel","text":"defaultsubstitutionmodel(network, modsymbol::Symbol, data::DataFrame,\n              siteweights::Vector)\n\nReturn a statistical substitution model (SSM) with appropriate state labels and a rate appropriate for the branch lengths in net (see startingrate). The data frame must have the actual trait/site data in columns 2 and up, as when the species names are in column 1. For DNA data, the relative rate model is returned, with a stationary distribution equal to the empirical frequencies.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.deleteEdge!-Tuple{HybridNetwork, PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.deleteEdge!","text":"deleteEdge!(net::HybridNetwork,  e::Edge, part=true)\ndeleteEdge!(net::QuartetNetwork, e::Edge)\n\nDelete edge e from net.edge and update net.numEdges. If part is true, update the network's partition field.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.deleteLeaf!-Tuple{PhyloNetworks.Network, AbstractString}","page":"Internals","title":"PhyloNetworks.deleteLeaf!","text":"deleteLeaf!(net::HybridNetwork, leaf::AbstractString) deleteLeaf!(net::Network, leaf::Node)\n\nDeletes the leaf taxon from the network. The leaf argument is the name of the taxon to delete.\n\nWarnings:\n\nrequires a level-1 network with up-to-date attributes for snaq! (e.g. non-missing branch lengths, gammaz, etc.)\ndoes not care where the root is and does not update it to a sensible location if the root is affected by the leaf removal.\ndoes not merge edges, i.e. does not remove all nodes of degree 2. Within snaq!, this is used to extract quartets and to keep track of which edge lengths in the original network map to the quartet network.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.deleteNode!-Tuple{HybridNetwork, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.deleteNode!","text":"deleteNode!(net::HybridNetwork, n::Node)\n\nDelete node n from a network, i.e. removes it from net.node, and from net.hybrid or net.leaf as appropriate. Update attributes numNodes, numTaxa, numHybrids. Warning: net.names is not updated.\n\nWarning: if the root is deleted, the new root is arbitrarily set to the first node in the list. This is intentional to save time because this function is used frequently in snaq!, which handles semi-directed (unrooted) networks.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.deletehybridedge!","page":"Internals","title":"PhyloNetworks.deletehybridedge!","text":"deletehybridedge!(net::HybridNetwork, edge::Edge,\n                  nofuse=false, unroot=false,\n                  multgammas=false, simplify=true, keeporiginalroot=false)\n\nDelete a hybrid edge from net and return the network. The network does not have to be of level 1 and may contain polytomies, although each hybrid node must have exactly 2 parents. Branch lengths are updated, allowing for missing values.\n\nIf nofuse is false, when edge is removed, its child (hybrid) node is removed and its partner hybrid edge is removed. Its child edge is retained (below the hybrid node), fused with the former partner, with new length: old length + length of edge's old partner. Any 2-cycle is simplified into a single edge, unless simplify is false.\n\nIf nofuse is true, edges with descendant leaves are kept as is, and are not fused. Nodes are retained during edge removal, provided that they have at least one descendant leaf. The hybrid edge that is partner to edge becomes a tree edge, but has its γ value unchanged (it is not set to 1), since it is not merged with its child edge after removal of the reticulation.   Also, 2-cycles are not simplified if nofuse is true. That is, if we get 2 hybrid edges both from the same parent to the same child, these hybrid edges are retained without being fused into a single tree edge.\n\nIf unroot is false and if the root is up for deletion during the process, it will be kept if it's of degree 2 or more. A root node of degree 1 will be deleted unless keeporiginalroot is true.\n\nIf multgammas is true: inheritance weights are kept by multiplying together the inheritance γ's of edges that are merged. For example, if there is a hybrid ladder, the partner hybrid edge remains a hybrid edge (with a new partner), and its γ is the product of the two hybrid edges that have been fused. So it won't add up to 1 with its new partner's γ.\n\nIf keeporiginalroot is true, a root of degree one will not be deleted.\n\nWarnings:\n\ncontainRoot is updated, but this requires correct isChild1 fields\nif the parent of edge is the root and if nofuse is false, the root is moved to keep the network unrooted with a root of degree two.\ndoes not update attributes needed for snaq! (like inCycle, edge.z, edge.y etc.)\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.deletehybridedgeLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, Float64, Bool, Vector{PhyloNetworks.TopologyConstraint}, PhyloNetworks.CacheGammaLiNC, PhyloNetworks.CacheLengthLiNC}","page":"Internals","title":"PhyloNetworks.deletehybridedgeLiNC!","text":"deletehybridedgeLiNC!(obj::SSM, currLik::Float64,\n    no3cycle::Bool,\n    constraints::Vector{TopologyConstraint},\n    γcache::CacheGammaLiNC, lcache::CacheLengthLiNC)\n\nDeletes a random hybrid edge and updates SSM object as part of PhyLiNC optimization. Return true if the move is accepted, false if not.\n\nNote: if net is tree-child and a hybrid edge is deleted, then the resulting network is still tree-child. But: if net has no hybrid ladders, deleting an existing reticulation may create a hybrid ladder. It happens if there is a reticulation above a W structure (tree node whose children are both hybrid nodes). This creates a problem if the user asked for nohybridladder: this request may not be met. fixit: In future, we could check for this case and prevent it.\n\nFor a description of arguments, see phyLiNC. Called by optimizestructure!, which does some checks.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.descendants","page":"Internals","title":"PhyloNetworks.descendants","text":"descendants(edge::Edge, internal::Bool=false)\n\nReturn the node numbers of the descendants of a given edge: all descendant nodes if internal is true (internal nodes and tips), or descendant tips only otherwise (defaults).\n\nedge should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.\n\nExamples\n\njulia> net5 = \"(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));\" |> readTopology |> directEdges! ;\n\njulia> PhyloNetworks.descendants(net5.edge[12], true) # descendants of 12th edge: all of them\n7-element Vector{Int64}:\n -6\n -7\n  4\n  6\n  5\n -9\n  7\n\njulia> PhyloNetworks.descendants(net5.edge[12]) # descendant leaves only\n3-element Vector{Int64}:\n 4\n 5\n 7\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.directionalconflict-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.Edge, Bool}","page":"Internals","title":"PhyloNetworks.directionalconflict","text":"directionalconflict(net::HybridNetwork, parent::Node, edge::Edge,\n                    hybridpartnernew::Bool)\n\nCheck if creating a hybrid edge down of parent node into the middle of edge would create a directed cycle in net, i.e. not a DAG. The proposed hybrid would go in the direction of edge down its child node if hybridpartnernew is true. Otherwise, both halves of edge would have their direction reversed, for the hybrid to go towards the original parent node of edge. Does not modify the network.\n\nOutput: true if a conflict would arise (non-DAG), false if no conflict.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.discrete_backwardlikelihood_trait!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, Integer, Integer}","page":"Internals","title":"PhyloNetworks.discrete_backwardlikelihood_trait!","text":"discrete_backwardlikelihood_trait!(obj::SSM, tree::Integer, ri::Integer)\n\nUpdate and return the backward likelihood (last argument backwardlik) assuming rate category ri and tree index tree, using current forward and backwards likelihoods in obj: these depend on the trait (or site) given to the last call to discrete_corelikelihood_trait!. Used by ancestralStateReconstruction.\n\nwarning: assume correct transition probabilities.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.discrete_corelikelihood!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}","page":"Internals","title":"PhyloNetworks.discrete_corelikelihood!","text":"discrete_corelikelihood!(obj::StatisticalSubstitutionModel;\n                         whichtrait::AbstractVector{Int} = 1:obj.nsites)\n\nCalculate the likelihood and update obj.loglik for discrete characters on a network, calling discrete_corelikelihood_trait!. The algorithm extracts all displayed trees and weighs the likelihood under all these trees. The object's partial likelihoods are updated:\n\nforward and direct partial likelihoods are re-used, one trait at a time,\noverall likelihoods on each displayed tree, given each rate category and for each given site/trait: are cached in _loglikcache.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.discrete_corelikelihood_trait!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, Integer, Integer, Integer}","page":"Internals","title":"PhyloNetworks.discrete_corelikelihood_trait!","text":"discrete_corelikelihood_trait!(obj::SSM, t::Integer, ci::Integer, ri::Integer)\n\nReturn the likelihood for tree t, trait (character/site) index ci and rate category ri. Update & modify the forward & directional log-likelihoods obj.forwardlik and obj.directlik, which are indexed by [state, nodenumber or edgenumber]. Used by discrete_corelikelihood!.\n\nPreconditions: obj.logtrans updated, edges directed, nodes/edges preordered\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.displayedNetworks!","page":"Internals","title":"PhyloNetworks.displayedNetworks!","text":"displayedNetworks!(net::HybridNetwork, node::Node, keepNode=false,\n                   unroot=false, multgammas=false, keeporiginalroot=false)\n\nExtracts the two networks that simplify a given network at a given hybrid node: deleting either one or the other parent hybrid edge. If nofuse is true, the original edges (and nodes) are kept in both networks, provided that they have one or more descendant leaves. If unroot is true, the root will be deleted if it becomes of degree 2. If keeporiginalroot is true, the root is retained even if it is of degree 1.\n\nthe original network is modified: the minor edge removed.\nreturns one HybridNetwork object: the network with the major edge removed\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.edgerelation-Tuple{PhyloNetworks.Edge, PhyloNetworks.Node, PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.edgerelation","text":"edgerelation(e::Edge, node::Node, origin::Edge)\n\nReturn a symbol:\n\n:origin if e is equal to origin, and otherwise:\n:parent if e is a parent of node,\n:child if e is a child of node\n\nusing the isChild1 attribute of edges. Useful when e iterates over all edges adjacent to node and when origin is one of the edges adjacent to node, to known the order in which these edges come.\n\nexample:\n\nlabs = [edgerelation(e, u, uv) for e in u.edge] # assuming u is a node of edge uv\nparentindex = findfirst(isequal(:parent), labs) # could be 'nothing' if no parent\nchildindices = findall( isequal(:child), labs)  # vector. could be empty\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.fliphybrid!","page":"Internals","title":"PhyloNetworks.fliphybrid!","text":"fliphybrid!(net::HybridNetwork, minor=true::Bool, nohybridladder=false::Bool,\n            constraints=TopologyConstraint[]::Vector{TopologyConstraint})\n\nCycle through hybrid nodes in random order until an admissible flip is found. At this hybrid node, flip the indicated hybrid parent edge (minor or major).\n\nIf an admissible flip is found, return the tuple: newhybridnode, flippededge, oldchildedge. Otherwise, return nothing.\n\nThe flip can be undone with fliphybrid!(net, newhybridnode, minor, constraints), or fliphybrid!(net, newhybridnode, !flippededge.isMajor, constraints) more generally, such as if the flipped edge had its γ modified after the original flip.\n\nWarnings\n\nif the root needed to be reset and if the original root was of degree 2, then a node of degree 2 remains in the modified network.\nundoing the flip may not recover the original root in case the root position was modified during the original flip.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.fliphybrid!-2","page":"Internals","title":"PhyloNetworks.fliphybrid!","text":"fliphybrid!(net::HybridNetwork, hybridnode::Node, minor=true::Bool,\n            nohybridladder=false::Bool,\n            constraints=TopologyConstraint[]::Vector{TopologyConstraint})\n\nFlip the direction of a single hybrid edge: the minor parent edge of hybridnode by default, or the major parent edge if minor is false. The parent node of the hybrid edge becomes the new hybrid node. The former hybrid edge partner is converted to a tree edge (with γ=1), and hybridnode becomes a tree node.\n\nFor the flip to be admissible, the new network must be a semi-directed phylogenetic network: with a root such that the rooted version is a DAG. If nohybridladder is false (default), the flip may create a hybrid ladder If nohybridladder is true and if the flip would create a hybrid ladder, then the flip is not admissible. A hybrid ladder is when a hybrid child of another hybrid.\n\nThe new hybrid partner is an edge adjacent to the new hybrid node, such that the flip is admissible (so it must be a tree edge). The flipped edge retains its original γ. The new hybrid edge is assigned inheritance 1-γ.\n\nOutput: (newhybridnode, flippededge, oldchildedge) if the flip is admissible, nothing otherwise.\n\nThe network is unchanged if the flip is not admissible. If the flip is admissible, the root position may be modified, and the direction of tree edges (via isChild1) is modified accordingly. If the root needs to be modified, then the new root is set to the old hybrid node.\n\nThe index of the new hybrid node in net.hybrid is equal to that of the old hybridnode.\n\nWarning: Undoing this move may not recover the original root if the root position was modified.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.fliphybridedgeLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, Float64, Bool, Vector{PhyloNetworks.TopologyConstraint}, Float64, PhyloNetworks.CacheGammaLiNC, PhyloNetworks.CacheLengthLiNC}","page":"Internals","title":"PhyloNetworks.fliphybridedgeLiNC!","text":"fliphybridedgeLiNC!(obj::SSM, currLik::Float64, nohybridladder::Bool,\n                constraints::Vector{TopologyConstraint}, ftolAbs::Float64,\n                γcache::CacheGammaLiNC, lcache::CacheLengthLiNC)\n\nRandomly chooses a minor hybrid edge and tries to flip its direction (that is, reverse the direction of gene flow) using fliphybrid!. If the flip fails, it looks for the next minor hybrid edge. If all minor edges fail, tries to flip major edges in random order.\n\nAfter a successful flip, optimize branch lengths and gammas, then compare the likelihood of the previous network with the new one.\n\nReturn:\n\ntrue if a flip hybrid move was completed and improved the likelihood\nfalse if a move was completed but did not improve the likelihoood\nnothing if no hybrid flip move was admissible in this network.\n\nWarning: Undoing this move may not recover the original root if the root position was modified.\n\nFor arguments, see phyLiNC. Called by optimizestructure!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.fuseedgesat!","page":"Internals","title":"PhyloNetworks.fuseedgesat!","text":"fuseedgesat!(i::Integer,net::HybridNetwork, multgammas=false::Bool)\n\nRemoves ith node in net.node, if it is of degree 2. The parent and child edges of this node are fused. If either of the edges is hybrid, the hybrid edge is retained. Otherwise, the edge with the lower edge number is retained.\n\nReverts the action of breakedge!.\n\nreturns the fused edge.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.gammaZero!-Tuple{HybridNetwork, DataCF, PhyloNetworks.Edge, Bool, Bool, Integer, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.gammaZero!","text":"gammaZero road map\n\nFunction that tries to fix a gamma zero problem (h==0,1; t==0; hz==0,1)\n\nFirst tries to do changeDirection\nIf not successful from start, we call moveHybrid\nIf successful move (change direction), we call optBL and check if we fixed the problem\nIf problem fixed and we do not have worse pseudolik, we return success=true\nIf still problem or worse pseudolik, we call moveHybrid\n\n** Important: ** Any function (afterOptBL) calling gammaZero is assuming that it only made a change, so if the returned value is true, then a change was made, and the other function needs to run optBL and check that all parameters are 'valid'. If the returned value is false, then no change was possible and we need to remove a hybridization if the problem is h==0,1; hz==0,1. If the problem is t==0, we ignore this problem.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getChild-Tuple{PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.getChild","text":"getChild(edge::Edge)\n\nReturn child node using the isChild1 attribute of the edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getChildEdge-Tuple{PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.getChildEdge","text":"getChildEdge(node::Node)\n\nReturn child edge below a hybrid node.\n\nWarning: Does not check that the node is a hybrid. If not a hybrid, returns the first child edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getChildren-Tuple{PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.getChildren","text":"getChildren(node)\n\nreturn a vector with all children nodes of node. warning: assume isChild1 field (for edges) are correct\n\nTo get all parent nodes: see getParents.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getDataValue!-Tuple{IO, Int64, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.getDataValue!","text":"getdataValue!(s::IO, int, numLeft::Array{Int,1})\n\nHelper function for parseEdgeData!. Read a single floating point edge data value in a tree topology. Return -1.0 if no value exists before the next colon, return the value as a float otherwise. Modifies s by advancing past the next colon character. Only call this function to read a value when you know a numerical value exists!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getGammas-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.getGammas","text":"getGammas(net)\n\nGet inheritance γ's of major hybrid edges. Assume pre-order calculated already (with up-to-date field nodes_changed). See setGammas!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getHeights-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.getHeights","text":"getHeights(net)\n\nReturn the height (distance to the root) of all nodes, assuming a time-consistent network (where all paths from the root to a given hybrid node have the same length). Also assumes that the network has been preordered, because it uses getGammas and setGammas!).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getMajorParent-Tuple{PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.getMajorParent","text":"getMajorParent(node)\ngetMinorParent(node)\n\nReturn major or minor parent of a node using the isChild1 field of edges (and assuming correct isMajor field). See also getMajorParentEdge and getMinorParentEdge\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getMajorParentEdge-Tuple{PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.getMajorParentEdge","text":"getMajorParentEdge(node)\ngetMinorParentEdge(node)\n\nreturn the parent edge of a given node: the major / minor if hybrid. warning: assume isChild1 and isMajor attributes are correct\n\nTo get all parent nodes: see getParents.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getMinorParent","page":"Internals","title":"PhyloNetworks.getMinorParent","text":"getMajorParent(node)\ngetMinorParent(node)\n\nReturn major or minor parent of a node using the isChild1 field of edges (and assuming correct isMajor field). See also getMajorParentEdge and getMinorParentEdge\n\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.getMinorParentEdge","page":"Internals","title":"PhyloNetworks.getMinorParentEdge","text":"getMajorParentEdge(node)\ngetMinorParentEdge(node)\n\nreturn the parent edge of a given node: the major / minor if hybrid. warning: assume isChild1 and isMajor attributes are correct\n\nTo get all parent nodes: see getParents.\n\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.getParent-Tuple{PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.getParent","text":"getParent(e::Edge)\n\nReturn parent node of edge e using the isChild1 attribute of the edge. To get parents of nodes: see getParents.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getParents-Tuple{PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.getParents","text":"getParents(node)\n\nGet vector of all parent nodes of n, based on isChild1 field (for edges). To get the parent node of an edge: see getParent. To get individual parent edges (rather than all parent nodes): see getMajorParentEdge and getMinorParentEdge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getPartner-Tuple{Any}","page":"Internals","title":"PhyloNetworks.getPartner","text":"getPartner(edge::Edge)\ngetPartner(edge::Edge, node::Node)\n\nReturn hybrid partner of edge, that is, hybrid edge pointing to the same child as edge. Assumptions (not checked):\n\ncorrect isChild1 field for edge and for hybrid edges\nno in-coming polytomy: a node has 0, 1 or 2 parents, no more\n\nWhen node is given, it is assumed to be the child of edge (the first form calls the second).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getTipSubmatrix-Tuple{Matrix{T} where T, HybridNetwork}","page":"Internals","title":"PhyloNetworks.getTipSubmatrix","text":"getTipSubmatrix(M, net; indexation=:both)\n\nExtract submatrix of M, with rows and/or columns corresponding to tips in the network, ordered like in net.leaf. In M, rows and/or columns are assumed ordered as in net.nodes_changed.\n\nindexation: one of :rows, :cols or :both: are nodes numbers indexed in the matrix by rows, by columns, or both? Subsetting is taken accordingly.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getlengths-Tuple{Vector{PhyloNetworks.Edge}}","page":"Internals","title":"PhyloNetworks.getlengths","text":"getlengths(edges::Vector{Edge})\n\nVector of edge lengths for a vector of edges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getparameters-Tuple{PhyloNetworks.RVASInv}","page":"Internals","title":"PhyloNetworks.getparameters","text":"getparameters(obj::RateVariationAcrossSites)\n\nReturn a copy of the alpha and/or pinv parameters of model obj, in a single vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getparamindex-Tuple{PhyloNetworks.RVASInv}","page":"Internals","title":"PhyloNetworks.getparamindex","text":"getparamindex(obj::RateVariationAcrossSites)\n\nIndices of parameters in (p_invariable, alpha).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hardwiredClusterDistance_unrooted-Tuple{HybridNetwork, HybridNetwork}","page":"Internals","title":"PhyloNetworks.hardwiredClusterDistance_unrooted","text":"hardwiredClusterDistance_unrooted(net1::HybridNetwork, net2::HybridNetwork)\n\nMiminum hardwired cluster dissimilarity between the two networks, considered as unrooted (or semi-directed). This dissimilarity is defined as the minimum rooted distance, over all root positions that are compatible with the direction of hybrid edges. Called by hardwiredClusterDistance.\n\nTo avoid repeating identical clusters, all degree-2 nodes are deleted before starting the comparison. Since rooting the network at a leaf creates a root node of degree 2 and an extra cluster, leaves are excluded from possible rooting positions.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hashybridladder-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.hashybridladder","text":"hashybridladder(net::HybridNetwork)\n\nReturn true if net contains a hybrid ladder: where a hybrid node's child is itself a hybrid node. This makes the network not treechild, assuming it is fully resolved. (One of the nodes does not have any tree-node child).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hybrid3cycle-Tuple{PhyloNetworks.Edge, PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.hybrid3cycle","text":"hybrid3cycle(edge1::Edge, edge2::Edge)\n\nCheck if proposed hybrid edge from edge1 into edge2 would create a 3 cycle, that is, if edge1 and edge2 have a node in common. (This move cannot create a 2-cycles because new nodes would be created in the middle of edges 1 and 2.)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node, PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.hybridEdges","text":"hybridEdges(node::Node, e::Edge)\n\nReturn the 2 edges connected to node other than e, in the same order as node.edge, except that e absent from the list.\n\nDespite what the name suggest, node need not be a hybrid node! node is assumed to have 3 edges, though.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.hybridEdges","text":"hybridEdges(node::Node)\n\nReturn the 3 edges attached to node in a specific order [e1,e2,e3]. Warning: assume a level-1 network with node field hasHybEdge and edge field inCycle up-to-date.\n\nIf node is a hybrid node:\n\ne1 is the major hybrid parent edge of node\ne2 is the minor hybrid parent edge\ne3 is the tree edge, child of node.\n\nIf node is a tree node parent of one child edge:\n\ne1 is the hybrid edge, child of node\ne2 is the tree edge that belongs to the cycle created by e1\ne3 is the other tree edge attached to node (not in a cycle)\n\nOtherwise:\n\ne3 is an external edge from node to a leaf, if one exists.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hybridatnode","page":"Internals","title":"PhyloNetworks.hybridatnode","text":"hybridatnode!(net::HybridNetwork, nodeNumber::Integer)\n\nChange the status of edges in network net, to move the hybrid node in a cycle to the node with number nodeNumber. This node must be in one (and only one) cycle, otherwise an error will be thrown.\n\nnet is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. Check and update the nodes' field inCycle.\n\nexample\n\nnet = readTopology(\"(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\");\nusing PhyloPlots\nplot(net, :R, showNodeNumber=true); # to locate nodes and their numbers. D of hybrid origin\nhybridatnode!(net, -4)\nplot(net, :R, showNodeNumber=true); # hybrid direction reversed: now 2B of hybrid origin\n\n\n\n\n\nhybridatnode!(net::HybridNetwork, hybrid::Node, newNode::Node)\n\nMove the reticulation from hybrid to newNode, which must in the same cycle. net is assumed to be of level 1, but no checks are made and fields are supposed up-to-date.\n\nCalled by hybridatnode!(net, node number), which is itself called by undirectedOtherNetworks.\n\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.inheritanceWeight-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.inheritanceWeight","text":"inheritanceWeight(tree::HybridNetwork)\n\nReturn the log inheritance weight of a network or tree (as provided by displayedTrees with nofuse = true for instance). For a tree displayed in a network, its inheritance weight is the log of the product of γ's of all edges retained in the tree. To avoid underflow, the log is calculated: i.e. sum of log(γ) across retained edges.\n\nIf any edge has a negative γ, it is assumed to mean that its γ is missing, and the function returns missing.\n\nExample\n\njulia> net = readTopology(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\");\n\njulia> trees = displayedTrees(net,0.0; nofuse=true);\n\njulia> PhyloNetworks.inheritanceWeight.(trees)\n2-element Vector{Float64}:\n -0.105361\n -2.30259 \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.initializeWeightsFromLeaves!-Tuple{AbstractArray, HybridNetwork, Any, Any, Symbol}","page":"Internals","title":"PhyloNetworks.initializeWeightsFromLeaves!","text":"initializeWeightsFromLeaves!(w, net, tips, stateset, criterion)\n\nModify weight in w: to Inf for w[n, i] if the \"tips\" data has a state different from the lineage state of index i at node number n. Assumes that w was initialized to 0 for the leaves.\n\ncriterion: should be one of :softwired, :parental or :hardwired.\n\nsoftwired parsimony: lineage states are in this order: ∅,{1},{2},{3},...,{nstates}\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.initializeWeightsFromLeavesSoftwired!-Tuple{AbstractArray, HybridNetwork, Any, Any}","page":"Internals","title":"PhyloNetworks.initializeWeightsFromLeavesSoftwired!","text":"initializeWeightsFromLeavesSoftwired!(w, net, tips, charset)\n\nModify weight in w: to Inf for w[n, s] if the \"tips\" data has a state different from s at node number n. Assumes that w was initialized to 0 for the leaves.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.isconnected-Tuple{Any, Any}","page":"Internals","title":"PhyloNetworks.isconnected","text":"isconnected(node1::Node, node2::Node)\n\nCheck if two nodes are connected by an edge. Return true if connected, false if not connected.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.isdescendant-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.isdescendant","text":"isdescendant(des:Node, anc::Node)\n\nReturn true if des is a strict descendant of anc, using isChild1 fields to determine the direction of edges. See isdescendant_undirected for a version that does not use isChild1.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.isdescendant_undirected-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.isdescendant_undirected","text":"isdescendant_undirected(des:Node, ancestor::Node, parentedge)\n\nReturn true if des is a strict descendant of ancestor when starting from edge parentedge and going towards ancestor onward, regardless of the field isChild1 of tree edges; false otherwise.\n\nThis is useful to know how descendant relationships would change as a result of reverting the direction of a tree edge, without actually modifying the direction (isChild1) of any edge.\n\nparentedge should be connected to ancestor (not checked). The direction of hybrid edges is respected (via isChild1), that is, the traversal does not go from the child to the parent of a hybrid edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.isnested-Tuple{PhyloNetworkLinearModel, PhyloNetworkLinearModel}","page":"Internals","title":"PhyloNetworks.isnested","text":"isnested(m1::PhyloNetworkLinearModel, m2::PhyloNetworkLinearModel)\nisnested(m1::ContinuousTraitEM, m2::ContinuousTraitEM)\n\nTrue if m1 is nested in m2, false otherwise. Models fitted with different criteria (ML and REML) are not nested. Models with different predictors (fixed effects) must be fitted with ML to be considered nested.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.ladderpartition-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.ladderpartition","text":"ladderpartition(tree::HybridNetwork)\n\nFor each node in tree, calculate the clade below each child edge of the node, and each clade moving up the \"ladder\" from the node to the root. The output is a tuple of 2 vectors (node) of vector (clade) of vectors (taxon in clade): below,above. More specifically, for node number n, below[n] is generally of vector of 2 clades: one for the left child and one for the right child of the node (unless the node is of degree 2 or is a polytomy). above[n] contains the grade of clades above node number n.\n\nWARNING: assumes that\n\nnode numbers and edge numbers can be used as indices, that is, be all distinct, positive, covering exactly 1:#nodes and 1:#edges.\nedges are corrected directed (isChild1 is up-to-date) and nodes have been pre-ordered already (field nodes_changed up-to-date).\n\nexamples\n\njulia> tree = readTopology(\"(O,A,((B1,B2),(E,(C,D))));\");\n\njulia> PhyloNetworks.resetNodeNumbers!(tree; checkPreorder=true, type=:postorder)\n\njulia> printNodes(tree)\nnode leaf  hybrid hasHybEdge name inCycle edges'numbers\n1    true  false  false      O    -1      1   \n2    true  false  false      A    -1      2   \n3    true  false  false      B1   -1      3   \n4    true  false  false      B2   -1      4   \n8    false false  false           -1      3    4    5   \n5    true  false  false      E    -1      6   \n6    true  false  false      C    -1      7   \n7    true  false  false      D    -1      8   \n9    false false  false           -1      7    8    9   \n10   false false  false           -1      6    9    10  \n11   false false  false           -1      5    10   11  \n12   false false  false           -1      1    2    11  \n\njulia> below, above = PhyloNetworks.ladderpartition(tree);\n\njulia> below\n12-element Vector{Vector{Vector{Int64}}}:\n [[1]]                      \n [[2]]                      \n [[3]]                      \n [[4]]                      \n [[5]]                      \n [[6]]                      \n [[7]]                      \n [[3], [4]]                 \n [[6], [7]]                 \n [[5], [6, 7]]              \n [[3, 4], [5, 6, 7]]        \n [[1], [2], [3, 4, 5, 6, 7]]\n\njulia> for n in 8:12\n         println(\"clades below node \", n, \": \", join(below[n], \" \"))\n       end\nclades below node 8: [3] [4]\nclades below node 9: [6] [7]\nclades below node 10: [5] [6, 7]\nclades below node 11: [3, 4] [5, 6, 7]\nclades below node 12: [1] [2] [3, 4, 5, 6, 7]\n\njulia> above[8:12] # clades sister to and above nodes 8 through 12:\n5-element Vector{Vector{Vector{Int64}}}:\n [[5, 6, 7], [1], [2]]\n [[5], [3, 4], [1], [2]]\n [[3, 4], [1], [2]]     \n [[1], [2]]             \n []                     \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.lambda!-Tuple{PhyloNetworkLinearModel, Any}","page":"Internals","title":"PhyloNetworks.lambda!","text":"lambda!(m::PhyloNetworkLinearModel, newlambda)\nlambda!(m::ContinuousTraitEM, newlambda)\n\nAssign a new value to the lambda parameter.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.lambda-Tuple{PhyloNetworkLinearModel}","page":"Internals","title":"PhyloNetworks.lambda","text":"lambda(m::PhyloNetworkLinearModel)\nlambda(m::ContinuousTraitEM)\n\nValue assigned to the lambda parameter, if appropriate.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.learnlabels-Tuple{Symbol, DataFrames.AbstractDataFrame}","page":"Internals","title":"PhyloNetworks.learnlabels","text":"learnlabels(model::Symbol, dat::DataFrame)\n\nReturn unique non-missing values in dat, and check that these labels can be used to construct of substitution model of type model.\n\nexamples:\n\njulia> using DataFrames\n\njulia> dat = DataFrame(trait1 = [\"A\", \"C\", \"A\", missing]); # 4×1 DataFrame\n\njulia> PhyloNetworks.learnlabels(:BTSM, dat)\n2-element Vector{String}:\n \"A\"\n \"C\"\n\njulia> PhyloNetworks.learnlabels(:JC69, dat)\n2-element Vector{String}:\n \"A\"\n \"C\"\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.majoredgelength-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.majoredgelength","text":"majoredgelength(net::HybridNetwork)\n\nGenerate vector of edge lengths of major net edges organized in the same order as the edge matrix created via majoredgematrix. Considers values of -1.0 as missing values, recognized as NA in R. Output: vector allowing for missing values.\n\nAssume nodes_changed was updated, to list nodes in pre-order.\n\nExamples\n\njulia> net = readTopology(\"(((A:3.1,(B:0.2)#H1:0.3::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);\");\n\njulia> directEdges!(net); preorder!(net);\n\njulia> PhyloNetworks.majoredgelength(net)\n8-element Vector{Union{Missing, Float64}}:\n  missing\n 0.7     \n  missing\n 1.1     \n  missing\n 3.1     \n 0.3     \n 0.2     \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.majoredgematrix","text":"majoredgematrix(net::HybridNetwork)\n\nMatrix of major edges from net where edge[i,1] is the number of the parent node of edge i and edge[i,2] is the number of the child node of edge i. Assume nodes_changed was updated, to list nodes in pre-order.\n\nExamples\n\njulia> net = readTopology(\"(A,(B,(C,D)));\");\n\njulia> PhyloNetworks.resetNodeNumbers!(net);\n\njulia> PhyloNetworks.majoredgematrix(net)\n6×2 Matrix{Int64}:\n 5  1\n 5  6\n 6  2\n 6  7\n 7  3\n 7  4\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.makemissing!-Tuple{AbstractVector{T} where T}","page":"Internals","title":"PhyloNetworks.makemissing!","text":"makemissing!(x::AbstractVector)\n\nTurn to missing any element of x exactly equal to -1.0. Used for branch lengths and γs. x needs to accept missing values. If not, this can be done with allowmissing(x).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.mapAllelesCFtable!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, Vector{Int64}, Bool, AbstractString}","page":"Internals","title":"PhyloNetworks.mapAllelesCFtable!","text":"mapAllelesCFtable!(quartet CF DataFrame, mapping DataFrame, columns, write?, filename)\n\nModify (and return) the quartet concordance factor (CF) DataFrame: replace each allele name by the species name that the allele maps onto based on the mapping data frame. This mapping data frame should have columns named \"allele\" and \"species\" (see rename! to change column names if need be).\n\nIf write? is true, the modified data frame is written to a file named \"filename\".\n\nWarning: mapAllelesCFtable takes the quartet data file as its second argument, while mapAllelesCFtable! takes the quartet data (which it modifies) as its first argument.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.maxParsimonyNetRun1","page":"Internals","title":"PhyloNetworks.maxParsimonyNetRun1","text":"Road map for various functions behind maxParsimonyNet\n\nmaxParsimonyNet\nmaxParsimonyNetRun1\nmaxParsimonyNetRun1!\n\nAll return their optimized network. Only maxParsimonyNet returns a rooted network (though all functions guarantee that the returned networks agree with the outgroup).\n\nmaxParsimonyNet calls maxParsimonyNetRun1 per run, after a read(write(.)) of the starting network (to ensure level-1 and semi-directedness).\nmaxParsimonyNetRun1 will make a copy of the topology, and will call findStartingTopology! to modify the topology according to random NNI/move origin/move target moves. It then calls maxParsimonyNetRun1! on the modified network\nmaxParsimonyNetRun1! proposes new network with various moves (same moves as snaq), and stops when it finds the most parsimonious network, using parsimonyGF.\n\nNone of these functions allow for multiple alleles yet.\n\nNote that the search algorithm keeps two HybridNetworks at a time: currT (current topology) and newT (proposed topology). Both are kept unrooted (semi-directed), otherwise the moves in proposedTop! function fail. We only root the topologies to calculate the parsimony, so we create a rooted copy (currTr, newTr) to compute parsimony score in this copied topology. We do not root and calculate parsimony score in the original HybridNetworks objects (currT,newT) because the computation of the parsimony score overwrites the inCycle attribute of the Nodes, which messes with the search moves.\n\nExtensions:\n\nother criteria: hardwired, parental (only softwired implemented now)\nremove level-1 restriction: this will involve changing the proposedTop! function to use rSPR or rNNI moves (instead of the level-1 moves coded for snaq!). We need:\nfunctions for rSPR and rNNI moves\ncreate new proposedTop! function (proposedRootedTop?) to choose from the rSPR/rNNI/other moves\nhave the search in maxParsimonuNetRun1! to have rooted currT and rooted newT, instead of keeping semi-directed objects (currT, newT), only to root for the parsimony score (currTr, newTr)\noutgroup is currently String or Node number, but it would be good if it allowed Edge number as an option too. Not sure best way to distinguish between Node number and Edge number, which is why left as Node number for now.\n\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.maxParsimonyNetRun1!","page":"Internals","title":"PhyloNetworks.maxParsimonyNetRun1!","text":"Road map for various functions behind maxParsimonyNet\n\nmaxParsimonyNet\nmaxParsimonyNetRun1\nmaxParsimonyNetRun1!\n\nAll return their optimized network. Only maxParsimonyNet returns a rooted network (though all functions guarantee that the returned networks agree with the outgroup).\n\nmaxParsimonyNet calls maxParsimonyNetRun1 per run, after a read(write(.)) of the starting network (to ensure level-1 and semi-directedness).\nmaxParsimonyNetRun1 will make a copy of the topology, and will call findStartingTopology! to modify the topology according to random NNI/move origin/move target moves. It then calls maxParsimonyNetRun1! on the modified network\nmaxParsimonyNetRun1! proposes new network with various moves (same moves as snaq), and stops when it finds the most parsimonious network, using parsimonyGF.\n\nNone of these functions allow for multiple alleles yet.\n\nNote that the search algorithm keeps two HybridNetworks at a time: currT (current topology) and newT (proposed topology). Both are kept unrooted (semi-directed), otherwise the moves in proposedTop! function fail. We only root the topologies to calculate the parsimony, so we create a rooted copy (currTr, newTr) to compute parsimony score in this copied topology. We do not root and calculate parsimony score in the original HybridNetworks objects (currT,newT) because the computation of the parsimony score overwrites the inCycle attribute of the Nodes, which messes with the search moves.\n\nExtensions:\n\nother criteria: hardwired, parental (only softwired implemented now)\nremove level-1 restriction: this will involve changing the proposedTop! function to use rSPR or rNNI moves (instead of the level-1 moves coded for snaq!). We need:\nfunctions for rSPR and rNNI moves\ncreate new proposedTop! function (proposedRootedTop?) to choose from the rSPR/rNNI/other moves\nhave the search in maxParsimonuNetRun1! to have rooted currT and rooted newT, instead of keeping semi-directed objects (currT, newT), only to root for the parsimony score (currTr, newTr)\noutgroup is currently String or Node number, but it would be good if it allowed Edge number as an option too. Not sure best way to distinguish between Node number and Edge number, which is why left as Node number for now.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.minorreticulationgamma","text":"minorreticulationgamma(net::HybridNetwork)\n\nVector of minor edge gammas (inheritance probabilities) organized in the same order as in the matrix created via minorreticulationmatrix. Considers values of -1.0 as missing values, recognized as NA in R. Output: vector allowing for missing values.\n\nExamples\n\njulia> net = readTopology(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\");\n\njulia> PhyloNetworks.minorreticulationgamma(net)\n1-element Vector{Union{Float64, Missings.Missing}}:\n 0.1\n\n\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.minorreticulationlength","text":"minorreticulationlength(net::HybridNetwork)\n\nVector of lengths for the minor hybrid edges, organized in the same order as in the matrix created via minorreticulationmatrix. Replace values of -1.0 with missing values recognized by R. Output: vector allowing for missing values.\n\nExamples\n\njulia> net = readTopology(\"(((A:3.1,(B:0.2)#H1:0.4::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);\");\n\njulia> PhyloNetworks.minorreticulationlength(net)\n1-element Vector{Union{Missing, Float64}}:\n 0.3\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.minorreticulationmatrix","text":"minorreticulationmatrix(net::HybridNetwork)\n\nMatrix of integers, representing the minor hybrid edges in net. edge[i,1] is the number of the parent node of the ith minor hybrid edge, and edge[i,2] is the number of its child node. Node numbers may be negative, unless they were modified by resetNodeNumbers!. Assumes correct isChild1 fields.\n\nExamples\n\njulia> net = readTopology(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\");\njulia> PhyloNetworks.minorreticulationmatrix(net)\n1×2 Matrix{Int64}:\n -6  3\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.moveHybrid!-Tuple{HybridNetwork, PhyloNetworks.Edge, Bool, Bool, Integer, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.moveHybrid!","text":"moveHybrid road map\n\nFunction that tries to fix a gamma zero problem (h==0,1; t==0; hz==0,1) after changing direction of hybrid edge failed. This function is called in gammaZero.\n\nArguments:\n\ncloseN=true will try move origin/target on all neighbors (first choose minor/major edge at random, then make list of all neighbor edges and tries to put the hybrid node in all the neighbors until successful move); if false, will delete and add hybrid until successful move up to N times (this is never tested)\n\nReturns true if change was successful (not testing optBL again), and false if we could not move anything\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.moveroot!","page":"Internals","title":"PhyloNetworks.moveroot!","text":"moveroot!(net::HybridNetwork, constraints=TopologyConstraint[]::Vector{TopologyConstraint})\n\nMove the root to a randomly chosen non-leaf node that is different from the current root, and not within a constraint clade or species. Output: true if successul, nothing otherwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.nameinternalnodes!-Tuple{HybridNetwork, Any}","page":"Internals","title":"PhyloNetworks.nameinternalnodes!","text":"nameinternalnodes!(net::HybridNetwork, prefix)\n\nAdd names to nodes in net that don't already have a name. Leaves already have names; but if not, they will be give names as well. New node names will be of the form \"prefixI\" where I is an integer.\n\nexamples\n\njulia> net = readTopology(\"((a:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);\");\n\njulia> PhyloNetworks.nameinternalnodes!(net, \"I\") # by default, shown without internal node names\nHybridNetwork, Rooted Network\n7 edges\n7 nodes: 3 tips, 1 hybrid nodes, 3 internal tree nodes.\ntip labels: a, b, c\n((a:1.0,(b:1.0)#H1:1.0::0.8)I1:5.0,(#H1:0.0::0.2,c:1.0)I2:1.0)I3;\n\njulia> writeTopology(net; internallabel=false) # by default, writeTopology shows internal names if they exist\n\"((a:1.0,(b:1.0)#H1:1.0::0.8):5.0,(#H1:0.0::0.2,c:1.0):1.0);\"\n\njulia> net = readTopology(\"((int5:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);\"); # one taxon name starts with \"int\"\n\njulia> PhyloNetworks.nameinternalnodes!(net, \"int\");\n\njulia> writeTopology(net)\n\"((int5:1.0,(b:1.0)#H1:1.0::0.8)int6:5.0,(#H1:0.0::0.2,c:1.0)int7:1.0)int8;\"\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.nchoose1234-Tuple{Int64}","page":"Internals","title":"PhyloNetworks.nchoose1234","text":"nchoose1234(nmax)\n\nnmax+1 x 4 matrix containing the binomial coefficient \"n choose k\" in row n+1 and column k. In other words, M[i,k] gives \"i-1 choose k\". It is useful to store these values and look them up to rank (a large number of) 4-taxon sets: see quartetrank.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.nj!","page":"Internals","title":"PhyloNetworks.nj!","text":"nj!(D::Matrix{Float64}, names::AbstractVector{String}=String[];\n    force_nonnegative_edges::Bool=false)\n\nConstruct a phylogenetic tree from the input distance matrix and vector of names (as strings), using the Neighbour-Joinging algorithm (Satou & Nei 1987). The order of the names argument should match that of the row (and column) of the matrix D. With force_nonnegative_edges being true, any negative edge length is changed to 0.0 (with a message).\n\nWarning: D is modified.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.nni_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, Bool, Bool, Vector{PhyloNetworks.TopologyConstraint}, Float64, PhyloNetworks.CacheGammaLiNC, PhyloNetworks.CacheLengthLiNC}","page":"Internals","title":"PhyloNetworks.nni_LiNC!","text":"nni_LiNC!(obj::SSM, no3cycle::Bool, nohybridladder::Bool,\n          constraints::Vector{TopologyConstraint},\n          ftolAbs::Float64,\n          γcache::CacheGammaLiNC, lcache::CacheLengthLiNC)\n\nLoop over possible edges for a nearest-neighbor interchange move until one is found. Performs move and compares the original and modified likelihoods. If the modified likelihood is greater than the original by likAbs, the move is accepted.\n\nReturn true if move accepted, false if move rejected. Return nothing if there are no nni moves possible in the network.\n\nFor arguments, see phyLiNC.\n\nCalled by optimizestructure!, which is called by phyLiNC!.\n\nNote: an RR move does not change the best likelihood. RR means that there's a hybrid ladder, so it looks like a hard polytomy at the reticulation after unzipping. Theoretically, we could avoid the re-optimizing the likelihood accept the move: just change inheritance values to get same likelihood, and update the tree priors. Not done.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.nnimax-Tuple{PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.nnimax","text":"nnimax(e::Edge)\n\nReturn the number of NNI moves around edge e, assuming that the network is semi-directed. Return 0 if e is not internal, and more generally if either node attached to e does not have 3 edges.\n\nOutput: UInt8 (e.g. 0x02)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.norootbelow!-Tuple{PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.norootbelow!","text":"norootbelow!(e::Edge)\n\nSet containRoot to false for edge e and all edges below, recursively. The traversal stops if e.containRoot is already false, assuming that containRoot is already false all the way below down that edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.optBL!-Tuple{HybridNetwork, DataCF, Bool, Float64, Float64, Float64, Float64}","page":"Internals","title":"PhyloNetworks.optBL!","text":"optBL road map\n\nFunction that optimizes the numerical parameters (branch lengths and inheritance probabilities) for a given network. This function is called multiple times inside optTopLevel!.\n\nInput: network net, data d\nNumerical tolerances: ftolAbs, ftolRel, xtolAbs, xtolRel\nFunction based on MixedModels fit function\nThe function assumes net has all the right attributes, and cannot check this inside because it would be inefficient\n\nProcedure:\n\nht = parameters!(net) extracts the vector of parameters to estimate (h,t,gammaz), and sets as net.ht; identifies a bad diamond I, sets net.numht (vector of hybrid node numbers for h, edge numbers for t, hybrid node numbers for gammaz), and net.index to keep track of the vector of parameters to estimate\nextractQuartet!(net,d) does the following for all quartets in d.quartet:\nExtract quartet by deleting all leaves not in q -> create QuartetNetwork object saved in q.qnet\nThis network is ugly and does not have edges collapsed. This is done to keep a one-to-one correspondence between the edges in q.qnet and the edges in net (if we remove nodes with only two edges, we will lose this correspondence)\nCalculate expected CF with calculateExpCFAll for a copy of q.qnet. We do this copy because we want to keep q.qnet as it is (without collapsed edges into one). The function will then save the expCF in q.qnet.expCF\ncalculateExpCFAll!(qnet) will\nidentify the type of quartet as type 1 (equivalent to a tree) or type 2 (minor CF different). Here the code will first clean up any hybrid node by removing nodes with only two edges before identifying the qnet (because identification depends on neighbor nodes to hybrid node); later, set qnet.which (1 or 2), node.prev (neighbor node to hybrid node), updates node.k (number of nodes in hybridization cycle, this can change after deleting the nodes with only two edges), node.typeHyb (1,2,3,4,5 depending on the number of nodes in the hybridization cycle and the origin/target of the minor hybrid edge; this attribute is never used).\neliminate hybridization: this will remove type 1 hybridizations first. If qnet.which=1, then the qnet is similar to a tree quartet, so it will calculate the internal length of the tree quartet: qnet.t1.\nupdate split for qnet.which=1, to determine which taxa are together. For example, for the quartet 12|34, the split is [1,1,2,2] or [2,2,1,1], that is, taxon 1 and 2 are on the same side of the split. This will update qnet.split\nupdate formula for qnet.which=1 to know the order of minorCF and majorCF in the vector qnet.expCF. That is, if the quartet is 1342 (order in qnet.quartet.taxon), then the expected CF should match the observed CF in 13|42, 14|32, 12|34 and the qnet is 12|34 (given by qnet.split), qnet.formula will be [2,2,1] minor, minor, major\ncalculateExpCF!(qnet) for qnet.which=1, it will do 1-2/3exp(-qnet.t1) if qnet.formula[i]==1, and 1/3exp(qnet.t1) if qnet.formula[i]==2. For qnet.which=2, we need to make sure that there is only one hybrid node, and compute the major, minor1,minor2 expected CF in the order 12|34, 13|24, 14|23 of the taxa in qnet.quartet.taxon\n\nThen we create a NLopt object with algorithm BOBYQA and k parameters (length of ht). We define upper and lower bounds and define the objective function that should only depend on x=(h,t,gz) and g (gradient, which we do not have, but still need to put as argument).\n\nThe objective function obj(x,g) calls\n\ncalculateExpCFAll!(d,x,net) needs to be run after extractQuartet(net,d) that will update q.qnet for all quartet.  Assumes that qnet.indexht is updated already: we only need to do this at the beginning of optBL! because the topology is fixed at this point)\nFirst it will update the edge lengths according to x\nIf the q.qnet.changed=true (that is, any of qnet branches changed value), we need to call calculateExpCFAll!(qnet) on a copy of q.qnet (again because we want to leave q.qnet with the edge correspondence to net)\nupdate!(net,x) simply saves the new x in net.ht\n\nFinally, we call NLopt.optimize, and we update the net.loglik and net.ht at the end. After optBL, we want to call afterOptBLAll (or afterOptBLAllMultipleAlleles) to check if there are h==0,1; t==0; hz==0,1.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.optTopLevel!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, IO, Bool}","page":"Internals","title":"PhyloNetworks.optTopLevel!","text":"optTopLevel road map\n\nFunction that does most of the heavy-lifting of snaq. It optimizes the pseudolikelihood for a given starting topology, and returns the best network. Assumes that the starting topology is level-1 network, and has all the attributes correctly updated.\n\nInput parameters:\n\nStarting topology currT, input data DataCF d, maximum number of hybridizations hmax\nNumerical optimization parameters: liktolAbs, Nfail, ftolRel, ftolAbs, xtolRel, xtolAbs\nPrint parameters: verbose, logfile, writelog\nParameters to tune the search in space of networks: closeN=true only propose move origin/target to neighbor edges (coded, but not tested with closeN=false), Nmov0 vector with maximum number of trials allowed per type of move (add, mvorigin, mvtarget, chdir, delete, nni), by default computed inside with coupon’s collector formulas\n\nThe optimization procedure keeps track of\n\nmovescount: count of proposed moves,\nmovesgamma: count of proposed moves to fix a gamma zero situation (see below for definition of this situation),\nmovesfail: count of failed moves by violation of level-1 network (inCycle attribute) or worse pseudolikelihood than current,\nfailures: number of failed proposals that had a worse pseudolikelihood\n\nOptimization procedure:\n\nWhile the difference between current loglik and proposed loglik is greater than liktolAbs, or failures<Nfail, or stillmoves=true:\n\nNmov is updated based on newT. The type of move proposed will depend on newT (which is the same as currT at this point). For example, if currT is a tree, we cannot propose move origin/target.\nmove = whichMove selects randomly a type of move, depending on Nmov,movesfail,hmax,newT with weights 1/5 by default for all, and 0 for delete. These weights are adjusted depending on newT.numHybrids and hmax. If newT.numHybrids is far from hmax, we give higher probability to adding a new hybrid (we want to reach the hmax sooner, maybe not the best strategy, easy to change).  Later, we adjust the weights by movesfail (first, give weight of 0 if movesfail[i]>Nmov[i], that is, if we reached the maximum possible number of moves allowed for a certain type) and then increase the probability of the other moves.  So, unless one move has w=0, nothing changes. This could be improved by using the outlier quartets to guide the proposal of moves.\nwhichMove will choose a move randomly from the weights, it will return none if no more moves allowed, in which case, the optimization ends\nflag=proposedTop!(move, newT) will modify newT based on move. The function proposedTop will return flag=true if the move was successful (the move succeeded by inCycle, containRoot, available edge to make the move (more details in proposedTop)). If flag=false, then newT is cleaned, except for the case of multiple alleles. The function proposedTop keeps count of movescount (successful move), movesfail (unsuccessful move),\nOptions:\nrandom=true: moves major/minor hybrid edge with prob h,1-h, respectively\nN=10: number of trials for NNI edge.\nif(flag) Optimize branch lengths with optBL\nIf newT.loglik is better than currT.loglik by liktolAbs, jump to newT (accepted=true) and fix gamma=0, t=0 problems (more info on afterOptBL)\nIf(accepted)   failures=0, movesfail=zeros, movescount for successful move +1\n\nend while\n\nAfter choosing the best network newT, we do one last more thorough optimization of branch lengths with optBL, we change non identifiable branch lengths to -1 (only in debug mode) and return newT\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.optTopRun1!-Tuple{HybridNetwork, Any, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, IO, Bool, Float64}","page":"Internals","title":"PhyloNetworks.optTopRun1!","text":"optTopRun1!(net, liktolAbs, Nfail, d::DataCF, hmax, etc.)\n\nThe function will run 1 run by modifying the starting topology and calling optTopLevel. See optTopRuns! for a roadmap.\n\nprobST (default in snaq is 0.3) is the probability of starting one run at the same input tree. So, with probability 1-probST, we will change the topology by a NNI move on a tree edge without neighbor hybrid. If the starting topology is a network, then with probability 1-probST it will also modify one randomly chosen hybrid edge: with prob 0.5, the function will move origin, with prob 0.5 will do move target.\n\nIf there are multiple alleles (d.repSpecies not empty), then the function has to check that the starting topology does not violate the multiple alleles condition.\n\nAfter modifying the starting topology with NNI and/or move origin/target, optTopLevel is called.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.optTopRuns!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, AbstractString, AbstractString, Integer, Float64}","page":"Internals","title":"PhyloNetworks.optTopRuns!","text":"Road map for various functions behind snaq!\n\nsnaq!\noptTopRuns!\noptTopRun1!\noptTopLevel!\noptBL!\n\nAll return their optimized network.\n\nsnaq! calls optTopRuns! once, after a deep copy of the starting network. If the data contain multiple alleles from a given species, snaq! first expands the leaf for that species into 2 separate leaves, and merges them back into a single leaf after calling optTopRuns!.\noptTopRuns! calls optTopRun1! several (nrun) times. assumes level-1 network with >0 branch lengths. assumes same tips in network as in data: i.e. 2 separate tips per species                                          that has multiple alleles. each call to optTopRun1! gets the same starting network.\noptTopRun1! calls optTopLevel! once, after deep copying + changing the starting network slightly.\noptTopLevel! calls optBL! various times and proposes new network with various moves.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.optimizeallgammas_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, Float64, PhyloNetworks.CacheGammaLiNC, Int64}","page":"Internals","title":"PhyloNetworks.optimizeallgammas_LiNC!","text":"optimizeallgammas_LiNC!(obj::SSM, ftolAbs::Float64,\n                        γcache::CacheGammaLiNC, maxeval=1000::Int)\n\nOptimize all γ's in a network, one by one using [optimizegamma_LiNC!] until maxeval γ's have been optimized or until the difference in log-likelihood falls below ftolAbs.\n\nAt the end: hybrid edges with γ=0 are deleted (if any).\n\nOutput: true if reticulations have been deleted, false otherwise. If true, updateSSM! needs to be called afterwards, with constraints if any. (Constraints are not known here). Before updating the displayed trees in the SSM, shrink2cycles! or shrink3cycles! could be called, if desired, despite the (slight?) change in likelihood that this shrinking would cause. 2/3-cycles are not shrunk here.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.optimizealllengths_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, PhyloNetworks.CacheLengthLiNC}","page":"Internals","title":"PhyloNetworks.optimizealllengths_LiNC!","text":"optimizealllengths_LiNC!(obj::SSM, lcache::CacheLengthLiNC)\n\nOptimize all branch lengths, except those below hybrid edges (whose lengths are not identifiable). Same assumptions as in optimizelocalBL_LiNC!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.optimizegamma_LiNC!","page":"Internals","title":"PhyloNetworks.optimizegamma_LiNC!","text":"optimizegamma_LiNC!(obj::SSM, focusedge::Edge,\n                ftolAbs::Float64, cache::CacheGammaLiNC, maxNR=10::Int)\n\nOptimize γ on a single hybrid edge using the Newton-Raphson method (the log-likelihood is concave). The new log-likelihood is returned after updating obj and its fields with the new γ.\n\nThe search stops if the absolute difference in log-likelihood between two consecutive iterations is below ftolAbs, or after maxNR Newton-Raphson iterations.\n\nWarnings:\n\nno check that edge is hybrid\nobj._loglikcache and displayed trees (etc.) are assumed to be up-to-date, and is updated alongside the new γ.\n\nUsed by optimizelocalgammas_LiNC! and optimizeallgammas_LiNC!.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.optimizelength_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, PhyloNetworks.Edge, PhyloNetworks.CacheLengthLiNC, Any}","page":"Internals","title":"PhyloNetworks.optimizelength_LiNC!","text":"optimizelength_LiNC!(obj::SSM, edge::Edge, cache::CacheLengthLiNC, Qmatrix)\n\nOptimize the length of a single edge using a gradient method, if edge is not below a reticulation (the unzipped canonical version should have a length of 0 below reticulations). Output: nothing.\n\nWarning: displayed trees are assumed up-to-date, with nodes preordered\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.optimizelocalBL_LiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, PhyloNetworks.Edge, PhyloNetworks.CacheLengthLiNC}","page":"Internals","title":"PhyloNetworks.optimizelocalBL_LiNC!","text":"optimizelocalBL_LiNC!(obj::SSM, edge::Edge, lcache::CacheLengthLiNC)\n\nOptimize branch lengths in net locally around edge. Update all edges that share a node with edge (including itself). Constrains branch lengths to zero below hybrid nodes. Return vector of updated edges (excluding constrained edges). The tolerance values and parameters controlling the search are set in lcache.\n\nUsed after nni! or addhybridedge! moves to update local branch lengths. See phyLiNC!.\n\nAssumptions:\n\ndisplayed trees in obj are up-to-date with nodes preordered, and obj.priorltw are up-to-date.\nbranch lengths are at or above the lower bound, and definitely non-negative.\n\njulia> net = readTopology(\"(((A:2.0,(B:0.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\");\n\njulia> fastafile = abspath(joinpath(dirname(Base.find_package(\"PhyloNetworks\")), \"..\", \"examples\", \"simple.aln\"));\n\njulia> obj = PhyloNetworks.StatisticalSubstitutionModel(net, fastafile, :JC69);\n\njulia> obj.loglik = -Inf64; # not calculated yet\n\njulia> e = obj.net.edge[4];\n\njulia> e.length\n1.5\n\njulia> using Random; Random.seed!(1234);\n\njulia> PhyloNetworks.optimizelocalBL_LiNC!(obj, e, PhyloNetworks.CacheLengthLiNC(obj, 1e-6,1e-6,1e-2,1e-2, 10));\n\njulia> round(e.length, sigdigits=6) # we get the lower bound from PhyLiNC in this case\n1.0e-8\n\njulia> writeTopology(obj.net; round=true)\n\"(((A:0.338,(B:0.0)#H1:0.04::0.9):0.0,(C:0.6,#H1:1.0::0.1):0.0):0.0,D:2.0);\"\n\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.optimizelocalgammas_LiNC!","page":"Internals","title":"PhyloNetworks.optimizelocalgammas_LiNC!","text":"optimizelocalgammas_LiNC!(obj::SSM, edge::Edge,\n                          ftolAbs::Float64, γcache::CacheGammaLiNC,\n                          maxeval=1000::Int)\n\nOptimize γ's in net locally around edge. Update all edges adjacent to edge (including itself), one by one using [optimizegamma_LiNC!] until maxeval γ's have been optimized or until the difference in log-likelihood falls below ftolAbs. nothing is returned.\n\nUsed after nni! or addhybridedge! moves to update local gammas.\n\nAssumptions:\n\ncorrect isChild1 field for edge and for hybrid edges\nno in-coming polytomy: a node has 0, 1 or 2 parents, no more\n\n```jldoctest julia> net = readTopology(\"(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\");\n\njulia> fastafile = abspath(joinpath(dirname(Base.find_package(\"PhyloNetworks\")), \"..\", \"examples\", \"simple.aln\"));\n\njulia> obj = PhyloNetworks.StatisticalSubstitutionModel(net, fastafile, :JC69);\n\njulia> obj.net.edge[3].gamma 0.9\n\njulia> using Random; Random.seed!(1234);\n\njulia> PhyloNetworks.optimizelocalgammas_LiNC!(obj, obj.net.edge[3], 1e-3, PhyloNetworks.CacheGammaLiNC(obj));\n\njulia> obj.net.edge[3].gamma 0.0 ````\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.optimizestructure!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, Integer, Integer, Bool, Bool, Integer, Integer, Vector{PhyloNetworks.TopologyConstraint}, Float64, PhyloNetworks.CacheGammaLiNC, PhyloNetworks.CacheLengthLiNC}","page":"Internals","title":"PhyloNetworks.optimizestructure!","text":"optimizestructure!(obj::SSM, maxmoves::Integer, maxhybrid::Integer,\n                   no3cycle::Bool, nohybridladder::Bool,\n                   nreject::Integer, nrejectmax::Integer,\n                   constraints::Vector{TopologyConstraint},\n                   ftolAbs::Float64,\n                   γcache::CacheGammaLiNC, lcache::CacheLengthLiNC)\n\nAlternate NNI moves, hybrid additions / deletions, and root changes based on their respective weights in moveweights_LiNC ([0.4, 0.2, 0.2, 0.2]). Branch lengths and hybrid γs around the NNI focal edge or around the added / deleted hybrid edge are optimized (roughly) on the proposed network. Each proposed network is accepted –or not– if the likelihood improves (or doesn't decrease much for hybrid deletion). After adding or removing a hybrid, obj is updated, to have correct displayed trees and node/edge numberings: done by nni_LiNC!, addhybridedgeLiNC! and deletehybridedgeLiNC!.\n\nOutput: number of consecutive rejections so far.\n\nThe percent of nni moves, hybrid additions, hybrid deletions, and root changes to be performed is in PhyloNetworks.moveweights_LiNC.\n\nmaxmoves: maximum number of moves to be performed, including root changes, which don't actually change the semi-directed topology and likelihood.\nnreject: number of consecutive rejections (ignoring root changes), prior to starting the search (from a prior function call)\nnrejectmax: the search stops when there has been this number of moves that have been rejected in a row (ignoring root changes)\n\nFor a description of other arguments, see phyLiNC.\n\nAssumptions:\n\nchecknetworkbeforeLiNC and discrete_corelikelihood! have been called on obj.net.\nstarting with a network without 2- and 3- cycles (checked by checknetworkbeforeLiNC)\n\nNote: When removing a hybrid edge, always removes the minor edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.pairwiseTaxonDistanceGrad-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.pairwiseTaxonDistanceGrad","text":"pairwiseTaxonDistanceGrad(net; checkEdgeNumber=true, nodeAges=[])\n\n3-dim array: gradient of pairwise distances between all nodes. (internal and leaves); gradient with respect to edge lengths if nodeAges is empty; with respect to node ages otherwise. Assume correct net.nodes_changed (preorder).   This gradient depends on the network's topology and γ's only, not on branch lengths or node ages (distances are linear in either).\n\nWARNING: edge numbers need to range between 1 and #edges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parseEdgeData!-Tuple{IO, PhyloNetworks.Edge, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.parseEdgeData!","text":"parseEdgeData!(s::IO, edge, numberOfLeftParentheses::Array{Int,1})\n\nHelper function for readSubtree!, fixes a bug from using setGamma Modifies e according to the specified edge length and gamma values in the tree topology. Advances the stream s past any existing edge data. Edges in a topology may optionally be followed by \":edgeLen:bootstrap:gamma\" where edgeLen, bootstrap, and gamma are decimal values.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parseHybridNode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, String, HybridNetwork, Vector{String}}","page":"Internals","title":"PhyloNetworks.parseHybridNode!","text":"parseHybridNode!(node, parentNode, hybridName, net, hybrids)\n\nHelper function for readSubtree!. Create the parent edge for node. Return this edge, and the hybrid node retained (node or its clone in the newick string). Insert new edge and appropriate node into net and hybrids accordingly. Handles any type of given hybrid node. Called after a # has been found in a tree topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parseRemainingSubtree!-Tuple{IO, Vector{Int64}, HybridNetwork, Vector{String}}","page":"Internals","title":"PhyloNetworks.parseRemainingSubtree!","text":"parseRemainingSubtree!(s::IO, numLeft, net, hybrids)\n\nCreate internal node. Helper for readSubtree!, which creates the parent edge of the node created by parseRemainingSubtree!: readSubtree! calls parseRemainingSubtree!, and vice versa. Called once a ( has been read in a tree topology and reads until the corresponding ) has been found. This function performs the recursive step for readSubtree!. Advances s past the subtree, adds discovered nodes and edges to net, and hybrids.\n\nDoes not read the node name and the edge information of the subtree root: this is done by readSubtree!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parseTreeNode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, HybridNetwork}","page":"Internals","title":"PhyloNetworks.parseTreeNode!","text":"parseTreeNode!(node, parentNode, net)\n\nHelper function for readSubtree!. Insert the input tree node and associated edge (created here) into net.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyBottomUpFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}, Vector{Int64}}} where T","page":"Internals","title":"PhyloNetworks.parsimonyBottomUpFitch!","text":"parsimonyBottomUpFitch!(node, states, score)\n\nBottom-up phase (from tips to root) of the Fitch algorithm: assign sets of character states to internal nodes based on character states at tips. Polytomies okay. Assumes a tree (no reticulation) and correct isChild1 attribute.\n\noutput: dictionary with state sets and most parsimonious score\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyBottomUpGF!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"Internals","title":"PhyloNetworks.parsimonyBottomUpGF!","text":"parsimonyBottomUpGF!(node, blobroot, nchar, w, scores,\n                     costmatrix1, costmatrix2)\n\nCompute the MP scores (one for each assignment of the blob root state) given the descendants of a blob, conditional on the states at predefined parents of hybrids in the blobs (one parent per hybrid) as described in\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\n\nAssumes a set of state guesses, ie correct initialization of w for predefined hybrid parents, and correct fromBadDiamondI field for the children edges of these predefined parents. fromBadDiamondI is true for edges that are cut.\n\nThe field isExtBadTriangle is used to know which nodes are at the root of a blob. The field isChild1 is used (and assumed correct). Field inCycle is assumed to store the # of detached parents (with guessed states)\n\nnchar: number of characters considered at internal lineages. For softwired parsimony, this is # states + 1, because characters at internal nodes are ∅, {1}, {2}, etc. For parental parsimony, this is 2^#states -1, because characters are all sets on {1,2,...} except for the empty set ∅.\ncostmatrix1[i,j] and costmatrix2[k][i,j]: 2d array and vector of 2d arrays containing the cost of going to character j starting from character i when the end node has a single parent, or the cost of a child node having character j when its parents have characters k and i. These cost matrices are pre-computed depending on the parsimony criterion (softwired, hardwired, parental etc.)\n\nused by parsimonyGF.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyBottomUpSoftwired!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, AbstractArray, AbstractArray}","page":"Internals","title":"PhyloNetworks.parsimonyBottomUpSoftwired!","text":"parsimonyBottomUpSoftwired!(node, blobroot, states, w, scores)\n\nComputing the MP scores (one for each assignment of the root state) of a swicthing as described in Algorithm 1 in the following paper:\n\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\nAssumes a switching (ie correct fromBadDiamondI field) and correct isChild1 field. The field isExtBadTriangle is used to know which nodes are at the root of a blob.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyDiscreteFitch-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T","page":"Internals","title":"PhyloNetworks.parsimonyDiscreteFitch","text":"parsimonyDiscreteFitch(net, tipdata)\n\nCalculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network. Tip data can be given in a data frame, in which case the taxon names are to appear in column 1 or in a column named \"taxon\" or \"species\", and trait values are to appear in column 2 or in a column named \"trait\". Alternatively, tip data can be given as a dictionary taxon => trait.\n\nalso return the union of all optimized character states at each internal node as obtained by Fitch algorithm, where the union is taken over displayed trees with the MP score.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonySummaryFitch-Union{Tuple{T}, Tuple{HybridNetwork, Dict{Int64, Set{T}}}} where T","page":"Internals","title":"PhyloNetworks.parsimonySummaryFitch","text":"parsimonySummaryFitch(tree, nodestates)\n\nsummarize character states at nodes, assuming a tree\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyTopDownFitch!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}}} where T","page":"Internals","title":"PhyloNetworks.parsimonyTopDownFitch!","text":"parsimonyTopDownFitch!(node, states)\n\nTop-down phase (root to tips) of the Fitch algorithm: constrains character states at internal nodes based on the state of the root. Assumes a tree: no reticulation.\n\noutput: dictionary with state sets\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.phyLiNC","page":"Internals","title":"PhyloNetworks.phyLiNC","text":"phyLiNC(net::HybridNetwork, fastafile::String, substitutionModel::Symbol)\n\nEstimate a phylogenetic network from concatenated DNA data using maximum likelihood, ignoring incomplete lineage sorting (phyLiNC: phylogenetic Likelihood Network from Concatenated data). The network is constrained to have maxhybrid reticulations at most, but can be of any level. The search starts at (or near) the network net, using a local hill-climbing search to optimize the topology (nearest-neighbor interchange moves, add hybridizations, and remove hybridizations). Also optimized are evolutionary rates, amount of rate variation across sites, branch lengths and inheritance γs. This search strategy is run nruns times, and the best of the nruns networks is returned.\n\nReturn a StatisticalSubstitutionModel object, say obj, which contains the estimated network in obj.net.\n\nRequired arguments:\n\nnet: a network or tree of type HybridNetwork, to serve as a starting point in the search for the best network. Newick strings can be converted to this format with readTopology.\nfastafile: file with the sequence data in FASTA format. Ambiguous states are treated as missing.\nsubstitutionModel: A symbol indicating which substitution model is used. Choose :JC69 JC69 for the Jukes-Cantor model or :HKY85 for the Hasegawa, Kishino, Yano model HKY85.\n\nThe length of the edge below a reticulation is not identifiable. Therefore, phyLiNC estimates the canonical version of the network: with reticulations unzipped: edges below reticulations are set to 0, and hybrid edges (parental lineages) have estimated lengths that are increased accordingly.\n\nIf any branch lengths are missing in the input network, phyLiNC estimates the starting branch lengths using pairwise distances. Otherwise, it uses the input branch lengths as starting branch lengths, only unzipping all reticulations, as described above.\n\nOptional arguments (default value in parenthesis):\n\nsymbol for the model of rate variation across sites (:noRV for no rate variation): use :G or :Gamma for Gamma-distributed rates, :I or :Inv for a proportion of invariable sites, and :GI or :GammaInv for a combination (not recommended).\ninteger (4) for the number of categories to use in estimating evolutionary rates using a discretized gamma model. When allowing for rate variation, four categories is standard. With 1 category, no rate variation is assumed. See RateVariationAcrossSites.\n\nMain optional keyword arguments (default value in parenthesis):\n\nspeciesfile (\"\"): path to a csv file with samples in rows and two columns: species (column 1), individual (column 2) Include this file to group individuals by species.\ncladefile (\"\"): path to a csv file containing two columns: clades and individuals used to create one or more clade topology constraints to meet during the search. (NOTE: clade contraints not yet implemented.)\nfilename (\"phyLiNC\"): root name for the output files (.out, .err). If empty (\"\"), files are not created, progress log goes to the screen only (standard out).\nmaxhybrid (1): maximum number of hybridizations allowed. net (starting network) must have maxhybrid or fewer reticulations.\nnruns (10): number of independent starting points for the search\nno3cycle (true): prevents 3-cycles, which are (almost) not identifiable\nnohybridladder (true): prevents hybrid ladder in network. If true, the input network must not have hybrid ladders. Warning: Setting this to true will avoid most hybrid ladders, but some can still occur in some cases when deleting hybrid edges. This might be replaced with an option to avoid all non-tree-child networks in the future.\n\nOptional arguments controlling the search:\n\nseed (default 0 to get it from the clock): seed to replicate a given search\nnreject (75): maximum number of times that new topologies are proposed and rejected in a row. Lower values of nreject result in a less thorough but faster search. Controls when to stop proposing new network topologies.\nprobST (0.5): probability to use net as the starting topology for each given run. If probST < 1, the starting topology is k NNI moves away from net, where k is drawn from a geometric distribution: p (1-p)ᵏ, with success probability p = probST.\nmaxmoves (100): maximum number of topology moves before branch lengths, hybrid γ values, evolutionary rates, and rate variation parameters are reestimated.\nverbose (true): set to false to turn off screen output\nalphamin (0.02) and alphamax (50.0): minimum and maximum values for the shape parameter alpha for Gamma-distributed rates across sites.\npinvmin (1e-8) and pinvmax (0.99): minimum and maximum values for the proportion of invariable sites, if included in the model.\n\nThe following optional arguments control when to stop the optimization of branch lengths and gamma values on each individual candidate network. Defaults in parentheses.\n\nftolRel (1e-6) and ftolAbs (1e-6): relative and absolute differences of the network score between the current and proposed parameters\nxtolRel (1e-5) and xtolAbs (1e-5): relative and absolute differences between the current and proposed parameters.\n\nGreater values will result in a less thorough but faster search. These parameters are used when evaluating candidate networks only. Regardless of these arguments, once a final topology is chosen, branch lenghts are optimized using stricter tolerances (1e-10, 1e-12, 1e-10, 1e-10) for better estimates.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.phyLiNC!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}","page":"Internals","title":"PhyloNetworks.phyLiNC!","text":"phyLiNC!(obj::SSM; kwargs...)\n\nCalled by phyLiNC after obj is created (containing both the data and the model) and after checks are made to start from a network that satisfies all the constraints. Different runs are distributed to different processors, if more than one are available.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.phyLiNCone!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, Int64, Bool, Bool, Int64, Int64, Bool, Bool, IO, Int64, Float64, Vector{PhyloNetworks.TopologyConstraint}, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, PhyloNetworks.CacheGammaLiNC, PhyloNetworks.CacheLengthLiNC}","page":"Internals","title":"PhyloNetworks.phyLiNCone!","text":"phyLiNCone!(obj::SSM, maxhybrid::Int, no3cycle::Bool,\n            nohybridladder::Bool, maxmoves::Int, nrejectmax::Int,\n            verbose::Bool, writelog_1proc::Bool, logfile::IO,\n            seed::Int, probST::Float64,\n            constraints::Vector{TopologyConstraint},\n            ftolRel::Float64, ftolAbs::Float64,\n            xtolRel::Float64, xtolAbs::Float64,\n            alphamin::Float64, alphamax::Float64,\n            pinvmin::Float64, pinvmax::Float64,\n            γcache::CacheGammaLiNC)\n\nEstimate one phylogenetic network (or tree) from concatenated DNA data, like phyLiNC!, but doing one run only, and taking as input an StatisticalSubstitutionModel object obj. The starting network is obj.net and is assumed to meet all the requirements.\n\nwritelog_1proc is passed by phyLiNC! an indicates if a log should be written. If the number of processors is > 1, this will be false because workers can't write on streams opened by master. logfile will be stdout if writelog_1proc is false. Otherwise, it will be the log file created by phyLiNC!.\n\nSee phyLiNC for other arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.posterior_logtreeweight","page":"Internals","title":"PhyloNetworks.posterior_logtreeweight","text":"posterior_logtreeweight(obj::SSM, trait = 1)\n\nReturn an array A such that A[t] = log of P(tree t and trait trait) if a single trait is requested, or A[i,t]= log of P(tree t and trait i) if trait is a vector or range (e.g. trait = 1:obj.nsites). These probabilities are conditional on the model parameters in obj.\n\nPrecondition: _loglikcache updated by discrete_corelikelihood!\n\nexamples\n\njulia> net = readTopology(\"(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\");\n\njulia> m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [\"lo\", \"hi\"]); # arbitrary rates\n\njulia> using DataFrames\n\njulia> dat = DataFrame(species=[\"C\",\"A\",\"B\",\"D\"], trait=[\"hi\",\"lo\",\"lo\",\"hi\"]);\n\njulia> fit = fitdiscrete(net, m1, dat); # optimized rates: α=0.27 and β=0.35\n\njulia> pltw = PhyloNetworks.posterior_logtreeweight(fit);\n\njulia> round.(exp.(pltw), digits=5) # posterior trees probabilities (sum up to 1)\n2-element Vector{Float64}:\n 0.91983\n 0.08017\n\njulia> round.(exp.(fit.priorltw), digits=4) # the prior tree probabilities are similar here (tiny data set!)\n2-element Vector{Float64}:\n 0.9\n 0.1\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.problem4cycle-NTuple{4, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.problem4cycle","text":"problem4cycle(β::Node, δ::Node, α::Node, γ::Node)\n\nCheck if the focus edge uv has a 4 cycle that could lead to a 3 cycle after an chosen NNI. Return true if there is a problem 4 cycle, false if none.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.proposedTop!-Tuple{Integer, HybridNetwork, Bool, Integer, Integer, Vector{Int64}, Vector{Int64}, Bool}","page":"Internals","title":"PhyloNetworks.proposedTop!","text":"proposedTop!(move,newT,random,count,N,movescount,movesfail,multall) road map\n\nFunction to change the current network newT by a given move, and checks that the move was successful (correct attributes). If not successful, newT is changed back to its original state, except for the case of multiple alleles.\n\nNote that the update of attributes by each move is not done in all the network, but only in the local edges that were changed by the move. This is efficient (and makes a move easy to undo), but makes the code of each move function very clunky.\n\nArguments:\n\nmove chosen from whichMove as described in optTopLevel\nnewT is the topology that will be modified inside with the move\nrandom=true: chooses minor hybrid edge with prob 1-h, and major edge with prob h, if false, always chooses minor hybrid edge\ncount: simply which likelihood step we are in in the optimization at optTopLevel\nmovescount and movesfail: vector of counts of number of moves proposed\nmultall=true if multiple alleles case: we need to check if the move did not violate the multiple alleles condition (sister alleles together and no gene flow into the alleles). This is inefficient because we are proposing moves that we can reject later, instead of being smart about the moves we propose: for example, move origin/target could rule out some neighbors that move gene flow into the alleles, the same for add hybridization; nni move can check if it is trying to separate the alleles)\n\nMoves:\n\naddHybridizationUpdate(newT,N):\n\nwill choose a partition first (to avoid choosing edges that will create a non level-1 network) will choose two edges from this partition randomly, will not allow two edges in a cherry (non-identifiable), or sister edges that are not identifiable (the blacklist was a way to keep track of \"bad edges\" were we should not waste time trying to put hybridizations, it has never been used nor tested). Also choose gamma from U(0,0.5). The \"Update\" in the function name means that it creates the new hybrid, and also updates all the attributes of newT\n\nnode = chooseHybrid(newT) choose a hybrid randomly for the next moves:\nmoveOriginUpdateRepeat!(newT,node,random)\n\nwill choose randomly the minor/major hybrid edge to move (if random=true); will get the list of all neighbor edges where to move the origin, will move the origin and update all the attributes and check if the move was successful (not conflicting attributes); if not, will undo the move, and try with a different neighbor until it runs out of neighbors. Return true if the move was successful.\n\nmoveTargetUpdateRepeat!(newT,node,random)\n\nsame as move origin but moving the target\n\nchangeDirectionUpdate!(newT,node,random)\n\nchooses minor/major hybrid edge at random (if `random=true), and changes the direction, and updates all the attributes. Checks if the move was successful (returns true), or undoes the change and returns false.\n\ndeleteHybridizationUpdate!(newT,node)\n\nremoves the hybrid node, updates the attributes, no need to check any attributes, always successful move\n\nNNIRepeat!(newT,N)\n\nchoose an edge for nni that does not have a neighbor hybrid. It will try to find such an edge N times, and if it fails, it will return false (unsuccessful move). N=10 by default. If N=1, it rarely finds such an edge if the network is small or complex. The function cannot choose an external edge. it will update locally the attributes.\n\n** Important: ** All the moves undo what they did if the move was not successful, so at the end you either have a newT with a new move and with all good attributes, or the same newT that started. This is important to avoid having to do deepcopy of the network before doing the move. Also, after each move, when we update the attributes, we do not update the attributes of the whole network, we only update the attributes of the edges that were affected by the move. This saves time, but makes the code quite clunky. Only the case of multiple alleles the moves does not undo what it did, because it finds out that it failed after the function is over, so just need to treat this case special.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.quartetrank-Tuple{AbstractVector{T} where T, Matrix{T} where T}","page":"Internals","title":"PhyloNetworks.quartetrank","text":"quartetrank(t1,t2,t3,t4, nCk::Matrix)\nquartetrank([t1,t2,t3,t4], nCk)\n\nReturn the rank of a four-taxon set with taxon numbers t1,t2,t3,t4, assuming that tis are positive integers such that t1<t2, t2<t3 and t3<t4 (assumptions not checked!). nCk should be a matrix of \"n choose k\" binomial coefficients: see nchoose1234.\n\nexamples\n\njulia> nCk = PhyloNetworks.nchoose1234(5)\n6×4 Matrix{Int64}:\n 0   0   0  0\n 1   0   0  0\n 2   1   0  0\n 3   3   1  0\n 4   6   4  1\n 5  10  10  5\n\njulia> PhyloNetworks.quartetrank([1,2,3,4], nCk)\n1\n\njulia> PhyloNetworks.quartetrank([3,4,5,6], nCk)\n15\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readCSVtoArray-Tuple{DataFrames.DataFrame}","page":"Internals","title":"PhyloNetworks.readCSVtoArray","text":"readCSVtoArray(dat::DataFrame)\nreadCSVtoArray(filename::String)\n\nRead a CSV table containing both species names and data, create two separate arrays: one for the species names, a second for the data, in a format that parsimonyGF needs.\n\nWarning:\n\nit will try to find a column 'taxon' or 'species' for the taxon names. If none found, it will assume the taxon names are in column 1.\nwill use all other columns as characters\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readInputData-Tuple{AbstractString, AbstractString, Symbol, Integer, Bool, AbstractString, Bool, Bool}","page":"Internals","title":"PhyloNetworks.readInputData","text":"readInputData(trees, quartetfile, whichQuartets, numQuartets, writetable, tablename, writeQfile, writesummary)\nreadInputData(trees, whichQuartets, numQuartets, taxonlist,   writetable, tablename, writeQfile, writesummary)\n\nRead gene trees and calculate the observed quartet concordance factors (CF), that is, the proportion of genes (and the number of genes) that display each quartet for a given list of four-taxon sets.\n\nInput:\n\ntrees: name of a file containing a list of input gene trees, or vector of trees (HybridNetwork objects)\n\nOptional arguments (defaults):\n\nquartetfile: name of a file containing a list of quartets, or more precisely, a list of four-taxon sets\nwhichQuartets (:all): which quartets to sample. :all for all of them, :rand for a random sample.\nnumQuartets: number of quartets in the sample. default: total number of quartets if whichQuartets=:all and 10% of total if whichQuartets=:rand\ntaxonlist (all in the input gene trees): If taxonlist is used, whichQuartets will consist of all sets of 4 taxa in the taxonlist. \nwritetable (true): write the table of observed CF?\ntablename (\"tableCF.txt\"): if writetable is true, the table of observed CFs is write to file tablename\nwriteQfile (false): write intermediate file with sampled quartets?\nwritesummary (true): write a summary file? if so, the summary will go in file \"summaryTreesQuartets.txt\".\n\nUses calculateObsCFAll!, which implements a slow algorithm.\n\nSee also: countquartetsintrees, which uses a much faster algorithm; readTrees2CF, which is basically a re-naming of readInputData, and readTableCF to read a table of quartet CFs directly.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readSubtree!-Tuple{IO, PhyloNetworks.Node, Vector{Int64}, HybridNetwork, Vector{String}}","page":"Internals","title":"PhyloNetworks.readSubtree!","text":"readSubtree!(s::IO, parentNode, numLeft, net, hybrids)\n\nRecursive helper method for readTopology: read a subtree from an extended Newick topology. input s: IOStream/IOBuffer.\n\nReads additional info formatted as: :length:bootstrap:gamma. Allows for name of internal nodes without # after closing parenthesis: (1,2)A. Warning if hybrid edge without γ, or if γ (ignored) without hybrid edge\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.recursionPostOrder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Any}","page":"Internals","title":"PhyloNetworks.recursionPostOrder","text":"recursionPostOrder(net::HybridNetwork, checkPreorder::Bool,\n                   init_function, tip_function, node_function,\n                   indexation=\"b\", parameters...)\nrecursionPostOrder(nodes, init_function, tip_function, node_function,\n                   parameters)\nupdatePostOrder!(index, nodes, updated_matrix, tip_function, node_function,\n                parameters)\n\nGeneric tool to apply a post-order (or topological ordering) algorithm, acting on a matrix where rows & columns correspond to nodes. Used by descendenceMatrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.recursionPreOrder!","page":"Internals","title":"PhyloNetworks.recursionPreOrder!","text":"recursionPreOrder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters)\nrecursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,\n                   hybrid_node_function, parameters)\nupdatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,\n               hybrid_node_function, parameters)\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by sharedPathMatrix and by pairwiseTaxonDistanceMatrix.\n\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.recursionPreOrder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Function, Any}","page":"Internals","title":"PhyloNetworks.recursionPreOrder","text":"recursionPreOrder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters)\nrecursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,\n                   hybrid_node_function, parameters)\nupdatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,\n               hybrid_node_function, parameters)\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by sharedPathMatrix and by pairwiseTaxonDistanceMatrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.removeHybrid!","text":"removeHybrid!(net::Network, n::Node)\n\nDelete a hybrid node n from net.hybrid, and update net.numHybrid. The actual node n is not deleted. It is kept in the full list net.node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.removedegree2nodes!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.removedegree2nodes!","text":"removedegree2nodes!(net::HybridNetwork)\n\nDelete all nodes of degree two in net, fusing the two adjacent edges together each time, and return the network. If the network has a degree-2 root, then the root is eliminated as well, leaving the network unrooted.\n\nSee fuseedgesat!.\n\njulia> net = readTopology(\"(((((S1,(S2)#H1),(#H1,S3)))#H2),(#H2,S4));\");\n\njulia> PhyloNetworks.breakedge!(net.edge[3], net); # create a degree-2 node along hybrid edge\n\njulia> PhyloNetworks.breakedge!(net.edge[3], net); # another one: 2 in a row\n\njulia> PhyloNetworks.breakedge!(net.edge[10], net); # another one, elsewhere\n\njulia> writeTopology(net) # extra pairs of parentheses\n\"((#H2,S4),(((((S1,(((S2)#H1))),(#H1,S3)))#H2)));\"\n\njulia> PhyloNetworks.removedegree2nodes!(net);\n\njulia> writeTopology(net) # even the root is gone\n\"(#H2,S4,(((S1,(S2)#H1),(#H1,S3)))#H2);\"\n\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.resetEdgeNumbers!","page":"Internals","title":"PhyloNetworks.resetEdgeNumbers!","text":"resetEdgeNumbers!(net::HybridNetwork, verbose=true)\n\nCheck that edge numbers of net are consecutive numbers from 1 to the total number of edges. If not, reset the edge numbers to be so.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.resetNodeNumbers!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.resetNodeNumbers!","text":"resetNodeNumbers!(net::HybridNetwork; checkPreorder=true, type=:ape)\n\nChange internal node numbers of net to consecutive numbers from 1 to the total number of nodes.\n\nkeyword arguments:\n\ntype: default is :ape, to get numbers that satisfy the conditions assumed by the ape R package: leaves are 1 to n, the root is n+1, and internal nodes are higher consecutive integers. If :postorder, nodes are numbered in post-order, with leaves from 1 to n (and the root last). If :internalonly, leaves are unchanged. Only internal nodes are modified, to take consecutive numbers from (max leaf number)+1 and up. With this last option, the post-ordering of nodes is by-passed.\ncheckPreorder: if false, the isChild1 edge field and the net.nodes_changed network field are supposed to be correct (to get nodes in preorder). This is not needed when type=:internalonly.\n\nExamples\n\njulia> net = readTopology(\"(A,(B,(C,D)));\");\n\njulia> PhyloNetworks.resetNodeNumbers!(net)\n\njulia> printNodes(net) # first column \"node\": root is 5\nnode leaf  hybrid hasHybEdge name inCycle edges'numbers\n1    true  false  false      A    -1      1   \n2    true  false  false      B    -1      2   \n3    true  false  false      C    -1      3   \n4    true  false  false      D    -1      4   \n7    false false  false           -1      3    4    5   \n6    false false  false           -1      2    5    6   \n5    false false  false           -1      1    6   \n\njulia> net = readTopology(\"(A,(B,(C,D)));\");\n\njulia> PhyloNetworks.resetNodeNumbers!(net; type=:postorder)\n\njulia> printNodes(net) # first column \"node\": root is 7\nnode leaf  hybrid hasHybEdge name inCycle edges'numbers\n1    true  false  false      A    -1      1   \n2    true  false  false      B    -1      2   \n3    true  false  false      C    -1      3   \n4    true  false  false      D    -1      4   \n5    false false  false           -1      3    4    5   \n6    false false  false           -1      2    5    6   \n7    false false  false           -1      1    6   \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.rezip_canonical!-Tuple{Vector{PhyloNetworks.Node}, Vector{PhyloNetworks.Edge}, Vector{Float64}}","page":"Internals","title":"PhyloNetworks.rezip_canonical!","text":"rezip_canonical!(hybridnodes::Vector{Node}, childedges::Vector{Edge},\n                 originallengths::Vector{Float64})\n\nUndo unzip_canonical!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.sameTaxa-Tuple{Quartet, HybridNetwork}","page":"Internals","title":"PhyloNetworks.sameTaxa","text":"sameTaxa(Quartet, HybridNetwork)\n\nReturn true if all taxa in the quartet are represented in the network, false if one or more taxa in the quartet does not appear in the network.\n\nwarning: the name can cause confusion. A more appropriate name might be \"in\", or \"taxain\", or \"taxonsubset\", or etc.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.sampleBootstrapTrees-Tuple{Vector{Vector{HybridNetwork}}}","page":"Internals","title":"PhyloNetworks.sampleBootstrapTrees","text":"sampleBootstrapTrees(vector of tree lists; seed=0::Integer, generesampling=false, row=0)\nsampleBootstrapTrees!(tree list, vector of tree lists; seed=0::Integer, generesampling=false, row=0)\n\nSample bootstrap gene trees, 1 tree per gene. Set the seed with keyword argument seed, which is 0 by default. When seed=0, the actual seed is set using the clock. Assumes a vector of vectors of networks (see readBootstrapTrees), each one of length 1 or more (error if one vector is empty, tested in bootsnaq).\n\nsite resampling: always, from sampling one bootstrap tree from each given list. This tree is sampled at random unless row>0 (see below).\ngene resampling: if generesampling=true (default is false), genes (i.e. lists) are sampled with replacement.\nrow=i: samples the ith bootstrap tree for each gene. row is turned back to 0 if gene resampling is true.\n\noutput: one vector of trees. the modifying function (!) modifies the input tree list and returns it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.sampleCFfromCI","page":"Internals","title":"PhyloNetworks.sampleCFfromCI","text":"sampleCFfromCI(data frame, seed=0)\nsampleCFfromCI!(data frame, seed=0)\n\nRead a data frame containing CFs and their credibility intervals, and sample new obsCF uniformly within the CIs. These CFs are then rescaled to sum up to 1 for each 4-taxon sets. Return a data frame with taxon labels in first 4 columns, sampled obs CFs in columns 5-7 and credibility intervals in columns 8-13.\n\nThe non-modifying function creates a new data frame (with re-ordered columns) and returns it. If seed=-1, the new df is a deep copy of the input df, with no call to the random number generator. Otherwise, seed is passed to the modifying function.\nThe modifying function overwrites the input data frame with the sampled CFs and returns it. If seed=0, the random generator is seeded from the clock. Otherwise the random generator is seeded using seed.\n\nWarning: the modifying version does not check the data frame: assumes correct columns.\n\noptional argument: delim=',' by default: how columns are delimited.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.setBLGammaParsimony!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.setBLGammaParsimony!","text":"setBLGammaParsimony!(net::HybridNetwork)\n\nMaximum parsimony function does not provide estimates for branch lengths, or gamma. But since the maxParsimonyNet function is using snaq move functions, branch lengths and gamma values are set randomly (to initialize optimization). We need to remove these random values before returning the maximum parsimony network.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setBranchLength!-Tuple{PhyloNetworks.Edge, Number}","page":"Internals","title":"PhyloNetworks.setBranchLength!","text":"setBranchLength!(Edge, newlength)\n\nSet the length of an Edge object. The new length needs to be non-negative, or -1.0 to be interpreted as missing. edge.y and edge.z are updated accordingly.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}","page":"Internals","title":"PhyloNetworks.setGammaBLfromGammaz!","text":"setGammaBLfromGammaz!(node, network)\n\nUpdate the γ values of the two sister hybrid edges in a bad diamond I, given the gammaz values of their parent nodes, and update the branch lengths t1 and t2 of their parent edges (those across from the hybrid nodes), in such a way that t1=t2 and that these branch lengths and γ values are consistent with the gammaz values in the network.\n\nSimilar to the first section of undoGammaz!, but does not update anything else than γ and t's. Unlike undoGammaz!, no error if non-hybrid node or not at bad diamond I.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setGammas!-Tuple{HybridNetwork, Vector{T} where T}","page":"Internals","title":"PhyloNetworks.setGammas!","text":"setGammas!(net, γ vector)\n\nSet inheritance γ's of hybrid edges, using input vector for major edges. Assume pre-order calculated already, with up-to-date field nodes_changed. See getGammas.\n\nVery different from setGamma!, which focuses on a single hybrid event, updates the field isMajor according to the new γ, and is not used here.\n\nMay assume a tree-child network.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setNonIdBL!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.setNonIdBL!","text":"setNonIdBL!(net)\n\nSet non-identifiable edge branch lengths to -1.0 (i.e. missing) for a level-1 network net, except for edges in\n\na good triangle: the edge below the hybrid is constrained to 0.\na bad diamond II: the edge below the hybrid is constrained to 0\na bad diamond I: the edges across from the hybrid node have non identifiable lengths but are kept, because the two γ*(1-exp(-t)) values are identifiable.\n\nwill break if inCycle attributes are not initialized (at -1) or giving a correct node number.\n\nsee Node for the meaning of boolean attributes isBadTriangle (which corresponds to a \"good\" triangle above), isBadDiamondI and isBadDiamondII.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setalpha!-Union{Tuple{S}, Tuple{PhyloNetworks.RVASGamma{S}, Float64}} where S","page":"Internals","title":"PhyloNetworks.setalpha!","text":"setalpha!(obj, alpha)\n\nSet the shape parameter alpha in a RateVariationAcrossSites model obj, and update the rate multipliers accordingly. Return the modified object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.seteigeninfo!-Tuple{BinaryTraitSubstitutionModel}","page":"Internals","title":"PhyloNetworks.seteigeninfo!","text":"for a [BinaryTraitSubstitutionModel]: store eigenvalue (q01+q10) and stationary distribution\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.seteigeninfo!-Tuple{EqualRatesSubstitutionModel}","page":"Internals","title":"PhyloNetworks.seteigeninfo!","text":"for a [EqualRatesSubstitutionModel]: store lambda = k/(k-1), where k is the number of states\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.seteigeninfo!-Tuple{HKY85}","page":"Internals","title":"PhyloNetworks.seteigeninfo!","text":"for HKY85: store piR, piY, the 2 non-zero eigenvalues and a scaling factor\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.seteigeninfo!-Tuple{JC69}","page":"Internals","title":"PhyloNetworks.seteigeninfo!","text":"for JC69: store lambda = 4/3 (if relative) or rate * 4/3 (absolute).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.seteigeninfo!-Tuple{PhyloNetworks.SubstitutionModel}","page":"Internals","title":"PhyloNetworks.seteigeninfo!","text":"seteigeninfo!(obj)\n\nCalculate eigenvalue & eigenfector information for a substitution model (SM) object (as needed to calculate transition rate matrices) and store this info within the object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setlengths!-Tuple{Vector{PhyloNetworks.Edge}, Vector{Float64}}","page":"Internals","title":"PhyloNetworks.setlengths!","text":"setlengths!(edges::Vector{Edge}, lengths::Vector{Float64})\n\nAssign new lengths to a vector of edges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setparameters!-Tuple{PhyloNetworks.RVASInv, AbstractVector{T} where T}","page":"Internals","title":"PhyloNetworks.setparameters!","text":"setparameters!(obj::RateVariationAcrossSites, par::AbstractVector)\n\nSet the values of the alpha and/or pinv parameters of model obj. See also setalpha!, setpinv! and setpinvalpha!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setpinv!-Tuple{PhyloNetworks.RVASInv, Float64}","page":"Internals","title":"PhyloNetworks.setpinv!","text":"setpinv!(obj, pinv)\n\nSet the proportion of invariable sites pinv in a RateVariationAcrossSites model obj, and update the rate multipliers & weights accordingly. For RVASInvGamma objects, the original rate multipliers are assumed correct, according to the original pinv value. Return the modified object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setpinvalpha!-Union{Tuple{S}, Tuple{PhyloNetworks.RVASGammaInv{S}, Float64, Float64}} where S","page":"Internals","title":"PhyloNetworks.setpinvalpha!","text":"setpinvalpha!(obj, pinv, alpha)\n\nSet the proportion of invariable sites pinv and the alpha parameter for the discretized gamma distribution in a model obj of type RVASGammaInv{S}. Update the rate multipliers & weights accordingly. The mean of the distribution is constrained to 1.\n\nReturn the modified object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setrates!-Tuple{PhyloNetworks.SubstitutionModel, AbstractVector{T} where T}","page":"Internals","title":"PhyloNetworks.setrates!","text":"setrates!(model, rates)\n\nupdate rates then call seteigeninfo! to update a model's eigeninfo\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.showQ-Tuple{IO, PhyloNetworks.SubstitutionModel}","page":"Internals","title":"PhyloNetworks.showQ","text":"showQ(IO, model)\n\nPrint the Q matrix to the screen, with trait states as labels on rows and columns. adapted from prettyprint function by mcreel, found 2017/10 at https://discourse.julialang.org/t/display-of-arrays-with-row-and-column-names/1961/6\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.showdata","page":"Internals","title":"PhyloNetworks.showdata","text":"showdata(io::IO, obj::SSM, fullsiteinfo=false::Bool)\n\nReturn information about the data in an SSM object: number of species, number or traits or sites, number of distinct patterns, and more information if fullsiteinfo is true: number sites with missing data only, number of invariant sites, number of sites with 2 distinct states, number of parsimony-informative sites (with 2+ states being observed in 2+ tips), number of sites with some missing data, and overall proportion of entries with missing data.\n\nNote: Missing is not considered an additional state. For example, if a site contains some missing data, but all non-missing values take the same state, then this site is counted in the category \"invariant\".\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.shrink2cycleat!-Tuple{HybridNetwork, PhyloNetworks.Edge, PhyloNetworks.Edge, Bool}","page":"Internals","title":"PhyloNetworks.shrink2cycleat!","text":"shrink2cycleat!(net::HybridNetwork, minor::Edge, major::Edge, unroot::Bool)\n\nRemove minor edge then update the branch length of the remaining major edge. Called by shrink2cycles!\n\nAssumption: minor and major do form a 2-cycle. That is, they start and end at the same node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.shrink2cycles!","page":"Internals","title":"PhyloNetworks.shrink2cycles!","text":"shrink2cycles!(net::HybridNetwork, unroot=false::Bool)\n\nIf net contains a 2-cycle, collapse the cycle into one edge of length tA + γt1+(1-γ)t2 + tB (see below), and return true. Return false otherwise. A 2-cycle is a set of 2 parallel hybrid edges, from the same parent node to the same hybrid child node.\n\n       A                A\n       | tA             |\n     parent             |\n       | \\              |\nt2,1-γ |  | t1,γ        | tA + γ*t1 + (1-γ)*t2 + tB\n       | /              |\n     hybrid             |\n       | tB             |\n       B                B\n\nIf any of the lengths or gammas associated with a 2-cycle are missing, the combined length is missing. If γ is missing, branch lengths are calculated using γ=0.5.\n\nIf unroot is false and the root is up for deletion, it will be kept only if it is has degree 2 or more. If unroot is true and the root is up for deletion, it will be kept only if it has degree 3 or more. A root node with degree 1 will be deleted in both cases.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.shrink3cycleat!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.Edge, PhyloNetworks.Edge, PhyloNetworks.Node, PhyloNetworks.Node, Bool}","page":"Internals","title":"PhyloNetworks.shrink3cycleat!","text":"shrink3cycleat!(net::HybridNetwork, hybrid::Node, edge1::Edge, edge2::Edge,\n                node1::Node, node2::Node, unroot::Bool)\n\nReplace a 3-cycle at a given hybrid node by a single node, if any. Assumption: edge1 (node1) and edge2 (node2) are the parent edges (nodes) of hybrid. Return true if a 3-cycle is found and removed, false otherwise. There is a 3-cycle if nodes 1 & 2 are connected, by an edge called e3 below.\n\nThere are two cases, with differing effects on the γ inheritance values and branch lengths.\n\nHybrid case: the 3-cycle is shrunk to a hybrid node, which occurs if either node 1 or 2 is a hybrid node (that is, e3 is hybrid). If e3 goes from node 1 to node 2, the 3-cycle (left) is shrunk as on the right:\n\n\\eA      /eB           \\eA  /eB\n 1--e3->2       γ1+γ2γ3 \\  / γ2(1-γ3)\n  \\    /               hybrid\n γ1\\  /γ2\n  hybrid\n\nwith new branch lengths: new tA = tA + (γ1.t1 + γ2γ3.(t2+t3))/(γ1+γ2γ3), new tB = tB + t2, provided that γ1, γ2=1-γ1, and γ3 are not missing. If one of them is missing then γ1 and γ2 remain as is, and e3 is deleted naively, such that new tA = tA + t1 and new tB = tB + t2. If γ's are not missing but one of t1,t2,t3 is missing, then the γ's are updated to γ1+γ2γ3 and γ2(1-γ3), but t's are update naively.\n\nTree case: the 3-cycle is shrunk to a tree node, which occurs if node 1 & 2 are both tree nodes (that is, e3 is a tree edge). If eC is the child edge of hybrid, the 3-cycle (left) is shrunk as on the right:\n\n\\eA                  \\eA\n 1--e3--2--eB--       \\\n  \\    /               n--eB--\n γ1\\  /γ2              |\n  hybrid               |eC\n    |\n    |eC\n\nwith new branch lengths: new tA = tA + γ2.t3, new tB = tB + γ1.t3, new tC = tC + γ1.t1 + γ2.t2, provided that γ1, γ2=1-γ1, t1, t2 and t3 are not missing. If one is missing, then e1 is deleted naively such that tB is unchanged, new tC = tC + t2 and new tA = tA + t3.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.shrink3cycles!","page":"Internals","title":"PhyloNetworks.shrink3cycles!","text":"shrink3cycles!(net::HybridNetwork, unroot=false::Bool)\n\nRemove all 2- and 3-cycles from a network.\n\nReturn true if net contains a 2-cycle or a 3-cycle; false otherwise. A 3-cycle (2-cycle) is a set of 3 (2) nodes that are all connected. One of them must be a hybrid node, since net is a DAG.\n\nIf unroot is false and the root is up for deletion, it will be kept only if it is has degree 2 or more. If unroot is true and the root is up for deletion, it will be kept only if it has degree 3 or more. A root node with degree 1 will be deleted in both cases.\n\nSee shrink3cycleat! for details on branch lengths and inheritance values.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.sort_stringasinteger!-Tuple{Any}","page":"Internals","title":"PhyloNetworks.sort_stringasinteger!","text":"sort_stringasinteger!(taxa)\n\nSort a vector of strings taxa, numerically if elements can be parsed as an integer, alphabetically otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.startingBL!","page":"Internals","title":"PhyloNetworks.startingBL!","text":"startingBL!(net::HybridNetwork,\n            trait::AbstractVector{Vector{Union{Missings.Missing,Int}}},\n            siteweight=ones(length(trait[1]))::AbstractVector{Float64})\n\nCalibrate branch lengths in net by minimizing the mean squared error between the JC-adjusted pairwise distance between taxa, and network-predicted pairwise distances, using calibrateFromPairwiseDistances!. siteweight[k] gives the weight of site (or site pattern) k (default: all 1s). Note: the network is not \"unzipped\". PhyLiNC unzips reticulations later.\n\nAssumptions:\n\nall species have the same number of traits (sites): length(trait[i]) constant\ntrait[i] is for leaf with node.number = i in net, and trait[i][j] = k means that leaf number i has state index k for trait j. These indices are those used in a substitution model: kth value of getlabels(model).\nHamming distances are < 0.75 with four states, or < (n-1)/n for n states. If not, all pairwise hamming distances are scaled by .75/(m*1.01) where m is the maximum observed hamming distance, to make them all < 0.75.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.startingrate-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.startingrate","text":"startingrate(net)\n\nEstimate an evolutionary rate appropriate for the branch lengths in the network, which should be a good starting value before optimization in fitdiscrete, assuming approximately 1 change across the entire tree. If all edge lengths are missing, set starting rate to 1/(number of taxa).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.startree_newick","page":"Internals","title":"PhyloNetworks.startree_newick","text":"startree_newick(n, l)\n\nString for the Newick parenthetical description of the star tree with n tips, and all branch lengths equal to l.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.symmetricnet_newick","page":"Internals","title":"PhyloNetworks.symmetricnet_newick","text":"symmetricnet_newick(n::Int, h::Int, γ::Real)\n\nCreate a string for a symmetric network with 2^n tips, numbered from 1 to 2^n, with a symmetric major tree, whose branch lengths are all equal. 2^(n-h) hybrids are added from level h to h-1 \"symmetrically\". The network is time-consistent and ultrametric, with a total height of 1.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.symmetricnet_newick-Tuple{Int64, Int64, Int64, Real, Real}","page":"Internals","title":"PhyloNetworks.symmetricnet_newick","text":"symmetricnet_newick(n::Int, i::Int, j::Int, γ::Real, l::Real)\n\nNewick string for a network with a symmetric major tree with 2^n tips, numbered from 1 to 2^n. All the branch lengths of the major tree are set to l. One hybrid branch, going from level i to level j is added, cutting in half each initial edge in the tree. The new edge has length l and inheritance γ.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.symmetrictree_newick","page":"Internals","title":"PhyloNetworks.symmetrictree_newick","text":"symmetrictree_newick(n::Int, ell::Real, i=1)\n\nString for the Newick parenthetical description of a symmetric tree with 2^n tips, numbered from i to i+2^n-1. All branch lengths are set equal to ell. The tree can be created later by reading the string with readTopology.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.synchronizePartnersData!-Tuple{PhyloNetworks.Edge, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.synchronizePartnersData!","text":"synchronizePartnersData!(e::Edge, n::Node)\n\nSynchronize γ and isMajor for edges e and its partner, both hybrid edges with the same child n:\n\nif one γ is missing and the other is not: set the missing γ to 1 - the other\nγ's should sum up to 1.0\nupdate isMajor to match the γ information: the major edge is the one with γ > 0.5.\n\nWarnings: does not check that e is a hybrid edge, nor that n is the child of e.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.taxadiff-Tuple{Vector{Quartet}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.taxadiff","text":"taxadiff(Vector{Quartet}, network; multiplealleles=true)\ntaxadiff(DataCF, network; multiplealleles=true)\n\nReturn 2 vectors:\n\ntaxa in at least 1 of the quartets but not in the network, and\ntaxa in the network but in none of the quartets.\n\nWhen multiplealleles is true, the taxon names that end with \"__2\" are ignored in the quartets: they are not expected to appear in the networks that users give as input, or get as output.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.traitlabels2indices-Tuple{AbstractVector{T} where T, PhyloNetworks.SubstitutionModel}","page":"Internals","title":"PhyloNetworks.traitlabels2indices","text":"traitlabels2indices(data, model::SubstitutionModel)\n\nCheck that the character states in data are compatible with (i.e. subset of) the trait labels in model. All columns are used. data can be a DataFrame or a Matrix (multiple traits), or a Vector (one trait). Return a vector of vectors (one per species) with integer entries, where each state (label) is replaced by its index in model. For DNA data, any ambiguous site is treated as missing.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.traverseContainRoot!-Tuple{PhyloNetworks.Node, PhyloNetworks.Edge, Vector{PhyloNetworks.Edge}, Vector{Bool}}","page":"Internals","title":"PhyloNetworks.traverseContainRoot!","text":"updateContainRoot!(HybridNetwork, Node)\ntraverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})\n\nThe input node to updateContainRoot! must be a hybrid node (can come from searchHybridNode). updateContainRoot! starts at the input node and calls traverseContainRoot!, which traverses the network recursively. By default, containRoot attributes of edges are true. Changes containRoot to false for all the visited edges: those below the input node, but not beyond any other hybrid node.\n\nupdateContainRoot! Returns a flag and an array of edges whose containRoot has been changed from true to false. flag is false if the set of edges to place the root is empty\n\nIn traverseContainRoot!, rightDir turns false if hybridizations have incompatible directions (vector of length 1, to be modified).\n\nWarning:\n\ndoes not update containRoot of minor hybrid edges.\nassumes correct isMajor attributes: to stop the recursion at minor hybrid edges.\nassumes correct hybrid attributes of both nodes & edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).\n\nrightDir: vector of length 1 boolean, to be mutable and modified by the function\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.undoGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}","page":"Internals","title":"PhyloNetworks.undoGammaz!","text":"undoGammaz!(node, network)\n\nUndo updateGammaz! for the 2 cases: bad diamond I,II. node should be a hybrid node. Set length to edges that were not identifiable and change edges' gammaz attribute to -1.0. Recalculate branch lengths in terms of gammaz.   warning: needs to know incycle attributes\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.unzip_canonical!","text":"unzip_canonical!(net::HybridNetwork)\n\nUnzip all reticulations: set the length of child edge to 0, and increase the length of both parent edges by the original child edge's length, to obtain the canonical version of the network according to Pardi & Scornavacca (2015).\n\nOutput: vector of hybrid node in postorder, vector of child edges whose length is constrained to be 0, and vector of their original branch lengths to re-zip if needed using rezip_canonical!.\n\nAssumption: net.hybrid is correct, but a preordering of all nodes is not assumed.\n\nNote: This unzipping is not as straightforward as it might seem, because of \"nested\" zippers: when the child of a hybrid node is itself a hybrid node. The unzipping is propagated all the way through.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.unzipat_canonical!-Tuple{PhyloNetworks.Node, PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.unzipat_canonical!","text":"unzipat_canonical!(hybnode::Node, childedge::Edge)\n\nUnzip the reticulation a node hyb. See unzip_canonical!. Warning: no check that hyb has a single child.\n\nOutput: constrained edge (child of hyb) and its original length.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.updateBL!-Tuple{HybridNetwork, DataCF}","page":"Internals","title":"PhyloNetworks.updateBL!","text":"updateBL!(net::HybridNetwork, d::DataCF)\n\nUpdate internal branch lengths of net based on the average quartet concordance factor (CF) across all quartets that exactly correspond to a given branch: new branch length = -log(3/2(1-mean(CF observed in d))). net is assumed to be a tree, such that the above equation holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.updateContainRoot!","page":"Internals","title":"PhyloNetworks.updateContainRoot!","text":"updateContainRoot!(HybridNetwork, Node)\ntraverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})\n\nThe input node to updateContainRoot! must be a hybrid node (can come from searchHybridNode). updateContainRoot! starts at the input node and calls traverseContainRoot!, which traverses the network recursively. By default, containRoot attributes of edges are true. Changes containRoot to false for all the visited edges: those below the input node, but not beyond any other hybrid node.\n\nupdateContainRoot! Returns a flag and an array of edges whose containRoot has been changed from true to false. flag is false if the set of edges to place the root is empty\n\nIn traverseContainRoot!, rightDir turns false if hybridizations have incompatible directions (vector of length 1, to be modified).\n\nWarning:\n\ndoes not update containRoot of minor hybrid edges.\nassumes correct isMajor attributes: to stop the recursion at minor hybrid edges.\nassumes correct hybrid attributes of both nodes & edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).\n\nrightDir: vector of length 1 boolean, to be mutable and modified by the function\n\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.updatePostOrder!","page":"Internals","title":"PhyloNetworks.updatePostOrder!","text":"recursionPostOrder(net::HybridNetwork, checkPreorder::Bool,\n                   init_function, tip_function, node_function,\n                   indexation=\"b\", parameters...)\nrecursionPostOrder(nodes, init_function, tip_function, node_function,\n                   parameters)\nupdatePostOrder!(index, nodes, updated_matrix, tip_function, node_function,\n                parameters)\n\nGeneric tool to apply a post-order (or topological ordering) algorithm, acting on a matrix where rows & columns correspond to nodes. Used by descendenceMatrix.\n\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.updatePreOrder!","page":"Internals","title":"PhyloNetworks.updatePreOrder!","text":"recursionPreOrder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters)\nrecursionPreOrder!(nodes, AbstractArray, root_function, tree_node_function,\n                   hybrid_node_function, parameters)\nupdatePreOrder(index, nodes, updated_matrix, root_function, tree_node_function,\n               hybrid_node_function, parameters)\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by sharedPathMatrix and by pairwiseTaxonDistanceMatrix.\n\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.updateSSM!","page":"Internals","title":"PhyloNetworks.updateSSM!","text":"updateSSM!(obj::SSM, renumber=false::Bool;\n           constraints=TopologyConstraint[]::Vector{TopologyConstraint})\n\nAfter adding or removing a hybrid, displayed trees will change. Updates the displayed tree list. Return SSM object.\n\nif renumber, reorder edge and internal node numbers. Only need to renumber after deleting a hybrid (which could remove edges and nodes from the middle of the edge and node lists).\n\nAssumptions:\n\nThe SSM object has cache arrays of size large enough, that is, the constructor StatisticalSubstitutionModel was previously called with maxhybrid equal or greater than in obj.net. obj.priorltw is not part of the \"cache\" arrays.\n\nWarning: Does not update the likelihood.\n\njulia> net = readTopology(\"(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\");\n\njulia> fastafile = abspath(joinpath(dirname(Base.find_package(\"PhyloNetworks\")), \"..\", \"examples\", \"simple.aln\"));\n\njulia> obj = PhyloNetworks.StatisticalSubstitutionModel(net, fastafile, :JC69; maxhybrid=3);\n\njulia> PhyloNetworks.checknetwork_LiNC!(obj.net, 3, true, true);\n\njulia> using Random; Random.seed!(432);\n\njulia> PhyloNetworks.addhybridedge!(obj.net, obj.net.edge[8], obj.net.edge[1], true, 0.0, 0.4);\n\njulia> writeTopology(obj.net)\n\"(((B:1.0)#H1:0.1::0.9,(A:1.0)#H2:1.0::0.6):1.5,(C:0.6,#H1:1.0::0.1):1.0,(D:1.25,#H2:0.0::0.4):1.25);\"\n\njulia> length(obj.displayedtree) # still as if 1 single reticulation\n2\n\njulia> PhyloNetworks.updateSSM!(obj);\n\njulia> length(obj.displayedtree) # now correct 4 displayed treess: 2 reticulations\n4\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.updateSSM_root!-Tuple{PhyloNetworks.StatisticalSubstitutionModel}","page":"Internals","title":"PhyloNetworks.updateSSM_root!","text":"updateSSM_root!(obj::SSM)\n\nUpdate root and direction of edges in displayed trees to match the root in the network.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.update_logtrans-Tuple{PhyloNetworks.StatisticalSubstitutionModel, PhyloNetworks.Edge}","page":"Internals","title":"PhyloNetworks.update_logtrans","text":"update_logtrans(obj::SSM, edge::Edge)\n\nUpdate the log-transition probabilities associates to one particular edge in the network.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.update_logtrans-Tuple{PhyloNetworks.StatisticalSubstitutionModel}","page":"Internals","title":"PhyloNetworks.update_logtrans","text":"update_logtrans(obj::SSM)\n\nInitialize and update obj.logtrans, the log transition probabilities along each edge in the full network. They are re-used for each displayed tree, which is why edges are not fused around degree-2 nodes when extracting displayed trees.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.updatecache_edge!-Tuple{PhyloNetworks.CacheLengthLiNC, PhyloNetworks.StatisticalSubstitutionModel, Any}","page":"Internals","title":"PhyloNetworks.updatecache_edge!","text":"updatecache_edge!(lcache::CacheLengthLiNC, obj::SSM, focusedge)\n\nUpdate fields in lcache, to correspond to the forward likelihood at the child node of the focus edge, backwards (at parent node) x directional (at sister edges) likelihoods, and keep track of which displayed trees do have the focus edge. These don't change if the length of the focus edge is modified. These quantities are then rescaled on the log scale (to get a max of 0) and exponentiated to get back to the probability scale.\n\nAssumptions: the following fields of obj are up-to-date:\n\ndisplayed trees, with nodes preordered\nprior log tree weights in .priorltw\nlog transition probabilities in .logtrans\n\nOutput:\n\nmissing, if the edge length does not affect the likelihood,\nconstant used to rescale each site on the log scale, otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.updateconstraintfields!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.updateconstraintfields!","text":"updateconstraintfields!(constraints::Vector{TopologyConstraint}, net::HybridNetwork)\n\nUpdate fields stem edge and crown node to match the given net.\n\nAssumes that the constraints are still met in net, and that nodes & edges are numbered identically in net as in the network used to create all constraints.\n\nfixit: remove the assumption that constraints are still met, since an NNI near the crown of a constrained clade might change the crown node and / or the stem edge (u and v exchange).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.updateconstraints!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.updateconstraints!","text":"updateconstraints!(constraints::Vector{TopologyConstraint}, net::HybridNetwork)\n\nUpdate the set taxonnum in each constraint, assuming that the stem edge and the crown node are still correct, and that their descendants are still correct. May be needed if the node and edge numbers were modified by resetNodeNumbers! or resetEdgeNumbers!.\n\nWarning: does not check that the names of leaves with numbers in taxonnum are taxonnames.\n\njulia> net = readTopology(\"(((2a,2b),(((((1a,1b,1c),4),(5)#H1),(#H1,(6,7))))#H2),(#H2,10));\");\n\njulia> c_species1 = PhyloNetworks.TopologyConstraint(0x01, [\"1a\",\"1b\",\"1c\"], net)\nSpecies constraint, on tips: 1a, 1b, 1c\n stem edge number 7\n crown node number -9\n\njulia> c_species1.taxonnums\nSet{Int64} with 3 elements:\n  5\n  4\n  3\n\njulia> c_clade145 = PhyloNetworks.TopologyConstraint(0x02, [\"1a\",\"1b\",\"1c\",\"4\",\"5\"], net)\nClade constraint, on tips: 1a, 1b, 1c, 4, 5\n stem edge number 12\n crown node number -7\n\njulia> PhyloNetworks.resetNodeNumbers!(net)\n\njulia> net.node[4].number = 111;\n\njulia> PhyloNetworks.updateconstraints!([c_species1, c_clade145], net)\n\njulia> c_species1\nSpecies constraint, on tips: 1a, 1b, 1c\n stem edge number 7\n crown node number 21\n\njulia> c_species1.taxonnums\nSet{Int64} with 3 elements:\n  5\n  4\n  111\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.writeTopologyLevel1-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.writeTopologyLevel1","text":"writeTopologyLevel1(net::HybridNetwork)\n\nWrite the extended Newick parenthetical format of a level-1 network object with many optional arguments (see below). Makes a deep copy of net: does not modify net.\n\ndi=true: write in format for Dendroscope (default false)\nnamelabel=true: If namelabel is true, taxa are labelled by their names;\n\notherwise taxa are labelled by their numbers (unique identifiers).\n\noutgroup (string): name of outgroup to root the tree/network. if \"none\" is given, the root is placed wherever possible.\nprintID=true, only print branch lengths for identifiable egdes according to the snaq estimation procedure (default false) (true inside of snaq!.)\nround: rounds branch lengths and heritabilities γ (default: true)\ndigits: digits after the decimal place for rounding (defult: 3)\nstring: if true (default), returns a string, otherwise returns an IOBuffer object.\nmultall: (default false). set to true when there are multiple alleles per population.\n\nThe topology may be written using a root different than net.root, if net.root is incompatible with one of more hybrid node. Missing hybrid names are written as \"#Hi\" where \"i\" is the hybrid node number if possible.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#StatsBase.coeftable-Tuple{PhyloNetworkLinearModel}","page":"Internals","title":"StatsBase.coeftable","text":"coeftable(m::PhyloNetworkLinearModel; level::Real=0.95)\n\nReturn coefficient estimates, standard errors, t-values, p-values, and t-intervals as a StatsBase.CoefTable.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#StatsBase.confint-Tuple{PhyloNetworkLinearModel}","page":"Internals","title":"StatsBase.confint","text":"confint(m::PhyloNetworkLinearModel; level::Real=0.95)\n\nReturn confidence intervals for coefficients, with confidence level level, based on the t-distribution whose degree of freedom is determined by the number of species (as returned by dof_residual)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#StatsBase.deviance","page":"Internals","title":"StatsBase.deviance","text":"StatsBase.deviance(m::PhyloNetworkLinearModel)\n\n-2 loglikelihood of the fitted model. See also  loglikelihood.\n\nNote: this is not the residual-sum-of-squares deviance as output by GLM, such as one would get with deviance(m.model).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#StatsBase.deviance-Tuple{PhyloNetworkLinearModel, Val{true}}","page":"Internals","title":"StatsBase.deviance","text":"StatsBase.deviance(m::PhyloNetworkLinearModel, Val(true))\n\nResidual sum of squares with metric V, the estimated phylogenetic covariance, if the model is appropriate.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#StatsBase.fit-Tuple{Type{PhyloNetworks.StatisticalSubstitutionModel}, HybridNetwork, PhyloNetworks.SubstitutionModel, RateVariationAcrossSites, AbstractVector{T} where T}","page":"Internals","title":"StatsBase.fit","text":"fit(StatisticalSubstitutionModel, net, model, traits; kwargs...)\nfit!(StatisticalSubstitutionModel; kwargs...)\n\nInternal function called by fitdiscrete: with same key word arguments kwargs. But dangerous: traits should be a vector of vectors as for fitdiscrete but here traits need to contain the indices of trait values corresponding to the indices in getlabels(model), and species should appear in traits in the order corresponding to the node numbers in net. See traitlabels2indices to convert trait labels to trait indices.\n\nWarning: does not perform checks. fitdiscrete calls this function after doing checks, preordering nodes in the network, making sure nodes have consecutive numbers, species are matched between data and network etc.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#StatsBase.loglikelihood-Tuple{PhyloNetworkLinearModel}","page":"Internals","title":"StatsBase.loglikelihood","text":"loglikelihood(m::PhyloNetworkLinearModel)\n\nLog likelihood, or log restricted likelihood (REML), depending on m.reml.\n\nFor models with no within-species variation, the likelihood (or REML) is calculated based on the joint density for species-level mean responses.\n\nFor within-species variation models, the likelihood is calculated based on the joint density for individual-level responses. This can be calculated from individual-level data, but also by providing species-level means and standard deviations which is accepted by phylolm.\n\nWarning: many summaries are based on the species-level model, like \"dof_residual\", \"residuals\", \"predict\" or \"deviance\". So deviance is innapropriate to compare models with within-species variation. Use loglikelihood to compare models based on data at the individual level.\n\nReminder: do not compare ML or REML values across models fit on different data. Do not compare REML values across models that do not have the same predictors (fixed effects): use ML instead, for that purpose.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#StatsBase.nobs-Tuple{PhyloNetworkLinearModel}","page":"Internals","title":"StatsBase.nobs","text":"StatsBase.nobs(m::PhyloNetworkLinearModel)\n\nNumber of observations: number of species with data, if the model assumes known species means, and number of individuals with data, if the model accounts for within-species variation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#StatsBase.nulldeviance-Tuple{PhyloNetworkLinearModel}","page":"Internals","title":"StatsBase.nulldeviance","text":"StatsBase.nulldeviance(m::PhyloNetworkLinearModel)\n\nResidual sums of squares of the null model, that is when including only the intercept, if the model is appropriate. The residual sums of squares is taken with metric V, the estimated phylogenetic covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#StatsBase.stderror-Tuple{PhyloNetworkLinearModel}","page":"Internals","title":"StatsBase.stderror","text":"stderror(m::PhyloNetworkLinearModel)\n\nReturn the standard errors of the coefficient estimates. See vcov for related information on how these are computed.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#StatsBase.vcov-Tuple{PhyloNetworkLinearModel}","page":"Internals","title":"StatsBase.vcov","text":"vcov(m::PhyloNetworkLinearModel)\n\nReturn the variance-covariance matrix of the coefficient estimates.\n\nFor the continuous trait evolutionary models currently implemented, species-level mean response (conditional on the predictors), Y|X is modeled as:\n\nY|X ∼ 𝒩(Xβ, σ²ₛV) for models assuming known species mean values (no within-species variation)\nY|X ∼ 𝒩(Xβ, σ²ₛV + σ²ₑD⁻¹) for models with information from multiple individuals and assuming within-species variation\n\nThe matrix V is inferred from the phylogeny, but may also depend on additional parameters to be estimated (e.g. lambda for Pagel's Lambda model). See ContinuousTraitEM, PhyloNetworkLinearModel for more details.\n\nIf (1), then return σ²ₛ(X'V⁻¹X)⁻¹, where σ²ₛ is estimated with REML, even if the model was fitted with reml=false. This follows the conventions of nlme::gls and stats::glm in R.\n\nIf (2), then return σ²ₛ(X'W⁻¹X)⁻¹, where W = V+(σ²ₑ/σ²ₛ)D⁻¹ is estimated, and σ²ₛ & σₑ are the estimates obtained with ML or REML, depending on the reml option used to fit the model m. This follows the convention of MixedModels.fit in Julia.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.fAbs","page":"Internals","title":"PhyloNetworks.fAbs","text":"default values for tolerance parameters, used in the optimization of branch lengths (fAbs, fRel, xAbs, xRel) and in the acceptance of topologies (likAbs, numFails).\n\nif changes are made here, make the same in the docstring for snaq! below\n\nversion fAbs fRel xAbs xRel numFails likAbs multiplier\nv0.5.1 1e-6 1e-6 1e-3 1e-2 75 1e-6 \nv0.3.0 1e-6 1e-5 1e-4 1e-3 100 0.01 \nv0.0.1 1e-6 1e-5 1e-4 1e-3 100  10000\nolder 1e-10 1e-12 1e-10 1e-10   \n\nv0.5.1: based on Nan Ji's work. same xAbs and xRel as in phylonet (as of 2015). earlier: multiplier was used; later: likAbs = multiplier*fAbs) \"older\": values from GLM.jl, Prof Bates\n\ndefault values used on a single topology, to optimize branch lengths and gammas, at the very end of snaq!, and by topologyMaxQPseudolik! since v0.5.1.\n\nversion fAbsBL fRelBL xAbsBL xRelBL\nv0.0.1 1e-10 1e-12 1e-10 1e-10\n\n\n\n\n\n","category":"constant"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"using PhyloNetworks\nusing DataFrames\nmkpath(\"../assets/figures\")\nfigname(x) = joinpath(\"..\", \"assets\", \"figures\", x)","category":"page"},{"location":"man/fitDiscrete/#Discrete-Trait-Evolution","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"With a phylogenetic network structure inferred, we can now estimate how quickly traits have evolved over time using a likelihood model. These traits should be discrete characteristics of a species such as feather color, diet type, or DNA in aligned genetic sequences.","category":"page"},{"location":"man/fitDiscrete/#Discrete-trait-data","page":"Discrete Trait Evolution","title":"Discrete trait data","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"As with continuous trait evolution, we assume a fixed network, correctly rooted, with branch lengths proportional to calendar time. We start with a network, then add data about the tips of this network.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"The simplest way is to use a vector of species names with a data frame of traits:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"# read in network\nnet = readTopology(\"(O:4,(A:3,((B:0.4)#H1:1.6::0.92,((C:0.4,#H1:0::0.08):0.6,(D:.2,E:.2):0.8):1):1):1);\");\n# read in trait data\nspecies = [\"C\",\"A\",\"D\",\"B\",\"O\",\"E\"];\ndat = DataFrame(trait=[\"hi\",\"lo\",\"lo\",\"hi\",\"lo\",\"lo\"])","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"If your species names and trait data are in the same data frame, read in your data frame then subset the data like this:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"dat = DataFrame(species=[\"C\",\"A\",\"D\",\"B\",\"O\",\"E\"], trait=[\"hi\",\"lo\",\"lo\",\"hi\",\"lo\",\"lo\"]);\nspecies = dat.species # or: dat[!, :species]\nselect!(dat, Not(:species)) # select all columns except for :species; modifies dat in place\nnothing # hide","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"Let's plot the network and map the data onto it:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"using RCall, PhyloPlots\nR\"svg\"(figname(\"fitdiscrete_trait_net_1.svg\"), width=4, height=3); # hide\nR\"par\"(mar=[0,0,0,0]); # to reduce margins\nres = plot(net, :R; tipOffset=0.3); # the results \"res\" provides point coordinates, to use for data annotation\no = [findfirst(isequal(tax), species) for tax in tipLabels(net)] # 5,2,4,1,3,6: order to match taxa from \"species\" to tip labels\nisequal(species[o], tipLabels(net)) # true :)\ntraitcolor = map(x -> (x==\"lo\" ? \"grey\" : \"red\"), dat.trait[o])\nleaves = res[13][!,:lea]\nR\"points\"(x=res[13][leaves,:x] .+0.1, y=res[13][leaves,:y], pch=16, col=traitcolor, cex=1.5); # adds grey & red points\nR\"legend\"(x=1, y=2, legend=[\"hi\",\"lo\"], pch=16, col=[\"red\",\"grey\"],\n          title=\"my trait\", bty=\"n\",var\"title.adj\"=0);\n# next: add arrow to show gene flow edge, and proportion γ of genes affected\nhi = findfirst([!e.isMajor for e in net.edge]) # 6 : \"h\"ybrid \"i\"ndex: index of gene flow edge (minor hybrid) in net\n(hx1, hx2, hy1, hy2) = (res[i][hi] for i in 9:12); # coordinates for minor hybrid edge; 1=start, 2=end\nR\"arrows\"(hx1, hy1, hx2, hy2, col=\"deepskyblue\", length=0.08, angle=20); # adds the arrow\nR\"text\"(res[14][hi,:x]-0.2, res[14][hi,:y]+0.1, res[14][hi,:gam], col=\"deepskyblue\", cex=0.75); # add the γ value\nR\"dev.off\"(); # hide\nnothing # hide","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"(Image: net_1)","category":"page"},{"location":"man/fitDiscrete/#Substitution-models","page":"Discrete Trait Evolution","title":"Substitution models","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"After reading in your data, choose a model to describe how evolutionary changes (or substitutions, in the case of DNA) happened over time. Available Markov substitution models are described below.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"For general trait types, use one of these three models:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":":BTSM Binary Trait Substitution Model (2 states, rates unconstrained)\n:ERSM Equal Rates Substitution Model (k states, all transitions possible with equal rates)\n:TBTSM Two Binary Trait Substitution Model (though not fully implemented yet)","category":"page"},{"location":"man/fitDiscrete/#Inference","page":"Discrete Trait Evolution","title":"Inference","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"To infer evolutionary rates, run fitdiscrete on the network and data. It will calculate the maximum likelihood score of one or more discrete trait characters at the tips on a fixed network.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"Along each edge, evolutionary changes are modeled with a continous time Markov model.\nAt a hybrid node, the trait is assumed to be inherited from one or the other of its parents (immediately before the reticulation event), with probabilities equal to the inheritance γ of each parent edge, which is given by the network.\nAt the root of the network, a uniform distribution among the possible states is assumed a priori.\nThe model ignores incomplete lineage sorting (e.g. hemiplasy).","category":"page"},{"location":"man/fitDiscrete/#parameter-estimation-and-model-fit","page":"Discrete Trait Evolution","title":"parameter estimation & model fit","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"The example below if for a binary trait, first using a model assuming equal rates (from lo to hi and from hi to lo); then using a model allowing for distinct rates. The option optimizeQ=false causes transition rates to stay at their starting values, without being optimized.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"s1 = fitdiscrete(net, :ERSM, species, dat; optimizeQ=false)\ns2 = fitdiscrete(net, :BTSM, species, dat; optimizeQ=false)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"The default rates, which act as starting value if rates were to be optimized, are chosen equal to the inverse of the total edge lengths in the network (or 1/ntax if all branch lengths are missing).","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"By default optimizeQ = true, such that fitdiscrete estimates the parameters of the rate matrix Q.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"s3 = fitdiscrete(net, :ERSM, species, dat)\ns4 = fitdiscrete(net, :BTSM, species, dat)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"To compare the two models, we can use the Akaike criterion.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"using StatsBase\naic(s3)\naic(s4)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"Here, the equal-rate model is slightly favored (lower AIC), so we will use s3 below.","category":"page"},{"location":"man/fitDiscrete/#ancestral-state-prediction","page":"Discrete Trait Evolution","title":"ancestral state prediction","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"This is traditionally called \"ancestral state reconstruction\", but we do not actually reconstruct anything. We make predictions for (past of present-day) values, hopefully with some measure to quantify our uncertainty.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"# show(ancestralStateReconstruction(s3), allrows=true)\nancestralStateReconstruction(s3)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"Rows 1-6 correspond to the tips, with known values. We see much prediction uncertainty at most of the internal nodes. To see where these internal nodes (7-13/H1) are, we need to look at the network stored within the fitted model. This network might differ somewhat from the input network in case taxa with missing data where pruned, and with edges possibly renumbered.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"R\"svg\"(figname(\"fitdiscrete_trait_net_2.svg\"), width=4, height=3); # hide\nR\"par\"(mar=[0,0,0,0]); # hide\nplot(s3.net, :R, showNodeNumber=true, showIntNodeLabel=true, tipOffset=0.2);\nR\"dev.off\"(); # hide\nnothing # hide","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"(Image: net_2)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"Looking back at the posterior probabilities of states \"hi\" and \"lo\" at each node from the ancestral 'prediction' table above, we see that there is more uncertainty near the root, and less uncertainty near the tips. The most recent common ancestor of D and E (node 11), in particular, is predicted to be \"lo\" with fairly high certainty.","category":"page"},{"location":"man/fitDiscrete/#impact-of-gene-flow-on-the-trait","page":"Discrete Trait Evolution","title":"impact of gene flow on the trait","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"An interesting question is whether there is evidence that B obtained it's \"hi\" state via gene flow. The prior probability for this is γ: the supposedly known proportion of genes inherited via gene flow, which is part of the network (along with branch lengths). Here, this prior probability of trait inheritance via gene flow is:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"net.edge[6].gamma # the minor hybrid edge was edge 6, from above","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"We can compare this to the posterior probability, and get a Bayes factor to compare the two hypotheses: gene flow vs. vertical inheritance.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"exp(s3.priorltw[1]) # prior: for vertical inheritance. \"ltw\" = log tree weight\nexp(s3.priorltw[2]) # prior: for gene flow inheritance, same as γ above\npostltw = PhyloNetworks.posterior_logtreeweight(s3)\nexp(postltw[2])     # posterior: for gene flow inheritance\nfunction geneflowBF(fit)\n    postltw = PhyloNetworks.posterior_logtreeweight(fit)\n    exp(postltw[2] - postltw[1] + fit.priorltw[1] - fit.priorltw[2])\nend\ngeneflowBF(s3)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"We get a Bayes factor greater than 1, so there is more evidence that the \"hi\" value of B was inherited via gene flow, than via vertical inheritance. But the Bayes factor is just barely above 1, so the evidence is very equivocal. This may not be surprising given that gene flow occurred between fairly closely related species, and that the data set is very small.","category":"page"},{"location":"man/fitDiscrete/#Trait-simulation","page":"Discrete Trait Evolution","title":"Trait simulation","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"randomTrait can simulate traits along a known network. For example, we can define a binary trait model with states \"carnivory\" (state 1) and \"non-carnivory\" (state 2), then ask for a trait to be simulated along our network. We can ask for 3 independent simulations, giving us 3 traits then, arranged in 3 rows.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"m1 = BinaryTraitSubstitutionModel(1.0,2.0, [\"carnivory\", \"non-carnivory\"])\nusing Random; Random.seed!(1234); # for reproducibility of this example\ntraitmatrix, nodecolumn = randomTrait(m1, net; ntraits=3);\ntraitmatrix","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"In this trait matrix, each column corresponds to a node, each row is a trait, and each entry gives the state of that trait for that node, as an index. To get the state labels:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"m1.label[traitmatrix]","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"The nodecolumn vector says which node corresponds to which column in the trait matrix, and we can compare to the node numbers in the network. For example, the first column corresponds to node -2, which is the root. (The root is always in the first column: that's where the simulation starts.) Also, as an example, the column for taxon \"A\" is column 12:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete Trait Evolution","title":"Discrete Trait Evolution","text":"nodecolumn\nnet.node[net.root]\nfindfirst(isequal(\"A\"), nodecolumn)\nnodecolumn[12]\ntraitmatrix[:,12]\nm1.label[traitmatrix[:,12]]","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"using PhyloNetworks\nmkpath(\"../assets/figures\")\nraxmltrees = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"raxmltrees.tre\")\nraxmlCF = readTableCF(writeTableCF(countquartetsintrees(readMultiTopology(raxmltrees), showprogressbar=false)...))\ntruenet = readTopology(\"((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\");","category":"page"},{"location":"man/expectedCFs/#Extract-Expected-CFs","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"","category":"section"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"A good way to visualize the \"goodness-of-fit\" of a given estimated network to the data is to plot the observed CF versus the expected CF. If the network is a good fit, then the dots in the plot will be close to the diagonal (x=y line). The following function will create a dataframe with the observed and expected CFs, which are all saved in the DataCF object after running snaq:","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"topologyMaxQPseudolik!(truenet, raxmlCF);\ndf_wide = fittedQuartetCF(raxmlCF) # same as fittedQuartetCF(raxmlCF, :wide)\ndf_long = fittedQuartetCF(raxmlCF, :long)","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"It is important to have run snaq!, topologyQPseudolik! or topologyMaxQPseudolik! before making these tables, or the result would be meaningless. These functions update the fitted concordance factors (those expected under the network) inside the DataCF object raxmlCF.","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"Here is one way to plot them, via R again, and using the R package ggplot2.","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"using RCall\nobsCF = df_long[!,:obsCF]; expCF = df_long[!,:expCF]; # hide\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\"; # hide\nR\"svg(name('expCFs_obsvsfitted.svg'), width=5, height=4)\"; # hide\nR\"par\"(mar=[2.5,2.6,.5,.5], mgp=[1.5,.4,0], tck=-0.01, las=1, pty=\"s\"); # hide\nR\"plot(0:1, 0:1, type='l', bty='L', lwd=0.3, col='#008080', xlab='quartet CF observed in gene trees', ylab='quartet CF expected from network')\"; # hide\nR\"set.seed\"(1234); # hide\nR\"points(jitter($obsCF,amount=0.005),jitter($expCF,amount=0.005),col='#008080',bg='#00808090',pch=21)\"; # hide\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"To install ggplot2 if not installed already, do: R\"install.packages('ggplot2', dep=TRUE)\"","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"@rlibrary ggplot2\nggplot(df_long, aes(x=:obsCF,y=:expCF)) + theme_classic() +\n    geom_segment(x=0,y=0,xend=1,yend=1, color=\"#008080\", size=0.3) + # diagonal line\n    geom_point(alpha=0.5, color=\"#008080\", position=position_jitter(width=0.005, height=0.005)) +\n    ylab(\"quartet CF expected from network\") + xlab(\"quartet CF observed in gene trees\") + coord_equal(ratio=1);\n# if needed, save with:\nggsave(\"expCFs_obsvsfitted.svg\", scale=1, width=6, height=5);","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"(Image: obsvsfitted)","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"Many points are overlapping, so they were \"jittered\" a little to see them all better. There are always many points overlapping on the bottom-left corner: concordance factors of 0.0 for quartet resolutions not observed, and not expected.   To export the table of quartet CFs and explore the fit of the network with other tools:","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"using CSV\nCSV.write(\"fittedCF.csv\", df_long)","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"alternative code to get a similar plot with Gadfly:","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"using Gadfly\nplot(layer(df_long, Geom.point, x=\"obsCF\", y=\"expCF\"),\n     layer(x=0:1,y=0:1, Geom.line), # diagonal line\n     Guide.xlabel(\"CF observed in gene trees\"), Guide.ylabel(\"CF expected from network\"))","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"We could highlight quartets that include taxon A, say, if we suspect that it is an unrecognized hybrid. Many points are overlapping, like before, so they are again \"jittered\" a bit.","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"using DataFrames\ndf_long[!,:has_A] .= \"no\"; # add a column to our data, to indicate which 4-taxon sets have A or not\nfor r in eachrow(df_long)\n    if \"A\" ∈ [r[:tx1], r[:tx2], r[:tx3], r[:tx4]]\n       r[:has_A]=\"yes\"\n    end\nend\nhas_A = df_long.has_A # hide\nnq = length(has_A); # hide\nR\"colA=rep('#008080',$nq); bgA=rep('#00808090',$nq);\"; # hide\nR\"colA[$has_A=='yes']='#F8766D'; bgA[$has_A=='yes']='#F8766D90'\"; # hide\nR\"svg(name('expCFs_obsvsfitted_A.svg'), width=5, height=4)\"; # hide\nR\"par\"(mar=[2.5,2.6,.5,.5], mgp=[1.5,.4,0], tck=-0.01, las=1, pty=\"s\"); # hide\nR\"plot(0:1, 0:1, type='l', bty='L', lwd=0.3, col='black', xlab='quartet CF observed in gene trees', ylab='quartet CF expected from network')\"; # hide\nR\"set.seed\"(2345); # hide\nR\"points(jitter($obsCF,amount=0.005),jitter($expCF,amount=0.005),col=colA,bg=bgA,pch=21)\"; # hide\nR\"legend(x=0.7,y=0.3,pch=21,col=c('#008080','#F8766D'),legend=c('no','yes'),title='has A?', bty='n',bg=c('#00808090','#F8766D90'))\"; # hide\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"first(df_long, 7) # first 7 rows","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"ggplot(df_long, aes(x=:obsCF, y=:expCF, color=:has_A)) + theme_classic() +\n    geom_segment(x=0,y=0,xend=1,yend=1, color=\"black\", size=0.3) + # diagonal line\n    geom_point(alpha=0.5, position=position_jitter(width=0.005, height=0.005)) +\n    ylab(\"quartet CF expected from network\") + xlab(\"quartet CF observed in gene trees\") + coord_equal(ratio=1);\n# can be saved:\nggsave(\"expCFs_obsvsfitted_A.svg\", width=6, height=5);","category":"page"},{"location":"man/expectedCFs/","page":"Extract Expected CFs","title":"Extract Expected CFs","text":"(Image: obsvsfitted A present or not)","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for PhyloNetworks's public (exported) interface.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"See Internal Documentation for documentation on internal functions.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#types","page":"Public","title":"types","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [PhyloNetworks]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"lib/public/#PhyloNetworks.BinaryTraitSubstitutionModel","page":"Public","title":"PhyloNetworks.BinaryTraitSubstitutionModel","text":"BinaryTraitSubstitutionModel(α, β [, label])\n\nModel for binary traits, that is, with 2 states. Default labels are \"0\" and \"1\". α is the rate of transition from \"0\" to \"1\", and β from \"1\" to \"0\".\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.DataCF","page":"Public","title":"PhyloNetworks.DataCF","text":"DataCF\n\ntype that contains the following attributes:\n\nquartet (vector of Quartets)\nnumQuartets\ntree (vector of trees: empty if a table of CF was input instead of list of trees)\nnumTrees (-1 if a table CF was input instead of list of trees)\nrepSpecies (taxon names that were repeated in table of CF or input gene trees: used inside snaq for multiple alleles case)\n\nThe list of Quartet may be accessed with the attribute .quartet. If the input was a list of trees, the HybridNetwork's can be accessed with the attribute .tree. For example, if the DataCF object is named d, d.quartet[1] will show the first quartet and d.tree[1] will print the first input tree.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.EqualRatesSubstitutionModel","page":"Public","title":"PhyloNetworks.EqualRatesSubstitutionModel","text":"EqualRatesSubstitutionModel(numberStates, α, labels)\n\nTraitSubstitutionModel for traits with any number of states and equal substitution rates α between all states. Default labels are \"1\",\"2\",...\n\nexample\n\njulia> m1 = EqualRatesSubstitutionModel(2, [1.0], [\"low\",\"high\"])\nEqual Rates Substitution Model with k=2,\nall rates equal to α=1.0.\nrate matrix Q:\n             low    high\n     low       *  1.0000\n    high  1.0000       *\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.HKY85","page":"Public","title":"PhyloNetworks.HKY85","text":"HKY85(rate, pi, relative)\n\nA nucleic acid substitution model based on Hasegawa et al. 1985 substitution model. rate should be a vector of 1 or 2 rates, and pi a vector of 4 probabilities summing to 1.\n\nIf relative is false, the 2 rates represent the transition rate and the transversion rate, α and β. If relative is true (default), only the first rate is used and represents the transition/transversion ratio: κ=α/β. The rate transition matrix Q is normalized to have 1 change / unit of time on average, i.e. the absolute version of Q is divided by 2(piT*piC + piA*piG)α + 2(piY*piR)β.\n\nnparams returns 1 or 2. In other words: the stationary distribution is not counted in the number of parameters (and fitdiscrete does not optimize the pi values at the moment).\n\nexamples\n\njulia> m1 = HKY85([.5], [0.20, 0.30, 0.30, 0.20])\nHKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]\nrelative rate version with transition/tranversion ratio kappa = 0.5,\n scaled so that there is one substitution per unit time\nrate matrix Q:\n               A       C       G       T\n       A       *  0.4839  0.2419  0.3226\n       C  0.3226       *  0.4839  0.1613\n       G  0.1613  0.4839       *  0.3226\n       T  0.3226  0.2419  0.4839       *\n\njulia> nstates(m1)\n4\n\njulia> m2 = HKY85([0.5, 0.5], [0.20, 0.30, 0.30, 0.20], false)\nHKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]\nabsolute rate version with transition/transversion ratio kappa = a/b = 1.0\n with rates a = 0.5 and b = 0.5\nrate matrix Q:\n               A       C       G       T\n       A       *  0.1500  0.1500  0.1000\n       C  0.1000       *  0.1500  0.1000\n       G  0.1000  0.1500       *  0.1000\n       T  0.1000  0.1500  0.1500       *\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.HybridNetwork","page":"Public","title":"PhyloNetworks.HybridNetwork","text":"HybridNetwork\n\nSubtype of abstract Network type. Explicit network or tree with the following attributes:\n\nnumTaxa (taxa are tips, i.e. nodes attached to a single edge)\nnumNodes (total number of nodes: tips and internal nodes)\nnumEdges\nnumHybrids (number of hybrid nodes)\nedge (array of Edges)\nnode (array of Nodes)\nroot (index of root in vector 'node'. May be artificial, for printing and traversal purposes only.)\nhybrid (array of Nodes: those are are hybrid nodes)\nleaf (array of Nodes: those that are leaves)\nloglik (score after fitting network to data, i.e. negative log pseudolik for SNaQ)\nisRooted (true or false)\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.JC69","page":"Public","title":"PhyloNetworks.JC69","text":"JC69(rate, relative)\n\nJukes Cantor (1969) nucleic acid substitution model, which has a single rate parameter. rate corresponds to the absolute diagonal elements, that is, the rate of change (to any of the other 2 states). Individual rates are rate/3. If relative is true (default), the transition matrix Q is normalized to an average of 1 transition per unit of time: in which case rate is set to 1.0.\n\nexamples\n\njulia> m1 = JC69([0.25], false)\nJukes and Cantor 69 Substitution Model,\nabsolute rate version\noff-diagonal rates equal to 0.25/3.\nrate matrix Q:\n               A       C       G       T\n       A       *  0.0833  0.0833  0.0833\n       C  0.0833       *  0.0833  0.0833\n       G  0.0833  0.0833       *  0.0833\n       T  0.0833  0.0833  0.0833       *\n\njulia> nstates(m1)\n4\n\njulia> nparams(m1)\n1\n\njulia> m2 = JC69([0.5])\nJukes and Cantor 69 Substitution Model,\nrelative rate version\noff-diagonal rates equal to 1/3\nrate matrix Q:\n               A       C       G       T\n       A       *  0.3333  0.3333  0.3333\n       C  0.3333       *  0.3333  0.3333\n       G  0.3333  0.3333       *  0.3333\n       T  0.3333  0.3333  0.3333       *\n\njulia> nparams(m2)\n0\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.ParamsBM","page":"Public","title":"PhyloNetworks.ParamsBM","text":"ParamsBM <: ParamsProcess\n\nType for a BM process on a network. Fields are mu (expectation), sigma2 (variance), randomRoot (whether the root is random, default to false), and varRoot (if the root is random, the variance of the root, default to NaN).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.ParamsMultiBM","page":"Public","title":"PhyloNetworks.ParamsMultiBM","text":"ParamsMultiBM <: ParamsProcess\n\nType for a multivariate Brownian diffusion (MBD) process on a network. Fields are mu (expectation), sigma (covariance matrix), randomRoot (whether the root is random, default to false), varRoot (if the root is random, the covariance matrix of the root, default to [NaN]), shift (a ShiftNet type, default to missing), and L (the lower triangular of the cholesky decomposition of sigma, computed automatically)\n\nConstructors\n\njulia> ParamsMultiBM([1.0, -0.5], [2.0 0.3; 0.3 1.0]) # no shifts\nParamsMultiBM:\nParameters of a MBD with fixed root:\nmu: [1.0, -0.5]\nSigma: [2.0 0.3; 0.3 1.0]\n\njulia> net = readTopology(\"((A:1,B:1):1,C:2);\");\n\njulia> shifts = ShiftNet(net.node[2], [-1.0, 2.0], net);\n\njulia> ParamsMultiBM([1.0, -0.5], [2.0 0.3; 0.3 1.0], shifts) # with shifts\nParamsMultiBM:\nParameters of a MBD with fixed root:\nmu: [1.0, -0.5]\nSigma: [2.0 0.3; 0.3 1.0]\n\nThere are 2 shifts on the network:\n───────────────────────────────────────────\n  Edge Number  Shift Value 1  Shift Value 2\n───────────────────────────────────────────\n          2.0           -1.0            2.0\n───────────────────────────────────────────\n\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.PhyloNetworkLinearModel","page":"Public","title":"PhyloNetworks.PhyloNetworkLinearModel","text":"PhyloNetworkLinearModel <: GLM.LinPredModel\n\nPhylogenetic linear model representation.\n\nFields\n\nlm, V, Vy, RL, Y, X, logdetVy, reml, ind, nonmissing, model, model_within. The following syntax pattern can be used to get more information on a specific field: e.g. to find out about the lm field, do ?PhyloNetworkLinearModel.lm.\n\nMethods applied to fitted models\n\nThe following StatsBase functions can be applied: coef, nobs, vcov, stderror, confint, coeftable, dof_residual, dof, deviance, residuals, response, predict, loglikelihood, nulldeviance, nullloglikelihood, r2, adjr2, aic, aicc, bic, ftest, lrtest etc.\n\nThe estimated variance-rate and estimated mean of the species-level trait model (see ContinuousTraitEM) can be retrieved using sigma2_phylo and mu_phylo respectively.\n\nIf relevant, the estimated individual-level/within-species variance can be retrieved using sigma2_within.\n\nThe optimized λ parameter for Pagel's λ model (see PagelLambda) can be retrieved using lambda_estim.\n\nAn ancestral state reconstruction can be performed using ancestralStateReconstruction.\n\nWithin-species variation\n\nThe true species/population means for the response trait/variable (or the residuals: conditional on the predictors) are jointly modeled as 𝒩(·, σ²ₛV) where V depends on the trait model (see ContinuousTraitEM) and on the species network. σ²ₛ is the between-species variance-rate.\n\nWithin-species variation is modeled by assuming that the individual-level responses are iid 𝒩(0, σ²ₑ) about the true species means, so that the species-level sample means (conditional on the predictors) are jointly modeled as 𝒩(·, σ²ₛV + σ²ₑD⁻¹), where σ²ₑ is the within-species variance and D⁻¹ is a diagonal matrix whose entries are the inverse sample-sizes (see WithinSpeciesCTM).\n\nAlthough the above two models can be expressed in terms of a joint distribution for the species-level sample means (or residuals conditional on the predictors), more data are required to fit a model accounting for within-species variation, that is, a model recognizing that the sample means are estimates of the true population means. To fit a model without within-species variation, data on the species means are sufficient. To fit a model with within-species variation, we need to have the species means and the standard deviations of the response variable for each species.\n\nphylolm can fit a model with within-species variation either from species-level statistics (\"mean response\" and \"standard deviation in response\") or from individual-level data (in which case the species-level statistics are computed internally). See phylolm for more details on these two input choices.\n\nIn the object, obj.Y and obj.X are the observed species means. predict, residuals and response return the values at the species level.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.Quartet","page":"Public","title":"PhyloNetworks.Quartet","text":"Quartet\n\ntype that saves the information on a given 4-taxon subset. It contains the following attributes:\n\nnumber: integer\ntaxon: vector of taxon names, like t1 t2 t3 t4\nobsCF: vector of observed CF, in order 12|34, 13|24, 14|23\nlogPseudoLik\nngenes: number of gene trees used to compute the observed CF; -1.0 if unknown\nqnet: QuartetNetwork, which saves the expCF after snaq estimation to emphasize that the expCF depend on a specific network, not the data\n\nsee also: QuartetT for quartet with data of user-defined type T, using a mapping between quartet indices and quartet taxa.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.RateVariationAcrossSites","page":"Public","title":"PhyloNetworks.RateVariationAcrossSites","text":"RateVariationAcrossSites(rvsymbol::Symbol, ncategories=4::Int)\n\nDefault model for rate variation across site, specified by a symbol:\n\n:noRV for no rate variation\n:G or :Gamma for gamma-distributed rates\n:I or :Inv for two categories: invariable and variable\n:GI or :GI for both.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.RateVariationAcrossSites-Tuple{}","page":"Public","title":"PhyloNetworks.RateVariationAcrossSites","text":"RateVariationAcrossSites(; pinv=0.0, alpha=Inf, ncat=4)\n\nModel for variable substitution rates across sites (or across traits) using the discrete Gamma model (+G, Yang 1994, Journal of Molecular Evolution) or the invariable-sites model (+I, Hasegawa, Kishino & Yano 1985 J Mol Evol). Both types of rate variation can be combined (+G+I, Gu, Fu & Li 1995, Mol Biol Evol) but this is discouraged (Jia, Lo & Ho 2014 PLOS One). Using rate variation increases the number of parameters by one (+G or +I) or by two (+G+I).\n\nBecause the mean of the desired distribution or rates is 1, we use a Gamma distribution with shape α and scale θ=1/α (rate β=α) if no invariable sites, or scale θ=1/(α(1-pinv)), that is rate β=α(1-pinv) with a proportion pinv of invariable sites. The shape parameter is referred to as alpha here. The Gamma distribution is discretized into ncat categories. In each category, the category's rate multiplier is a normalized quantile of the gamma distribution.\n\njulia> rv = RateVariationAcrossSites()\nRate variation across sites: discretized Gamma\ncategories for Gamma discretization: 1\nrates: [1.0]\n\njulia> nparams(rv)\n0\n\njulia> typeof(rv)\nPhyloNetworks.RVASGamma{1}\n\njulia> rv = RateVariationAcrossSites(alpha=1.0, ncat=4)\nRate variation across sites: discretized Gamma\nalpha: 1.0\ncategories for Gamma discretization: 4\nrates: [0.146, 0.513, 1.071, 2.27]\n\njulia> typeof(rv)\nPhyloNetworks.RVASGamma{4}\n\njulia> PhyloNetworks.setalpha!(rv, 2.0)\nRate variation across sites: discretized Gamma\nalpha: 2.0\ncategories for Gamma discretization: 4\nrates: [0.319, 0.683, 1.109, 1.889]\n\njulia> nparams(rv)\n1\n\njulia> rv = RateVariationAcrossSites(pinv=0.3)\nRate variation across sites: +I (invariable sites)\npinv: 0.3\nrates: [0.0, 1.429]\n\njulia> nparams(rv)\n1\n\njulia> typeof(rv)\nPhyloNetworks.RVASInv\n\njulia> PhyloNetworks.setpinv!(rv, 0.05)\nRate variation across sites: +I (invariable sites)\npinv: 0.05\nrates: [0.0, 1.053]\n\njulia> rv = RateVariationAcrossSites(pinv=0.3, alpha=2.0, ncat=4)\nRate variation across sites: discretized Gamma+I\npinv: 0.3\nalpha: 2.0\ncategories for Gamma discretization: 4\nrates: [0.0, 0.456, 0.976, 1.584, 2.698]\nprobabilities: [0.3, 0.175, 0.175, 0.175, 0.175]\n\njulia> nparams(rv)\n2\n\njulia> typeof(rv)\nPhyloNetworks.RVASGammaInv{5}\n\njulia> PhyloNetworks.setalpha!(rv, 3.0)\nRate variation across sites: discretized Gamma+I\npinv: 0.3\nalpha: 3.0\ncategories for Gamma discretization: 4\nrates: [0.0, 0.6, 1.077, 1.584, 2.454]\nprobabilities: [0.3, 0.175, 0.175, 0.175, 0.175]\n\njulia> PhyloNetworks.setpinv!(rv, 0.05)\nRate variation across sites: discretized Gamma+I\npinv: 0.05\nalpha: 3.0\ncategories for Gamma discretization: 4\nrates: [0.0, 0.442, 0.793, 1.167, 1.808]\nprobabilities: [0.05, 0.238, 0.238, 0.238, 0.238]\n\njulia> PhyloNetworks.setpinvalpha!(rv, 0.1, 5.0)\nRate variation across sites: discretized Gamma+I\npinv: 0.1\nalpha: 5.0\ncategories for Gamma discretization: 4\nrates: [0.0, 0.593, 0.91, 1.221, 1.721]\nprobabilities: [0.1, 0.225, 0.225, 0.225, 0.225]\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.ReconstructedStates","page":"Public","title":"PhyloNetworks.ReconstructedStates","text":"ReconstructedStates\n\nType containing the inferred information about the law of the ancestral states given the observed tips values. The missing tips are considered as ancestral states.\n\nThe following functions can be applied to it: expectations (vector of expectations at all nodes), stderror (the standard error), predint (the prediction interval).\n\nThe ReconstructedStates object has fields: traits_nodes, variances_nodes, NodeNumbers, traits_tips, tipNumbers, model. Type in \"?ReconstructedStates.field\" to get help on a specific field.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.ShiftNet","page":"Public","title":"PhyloNetworks.ShiftNet","text":"ShiftNet\n\nShifts associated to a HybridNetwork sorted in topological order. Its shift field is a vector of shift values, one for each node, corresponding to the shift on the parent edge of the node (which makes sense for tree nodes only: they have a single parent edge).\n\nTwo ShiftNet objects on the same network can be concatened with *.\n\nShiftNet(node::Vector{Node}, value::AbstractVector, net::HybridNetwork; checkPreorder=true::Bool)\n\nConstructor from a vector of nodes and associated values. The shifts are located on the edges above the nodes provided. Warning, shifts on hybrid edges are not allowed.\n\nShiftNet(edge::Vector{Edge}, value::AbstractVector, net::HybridNetwork; checkPreorder=true::Bool)\n\nConstructor from a vector of edges and associated values. Warning, shifts on hybrid edges are not allowed.\n\nExtractors: getShiftEdgeNumber, getShiftValue\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.TraitSimulation","page":"Public","title":"PhyloNetworks.TraitSimulation","text":"TraitSimulation\n\nResult of a trait simulation on an HybridNetwork with function simulate.\n\nThe following functions and extractors can be applied to it: tipLabels, obj[:Tips], obj[:InternalNodes] (see documentation for function getindex(::TraitSimulation, ::Symbol)).\n\nThe TraitSimulation object has fields: M, params, model.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.TraitSubstitutionModel","page":"Public","title":"PhyloNetworks.TraitSubstitutionModel","text":"TraitSubstitutionModel\n\nFor subtypes, see BinaryTraitSubstitutionModel, EqualRatesSubstitutionModel, TwoBinaryTraitSubstitutionModel\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloNetworks.TwoBinaryTraitSubstitutionModel","page":"Public","title":"PhyloNetworks.TwoBinaryTraitSubstitutionModel","text":"TwoBinaryTraitSubstitutionModel(rate [, label])\n\nTraitSubstitutionModel for two binary traits, possibly correlated. Default labels are \"x0\", \"x1\" for trait 1, and \"y0\", \"y1\" for trait 2. If provided, label should be a vector of size 4, listing labels for trait 1 first then labels for trait 2. rate should be a vector of substitution rates of size 8. rate[1],...,rate[4] describe rates of changes in trait 1. rate[5],...,rate[8] describe rates of changes in trait 2. In the transition matrix, trait combinations are listed in the following order: x0-y0, x0-y1, x1-y0, x1-y1.\n\nexample\n\nmodel = TwoBinaryTraitSubstitutionModel([2.0,1.2,1.1,2.2,1.0,3.1,2.0,1.1],\n        [\"carnivory\", \"noncarnivory\", \"wet\", \"dry\"]);\nmodel\nusing PhyloPlots\nplot(model) # to visualize states and rates\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#utilities","page":"Public","title":"utilities","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"tipLabels\nsorttaxa!\nprintEdges\nprintNodes\nsummarizeDataCF\ndirectEdges!\ncheckroot!\npreorder!\ncladewiseorder!\nrootatnode!\nrootonedge!\nhybridatnode!\nsetLength!\nsetGamma!\ndeleteleaf!\ndeleteHybridThreshold!\nrotate!\ngetindex(::TraitSimulation, ::Symbol)\ngetNodeAges\npairwiseTaxonDistanceMatrix\nbiconnectedComponents\nblobDecomposition\ntreeedgecomponents\ngetlabels\nnparams\nmapindividuals\nnni!","category":"page"},{"location":"lib/public/#PhyloNetworks.tipLabels","page":"Public","title":"PhyloNetworks.tipLabels","text":"tipLabels(x)\n\nReturn a vector of taxon names at the leaves, for objects of various types: HybridNetwork, Vector of HybridNetworks (in which case the union is taken then sorted), Vector of Quartets, DataCF, TraitSimulation, MatrixTopologicalOrder.\n\nFor a network, the taxon names are coerced to strings.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.sorttaxa!","page":"Public","title":"PhyloNetworks.sorttaxa!","text":"sorttaxa!(DataFrame, columns)\n\nReorder the 4 taxa and reorders the observed concordance factors accordingly, on each row of the data frame. If columns is ommitted, taxon names are assumed to be in columns 1-4 and CFs are assumed to be in columns 5-6 with quartets in this order: 12_34, 13_24, 14_23. Does not reorder credibility interval values, if present.\n\nsorttaxa!(DataCF)\nsorttaxa!(Quartet, permutation_tax, permutation_cf)\n\nReorder the 4 taxa in each element of the DataCF quartet. For a given Quartet, reorder the 4 taxa in its fields taxon and qnet.quartetTaxon (if non-empty) and reorder the 3 concordance values accordingly, in obsCF and qnet.expCF.\n\npermutation_tax and permutation_cf should be vectors of short integers (Int8) of length 4 and 3 respectively, whose memory allocation gets reused. Their length is not checked.\n\nqnet.names is unchanged: the order of taxon names here relates to the order of nodes in the network (???)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.printEdges","page":"Public","title":"PhyloNetworks.printEdges","text":"printEdges(net)\nprintEdges(io::IO, net)\n\nPrint information on the edges of a HybridNetwork or QuartetNetwork object net: edge number, numbers of nodes attached to it, edge length, whether it's a hybrid edge, its γ inheritance value, whether it's a major edge, if it could contain the root (this field is not always updated, though) and attributes pertaining to level-1 networks used in SNaQ: in which cycle it is contained (-1 if no cycle), and if the edge length is identifiable (based on quartet concordance factors).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.printNodes","page":"Public","title":"PhyloNetworks.printNodes","text":"printNodes(net)\nprintNodes(io, net)\n\nPrint information on the nodes of a HybridNetwork net: node number, whether it's a leaf, whether it's a hybrid node, whether it's connected to one or more hybrid edges, it's name (label), the cycle in which it is belong (-1 if no cycle; makes sense for level-1 networks), and the list of edges attached to it, by their numbers.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.summarizeDataCF","page":"Public","title":"PhyloNetworks.summarizeDataCF","text":"summarizeDataCF(d::DataCF)\n\nfunction to summarize the information contained in a DataCF object. It has the following optional arguments:\n\nfilename: if provided, the summary will be saved in the filename, not to screen\npc (number between (0,1)): threshold of percentage of missing genes to identify 4-taxon subsets with fewer genes than the threshold\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.directEdges!","page":"Public","title":"PhyloNetworks.directEdges!","text":"directEdges!(net::HybridNetwork; checkMajor=true::Bool)\n\nUpdates the edges' attribute isChild1, according to the root placement. Also updates edges' attribute containRoot, for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if checkMajor=true.\n\nWarnings:\n\nAssumes that isChild1 is correct on hybrid edges\n\n(to avoid changing the identity of which nodes are hybrids and which are not).\n\nDoes not check for cycles (to maintain a network's DAG status)\n\nReturns the network. Throws a 'RootMismatch' Exception if the root was found to conflict with the direction of any hybrid edge.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.checkroot!","page":"Public","title":"PhyloNetworks.checkroot!","text":"checkroot!(net)\ncheckroot!(net::HybridNetwork, membership::Dict{Node, Int})\n\nSet the root of net to an appropriate node and update the edges containRoot field appropriately, using the membership output by treeedgecomponents. A node is appropriate to serve as root if it belongs in the root tree-edge component, that is, the root of the tree-edge component graph.\n\nIf the current root is appropriate, it is left as is. The direction of edges (via isChild1) is also left as is, assuming it was in synch with the existing root.\nOtherwise, the root is set to the first appropriate node in net.node, that is not a leaf. Then edges are directed away from this root.\n\nA RootMismatch error is thrown if net is not a valid semidirected phylogenetic network (i.e. it is not possible to root the network in a way compatible with the given hybrid edges).\n\nOutput: the membership ID of the root component. The full set of nodes in the root component can be obtained as shown below. Warning: only use the output component ID after calling the second version checkroot!(net, membership).\n\njulia> net = readTopology(\"(#H1:::0.1,#H2:::0.2,(((b)#H1)#H2,a));\");\n\njulia> membership = treeedgecomponents(net);\n\njulia> rootcompID = checkroot!(net, membership);\n\njulia> rootcomp = keys(filter(p -> p.second == rootcompID, membership));\n\njulia> sort([n.number for n in rootcomp]) # number of nodes in the root component\n3-element Vector{Int64}:\n -3\n -2\n  4\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.preorder!","page":"Public","title":"PhyloNetworks.preorder!","text":"preorder!(net::HybridNetwork)\n\nUpdates attribute net.nodes_changed in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges' direction needs to be correct before calling preorder!, using directEdges!\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.cladewiseorder!","page":"Public","title":"PhyloNetworks.cladewiseorder!","text":"cladewiseorder!(net::HybridNetwork)\n\nUpdates attribute net.cladewiseorder_nodeIndex. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges' direction needs to be correct before calling cladewiseorder!, using directEdges!\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.rootatnode!","page":"Public","title":"PhyloNetworks.rootatnode!","text":"rootatnode!(HybridNetwork, nodeNumber::Integer; index=false::Bool, verbose=true::Bool)\nrootatnode!(HybridNetwork, Node; verbose=true)\nrootatnode!(HybridNetwork, nodeName::AbstractString; verbose=true)\n\nRoot the network/tree object at the node with name 'nodeName' or number 'nodeNumber' (by default) or with index 'nodeNumber' if index=true. Attributes isChild1 and containRoot are updated along the way. Use plot(net, showNodeNumber=true, showEdgeLength=false) to visualize and identify a node of interest. (see package PhyloPlots)\n\nReturn the network.\n\nWarnings:\n\nIf the node is a leaf, the root will be placed along the edge adjacent to the leaf. This might add a new node.\nIf the desired root placement is incompatible with one or more hybrids, then\na RootMismatch error is thrown; use verbose=false to silence the root mismatch info printed before the error is thrown.\nthe input network will still have some attributes modified.\n\nSee also: rootonedge!.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.rootonedge!","page":"Public","title":"PhyloNetworks.rootonedge!","text":"rootonedge!(HybridNetwork, edgeNumber::Integer; index=false::Bool, verbose=true::Bool)\nrootonedge!(HybridNetwork, Edge; verbose=true::Bool)\n\nRoot the network/tree along an edge with number edgeNumber (by default) or with index edgeNumber if index=true. Attributes isChild1 and containRoot are updated along the way.\n\nThis adds a new node and a new edge to the network. Use plot(net, showEdgeNumber=true, showEdgeLength=false) to visualize and identify an edge of interest. (see package PhyloPlots)\n\nSee also: rootatnode!.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.hybridatnode!","page":"Public","title":"PhyloNetworks.hybridatnode!","text":"hybridatnode!(net::HybridNetwork, nodeNumber::Integer)\n\nChange the status of edges in network net, to move the hybrid node in a cycle to the node with number nodeNumber. This node must be in one (and only one) cycle, otherwise an error will be thrown.\n\nnet is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. Check and update the nodes' field inCycle.\n\nexample\n\nnet = readTopology(\"(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\");\nusing PhyloPlots\nplot(net, :R, showNodeNumber=true); # to locate nodes and their numbers. D of hybrid origin\nhybridatnode!(net, -4)\nplot(net, :R, showNodeNumber=true); # hybrid direction reversed: now 2B of hybrid origin\n\n\n\n\n\nhybridatnode!(net::HybridNetwork, hybrid::Node, newNode::Node)\n\nMove the reticulation from hybrid to newNode, which must in the same cycle. net is assumed to be of level 1, but no checks are made and fields are supposed up-to-date.\n\nCalled by hybridatnode!(net, node number), which is itself called by undirectedOtherNetworks.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.setLength!","page":"Public","title":"PhyloNetworks.setLength!","text":"setLength!(edge, newlength)`\n\nSet the length of edge, and set edge.y and edge.z accordingly. Warning: specific to SNaQ. Use setlengths! or setBranchLength! for more general tools.\n\nThe new length is censored to 10: if the new length is above 10, the edge's length will be set to 10. Lengths are interpreted in coalescent units, and 10 is close to infinity: near perfect gene tree concordance. 10 is used as an upper limit to coalescent units that can be reliably estimated.\nThe new length is allowed to be negative, but must be greater than -log(1.5), to ensure that the major quartet concordance factor (1 - 2/3 exp(-length)) is >= 0.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.setGamma!","page":"Public","title":"PhyloNetworks.setGamma!","text":"setGamma!(Edge, new γ)\nsetGamma!(Edge, new γ, change_other=true::Bool)\n\nSet inheritance probability γ for an edge, which must be a hybrid edge. The new γ needs to be in [0,1]. The γ of the \"partner\" hybrid edge is changed accordingly, to 1-γ. The field isMajor is also changed accordingly. If the new γ is approximately 0.5, Edge is set to the major parent, its partner is set to the minor parent.\n\nIf net is a HybridNetwork object, printEdges(net) will show the list of edges and their γ's. The γ of the third hybrid edge (say) can be changed to 0.2 with setGamma!(net.edge[3],0.2). This will automatically set γ of the partner hybrid edge to 0.8.\n\nThe last argument is true by default. If false: the partner edge is not updated. This is useful if the new γ is 0.5, and the partner's γ is already 0.5, in which case the isMajor attributes can remain unchanged.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.deleteleaf!","page":"Public","title":"PhyloNetworks.deleteleaf!","text":"deleteleaf!(HybridNetwork, leafName::AbstractString; ...)\ndeleteleaf!(HybridNetwork, Node; ...)\ndeleteleaf!(HybridNetwork, Integer; index=false, ...)\n\nDelete a node from the network, possibly from its name, number, or index in the network's array of nodes. The first two versions require that the node is a leaf. The third version does not require that the node is a leaf: If it has degree 3 or more, nothing happens. If it has degree 1 or 2, then it is deleted.\n\nkeyword arguments\n\nsimplify: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.\n\nunroot: if true, a root of degree 1 or 2 is deleted. If false, the root is deleted if it is of degree 1 (no root edge is left), but is kept if it is of degree 2. Deleting all leaves in an outgroup clade or grade will leave the ingroup rooted (that is, the new root will be of degree 2).\n\nnofuse: if true, keep nodes (and edges) provided that they have at least one descendant leaf, even if they are of degree 2. This will keep two-cycles (forcing simplify to false). Nodes without any descendant leaves are deleted. If nofuse is false, edges adjacent to degree-2 nodes are fused.\n\nmultgammas: if true, the fused edge has γ equal to the product of the hybrid edges that have been fused together, which may result in tree edges with γ<1, or with reticulations in which the two parent γ don't add up to 1.\n\nkeeporiginalroot: if true, keep the root even if it is of degree one.\n\nWarning: does not update attributes related to level-1 networks, such as inCycle, partition, gammaz, etc. Does not require branch lengths, and designed to work on networks of all levels.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.deleteHybridThreshold!","page":"Public","title":"PhyloNetworks.deleteHybridThreshold!","text":"deleteHybridThreshold!(net::HybridNetwork, threshold::Float64,\n                       nofuse=false, unroot=false, multgammas=false,\n                       keeporiginalroot=false)\n\nDeletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.\n\nif threshold<0.5: delete minor hybrid edges with γ < threshold (or with a missing γ, for any threshold > -1.0)\nif threshold=0.5: delete all minor hybrid edges (i.e normally with γ < 0.5, if γ non-missing)\nnofuse: if true, do not fuse edges and keep original nodes.\nunroot: if false, the root will not be deleted if it becomes of degree 2.\nmultgammas: if true, the modified edges have γ values equal to the proportion of genes that the extracted subnetwork represents. For an edge e in the modified network, the inheritance γ for e is the product of γs of all edges in the original network that have been merged into e.\n\n-keeporiginalroot: if true, the root will be retained even if of degree 1.\n\nWarnings:\n\nby default, nofuse is false, partner hybrid edges are fused with their child edge and have their γ changed to 1.0. If nofuse is true: the γ's of partner hybrid edges are unchanged.\nassumes correct isMajor fields, and correct isChild1 fields to update containRoot.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.rotate!","page":"Public","title":"PhyloNetworks.rotate!","text":"rotate!(net::HybridNetwork, nodeNumber::Integer; orderedEdgeNum::Array{Int,1})\n\nRotates the order of the node's children edges. Useful for plotting, to remove crossing edges. If node is a tree node with no polytomy, the 2 children edges are switched and the optional argument orderedEdgeNum is ignored.\n\nUse plot(net, showNodeNumber=true, showEdgeNumber=false) to map node and edge numbers on the network, as shown in the examples below. (see package PhyloPlots)\n\nWarning: assumes that edges are correctly directed (isChild1 updated). This is done by plot(net). Otherwise run directEdges!(net).\n\nExample\n\njulia> net = readTopology(\"(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\");\njulia> using PhyloPlots\njulia> plot(net, showNodeNumber=true)\njulia> rotate!(net, -4)\njulia> plot(net)\njulia> net=readTopology(\"(4,((1,(2)#H7:::0.864):2.069,(6,5):3.423):0.265,(3,#H7:::0.136):10.0);\");\njulia> plot(net, showNodeNumber=true, showEdgeNumber=true)\njulia> rotate!(net, -1, orderedEdgeNum=[1,12,9])\njulia> plot(net, showNodeNumber=true, showEdgeNumber=true)\njulia> rotate!(net, -3)\njulia> plot(net)\n\nNote that LinearAlgebra also exports a function named rotate! in Julia v1.5. If both packages need to be used in Julia v1.5 or higher, usage of rotate! needs to be qualified, such as with PhyloNetworks.rotate!.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.getindex-Tuple{TraitSimulation, Symbol}","page":"Public","title":"Base.getindex","text":"getindex(obj, d)\n\nGetting submatrices of an object of type TraitSimulation.\n\nArguments\n\nobj::TraitSimulation: the matrix from which to extract.\nd::Symbol: a symbol precising which sub-matrix to extract. Can be:\n:Tips columns and/or rows corresponding to the tips\n:InternalNodes columns and/or rows corresponding to the internal nodes\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.getNodeAges","page":"Public","title":"PhyloNetworks.getNodeAges","text":"getNodeAges(net)\n\nvector of node ages in pre-order, as in nodes_changed, which is assumed to have been calculated before.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.pairwiseTaxonDistanceMatrix","page":"Public","title":"PhyloNetworks.pairwiseTaxonDistanceMatrix","text":"pairwiseTaxonDistanceMatrix(net; keepInternal=false,\n                            checkPreorder=true, nodeAges=[])\npairwiseTaxonDistanceMatrix!(M, net, nodeAges)\n\nReturn the matrix M of pairwise distances between nodes in the network:\n\nbetween all nodes (internal and leaves) if keepInternal=true, in which case the nodes are listed in M in the order in which they appear in net.nodes_changed\nbetween taxa only otherwise, in which case the nodes are listed in M in the order in which they appear in tipLabels(net) (i.e. same order as in net.leaf)\n\nThe second form modifies M in place, assuming all nodes.\n\nThe distance between the root and a given hybrid node (to take an example) is the weighted average of path lengths from the root to that node, where each path is weighted by the product of γs of all edges on that path. This distance measures the average genetic distance across the genome, if branch lengths are in substitutions/site.\n\noptional arguments:\n\ncheckPreorder: if true, net.nodes_changed is updated to get a topological ordering of nodes.\nnodeAges: if not provided, i.e. empty vector, the network is not modified.   If provided and non-empty, nodeAges should list node ages in the pre-order in which nodes are listed in nodes_changed (including leaves), and edge lengths in net are modified accordingly.\n\nProviding node ages hence makes the network time consistent: such that all paths from the root to a given hybrid node have the same length. If node ages are not provided, the network need not be time consistent.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.biconnectedComponents","page":"Public","title":"PhyloNetworks.biconnectedComponents","text":"biconnectedComponents(network, ignoreTrivial=false)\n\nCalculate biconnected components (aka \"blobs\") using Tarjan's algorithm: the output is an array of arrays of edges. These blobs are returned in post-order, but within a blob, edges are not necessarily sorted in topological order. If ignoreTrivial is true, trivial components (of a single edge) are not returned. The network is assumed to be connected.\n\nWarnings: for nodes, fields k, inCycle, and prev are modified during the algorithm. They are used to store the node's \"index\" (time of visitation), \"lowpoint\", and the node's \"parent\", as defined by the order in which nodes are visited.\n\nReferences:\n\np. 153 of Tarjan (1972). Depth first search and linear graph algorithms, SIAM Journal on Computing, 1(2):146-160\non geeksforgeeks, there is an error (as of 2018-01-30): elif v != parent[u] and low[u] > disc[v]: (python version) should be replaced by elif v != parent[u] and disc[u] > disc[v]:\nnice explanation at this url\n\n\n\n\n\nbiconnectedComponents(node, index, S, blobs, ignoreTrivial)\n\nHelper recursive function starting at a node (not a network). index is an array containing a single integer, thus mutable: order in which nodes are visited.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.blobDecomposition","page":"Public","title":"PhyloNetworks.blobDecomposition","text":"blobDecomposition!(network)\nblobDecomposition(network)\n\nFind blobs using biconnectedComponents; find their roots using blobInfo; create a forest in the form of a disconnected network (for efficiency), by deconnecting the root of each non-trivial blob from its parent. The root of each blob corresponds to a new leaf (in another tree of the forest): the number of the blob's root is given to the newly created leaf.\n\nThe first (bang) version modifies the network and returns the array of blob roots. The second version copies the network then returns a tuple: the forest and the blob roots.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.treeedgecomponents","page":"Public","title":"PhyloNetworks.treeedgecomponents","text":"treeedgecomponents(net::HybridNetwork)\n\nReturn the tree-edge components of the semidirected network as a membership dictionary Node => Int. Nodes with the same membership integer value are in the same tree-edge component. The tree-edge components of a network are the connected components of the network when all hybrid edges are removed.\n\nA RootMismatch error is thrown if there exists a cycle in any of the tree-edge components, or if a tree-edge component has more than one \"entry\" hybrid node.\n\nWarnings:\n\nsince Nodes are mutable, the network should not be modified until usage of the output membership dictionary is over.\nthe component IDs are not predicable, but will be consecutive integers from 1 to the number of components.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getlabels","page":"Public","title":"PhyloNetworks.getlabels","text":"getlabels(model)\n\nState labels of a substitution model.\n\n\n\n\n\nfor a given NucleicAcidSubstitutionModel, labels are symbols from BioSymbols. For now, only ACGTs are allowed. (When fitting data, any ambiguity code in the data would be treated as missing value).\n\nexamples\n\njulia> getlabels(JC69([0.03], false))\n4-element Vector{BioSymbols.DNA}:\n DNA_A\n DNA_C\n DNA_G\n DNA_T\n\njulia> getlabels(HKY85([.5], repeat([0.25], 4)))\n4-element Vector{BioSymbols.DNA}:\n DNA_A\n DNA_C\n DNA_G\n DNA_T\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.nparams","page":"Public","title":"PhyloNetworks.nparams","text":"nparams(model)\n\nNumber of parameters for a given trait evolution model (length of field model.rate).\n\n\n\n\n\nfor JC69 model: 0 if relative, 1 if absolute\n\n\n\n\n\nfor HKY85 model: 1 if relative, 2 if absolute\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.mapindividuals","page":"Public","title":"PhyloNetworks.mapindividuals","text":"mapindividuals(net::HybridNetwork, mappingFile::String)\n\nReturn a network expanded from net, where species listed in the mapping file are replaced by individuals mapped to that species. If a species has only 1 individual, the name of the leaf for that species is replaced by the name of its one individual representative. If a species has 2 or more individuals, the leaf for that species is expanded into a \"star\" (polytomy if 3 or more individuals) with a tip for each individual. If a species is in the network but not listed in the mapping file, the tip for that species is left as is. Species listed in the mapping file but not present in the network are ignored.\n\nThe mapping file should be readable by CSV.File and contain two columns: one for the species names and one for the individual (or allele) names. fixit: make this function more flexible by accepting column names\n\nOutput: individual-level network and vector of species constraint(s).\n\nexamples\n\njulia> species_net = readTopology(\"(((S8,S9),((((S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\");\n\njulia> filename = joinpath(dirname(Base.find_package(\"PhyloNetworks\")), \"..\", \"examples\", \"mappingIndividuals.csv\");\n\njulia> filename |> read |> String |> print # to see what the mapping file contains\nspecies,individual\nS1,S1A\nS1,S1B\nS1,S1C\n\njulia> individual_net, species_constraints = mapindividuals(species_net, filename);\n\njulia> writeTopology(individual_net, internallabel=true)\n\"(((S8,S9),(((((S1A,S1B,S1C)S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\"\n\njulia> species_constraints\n1-element Vector{PhyloNetworks.TopologyConstraint}:\n Species constraint, on tips: S1A, S1B, S1C\n stem edge number 4\n crown node number 3\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.nni!","page":"Public","title":"PhyloNetworks.nni!","text":"nni!(net::HybridNetwork, e::Edge, nohybridladder::Bool=true, no3cycle::Bool=true,\n     constraints=TopologyConstraint[]::Vector{TopologyConstraint})\n\nAttempt to perform a nearest neighbor interchange (NNI) around edge e, randomly chosen among all possible NNIs (e.g 3, sometimes more depending on e) satisfying the constraints, and such that the new network is a DAG. The number of possible NNI moves around an edge depends on whether the edge's parent/child nodes are tree or hybrid nodes. This is calculated by nnimax.\n\nThe option no3cycle forbids moves that would create a 3-cycle in the network. When no3cycle = false, 2-cycle and 3-cycles may be generated.\n\nNote that the defaults values are for positional (not keyword) arguments, so two or more arguments can be used, but in a specific order: nni!(net, e) or nni!(net, e, nohybridladder), nni!(net, e, nohybridladder, no3cycle), nni!(net, e, nohybridladder, no3cycle, contraints).\n\nAssumptions:\n\nThe starting network does not have 3-cycles, if no3cycle=true. No check for the presence of 2- and 3-cycles in the input network.\nThe edges' field isChild1 is correct in the input network. (This field will be correct in the output network.)\n\nOutput: information indicating how to undo the move or nothing if all NNIs failed.\n\nexamples\n\njulia> str_network = \"(((S8,S9),(((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\";\n\njulia> net = readTopology(str_network);\n\njulia> using Random; Random.seed!(321);\n\njulia> undoinfo = nni!(net, net.edge[3], true, true); # true's to avoid hybrid ladders and 3-cycles\n\njulia> writeTopology(net)\n\"(((S8,(((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2),S9),(#H2,S10));\"\n\njulia> nni!(undoinfo...);\n\njulia> writeTopology(net) == str_network # net back to original topology: the NNI was \"undone\"\ntrue\n\n\n\n\n\nnni!(net::HybridNetwork, uv::Edge, nummove::UInt8,\n     nohybridladder::Bool, no3cycle::Bool)\n\nModify net with a nearest neighbor interchange (NNI) around edge uv. Return the information necessary to undo the NNI, or nothing if the move was not successful (such as if the resulting graph was not acyclic (not a DAG) or if the focus edge is adjacent to a polytomy). If the move fails, the network is not modified. nummove specifies which of the available NNIs is performed.\n\nrooted-NNI options according to Gambette et al. (2017), fig. 8:\n\nBB: 2 moves, both to BB, if directed edges. 8 moves if undirected.\nRR: 2 moves, both to RR.\nBR: 3 moves, 1 RB & 2 BRs, if directed. 6 moves if e is undirected.\nRB: 4 moves, all 4 BRs.\n\nThe extra options are due to assuming a semi-directed network, whereas Gambette et al (2017) describe options for rooted networks. On a semi-directed network, there might be a choice of how to direct the edges that may contain the root, e.g. choice of e=uv versus vu, and choice of labelling adjacent nodes as α/β (BB), or as α/γ (BR).\n\nnohybridladder = true prevents moves that would create a hybrid ladder in the network, that is, 2 consecutive hybrid nodes (one parent of the other). no3cycle = true prevents NNI moves that would make a 3-cycle, and assumes that the input network does not have any 2- or 3-cycles. If no3cycle is false, 3-cycles can be generated, but NNIs generating 2-cycles are prevented.\n\nThe edge field isChild1 is assumed to be correct according to the net.root.\n\n\n\n\n\nnni!(αu, u, uv::Edge, v, vδ)\nnni!(αu,u,uv,v,vδ, flip::Bool, inner::Bool, indices)\n\nTransform a network locally around the focus edge uv with the following NNI, that detaches u-β and grafts it onto vδ:\n\nα - u -- v ------ δ\n    |    |\n    β    γ\n\nα ------ v -- u - δ\n         |    |\n         γ    β\n\nflip boolean indicates if the uv edge was flipped inner boolean indicates if edges αu and uv both point toward node u, i.e. α->u<-v<-δ. If this is true, we flip the hybrid status of αu and vδ.\n\nindices give indices for nodes and edges uinαu, αuinu, vδinv, and vinvδ. These are interpreted as:\n\nu_in_αu: the index for u in the edge αu\nαu_in_u: the index for αu in node u\nvδ_in_v: the index for vδ in node v\nv_in_vδ: the index for v in edge vδ\n\nWarnings:\n\nNo check of assumed adjacencies\nNot implemented for cases that are not necessary thanks to symmetry, such as cases covered by nni!(vδ, v, uv, u, αu) or nni!(βu, u, v, vγ). More specifically, these cases are not implemented (and not checked):\nu not hybrid & v hybrid\nu hybrid, v not hybrid, α -> u <- v -> δ\nBecause of this, nni(αu,u,uv,v,vδ, ...) should not be used directly; use instead nni!(net, uv, move_number).\nnni!(undoinfo...) restores the topology, but edges below hybrid nodes will have length 0.0 even if they didn't before.\n\nNode numbers and edge numbers are not modified. Edge uv keeps its direction unchanged unless the directions were α -> u -> v -> δ or α <- u <- v <- δ, in which case the direction of uv is flipped.\n\nThe second version's input has the same signature as the output, but will undo the NNI more easily. This means that if output = nni!(input), then nni!(output...) is valid and undoes the first operation.\n\nRight now, branch lengths are not modified except when below a hybrid node. Future versions might implement options to modify branch lengths.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#data-and-topology-read/write","page":"Public","title":"data and topology read/write","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"readfastatodna\nreadTopology\nreadTopologyLevel1\nreadInputTrees\nreadMultiTopology\nreadNexusTrees\nreadSnaqNetwork\nreadTrees2CF\ncountquartetsintrees\nreadTableCF\nreadTableCF!\nwriteTableCF\nreadBootstrapTrees\nwriteSubTree!\nwriteTopology\nwriteMultiTopology\nhybridlambdaformat\nmapAllelesCFtable","category":"page"},{"location":"lib/public/#PhyloNetworks.readfastatodna","page":"Public","title":"PhyloNetworks.readfastatodna","text":"readfastatodna(filename::String, countPatterns=false::Bool)\n\nRead a fasta file to a dataframe containing a column for each site. If countPatterns is true, calculate weights and remove identical site patterns to reduce matrix dimension.\n\nReturn a tuple containing:\n\ndata frame of BioSequence DNA sequences, with taxon names in column 1 followed by a column for each site pattern, in columns 2-npatterns;\narray of weights, one weight for each of the site columns. The length of the weight vector is equal to npatterns.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readTopology","page":"Public","title":"PhyloNetworks.readTopology","text":"readTopology(file name)\nreadTopology(parenthetical description)\n\nRead tree or network topology from parenthetical format (extended Newick). If the root node has a single child: ignore (i.e. delete from the topology) the root node and its child edge.\n\nInput: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description.\n\nA root edge, not enclosed within a pair a parentheses, is ignored. If the root node has a single edge, this one edge is removed.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readTopologyLevel1","page":"Public","title":"PhyloNetworks.readTopologyLevel1","text":"readTopologyLevel1(filename)\nreadTopologyLevel1(parenthetical format)\n\nsame as readTopology, reads a tree or network from parenthetical format, but this function enforces the necessary conditions for any starting topology in SNaQ: non-intersecting cycles, no polytomies, unrooted. It sets any missing branch length to 1.0.\n\nIf the network has a bad diamond II (in which edge lengths are γ's are not identifiable) and if the edge below this diamond has a length t different from 0, then this length is set back to 0 and the major parent hybrid edge is lengthened by t.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readInputTrees","page":"Public","title":"PhyloNetworks.readInputTrees","text":"readInputTrees(file)\n\nRead a text file with a list of trees/networks in parenthetical format (one tree per line) and transform them like readTopologyLevel1 does: to be unrooted, with resolved polytomies, missing branch lengths set to 1.0, etc. See readMultiTopology to read multiple trees or networks with no modification.\n\nOutput: array of HybridNetwork objects.\n\nEach line starting with \"(\" will be considered as describing one topology. The file can have extra lines that are ignored.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readMultiTopology","page":"Public","title":"PhyloNetworks.readMultiTopology","text":"readMultiTopology(file)\n\nRead a text file with a list of networks in parenthetical format (one per line). Each network is read with readTopology. Return an array of HybridNetwork object.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readNexusTrees","page":"Public","title":"PhyloNetworks.readNexusTrees","text":"readNexusTrees(filename::AbstractString, treereader=readTopology::Function [, args...])\n\nRead trees in nexus-formatted file and return a vector of HybridNetworks. For the nexus format, see Maddison, Swofford & Maddison (1997) https://doi.org/10.1093/sysbio/46.4.590. The optional arguments are passed onto the individual tree reader.\n\nWarnings:\n\n\"translate\" tables are not supported yet\nonly the first tree block is read\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readSnaqNetwork","page":"Public","title":"PhyloNetworks.readSnaqNetwork","text":"readSnaqNetwork(output file)\n\nRead the estimated network from a .out file generated by snaq!. The network score is read also, and stored in the network's field .loglik.\n\nWarning: despite the name \"loglik\", this score is only proportional to the network's pseudo-deviance: the lower, the better. Do NOT use this score to calculate an AIC or BIC (etc.) value.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readTrees2CF","page":"Public","title":"PhyloNetworks.readTrees2CF","text":"readTrees2CF(treefile)\nreadTrees2CF(vector of trees)\n\nRead trees in parenthetical format from a file, or take a vector of trees already read, and calculate the proportion of these trees having a given quartet (concordance factor: CF), for all quartets or for a sample of quartets. Optional arguments include:\n\nquartetfile: name of text file with list of 4-taxon subsets to be analyzed. If none is specified, the function will list all possible 4-taxon subsets.\nwhichQ=\"rand\": to choose a random sample of 4-taxon subsets\nnumQ: size of random sample (ignored if whichQ is not set to \"rand\")\nwriteTab=false: does not write the observedCF to a table (default true)\nCFfile: name of file to save the observedCF (default tableCF.txt)\nwriteQ=true: save intermediate files with the list of all 4-taxon subsets and chosen random sample (default false).\nwriteSummary: write descriptive stats of input data (default: true)\nnexus: if true, it assumes the gene trees are written in nexus file (default: false)\n\nSee also: countquartetsintrees, which uses a much faster algorithm; readTableCF to read a table of quartet CFs directly.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.countquartetsintrees","page":"Public","title":"PhyloNetworks.countquartetsintrees","text":"countquartetsintrees(trees [, taxonmap=Dict{String,String}]; which=:all, weight_byallele=true)\n\nCalculate the quartet concordance factors (CF) observed in the trees vector. If present, taxonmap should map each allele name to it's species name. To save to a file, first convert to a data frame using writeTableCF. When which=:all, quartet CFs are calculated for all 4-taxon sets. (Other options are not implemented yet.)\n\nThe algorithm runs in O(mn⁴) where m is the number of trees and n is the number of tips in the trees.\n\nCFs are calculated at the species level only, that is, considering 4-taxon sets made of 4 distinct species, even if the gene trees may have multiple alleles from the same species. For 4 distinct species a,b,c,d, all alleles from each species (a etc.) will be considered to calculate the quartet CF.\n\nBy default, each gene has a weight of 1. So if there are n_a alleles from a, n_b alleles from b etc. in a given gene, then each set of 4 alleles has a weight of 1/(n_a n_b b_c n_c) in the calculation of the CF for a,b,c,d. With option weight_byallele=true, then each set of 4 alleles is given a weight of 1 instead. This inflates the total number of sets used to calculate the quartet CFs (to something larger than the number of genes). This may also affect the CF values if the number of alleles varies across genes: genes with more alleles will be given more weight.\n\nexamples\n\njulia> tree1 = readTopology(\"(E,(A,B),(C,D),O);\"); tree2 = readTopology(\"(((A,B),(C,D)),E);\");\n\njulia> q,t = countquartetsintrees([tree1, tree2]);\nReading in trees, looking at 15 quartets in each...\n0+--+100%\n  **\n\njulia> t # taxon order: t[i] = name of taxon number i\n6-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n \"D\"\n \"E\"\n \"O\"\n\njulia> length(q) # 15 four-taxon sets on 6 taxa\n15\n\njulia> q[1] # both trees agree on AB|CD: resolution 1\n4-taxon set number 1; taxon numbers: 1,2,3,4\ndata: [1.0, 0.0, 0.0, 2.0]\n\njulia> q[8] # tree 2 is missing O (taxon 6), tree 1 wants resolution 3: AO|CD\n4-taxon set number 8; taxon numbers: 1,3,4,6\ndata: [0.0, 0.0, 1.0, 1.0]\n\njulia> q[11] # tree 1 has ACEO unresolved, and tree 2 is missing O: no data for this quartet\n4-taxon set number 11; taxon numbers: 1,3,5,6\ndata: [0.0, 0.0, 0.0, 0.0]\n\njulia> tree1 = readTopology(\"(E,(a1,B),(a2,D),O);\"); tree2 = readTopology(\"(((a1,a2),(B,D)),E);\");\n\njulia> q,t = countquartetsintrees([tree1, tree2], Dict(\"a1\"=>\"A\", \"a2\"=>\"A\"); showprogressbar=false);\n\njulia> t\n5-element Vector{String}:\n \"A\"\n \"B\"\n \"D\"\n \"E\"\n \"O\"\n\njulia> q[1] # tree 1 has discordance: a1B|DE and a2D|BE. tree 2 has AE|BD for both alleles of A\n4-taxon set number 1; taxon numbers: 1,2,3,4\ndata: [0.25, 0.25, 0.5, 2.0]\n\njulia> q[3] # tree 2 is missing O (taxon 5), and a2 is unresolved in tree 1. There's only a1B|EO\n4-taxon set number 3; taxon numbers: 1,2,4,5\ndata: [1.0, 0.0, 0.0, 0.5]\n\njulia> df = writeTableCF(q,t); # to get a DataFrame that can be saved to a file later\n\njulia> show(df, allcols=true)\n5×8 DataFrame\n Row │ t1      t2      t3      t4      CF12_34  CF13_24  CF14_23  ngenes  \n     │ String  String  String  String  Float64  Float64  Float64  Float64 \n─────┼────────────────────────────────────────────────────────────────────\n   1 │ A       B       D       E          0.25     0.25      0.5      2.0\n   2 │ A       B       D       O          0.5      0.5       0.0      1.0\n   3 │ A       B       E       O          1.0      0.0       0.0      0.5\n   4 │ A       D       E       O          1.0      0.0       0.0      0.5\n   5 │ B       D       E       O          0.0      0.0       0.0      0.0\njulia> # using CSV; CSV.write(df, \"filename.csv\");\n\njulia> tree2 = readTopology(\"((A,(B,D)),E);\");\n\njulia> q,t = countquartetsintrees([tree1, tree2], Dict(\"a1\"=>\"A\", \"a2\"=>\"A\"); weight_byallele=true);\nReading in trees, looking at 5 quartets in each...\n0+--+100%\n  **\n\njulia> show(writeTableCF(q,t), allcols=true)\n5×8 DataFrame\n Row │ t1      t2      t3      t4      CF12_34   CF13_24   CF14_23   ngenes  \n     │ String  String  String  String  Float64   Float64   Float64   Float64 \n─────┼───────────────────────────────────────────────────────────────────────\n   1 │ A       B       D       E       0.333333  0.333333  0.333333      3.0\n   2 │ A       B       D       O       0.5       0.5       0.0           2.0\n   3 │ A       B       E       O       1.0       0.0       0.0           1.0\n   4 │ A       D       E       O       1.0       0.0       0.0           1.0\n   5 │ B       D       E       O       0.0       0.0       0.0           0.0\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readTableCF","page":"Public","title":"PhyloNetworks.readTableCF","text":"readTableCF(file)\nreadTableCF(data frame)\nreadTableCF!(data frame)\n\nRead a file or DataFrame object containing a table of concordance factors (CF), with one row per 4-taxon set. The first 4 columns are assumed to give the labels of the 4 taxa in each set (tx1, tx2, tx3, tx4). Columns containing the CFs are assumed to be named CF12_34, CF13_24 and CF14_23; or CF12.34, CF13.24 and CF14.23; or else are assumed to be columns 5,6,7. If present, a column named 'ngenes' will be used to get the number of loci used to estimate the CFs for each 4-taxon set.\n\nOutput: DataCF object\n\nOptional arguments:\n\nsummaryfile: if specified, a summary file will be created with that name.\ndelim (for the first form only): to specify how columns are delimited, with single quotes: delim=';'. Default is a csv file, i.e. delim=','.\n\nThe last version modifies the input data frame, if species are represented by multiple alleles for instance (see readTableCF!(data frame, columns)).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readTableCF!","page":"Public","title":"PhyloNetworks.readTableCF!","text":"readTableCF!(data frame, columns)\n\nRead in quartet CFs from data frame, assuming information is in columns numbered columns, of length 7 or 8: 4 taxon labels then 3 CFs then ngenes possibly.\n\nIf some species appears more than once in the same 4-taxon set (e.g. t1,t1,t2,t3), then the data frame is modified to remove rows (4-taxon sets) that are uninformative about between-species relationships. This situation may occur if multiple individuals are sampled from the same species. A 4-taxon set is uninformative (and its row is removed) if one taxon is repeated 3 or 4 times (like t1,t1,t1,t1 or t1,t2,t2,t2). The list of species appearing twice in some 4-taxon sets is stored in the output DataCF object. For these species, the length of their external edge is identifiable (in coalescent units). If multiple rows correspond to the same 4-taxon set, these rows are merged and their CF values (and number of genes) are averaged.\n\nreadTableCF!(DataCF, data frame, columns)\n\nModify the .quartet.obsCF values in the DataCF object with those read from the data frame in columns numbered columns. columns should have 3 columns numbers for the 3 CFs in this order: 12_34, 13_24 and 14_23.\n\nAssumptions:\n\nsame 4-taxon sets in DataCF and in the data frame, and in the same order, but this assumption is not checked (for speed, e.g. during bootstrapping).\none single row per 4-taxon set (multiple individuals representatives of the same 4-taxon set should have been already merged); basically: the DataCF should have been created from the data frame by readTableCF!(df, colums)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.writeTableCF","page":"Public","title":"PhyloNetworks.writeTableCF","text":"writeTableCF(vector of Quartet objects)\nwriteTableCF(DataCF)\nwriteTableCF(vector of QuartetT objects [, taxonames])\n\nBuild a DataFrame containing observed quartet concordance factors, with columns named:\n\n:tx1, :tx2, :tx3, :tx4 for the four taxon names in each quartet\n:CF12_34, :CF13_24, :CF14_23 for the 3 quartets of a given four-taxon set\n:ngenes if this information is available for some quartets\n\nIf the input are QuartetT objects, their data field needs to contain vectors of 4 values.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readBootstrapTrees","page":"Public","title":"PhyloNetworks.readBootstrapTrees","text":"readBootstrapTrees(listfile; relative2listfile=true)\n\nRead the list of file names in listfile, then read all the trees in each of these files. Output: vector of vectors of trees (networks with h>0 allowed).\n\nlistfile should be the name of a file containing the path/name to multiple bootstrap files, one on each line (no header). Each named bootstrap file should contain multiple trees, one per line (such as bootstrap trees from a single gene).\n\nThe path/name to each bootstrap file should be relative to listfile. Otherwise, use option relative2listfile=false, in which case the file names are interpreted as usual: relative to the user's current directory if not given as absolute paths.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.writeSubTree!","page":"Public","title":"PhyloNetworks.writeSubTree!","text":"writeSubTree!(IO, network, dendroscope::Bool, namelabel::Bool,\n              round_branch_lengths::Bool, digits::Integer,\n              internallabel::Bool)\n\nWrite to IO the extended newick format (parenthetical description) of a network. If written for dendroscope, inheritance γ's are not written. If namelabel is true, taxa are labelled by their names; otherwise taxa are labelled by their number IDs. If unspecified, branch lengths and γ's are rounded to 3 digits. Use internallabel=false to suppress the labels of internal nodes.\n\n\n\n\n\nwriteSubTree!(IO, node, edge, dendroscope::Bool, namelabel::Bool,\n              round_branch_lengths::Bool, digits::Integer, internallabel::Bool)\n\nWrite the extended newick format of the sub-network rooted at node and assuming that edge is a parent of node.\n\nIf the parent edge is nothing, the edge attribute isChild1 is used and assumed to be correct to write the subtree rooted at node. This is useful to write a subtree starting at a non-root node. Example:\n\nnet = readTopology(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\")\ndirectEdges!(net)\ns = IOBuffer()\nwriteSubTree!(s, net.node[7], nothing, false, true)\nString(take!(s))\n\nUsed by writeTopology.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.writeTopology","page":"Public","title":"PhyloNetworks.writeTopology","text":"writeTopology(net)\nwriteTopology(net, filename)\nwriteTopology(net, IO)\n\nWrite the parenthetical extended Newick format of a network, as a string, to a file or to an IO buffer / stream. Optional arguments (default values):\n\ndi (false): write in format for Dendroscope\nround (false): rounds branch lengths and heritabilities γ\ndigits (3): digits after the decimal place for rounding\nappend (false): if true, appends to the file\ninternallabel (true): if true, writes internal node labels\n\nIf the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.\n\nUses lower-level function writeSubTree!.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.writeMultiTopology","page":"Public","title":"PhyloNetworks.writeMultiTopology","text":"writeMultiTopology(nets, file_name; append=false)\nwriteMultiTopology(nets, IO)\n\nWrite an array of networks in parenthetical extended Newick format, one network per line. Use the option append=true to append to the file. Otherwise, the default is to create a new file or overwrite it, if it already existed. Each network is written with writeTopology.\n\nExamples\n\njulia> net = [readTopology(\"(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10);\"),\n              readTopology(\"(A,(B,C));\"),readTopology(\"(E,F);\"),readTopology(\"(G,H,F);\")];\n\njulia> writeMultiTopology(net, \"fournets.net\") # to (over)write to file \"fournets.net\"\njulia> writeMultiTopology(net, \"fournets.net\", append=true) # to append to this file\njulia> writeMultiTopology(net, stdout)         # to write to the screen (standard out)\n(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10.0);\n(A,(B,C));\n(E,F);\n(G,H,F);\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.hybridlambdaformat","page":"Public","title":"PhyloNetworks.hybridlambdaformat","text":"hybridlambdaformat(net::HybridNetwork; prefix=\"I\")\n\nOutput net as a string in the format that the Hybrid-Lambda simulator expects, namely:\n\nall internal nodes are named, including the root\nhybrid nodes are written as H6#γ1:length1 and H6#γ1:length2 instead of #H6:length1::γ1 and #H6:length2::γ2 (note the samme γ value expected by Hybrid-Lambda)\n\nThis is a modified version of the extended Newick format.\n\nOptional keyword argument: prefix, \"I\" by default. Internal nodes without a name will be given names like \"I1\", \"I2\", etc. See nameinternalnodes! to add node names (modifies the input network).\n\nexamples\n\njulia> net = readTopology(\"((a:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);\");\n\njulia> hybridlambdaformat(net) # net is unchanged here\n\"((a:1.0,(b:1.0)H1#0.8:1.0)I1:5.0,(H1#0.8:0.0,c:1.0)I2:1.0)I3;\"\n\njulia> # using PhyloPlots; plot(net, :R, showNodeNumber=true) # shows that node -2 is the root\n\njulia> rotate!(net, -2)\n\njulia> writeTopology(net) # now the minor edge with γ=0.2 appears first\n\"((#H1:0.0::0.2,c:1.0):1.0,(a:1.0,(b:1.0)#H1:1.0::0.8):5.0);\"\n\njulia> hybridlambdaformat(net)\n\"((H1#0.2:0.0,c:1.0)I2:1.0,(a:1.0,(b:1.0)H1#0.2:1.0)I1:5.0)I3;\"\n\njulia> net = readTopology(\"((((B)#H1:::.6)#H2,((D,C,#H2:::0.8),(#H1,A))));\"); # 2 reticulations, no branch lengths\n\njulia> writeTopology(net, round=true)\n\"(#H2:::0.2,((D,C,((B)#H1:::0.6)#H2:::0.8),(#H1:::0.4,A)));\"\n\njulia> hybridlambdaformat(net; prefix=\"int\")\n\"(H2#0.2,((D,C,((B)H1#0.6)H2#0.2)int1,(H1#0.6,A)int2)int3)int4;\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.mapAllelesCFtable","page":"Public","title":"PhyloNetworks.mapAllelesCFtable","text":"mapAllelesCFtable(mapping file, CF file; filename, columns, delim)\n\nCreate a new DataFrame containing the same concordance factors as in the input CF file, but with modified taxon names. Each allele name in the input CF table is replaced by the species name that the allele maps onto, based on the mapping file. The mapping file should have column names: allele and species.\n\nOptional arguments:\n\nfile name to write/save resulting CF table. If not specified, then the output data frame is not saved to a file.\ncolumn numbers for the taxon names. 1-4 by default.\nany keyword arguments that CSV.File would accept. For example, delim=',' by default: columns are delimited by commas. Unless specified otherwise by the user, pool=false (to read taxon names as Strings, not levels of a categorical factor, for combining the 4 columns with taxon names more easily). The same CSV arguments are used to read both input file (mapping file and quartet file)\n\nSee also mapAllelesCFtable! to input DataFrames instead of file names.\n\nIf a filename is specified, such as \"quartetCF_speciesNames.csv\" in the example below, this file is best read later with the option pool=false. example:\n\nmapAllelesCFtable(\"allele-species-map.csv\", \"allele-quartet-CF.csv\";\n                  filename = \"quartetCF_speciesNames.csv\")\ndf_sp = DataFrame(CSV.File(\"quartetCF_speciesNames.csv\"); copycols=false); # DataFrame object\ndataCF_specieslevel = readTableCF!(df_sp); # DataCF object\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#network-inference","page":"Public","title":"network inference","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"snaq!\ntopologyMaxQPseudolik!\ntopologyQPseudolik!\nfittedQuartetCF\nbootsnaq\ncalibrateFromPairwiseDistances!\nundirectedOtherNetworks\nnj","category":"page"},{"location":"lib/public/#PhyloNetworks.snaq!","page":"Public","title":"PhyloNetworks.snaq!","text":"snaq!(T::HybridNetwork, d::DataCF)\n\nEstimate the network (or tree) to fit observed quartet concordance factors (CFs) stored in a DataCF object, using maximum pseudo-likelihood. A level-1 network is assumed. The search starts from topology T, which can be a tree or a network with no more than hmax hybrid nodes. The function name ends with ! because it modifies the CF data d by updating its attributes expCF: CFs expected under the network model. It does not modify T. The quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.\n\nOutput:\n\nestimated network in file .out (also in .log): best network overall and list of networks from each individual run.\nthe best network and modifications of it, in file .networks. All networks in this file have the same undirected topology as the best network, but have different hybrid/gene flow directions. These other networks are reported with their pseudo-likelihood scores, because  non-identifiability issues can cause them to have very similar scores, and because  SNaQ was shown to estimate the undirected topology accurately but not the direction of  hybridization in cases of near non-identifiability.\nif any error occurred, file .err provides information (seed) to reproduce the error.\n\nThere are many optional arguments, including\n\nhmax (default 1): maximum number of hybridizations allowed\nverbose (default false): if true, print information about the numerical optimization\nruns (default 10): number of independent starting points for the search\noutgroup (default none): outgroup taxon to root the estimated topology at the very end\nfilename (default \"snaq\"): root name for the output files (.out, .err). If empty (\"\"), files are not created, progress log goes to the screen only (standard out).\nseed (default 0 to get it from the clock): seed to replicate a given search\nprobST (default 0.3): probability to start from T at each given run. With problability 1-probST, the search is started from an NNI modification of T along a tree edge with no hybrid neighbor, with a possible modification of one reticulation if T has one.\nupdateBL (default true): If true and if T is a tree, the branch lengths in T are first optimized roughly with updateBL! by using the average CF of all quartets defining each branch and back-calculating the coalescent units.\n\nThe following optional arguments control when to stop the optimization of branch lengths and γ's on each individual candidate network. Defaults are in parentheses:\n\nftolRel (1e-6) and ftolAbs (1e-6): relative and absolute differences of the network score between the current and proposed parameters,\nxtolRel (1e-2) and xtolAbs (1e-3): relative and absolute differences between the current and proposed parameters.\n\nGreater values will result in a less thorough but faster search. These parameters are used when evaluating candidate networks only. The following optional arguments control when to stop proposing new network topologies:\n\nNfail (75): maximum number of times that new topologies are proposed and rejected (in a row).\nliktolAbs (1e-6): the proposed network is accepted if its score is better than the current score by at least liktolAbs.\n\nLower values of Nfail and greater values of liktolAbs and ftolAbs would result in a less thorough but faster search.\n\nAt the end, branch lengths and γ's are optimized on the last \"best\" network with different and very thorough tolerance parameters: 1e-12 for ftolRel, 1e-10 for ftolAbs, xtolRel, xtolAbs.\n\nSee also: topologyMaxQPseudolik! to optimize parameters on a fixed topology, and topologyQPseudolik! to get the deviance (pseudo log-likelihood up to a constant) of a fixed topology with fixed parameters.\n\nReference:   Claudia Solís-Lemus and Cécile Ané (2016). Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting. PLoS Genetics 12(3):e1005896\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.topologyMaxQPseudolik!","page":"Public","title":"PhyloNetworks.topologyMaxQPseudolik!","text":"topologyMaxQPseudolik!(net::HybridNetwork, d::DataCF)\n\nEstimate the branch lengths and inheritance probabilities (γ's) for a given network topology. The network is not modified, only the object d is, with updated expected concordance factors.\n\nOuput: new network, with optimized parameters (branch lengths and gammas). The maximized quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0. This is also an attribute of the network, which can be accessed with net.loglik.\n\nOptional arguments (default value):\n\nverbose (false): if true, information on the numerical optimization is printed to screen\nftolRel (1e-5), ftolAbs (1e-6), xtolRel (1e-3), xtolAbs (1e-4): absolute and relative tolerance values for the pseudo-deviance function and the parameters\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.topologyQPseudolik!","page":"Public","title":"PhyloNetworks.topologyQPseudolik!","text":"topologyQPseudolik!(net::HybridNetwork, d::DataCF)\n\nCalculate the quartet pseudo-deviance of a given network/tree for DataCF d. This is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.\n\nBe careful if the net object does not have all internal branch lengths specified because then the pseudolikelihood will be meaningless.\n\nThe loglik attribute of the network is undated, and d is updated with the expected concordance factors under the input network.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.fittedQuartetCF","page":"Public","title":"PhyloNetworks.fittedQuartetCF","text":"fittedQuartetCF(d::DataCF, format::Symbol)\n\nreturn a data frame with the observed and expected quartet concordance factors after estimation of a network with snaq(T,d). The format can be :wide (default) or :long.\n\nif wide, the output has one row per 4-taxon set, and each row has 10 columns: 4 columns for the taxon names, 3 columns for the observed CFs and 3 columns for the expected CF.\nif long, the output has one row per quartet, i.e. 3 rows per 4-taxon sets, and 7 columns: 4 columns for the taxon names, one column to give the quartet resolution, one column for the observed CF and the last column for the expected CF.\n\nsee also: topologyQPseudolik! and topologyMaxQPseudolik! to update the fitted CF expected under a specific network, inside the DataCF object d.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.bootsnaq","page":"Public","title":"PhyloNetworks.bootsnaq","text":"bootsnaq(T::HybridNetwork, df::DataFrame)\nbootsnaq(T::HybridNetwork, vector of tree lists)\n\nBootstrap analysis for SNaQ. Bootstrap data can be quartet concordance factors (CF), drawn from sampling uniformly in their credibility intervals, as given in the data frame df. Alternatively, bootstrap data can be gene trees sampled from a vector of tree lists: one list of bootstrap trees per locus (see readBootstrapTrees to generate this, from a file containing a list of bootstrap files: one per locus).\n\nFrom each bootstrap replicate, a network is estimated with snaq!, with a search starting from topology T. Optional arguments include the following, with default values in parentheses:\n\nhmax (1): max number of reticulations in the estimated networks\nnrep (10): number of bootstrap replicates.\nruns (10): number of independent optimization runs for each replicate\nfilename (\"bootsnaq\"): root name for output files. No output files if \"\".\nseed (0 to get a random seed from the clock): seed for random number generator\notherNet (empty): another starting topology so that each replicate will start prcnet% runs on otherNet and (1-prcnet)% runs on T\nprcnet (0): percentage of runs starting on otherNet; error if different than 0.0, and otherNet not specified.\nftolRel, ftolAbs, xtolRel, xtolAbs, liktolAbs, Nfail, probST, verbose, outgroup: see snaq!, same defaults.\n\nIf T is a tree, its branch lengths are first optimized roughly with updateBL! (by using the average CF of all quartets defining each branch and calculating the coalescent units corresponding to this quartet CF). If T has one or more reticulations, its branch lengths are taken as is to start the search. The branch lengths of otherNet are always taken as is to start the search.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.calibrateFromPairwiseDistances!","page":"Public","title":"PhyloNetworks.calibrateFromPairwiseDistances!","text":"calibrateFromPairwiseDistances!(net, distances::Matrix{Float64},\n    taxon_names::Vector{String})\n\nCalibrate the network to match (as best as possible) input pairwise distances between taxa, such as observed from sequence data. taxon_names should provide the list of taxa, in the same order in which they they are considered in the distances matrix. The optimization criterion is the sum of squares between the observed distances, and the distances from the network (weighted average of tree distances, weighted by γ's). The network's edge lengths are modified.\n\nWarning: for many networks, mutiple calibrations can fit the pairwise distance data equally well (lack of identifiability). This function will output one of these equally good calibrations.\n\noptional arguments (default):\n\ncheckPreorder (true)\nforceMinorLength0 (false) to force minor hybrid edges to have a length of 0\nNLoptMethod (:LD_MMA) for the optimization algorithm. Other options include :LN_COBYLA (derivative-free); see NLopt package.\ntolerance values to control when the optimization is stopped: ftolRel (1e-12), ftolAbs (1e-10) on the criterion, and xtolRel (1e-10), xtolAbs (1e-10) on branch lengths / divergence times.\nverbose (false)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.undirectedOtherNetworks","page":"Public","title":"PhyloNetworks.undirectedOtherNetworks","text":"undirectedOtherNetworks(net::HybridNetwork)\n\nReturn a vector of HybridNetwork objects, obtained by switching the placement of each hybrid node to other nodes inside its cycle. This amounts to changing the direction of a gene flow event (recursively to move around the whole cycle of each reticulation).\n\nOptional argument: outgroup, as a String. If an outgroup is specified, then networks conflicting with the placement of the root are avoided.\n\nAssumptions: net is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. All level-1 fields of net are assumed up-to-date.\n\nExample\n\njulia> net = readTopology(\"(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\");\njulia> vnet = undirectedOtherNetworks(net)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.nj","page":"Public","title":"PhyloNetworks.nj","text":"nj(D::DataFrame; force_nonnegative_edges::Bool=false)\n\nConstruct a tree from a distance matrix by neighbor joining, where D is a DataFrame of the distance matrix, with taxon names taken from the header of the data frame. The rows are assumed to correspond to tips in the tree in the same order as they do in columns. With force_nonnegative_edges being true, any negative edge length is changed to 0.0 (with a message).\n\nFor the algorithm, see Satou & Nei 1987.\n\nSee nj! for using a matrix as input.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#network-Comparisons","page":"Public","title":"network Comparisons","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"majorTree\nminorTreeAt\ndisplayedTrees\ndisplayedNetworkAt!\nhardwiredClusters\nhardwiredCluster\nhardwiredClusterDistance\ntreeEdgesBootstrap\nhybridDetection\nsummarizeHFdf\nhybridBootstrapSupport","category":"page"},{"location":"lib/public/#PhyloNetworks.majorTree","page":"Public","title":"PhyloNetworks.majorTree","text":"majorTree(net::HybridNetwork; nofuse=false::Bool, unroot=false::Bool,\n          keeporiginalroot=false::Bool)\n\nExtract the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node.\n\nnofuse: if true, edges and degree-2 nodes are retained during edge removal. Otherwise, at each reticulation the child edge (below the hybrid node) is retained: the major hybrid edge is fused with it.\n\nunroot: is true, the root will be deleted if it becomes of degree 2.\n\nkeeporiginalroot: the network's root is kept even if it becomes of degree 1.\n\nWarnings:\n\nif nofuse is true: the hybrid edges that are retained (without fusing) have their γ values unchanged, but their isMajor is changed to true\nassume correct isMajor attributes.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.minorTreeAt","page":"Public","title":"PhyloNetworks.minorTreeAt","text":"minorTreeAt(net::HybridNetwork, hybindex::Integer, nofuse=false, unroot=false::Bool)\n\nExtract the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i=hybindex), where the minor hybrid edge is kept instead of the major hybrid edge. If nofuse is true, edges are not fused (degree-2 nodes are kept). If unroot is true, the root will be deleted if it becomes of degree 2.\n\nWarning: assume correct isMajor fields.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.displayedTrees","page":"Public","title":"PhyloNetworks.displayedTrees","text":"displayedTrees(net::HybridNetwork, gamma::Float64; nofuse=false::Bool,\n               unroot=false::Bool, multgammas=false::Bool,\n               keeporiginalroot=false::Bool)\n\nExtracts all trees displayed in a network, following hybrid edges with heritability >= γ threshold (or >0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than γ. Returns an array of trees, as HybridNetwork objects.\n\nnofuse: if true, do not fuse edges (keep degree-2 nodes) during hybrid edge removal.   unroot: if false, the root will not be deleted if it becomes of degree 2 unless   keeporiginalroot is true.   multgammas: if true, the edges in the displayed trees have γ values   equal to the proportion of genes that the edge represents, even though all   these edges are tree edges. The product of all the γ values across all edges   is the proportion of genes that the tree represents. More specifically,   edge e in a given displayed tree has γ equal to the product of γs   of all edges in the original network that have been merged into e.   keeporiginalroot: if true, keep root even if of degree 1.\n\nWarnings:\n\nif nofuse is true: the retained partner hybrid edges have their γ values unchanged, but their isMajor is changed to true\nassume correct isMajor attributes.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.displayedNetworkAt!","page":"Public","title":"PhyloNetworks.displayedNetworkAt!","text":"displayedNetworkAt!(net::HybridNetwork, node::Node, nofuse=false,\n                    unroot=false, multgammas=false)\n\nDelete all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before. If nofuse is true, edges are not fused (degree-2 nodes are kept).\n\nWarning: assume correct isMajor fields.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.hardwiredClusters","page":"Public","title":"PhyloNetworks.hardwiredClusters","text":"hardwiredClusters(net::HybridNetwork, S::Union{Vector{String},Vector{Int}})\n\nReturns a matrix describing all the hardwired clusters in a network. Warnings: Clusters are rooted, so the root must be correct.           Allows for missing taxa, with entries all 0.\n\nEach row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).\n\nfirst column: edge number\nnext columns: 0/1. 1=descendant of edge, 0=not a descendant, or missing taxon.\nlast column:  10/11 values. 10=tree edge, 11=hybrid edge\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.hardwiredCluster","page":"Public","title":"PhyloNetworks.hardwiredCluster","text":"hardwiredCluster(edge::Edge,taxa::Union{Vector{String},Vector{Int}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}},\n                  visited::Vector{Int})\n\nCalculate the hardwired cluster of node, coded a vector of booleans: true for taxa that are descendent of nodes, false for other taxa (including missing taxa).\n\nThe node should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.\n\nvisited: vector of node numbers, of all visited nodes.\n\nExamples:\n\njulia> net5 = \"(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));\" |> readTopology |> directEdges! ;\n\njulia> taxa = net5 |> tipLabels # ABC EF D\n6-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n \"E\"\n \"F\"\n \"D\"\n\njulia> hardwiredCluster(net5.edge[12], taxa) # descendants of 12th edge = CEF\n6-element Vector{Bool}:\n 0\n 0\n 1\n 1\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.hardwiredClusterDistance","page":"Public","title":"PhyloNetworks.hardwiredClusterDistance","text":"hardwiredClusterDistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)\n\nTakes 2 networks and returns their hardwired cluster distance, that is, the number of hardwired clusters found in one network and not in the other. Note that this is not a distance per se on the full space of hybrid networks: there are pairs of different networks for which this measure is 0. But it is a distance on some network subspaces.\n\nIf the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, the trees are considered unrooted.\n\nIf rooted is false and one of the phylogenies is not a tree (1+ reticulations), then all degree-2 nodes are removed before comparing the hardwired clusters, and the minimum distance is returned over all possible ways to root the networks at internal nodes.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.treeEdgesBootstrap","page":"Public","title":"PhyloNetworks.treeEdgesBootstrap","text":"treeEdgesBootstrap(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork)\n\nRead a list of bootstrap networks (boot_net) and a reference network (ref_net), and calculate the bootstrap support of the tree edges in the reference network. All minor hybrid edges (γ<0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.\n\noutput:\n\na data frame with one row per tree edge and two columns: edge number, bootstrap support (as a percentage)\nthe major tree from the reference network, where minor hybrid edges (with γ<0.5) have been removed.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.hybridDetection","page":"Public","title":"PhyloNetworks.hybridDetection","text":"hybridDetection(net::Vector{HybridNetwork}, net1::HybridNetwork, outgroup::AbstractString)\n\nfunction can only compare hybrid nodes in networks that have the same underlying major tree also, need to root all networks in the same place, and the root has to be compatible with the direction of the hybrid edges\n\nit computes the rooted hardwired distance between networks, the root matters. input: vector of bootstrap networks (net), estimated network (net1), outgroup\n\nreturns\n\na matrix with one row per bootstrap network, and 2*number of hybrids in net1, column i corresponds to whether hybrid i (net1.hybrid[i]) is found in the bootstrap network, column 2i+1 corresponds to the estimated gamma on the bootstrap network (0.0 if hybrid not found). To know the order of hybrids, print net1.hybrid or h.name for h in net1.hybrid\nlist of discrepant trees (trees not matching the main tree in net1)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.summarizeHFdf","page":"Public","title":"PhyloNetworks.summarizeHFdf","text":"summarizeHFdf(HFmat::Matrix)\n\nSummarize data frame output from hybridDetection. Output: dataframe with one row per hybrid, and 5 columns:\n\nhybrid index (order from estimated network, see hybridDetection,\nnumber of bootstrap trees that match the underlying tree of estimated network\nnumber of bootstrap networks that have the hybrid\nmean estimated gamma in the bootstrap networks that have the hybrid\nsd estimated gamma in the bootstrap networks that have the hybrid also\n\nlast row has index -1, and the third column has the number of networks that have all hybrids (hybrid index, mean gamma, sd gamma are meaningless in this last row)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.hybridBootstrapSupport","page":"Public","title":"PhyloNetworks.hybridBootstrapSupport","text":"hybridBootstrapSupport(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)\n\nMatch hybrid nodes in a reference network with those in an array of networks, like bootstrap networks. All networks must be fully resolved, and on the same taxon set. If rooted=true, all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).\n\nTwo hybrid edges in two networks are said to match if they share the same \"hybrid\" clade (or recipient) and the same \"donor clade\", which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with γ>0.5) and one is its minor sister (following the major hybrid edge with γ<0.5).\n\nTo calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If rooted=false, sister clades are considered as bipartitions.\n\nOutput:\n\na \"node\" data frame (see below)\nan \"edge\" data frame (see below)\na \"clade\" data frame to describe the make up of all clades found as hybrids or sisters, starting with a column taxa that lists all taxa. All other columns correspond to a given clade and contain true/false values. true means that a given taxon belongs in a given clade. For a clade named H1, for instance, and if the data frame was named cla, the list of taxa in this clade can be obtained with cla[:taxa][cla[:H1]].\nan array of gamma values, with one row for each bootstrap network and two columns (major/minor) for each hybrid edge in the reference network. If this hybrid edge was found in the bootstrap network (i.e. same hybrid and sister clades, after removal of all other hybrid nodes), its bootstrap gamma value is recorded here. Otherwise, the gamma entry is 0.0.\na vector with the number of each hybrid edge in the reference network, in the same order as for the columns in the array of gamma values above.\n\nThe \"node\" data frame has one row per clade and 9 columns giving:\n\n:clade: the clade's name, like the taxon name (if a hybrid is a single taxon) or the hybrid tag (like 'H1') in the reference network\n:node: the node number in the reference network. missing if the clade is not in this network.\n:hybridnode: typically the same node number as above, except for hybrid clades in the reference network. For those, the hybrid node number is listed here.\n:edge: number of the parent edge, parent to the node in column 2, if found in the ref network. missing otherwise.\n:BS_hybrid: percentage of bootstrap networks in which the clade is found to be a hybrid clade.\n:BS_sister: percentage of bootstrap networks in which the clade is found to be sister to some hybrid clade (sum of the next 2 columns)\n:BS_major_sister: percentage of bootstrap networks in which the clade is found to be the major sister to some hybrid clade\n:BS_minor_sister: same as previous, but minor\n:BS_hybrid_samesisters: percentage of bootstrap networks in which the clade is found to be a hybrid and with the same set of sister clades as in the reference network. Applies to hybrid clades found in the reference network only, missing for all other clades.\n\nThe \"edge\" data frame has one row for each pair of clades, and 8 columns:\n\n:edge: hybrid edge number, if the edge appears in the reference network. missing otherwise.\n:hybrid_clade: name of the clade found to be a hybrid, descendent of 'edge'\n:hybrid: node number of that clade, if it appears in the reference network. missing otherwise.\n:sister_clade: name of the clade that is sister to 'edge', i.e. be sister to a hybrid\n:sister: node number of that clade, if in the ref network.\n:BS_hybrid_edge: percentage of bootstrap networks in which 'edge' is found to be a hybrid  edge, i.e. when the clade in the 'hybrid' column is found to be a hybrid and the clade in  the 'sister' column is one of its sisters.\n:BS_major: percentage of bootstrap networks in which 'edge' is found to be a major hybrid  edge, i.e. when 'hybrid' is found to be a hybrid clade and 'sister' is found to be its  major sister.\n:BS_minor: same as previous, but minor\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#continuous-trait-evolution","page":"Public","title":"continuous trait evolution","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"phylolm\nsigma2_phylo\nsigma2_within\nmu_phylo\nlambda_estim\nancestralStateReconstruction\nexpectations\npredint\nexpectationsPlot\npredintPlot\nsimulate\nshiftHybrid\ngetShiftEdgeNumber\ngetShiftValue\ndescendenceMatrix\nregressorShift\nregressorHybrid\nsharedPathMatrix\nvcv","category":"page"},{"location":"lib/public/#PhyloNetworks.phylolm","page":"Public","title":"PhyloNetworks.phylolm","text":"phylolm(X::Matrix, Y::Vector, net::HybridNetwork, model::ContinuousTraitEM=BM(); kwargs...)\n\nReturn a PhyloNetworkLinearModel object. This method is called by phylolm(formula, data, network; kwargs...).\n\n\n\n\n\nphylolm(f::StatsModels.FormulaTerm, fr::AbstractDataFrame, net::HybridNetwork; kwargs...)\n\nFit a phylogenetic linear regression model to data.\n\nReturn a StatsModels.TableRegressionModel object. This object has three fields: model, mf, mm (see StatsModels). To access the fitted PhyloNetworkLinearModel, do object.model.\n\nArguments\n\nf: formula to use for the regression.\nfr: DataFrame containing the response values, predictor values, species/tip labels for each observation/row.\nnet: phylogenetic network to use. Should have labelled tips.\n\nKeyword arguments\n\nmodel=\"BM\": model for trait evolution (as a string) \"lambda\" (Pagel's lambda), \"scalingHybrid\" are other possible values (see ContinuousTraitEM)\ntipnames=:tipNames: column name for species/tip-labels, represented as a symbol. For example, if the column containing the species/tip labels in fr is named \"Species\", then do tipnames=:Species.\nno_names=false: If true, force the function to ignore the tips names. The data is then assumed to be in the same order as the tips of the network. Default is false, setting it to true is dangerous, and strongly discouraged.\nreml=true: if true, use REML criterion (\"restricted maximum likelihood\") for estimating variance components, else use ML criterion.\n\nThe following tolerance parameters control the optimization of lambda if model=\"lambda\" or model=\"scalingHybrid\", and control the optimization of the variance components if model=\"BM\" and withinspecies_var=true.\n\nfTolRel=1e-10: relative tolerance on the likelihood value\nfTolAbs=1e-10: absolute tolerance on the likelihood value\nxTolRel=1e-10: relative tolerance on the parameter value\nxTolAbs=1e-10: absolute tolerance on the parameter value\nstartingValue=0.5: If model=\"lambda\" or \"scalingHybrid\", this provides the starting value for the optimization in lambda.\nfixedValue=missing: If model=\"lambda\" or \"scalingHybrid\", and fixedValue is a number, then lambda is set to this number and is not optimized.\nwithinspecies_var=false: If true, fits a within-species variation model. Currently only implemented for model=\"BM\".\ny_mean_std::Bool=false: If true, and withinspecies_var=true, then accounts for within-species variation, using species-level statistics provided in fr.\n\nMethods applied to fitted models\n\nTo access the response values, do response(object). To access the model matrix, do object.mm.m. To access the model formula, do show(object.mf.f).\n\nAll of the StatsBase methods that can be applied to a PhyloNetworkLinearModel can also be applied to a StatsModels.TableRegressionModel.\n\nWithin-species variation\n\nFor a high-level description, see PhyloNetworkLinearModel. To fit a model with within-species variation in the response variable, either of the following must be provided in the data frame fr:\n\n(1) Individual-level data: There should be columns for response, predictors, and species/tip-labels. Every row should correspond to an individual observation. At least one species must be represented by two or more individuals.\n\n(2) Species-level statistics: There should be columns for mean response, predictors, species/tip-labels, species sample-sizes (number of individuals for each species), and species standard deviations (standard deviations of the response values by species). Every row should correspond to a species: each species should be represented by a unique row. The column names for species sample-sizes and species standard deviations are expected to be \"[response column name]_n\" and \"[response column name]_sd\". For example, if the response column name is \"y\", then the column names should be \"y_n\" and \"y_sd\" for the sample-sizes and standard deviations.\n\nRegardless of whether the data provided follows (1) or (2), withinspecies_var should be set to true. If the data provided follows (2), then y_mean_std should be set to false.\n\nWithin-species variation in predictors\n\nThe model assumes no within-species variation in predictors, because it aims to capture the evolutionary (historical, phylogenetic) relationship between the predictors and the response, not the within-species (present-day, or phenotypic) relationship.\n\nIf a within-species variation model is fitted on individual-level data, and if there are individuals within the same species with different values for the same predictor, these values are all replaced by the mean predictor value for all the individuals in that species. For example, suppose there are 3 individuals in a given species, and that their predictor values are (x₁=3, x₂=6), (x₁=4, x₂=8) and (x₁=2, x₂=1). Then the predictor values for these 3 individuals are each replaced by (x₁=(3+4+2)/3, x₂=(6+8+1)/3) before model fitting. If a fourth individual had data (x₁=10, x₂=missing), then that individual would be ignored for any model using x₂, and would not contribute any information to its species data for these models.\n\nMissing data\n\nRows with missing data for either the response or the predictors are omitted from the model-fitting. There should minimally be columns for response, predictors, species/tip-labels. As detailed above, additional columns may be required for fitting within-species variation. Missing data in the columns for species names, species standard deviation / sample sizes (if used) will throw an error.\n\nSee also\n\nPhyloNetworkLinearModel, ancestralStateReconstruction\n\nExamples: Without within-species variation\n\njulia> phy = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\", \"examples\", \"caudata_tree.txt\"));\n\njulia> using DataFrames, CSV # to read data file, next\n\njulia> dat = CSV.File(joinpath(dirname(pathof(PhyloNetworks)), \"..\", \"examples\", \"caudata_trait.txt\")) |> DataFrame;\n\njulia> using StatsModels # for stat model formulas\n\njulia> fitBM = phylolm(@formula(trait ~ 1), dat, phy; reml=false);\n\njulia> fitBM # Shows a summary\nStatsModels.TableRegressionModel{PhyloNetworkLinearModel, Matrix{Float64}}\n\nFormula: trait ~ 1\n\nModel: Brownian motion\n\nParameter Estimates, using ML:\nphylogenetic variance rate: 0.00294521\n\nCoefficients:\n─────────────────────────────────────────────────────────────────────\n             Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n─────────────────────────────────────────────────────────────────────\n(Intercept)  4.679    0.330627  14.15    <1e-31    4.02696    5.33104\n─────────────────────────────────────────────────────────────────────\nLog Likelihood: -78.9611507833\nAIC: 161.9223015666\n\njulia> round(sigma2_phylo(fitBM), digits=6) # rounding for jldoctest convenience\n0.002945\n\njulia> round(mu_phylo(fitBM), digits=4)\n4.679\n\njulia> using StatsBase # for aic() stderror() loglikelihood() etc.\n\njulia> round(loglikelihood(fitBM), digits=10)\n-78.9611507833\n\njulia> round(aic(fitBM), digits=10)\n161.9223015666\n\njulia> round(aicc(fitBM), digits=10)\n161.9841572367\n\njulia> round(bic(fitBM), digits=10)\n168.4887090241\n\njulia> round.(coef(fitBM), digits=4)\n1-element Vector{Float64}:\n 4.679\n\njulia> confint(fitBM)\n1×2 Matrix{Float64}:\n 4.02696  5.33104\n\njulia> abs(round(r2(fitBM), digits=10)) # absolute value for jldoctest convenience\n0.0\n\njulia> abs(round(adjr2(fitBM), digits=10))\n0.0\n\njulia> round.(vcov(fitBM), digits=6)\n1×1 Matrix{Float64}:\n 0.109314\n\njulia> round.(residuals(fitBM), digits=6)\n197-element Vector{Float64}:\n -0.237648\n -0.357937\n -0.159387\n -0.691868\n -0.323977\n -0.270452\n -0.673486\n -0.584654\n -0.279882\n -0.302175\n  ⋮\n -0.777026\n -0.385121\n -0.443444\n -0.327303\n -0.525953\n -0.673486\n -0.603158\n -0.211712\n -0.439833\n\njulia> round.(response(fitBM), digits=5)\n197-element Vector{Float64}:\n 4.44135\n 4.32106\n 4.51961\n 3.98713\n 4.35502\n 4.40855\n 4.00551\n 4.09434\n 4.39912\n 4.37682\n ⋮\n 3.90197\n 4.29388\n 4.23555\n 4.3517\n 4.15305\n 4.00551\n 4.07584\n 4.46729\n 4.23917\n\njulia> round.(predict(fitBM), digits=5)\n197-element Vector{Float64}:\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n ⋮\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n\nExamples: With within-species variation (two different input formats shown)\n\njulia> using DataFrames, StatsModels # for statistical model formulas\n\njulia> net = readTopology(\"((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\");\n\njulia> df = DataFrame( # individual-level observations\n           species = repeat([\"D\",\"C\",\"A\",\"B\",\"E\",\"O\"],inner=3),\n           trait1 = [4.08298,4.08298,4.08298,3.10782,3.10782,3.10782,2.17078,2.17078,2.17078,1.87333,1.87333,\n              1.87333,2.8445,2.8445,2.8445,5.88204,5.88204,5.88204],\n           trait2 = [-7.34186,-7.34186,-7.34186,-7.45085,-7.45085,-7.45085,-3.32538,-3.32538,-3.32538,-4.26472,\n              -4.26472,-4.26472,-5.96857,-5.96857,-5.96857,-1.99388,-1.99388,-1.99388],\n           trait3 = [18.8101,18.934,18.9438,17.0687,17.0639,17.0732,14.4818,14.1112,14.2817,13.0842,12.9562,\n              12.9019,15.4373,15.4075,15.4317,24.2249,24.1449,24.1302]);\n\njulia> m1 = phylolm(@formula(trait3 ~ trait1), df, net;\n                    tipnames=:species, withinspecies_var=true)\nStatsModels.TableRegressionModel{PhyloNetworkLinearModel, Matrix{Float64}}\n\nFormula: trait3 ~ 1 + trait1\n\nModel: Brownian motion\n\nParameter Estimates, using REML:\nphylogenetic variance rate: 0.156188\nwithin-species variance: 0.0086343\n\nCoefficients:\n──────────────────────────────────────────────────────────────────────\n               Coef.  Std. Error     t  Pr(>|t|)  Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────\n(Intercept)  9.65347    1.3066    7.39    0.0018    6.02577   13.2812\ntrait1       2.30358    0.276163  8.34    0.0011    1.53683    3.07033\n──────────────────────────────────────────────────────────────────────\nLog Likelihood: 1.9446255188\nAIC: 4.1107489623\n\njulia> df_r = DataFrame( # species-level statistics (sample means, standard deviations)\n           species = [\"D\",\"C\",\"A\",\"B\",\"E\",\"O\"],\n           trait1 = [4.08298,3.10782,2.17078,1.87333,2.8445,5.88204],\n           trait2 = [-7.34186,-7.45085,-3.32538,-4.26472,-5.96857,-1.99388],\n           trait3 = [18.896,17.0686,14.2916,12.9808,15.4255,24.1667],\n           trait3_sd = [0.074524,0.00465081,0.185497,0.0936,0.0158379,0.0509643],\n           trait3_n = [3, 3, 3, 3, 3, 3]);\n\njulia> m2 = phylolm(@formula(trait3 ~ trait1), df_r, net;\n                tipnames=:species, withinspecies_var=true, y_mean_std=true)\nStatsModels.TableRegressionModel{PhyloNetworkLinearModel, Matrix{Float64}}\n\nFormula: trait3 ~ 1 + trait1\n\nModel: Brownian motion\n\nParameter Estimates, using REML:\nphylogenetic variance rate: 0.15618\nwithin-species variance: 0.0086343\n\nCoefficients:\n──────────────────────────────────────────────────────────────────────\n               Coef.  Std. Error     t  Pr(>|t|)  Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────\n(Intercept)  9.65342    1.30657   7.39    0.0018    6.02582   13.281\ntrait1       2.30359    0.276156  8.34    0.0011    1.53686    3.07032\n──────────────────────────────────────────────────────────────────────\nLog Likelihood: 1.9447243714\nAIC: 4.1105512573\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.sigma2_phylo","page":"Public","title":"PhyloNetworks.sigma2_phylo","text":"sigma2_phylo(m::PhyloNetworkLinearModel)\n\nEstimated between-species variance-rate for a fitted object.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.sigma2_within","page":"Public","title":"PhyloNetworks.sigma2_within","text":"sigma2_within(m::PhyloNetworkLinearModel)\n\nEstimated within-species variance for a fitted object.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.mu_phylo","page":"Public","title":"PhyloNetworks.mu_phylo","text":"mu_phylo(m::PhyloNetworkLinearModel)\n\nEstimated root value for a fitted object.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.lambda_estim","page":"Public","title":"PhyloNetworks.lambda_estim","text":"lambda_estim(m::PhyloNetworkLinearModel)\n\nEstimated lambda parameter for a fitted object.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.ancestralStateReconstruction","page":"Public","title":"PhyloNetworks.ancestralStateReconstruction","text":"ancestralStateReconstruction(net::HybridNetwork, Y::Vector, params::ParamsBM)\n\nCompute the conditional expectations and variances of the ancestral (un-observed) traits values at the internal nodes of the phylogenetic network (net), given the values of the traits at the tips of the network (Y) and some known parameters of the process used for trait evolution (params, only BM with fixed root works for now).\n\nThis function assumes that the parameters of the process are known. For a more general function, see ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix]).\n\n\n\n\n\nancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])\n\nFunction to find the ancestral traits reconstruction on a network, given an object fitted by function phylolm. By default, the function assumes that the regressor is just an intercept. If the value of the regressor for all the ancestral states is known, it can be entered in X_n, a matrix with as many columns as the number of predictors used, and as many lines as the number of unknown nodes or tips.\n\nReturns an object of type ReconstructedStates.\n\nExamples\n\njulia> using DataFrames, CSV # to read data file\n\njulia> phy = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\", \"examples\", \"carnivores_tree.txt\"));\n\njulia> dat = CSV.File(joinpath(dirname(pathof(PhyloNetworks)), \"..\", \"examples\", \"carnivores_trait.txt\")) |> DataFrame;\n\njulia> using StatsModels # for statistical model formulas\n\njulia> fitBM = phylolm(@formula(trait ~ 1), dat, phy);\n\njulia> ancStates = ancestralStateReconstruction(fitBM) # Should produce a warning, as variance is unknown.\n┌ Warning: These prediction intervals show uncertainty in ancestral values,\n│ assuming that the estimated variance rate of evolution is correct.\n│ Additional uncertainty in the estimation of this variance rate is\n│ ignored, so prediction intervals should be larger.\n└ @ PhyloNetworks ~/build/crsl4/PhyloNetworks.jl/src/traits.jl:3359\nReconstructedStates:\n───────────────────────────────────────────────\n  Node index      Pred.        Min.  Max. (95%)\n───────────────────────────────────────────────\n        -5.0   1.32139   -0.33824      2.98102\n        -8.0   1.03258   -0.589695     2.65485\n        -7.0   1.41575   -0.140705     2.97221\n        -6.0   1.39417   -0.107433     2.89577\n        -4.0   1.39961   -0.102501     2.90171\n        -3.0   1.51341   -0.220523     3.24733\n       -13.0   5.3192     3.92279      6.71561\n       -12.0   4.51176    2.89222      6.13131\n       -16.0   1.50947   -0.0186118    3.03755\n       -15.0   1.67425    0.196069     3.15242\n       -14.0   1.80309    0.309992     3.29618\n       -11.0   2.7351     1.17608      4.29412\n       -10.0   2.73217    1.12361      4.34073\n        -9.0   2.41132    0.603932     4.21871\n        -2.0   2.04138   -0.0340955    4.11686\n        14.0   1.64289    1.64289      1.64289\n         8.0   1.67724    1.67724      1.67724\n         5.0   0.331568   0.331568     0.331568\n         2.0   2.27395    2.27395      2.27395\n         4.0   0.275237   0.275237     0.275237\n         6.0   3.39094    3.39094      3.39094\n        13.0   0.355799   0.355799     0.355799\n        15.0   0.542565   0.542565     0.542565\n         7.0   0.773436   0.773436     0.773436\n        10.0   6.94985    6.94985      6.94985\n        11.0   4.78323    4.78323      4.78323\n        12.0   5.33016    5.33016      5.33016\n         1.0  -0.122604  -0.122604    -0.122604\n        16.0   0.73989    0.73989      0.73989\n         9.0   4.84236    4.84236      4.84236\n         3.0   1.0695     1.0695       1.0695\n───────────────────────────────────────────────\n\njulia> expectations(ancStates)\n31×2 DataFrame\n Row │ nodeNumber  condExpectation\n     │ Int64       Float64\n─────┼─────────────────────────────\n   1 │         -5         1.32139\n   2 │         -8         1.03258\n   3 │         -7         1.41575\n   4 │         -6         1.39417\n   5 │         -4         1.39961\n   6 │         -3         1.51341\n   7 │        -13         5.3192\n   8 │        -12         4.51176\n  ⋮  │     ⋮              ⋮\n  25 │         10         6.94985\n  26 │         11         4.78323\n  27 │         12         5.33016\n  28 │          1        -0.122604\n  29 │         16         0.73989\n  30 │          9         4.84236\n  31 │          3         1.0695\n                    16 rows omitted\n\njulia> predint(ancStates)\n31×2 Matrix{Float64}:\n -0.33824     2.98102\n -0.589695    2.65485\n -0.140705    2.97221\n -0.107433    2.89577\n -0.102501    2.90171\n -0.220523    3.24733\n  3.92279     6.71561\n  2.89222     6.13131\n -0.0186118   3.03755\n  0.196069    3.15242\n  ⋮\n  0.542565    0.542565\n  0.773436    0.773436\n  6.94985     6.94985\n  4.78323     4.78323\n  5.33016     5.33016\n -0.122604   -0.122604\n  0.73989     0.73989\n  4.84236     4.84236\n  1.0695      1.0695\n\njulia> expectationsPlot(ancStates) # format the ancestral states\n31×2 DataFrame\n Row │ nodeNumber  PredInt\n     │ Int64       Abstract… \n─────┼───────────────────────\n   1 │         -5  1.32\n   2 │         -8  1.03\n   3 │         -7  1.42\n   4 │         -6  1.39\n   5 │         -4  1.4\n   6 │         -3  1.51\n   7 │        -13  5.32\n   8 │        -12  4.51\n  ⋮  │     ⋮           ⋮\n  25 │         10  6.95\n  26 │         11  4.78\n  27 │         12  5.33\n  28 │          1  -0.12\n  29 │         16  0.74\n  30 │          9  4.84\n  31 │          3  1.07\n              16 rows omitted\n\njulia> using PhyloPlots # next: plot ancestral states on the tree\n\njulia> plot(phy, :RCall, nodeLabel = expectationsPlot(ancStates));\n\njulia> predintPlot(ancStates) # prediction intervals, in data frame, useful to plot\n31×2 DataFrame\n Row │ nodeNumber  PredInt\n     │ Int64       Abstract…\n─────┼───────────────────────────\n   1 │         -5  [-0.34, 2.98]\n   2 │         -8  [-0.59, 2.65]\n   3 │         -7  [-0.14, 2.97]\n   4 │         -6  [-0.11, 2.9]\n   5 │         -4  [-0.1, 2.9]\n   6 │         -3  [-0.22, 3.25]\n   7 │        -13  [3.92, 6.72]\n   8 │        -12  [2.89, 6.13]\n  ⋮  │     ⋮             ⋮\n  25 │         10  6.95\n  26 │         11  4.78\n  27 │         12  5.33\n  28 │          1  -0.12\n  29 │         16  0.74\n  30 │          9  4.84\n  31 │          3  1.07\n                  16 rows omitted\n\njulia> plot(phy, :RCall, nodeLabel = predintPlot(ancStates));\n\njulia> allowmissing!(dat, :trait);\n\njulia> dat[[2, 5], :trait] .= missing; # missing values allowed to fit model\n\njulia> fitBM = phylolm(@formula(trait ~ 1), dat, phy);\n\njulia> ancStates = ancestralStateReconstruction(fitBM);\n┌ Warning: These prediction intervals show uncertainty in ancestral values,\n│ assuming that the estimated variance rate of evolution is correct.\n│ Additional uncertainty in the estimation of this variance rate is\n│ ignored, so prediction intervals should be larger.\n└ @ PhyloNetworks ~/build/crsl4/PhyloNetworks.jl/src/traits.jl:3166\n\njulia> first(expectations(ancStates), 3) # looking at first 3 nodes only\n3×2 DataFrame\n Row │ nodeNumber  condExpectation \n     │ Int64       Float64         \n─────┼─────────────────────────────\n   1 │         -5          1.42724\n   2 │         -8          1.35185\n   3 │         -7          1.61993\n\njulia> predint(ancStates)[1:3,:] # just first 3 nodes again\n3×2 Matrix{Float64}:\n -0.373749  3.22824\n -0.698432  3.40214\n -0.17179   3.41165\n\n   \njulia> first(expectationsPlot(ancStates),3) # format node <-> ancestral state\n3×2 DataFrame\n Row │ nodeNumber  PredInt   \n     │ Int64       Abstract… \n─────┼───────────────────────\n   1 │         -5  1.43\n   2 │         -8  1.35\n   3 │         -7  1.62\n\njulia> plot(phy, :RCall, nodeLabel = expectationsPlot(ancStates));\n\njulia> first(predintPlot(ancStates),3) # prediction intervals, useful to plot\n3×2 DataFrame\n Row │ nodeNumber  PredInt       \n     │ Int64       Abstract…     \n─────┼───────────────────────────\n   1 │         -5  [-0.37, 3.23]\n   2 │         -8  [-0.7, 3.4]\n   3 │         -7  [-0.17, 3.41]\n\njulia> plot(phy, :RCall, nodeLabel = predintPlot(ancStates));\n\n\n\n\n\nancestralStateReconstruction(fr::AbstractDataFrame, net::HybridNetwork; kwargs...)\n\nEstimate the ancestral traits on a network, given some data at the tips. Uses function phylolm to perform a phylogenetic regression of the data against an intercept (amounts to fitting an evolutionary model on the network).\n\nSee documentation on phylolm and ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix]) for further details.\n\nReturns an object of type ReconstructedStates.\n\n\n\n\n\nancestralStateReconstruction(obj::SSM, trait::Integer = 1)\n\nEstimate the marginal probability of ancestral states for discrete character number trait (first trait by default). The parameters of the StatisticalSubstitutionModel object obj must first be fitted using fitdiscrete, and ancestral state reconstruction is conditional on the estimated parameters. If these parameters were estimated using all traits, they are used as is, to do ancestral state reconstruction of the particular trait of interest.\n\noutput: data frame with a first column for the node numbers, a second column for the node labels, and a column for each possible state: the entries in these columns give the marginal probability that a given node has a given state.\n\nwarnings:\n\nnode numbers and node labels refer to those in obj.net, which might have a different internal representation of nodes than the original network used to build obj.\nobj is modified: its likelihood fields (forward, directional & backward) are updated to make sure that they correspond to the current parameter values in obj.model, and to the trait of interest.\n\nlimitations: the following are not checked.\n\nAssumes that every node in the large network is also present (with descendant leaves) in each displayed tree. This is not true if the network is not tree-child...\nAssumes that the root is also in each displayed tree, which may not be the case if the root had a hybrid child edge.\n\nSee also posterior_logtreeweight and discrete_backwardlikelihood_trait! to update obj.backwardlik.\n\nexamples\n\njulia> net = readTopology(\"(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\");\n\njulia> m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [\"lo\", \"hi\"]);\n\njulia> using DataFrames\n\njulia> dat = DataFrame(species=[\"C\",\"A\",\"B\",\"D\"], trait=[\"hi\",\"lo\",\"lo\",\"hi\"]);\n\njulia> fit1 = fitdiscrete(net, m1, dat);\n\njulia> asr = ancestralStateReconstruction(fit1)\n9×4 DataFrame\n Row │ nodenumber  nodelabel  lo        hi\n     │ Int64       String     Float64   Float64\n─────┼───────────────────────────────────────────\n   1 │          1  A          1.0       0.0\n   2 │          2  B          1.0       0.0\n   3 │          3  C          0.0       1.0\n   4 │          4  D          0.0       1.0\n   5 │          5  5          0.286021  0.713979\n   6 │          6  6          0.319456  0.680544\n   7 │          7  7          0.16855   0.83145\n   8 │          8  8          0.767359  0.232641\n   9 │          9  H1         0.782776  0.217224\n\njulia> using PhyloPlots\n\njulia> plot(fit1.net, :R, nodeLabel = asr[!,[:nodenumber, :lo]], tipOffset=0.2); # pp for \"lo\" state\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.expectations","page":"Public","title":"PhyloNetworks.expectations","text":"expectations(obj::ReconstructedStates)\n\nEstimated reconstructed states at the nodes and tips.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.predint","page":"Public","title":"PhyloNetworks.predint","text":"predint(obj::ReconstructedStates; level=0.95::Real)\n\nPrediction intervals with level level for internal nodes and missing tips.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.expectationsPlot","page":"Public","title":"PhyloNetworks.expectationsPlot","text":"expectationsPlot(obj::ReconstructedStates)\n\nCompute and format the expected reconstructed states for the plotting function. The resulting dataframe can be readily used as a nodeLabel argument to plot from package PhyloPlots. Keyword argument markMissing is a string that is appended to predicted tip values, so that they can be distinguished from the actual datapoints. Default to \"*\". Set to \"\" to remove any visual cue.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.predintPlot","page":"Public","title":"PhyloNetworks.predintPlot","text":"predintPlot(obj::ReconstructedStates; level=0.95::Real, withExp=false::Bool)\n\nCompute and format the prediction intervals for the plotting function. The resulting dataframe can be readily used as a nodeLabel argument to plot from package PhyloPlots. Keyworks argument level control the confidence level of the prediction interval. If withExp is set to true, then the best predicted value is also shown along with the interval.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.simulate","page":"Public","title":"PhyloNetworks.simulate","text":"simulate(net::HybridNetwork, params::ParamsProcess, checkPreorder=true::Bool)\n\nSimulate traits on net using the parameters params. For now, only parameters of type ParamsBM (univariate Brownian Motion) and ParamsMultiBM (multivariate Brownian motion) are accepted.\n\nThe simulation using a recursion from the root to the tips of the network, therefore, a pre-ordering of nodes is needed. If checkPreorder=true (default), preorder! is called on the network beforehand. Otherwise, it is assumed that the preordering has already been calculated.\n\nReturns an object of type TraitSimulation, which has a matrix with the trait expecations and simulated trait values at all the nodes.\n\nSee examples below for accessing expectations and simulated trait values.\n\nExamples\n\nUnivariate\n\njulia> phy = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\", \"examples\", \"carnivores_tree.txt\"));\n\njulia> par = ParamsBM(1, 0.1) # BM with expectation 1 and variance 0.1.\nParamsBM:\nParameters of a BM with fixed root:\nmu: 1\nSigma2: 0.1\n\n\njulia> using Random; Random.seed!(17920921); # for reproducibility\n\njulia> sim = simulate(phy, par) # Simulate on the tree.\nTraitSimulation:\nTrait simulation results on a network with 16 tips, using a BM model, with parameters:\nmu: 1\nSigma2: 0.1\n\n\njulia> traits = sim[:Tips] # Extract simulated values at the tips.\n16-element Vector{Float64}:\n  2.17618427971927\n  1.0330846124205684\n  3.048979175536912\n  3.0379560744947876\n  2.189704751299587\n  4.031588898597555\n  4.647725850651446\n -0.8772851731182523\n  4.625121065244063\n -0.5111667949991542\n  1.3560351170535228\n -0.10311152349323893\n -2.088472913751017\n  2.6399137689702723\n  2.8051193818084057\n  3.1910928691142915\n\njulia> sim.M.tipNames # name of tips, in the same order as values above\n16-element Vector{String}:\n \"Prionodontidae\"\n \"Felidae\"\n \"Viverridae\"\n \"Herpestidae\"\n \"Eupleridae\"\n \"Hyaenidae\"\n \"Nandiniidae\"\n \"Canidae\"\n \"Ursidae\"\n \"Odobenidae\"\n \"Otariidae\"\n \"Phocidae\"\n \"Mephitidae\"\n \"Ailuridae\"\n \"Mustelidae\"\n \"Procyonidae\"\n\njulia> traits = sim[:InternalNodes] # Extract simulated values at internal nodes. Order: as in sim.M.internalNodeNumbers\n15-element Vector{Float64}:\n 1.1754592873593104\n 2.0953234045227083\n 2.4026760531649423\n 1.8143470622283222\n 1.5958834784477616\n 2.5535578380290103\n 0.14811474751515852\n 1.2168428692963675\n 3.169431736805764\n 2.906447201806521\n 2.8191520015241545\n 2.280632978157822\n 2.5212485416800425\n 2.4579867601968663\n 1.0\n\njulia> traits = sim[:All] # simulated values at all nodes, ordered as in sim.M.nodeNumbersTopOrder\n31-element Vector{Float64}:\n 1.0\n 2.4579867601968663\n 2.5212485416800425\n 2.280632978157822\n 2.8191520015241545\n 2.906447201806521\n 3.169431736805764\n 3.1910928691142915\n 2.8051193818084057\n 2.6399137689702723\n ⋮\n 2.4026760531649423\n 4.031588898597555\n 2.0953234045227083\n 2.189704751299587\n 3.0379560744947876\n 3.048979175536912\n 1.1754592873593104\n 1.0330846124205684\n 2.17618427971927\n\njulia> traits = sim[:Tips, :Exp] # Extract expected values at the tips (also works for sim[:All, :Exp] and sim[:InternalNodes, :Exp]).\n16-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\nMultivariate\n\njulia> phy = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\", \"examples\", \"carnivores_tree.txt\"));\n\njulia> par = ParamsMultiBM([1.0, 2.0], [1.0 0.5; 0.5 1.0]) # BM with expectation [1.0, 2.0] and variance [1.0 0.5; 0.5 1.0].\nParamsMultiBM:\nParameters of a MBD with fixed root:\nmu: [1.0, 2.0]\nSigma: [1.0 0.5; 0.5 1.0]\n\njulia> using Random; Random.seed!(17920921); # for reproducibility\n\njulia> sim = simulate(phy, par) # Simulate on the tree.\nTraitSimulation:\nTrait simulation results on a network with 16 tips, using a MBD model, with parameters:\nmu: [1.0, 2.0]\nSigma: [1.0 0.5; 0.5 1.0]\n\n\njulia> traits = sim[:Tips] # Extract simulated values at the tips (each column contains the simulated traits for one node).\n2×16 Matrix{Float64}:\n 5.39465  7.223     1.88036  -5.10491   …  -3.86504  0.133704  -2.44564\n 7.29184  7.59947  -1.89206  -0.960013      3.86822  3.23285    1.93376\n\njulia> traits = sim[:InternalNodes] # simulated values at internal nodes. order: same as in sim.M.internalNodeNumbers\n2×15 Matrix{Float64}:\n 4.42499  -0.364198  0.71666   3.76669  …  4.57552  4.29265  5.61056  1.0\n 6.24238   2.97237   0.698006  2.40122     5.92623  5.13753  4.5268   2.0\n\njulia> traits = sim[:All] # simulated values at all nodes, ordered as in sim.M.nodeNumbersTopOrder\n2×31 Matrix{Float64}:\n 1.0  5.61056  4.29265  4.57552  …   1.88036  4.42499  7.223    5.39465\n 2.0  4.5268   5.13753  5.92623     -1.89206  6.24238  7.59947  7.29184\n\njulia> sim[:Tips, :Exp] # Extract expected values (also works for sim[:All, :Exp] and sim[:InternalNodes, :Exp])\n2×16 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0     2.0  2.0  2.0  2.0  2.0  2.0  2.0\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.shiftHybrid","page":"Public","title":"PhyloNetworks.shiftHybrid","text":"shiftHybrid(value::Vector{T} where T<:Real, net::HybridNetwork; checkPreorder=true::Bool)\n\nConstruct an object ShiftNet with shifts on all the edges below hybrid nodes, with values provided. The vector of values must have the same length as the number of hybrids in the network.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getShiftEdgeNumber","page":"Public","title":"PhyloNetworks.getShiftEdgeNumber","text":"getShiftEdgeNumber(shift::ShiftNet)\n\nGet the edge numbers where the shifts are located, for an object ShiftNet. If a shift is placed at the root node with no parent edge, the edge number of a shift is set to -1 (as if missing).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getShiftValue","page":"Public","title":"PhyloNetworks.getShiftValue","text":"getShiftValue(shift::ShiftNet)\n\nGet the values of the shifts, for an object ShiftNet.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.descendenceMatrix","page":"Public","title":"PhyloNetworks.descendenceMatrix","text":"descendenceMatrix(net::HybridNetwork; checkPreorder=true::Bool)\n\nDescendence matrix between all the nodes of a network: object D of type MatrixTopologicalOrder in which D[i,j] is the proportion of genetic material in node i that can be traced back to node j. If D[i,j]>0 then j is a descendent of i (and j is an ancestor of i). The network is assumed to be pre-ordered if checkPreorder is false. If checkPreorder is true (default), preorder! is run on the network beforehand.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.regressorShift","page":"Public","title":"PhyloNetworks.regressorShift","text":"regressorShift(node::Vector{Node}, net::HybridNetwork; checkPreorder=true)\nregressorShift(edge::Vector{Edge}, net::HybridNetwork; checkPreorder=true)\n\nCompute the regressor vectors associated with shifts on edges that are above nodes node, or on edges edge, on a network net. It uses function descendenceMatrix, so net might be modified to sort it in a pre-order. Return a DataFrame with as many rows as there are tips in net, and a column for each shift, each labelled according to the pattern shift{numberof_edge}. It has an aditional column labelled tipNames to allow easy fitting afterward (see example).\n\nExamples\n\njulia> net = readTopology(\"(A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5);\");\n\njulia> preorder!(net)\n\njulia> using PhyloPlots\n\njulia> plot(net, :RCall, showNodeNumber=true); # to locate nodes\n\njulia> nodes_shifts = indexin([1,-5], [n.number for n in net.node]) # Put a shift on edges ending at nodes 1 and -5\n2-element Vector{Union{Nothing, Int64}}:\n 1\n 7\n\njulia> params = ParamsBM(10, 0.1, ShiftNet(net.node[nodes_shifts], [3.0, -3.0],  net))\nParamsBM:\nParameters of a BM with fixed root:\nmu: 10\nSigma2: 0.1\n\nThere are 2 shifts on the network:\n──────────────────────────\n  Edge Number  Shift Value\n──────────────────────────\n          8.0         -3.0\n          1.0          3.0\n──────────────────────────\n\njulia> using Random; Random.seed!(2468); # sets the seed for reproducibility\n\njulia> sim = simulate(net, params); # simulate a dataset with shifts\n\njulia> using DataFrames # to handle data frames\n\njulia> dat = DataFrame(trait = sim[:Tips], tipNames = sim.M.tipNames)\n4×2 DataFrame\n Row │ trait     tipNames \n     │ Float64   String   \n─────┼────────────────────\n   1 │ 13.392    A\n   2 │  9.55741  B\n   3 │  7.17704  C\n   4 │  7.88906  D\n\njulia> dfr_shift = regressorShift(net.node[nodes_shifts], net) # the regressors matching the shifts.\n4×3 DataFrame\n Row │ shift_1  shift_8  tipNames \n     │ Float64  Float64  String   \n─────┼────────────────────────────\n   1 │     1.0      0.0  A\n   2 │     0.0      0.0  B\n   3 │     0.0      1.0  C\n   4 │     0.0      0.6  D\n\njulia> dfr = innerjoin(dat, dfr_shift, on=:tipNames); # join data and regressors in a single dataframe\n\njulia> using StatsModels # for statistical model formulas\n\njulia> fitBM = phylolm(@formula(trait ~ shift_1 + shift_8), dfr, net; reml=false) # actual fit\nStatsModels.TableRegressionModel{PhyloNetworkLinearModel, Matrix{Float64}}\n\nFormula: trait ~ 1 + shift_1 + shift_8\n\nModel: Brownian motion\n\nParameter Estimates, using ML:\nphylogenetic variance rate: 0.0112618\n\nCoefficients:\n────────────────────────────────────────────────────────────────────────\n                Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n────────────────────────────────────────────────────────────────────────\n(Intercept)   9.48238    0.327089  28.99    0.0220    5.32632   13.6384\nshift_1       3.9096     0.46862    8.34    0.0759   -2.04479    9.86399\nshift_8      -2.4179     0.422825  -5.72    0.1102   -7.7904     2.95461\n────────────────────────────────────────────────────────────────────────\nLog Likelihood: 1.8937302027\nAIC: 4.2125395947\n\n\nSee also\n\nphylolm, descendenceMatrix, regressorHybrid.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.regressorHybrid","page":"Public","title":"PhyloNetworks.regressorHybrid","text":"regressorHybrid(net::HybridNetwork; checkPreorder=true::Bool)\n\nCompute the regressor vectors associated with shifts on edges that imediatly below all hybrid nodes of net. It uses function descendenceMatrix through a call to regressorShift, so net might be modified to sort it in a pre-order. Return a DataFrame with as many rows as there are tips in net, and a column for each hybrid, each labelled according to the pattern shift{numberof_edge}. It has an aditional column labelled tipNames to allow easy fitting afterward (see example).\n\nThis function can be used to test for heterosis.\n\nExamples\n\njulia> using DataFrames # Needed to handle data frames.\n\njulia> net = readTopology(\"(A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5);\");\n\njulia> preorder!(net)\n\njulia> using PhyloPlots\n\njulia> plot(net, :RCall, showNodeNumber=true); # to locate nodes: node 5 is child of hybrid node\n\njulia> nodes_hybrids = indexin([5], [n.number for n in net.node]) # Put a shift on edges below hybrids\n1-element Vector{Union{Nothing, Int64}}:\n 5\n\njulia> params = ParamsBM(10, 0.1, ShiftNet(net.node[nodes_hybrids], [3.0],  net))\nParamsBM:\nParameters of a BM with fixed root:\nmu: 10\nSigma2: 0.1\n\nThere are 1 shifts on the network:\n──────────────────────────\n  Edge Number  Shift Value\n──────────────────────────\n          6.0          3.0\n──────────────────────────\n\n\njulia> using Random; Random.seed!(2468); # sets the seed for reproducibility\n\njulia> sim = simulate(net, params); # simulate a dataset with shifts\n\njulia> dat = DataFrame(trait = sim[:Tips], tipNames = sim.M.tipNames)\n4×2 DataFrame\n Row │ trait     tipNames \n     │ Float64   String   \n─────┼────────────────────\n   1 │ 10.392    A\n   2 │  9.55741  B\n   3 │ 10.177    C\n   4 │ 12.6891   D\n\njulia> dfr_hybrid = regressorHybrid(net) # the regressors matching the hybrids.\n4×3 DataFrame\n Row │ shift_6  tipNames  sum     \n     │ Float64  String    Float64 \n─────┼────────────────────────────\n   1 │     0.0  A             0.0\n   2 │     0.0  B             0.0\n   3 │     0.0  C             0.0\n   4 │     1.0  D             1.0\n\njulia> dfr = innerjoin(dat, dfr_hybrid, on=:tipNames); # join data and regressors in a single dataframe\n\njulia> using StatsModels\n\njulia> fitBM = phylolm(@formula(trait ~ shift_6), dfr, net; reml=false) # actual fit\nStatsModels.TableRegressionModel{PhyloNetworkLinearModel, Matrix{Float64}}\n\nFormula: trait ~ 1 + shift_6\n\nModel: Brownian motion\n\nParameter Estimates, using ML:\nphylogenetic variance rate: 0.041206\n\nCoefficients:\n────────────────────────────────────────────────────────────────────────\n                Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n────────────────────────────────────────────────────────────────────────\n(Intercept)  10.064      0.277959  36.21    0.0008    8.86805   11.26\nshift_6       2.72526    0.315456   8.64    0.0131    1.36796    4.08256\n────────────────────────────────────────────────────────────────────────\nLog Likelihood: -0.7006021946\nAIC: 7.4012043891\n\n\nSee also\n\nphylolm, descendenceMatrix, regressorShift.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.sharedPathMatrix","page":"Public","title":"PhyloNetworks.sharedPathMatrix","text":"sharedPathMatrix(net::HybridNetwork; checkPreorder=true::Bool)\n\nThis function computes the shared path matrix between all the nodes of a network. It assumes that the network is in the pre-order. If checkPreorder is true (default), then it runs function preorder! on the network beforehand.\n\nReturns an object of type MatrixTopologicalOrder.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.vcv","page":"Public","title":"PhyloNetworks.vcv","text":"vcv(net::HybridNetwork; model=\"BM\"::AbstractString,\n                        corr=false::Bool,\n                        checkPreorder=true::Bool)\n\nThis function computes the variance covariance matrix between the tips of the network, assuming a Brownian model of trait evolution (with unit variance). If optional argument corr is set to true, then the correlation matrix is returned instead.\n\nThe function returns a DataFrame object, with columns named by the tips of the network.\n\nThe calculation of the covariance matrix requires a pre-ordering of nodes to be fast. If checkPreorder is true (default), then preorder! is run on the network beforehand. Otherwise, the network is assumed to be already in pre-order.\n\nThis function internally calls sharedPathMatrix, which computes the variance matrix between all the nodes of the network.\n\nExamples\n\njulia> tree_str = \"(((t2:0.14,t4:0.33):0.59,t3:0.96):0.14,(t5:0.70,t1:0.18):0.90);\";\n\njulia> tree = readTopology(tree_str);\n\njulia> C = vcv(tree)\n5×5 DataFrame\n Row │ t2       t4       t3       t5       t1      \n     │ Float64  Float64  Float64  Float64  Float64 \n─────┼─────────────────────────────────────────────\n   1 │    0.87     0.73     0.14      0.0     0.0\n   2 │    0.73     1.06     0.14      0.0     0.0\n   3 │    0.14     0.14     1.1       0.0     0.0\n   4 │    0.0      0.0      0.0       1.6     0.9\n   5 │    0.0      0.0      0.0       0.9     1.08\n\n\nThe following block needs ape to be installed (not run):\n\njulia> using RCall # Comparison with ape vcv function\n\njulia> R\"ape::vcv(ape::read.tree(text = $tree_str))\"\nRCall.RObject{RCall.RealSxp}\n     t2   t4   t3  t5   t1\nt2 0.87 0.73 0.14 0.0 0.00\nt4 0.73 1.06 0.14 0.0 0.00\nt3 0.14 0.14 1.10 0.0 0.00\nt5 0.00 0.00 0.00 1.6 0.90\nt1 0.00 0.00 0.00 0.9 1.08\n\n\nThe covariance can also be calculated on a network (for the model, see Bastide et al. 2018)\n\njulia> net = readTopology(\"((t1:1.0,#H1:0.1::0.30):0.5,((t2:0.9)#H1:0.2::0.70,t3:1.1):0.4);\");\n\njulia> C = vcv(net)\n3×3 DataFrame\n Row │ t1       t2       t3      \n     │ Float64  Float64  Float64 \n─────┼───────────────────────────\n   1 │    1.5     0.15      0.0\n   2 │    0.15    1.248     0.28\n   3 │    0.0     0.28      1.5\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#discrete-trait-evolution","page":"Public","title":"discrete trait evolution","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"parsimonySoftwired\nparsimonyGF\nQ\nrandomTrait\nrandomTrait!\nfitdiscrete\nmaxParsimonyNet\nnstates\nstationary\nempiricalDNAfrequencies","category":"page"},{"location":"lib/public/#PhyloNetworks.parsimonySoftwired","page":"Public","title":"PhyloNetworks.parsimonySoftwired","text":"parsimonySoftwired(net, tipdata)\nparsimonySoftwired(net, species, sequences)\n\nCalculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network.\n\nData can given in one of the following:\n\ntipdata: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named \"taxon\" or \"species\", and  trait values are to appear in column 2 or in a column named \"trait\".\ntipdata: dictionary taxon => state, for a single trait.\nspecies: array of strings, and sequences: array of sequences,  in the order corresponding to the order of species names.\n\nalgorithm\n\nThe dynamic programming algorithm by Fischer et al. (2015) is used. The function loops over all the displayed subtrees within a blob (biconnected component), so its complexity is of the order of n * m * c^2 * 2^level where n is the number of tips, m the number of traits, c the number of states, and level is the level of the network: the maximum number of hybridizations within a blob.\n\nSee parsimonyGF for a different algorithm, slower but extendable to other parsimony criteria.\n\nreferences\n\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.parsimonyGF","page":"Public","title":"PhyloNetworks.parsimonyGF","text":"parsimonyGF(net, tip_dictionary, criterion=:softwired)\nparsimonyGF(net, species, sequenceData, criterion=:softwired)\n\nCalculate the most parsimonious score of a network given discrete characters at the tips using a general framework (Van Iersel et al. 2018) allowing for various parsimony criteria: softwired (default), hardwired, parental etc. Only softwired is implemented at the moment.\n\nData can given in one of the following:\n\ntipdata: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named \"taxon\" or \"species\", and  trait values are to appear in column 2 or in a column named \"trait\".\ntipdata: dictionary taxon => state, for a single trait.\nspecies: array of strings, and sequences: array of sequences,   in the order corresponding to the order of species names.\n\nalgorithm\n\nThe complexity of the algorithm is exponential in the level of the network, that is, the maximum number of hybridizations in a single blob, or biconnected component (Fischer et al. 2015). The function loops over all the state assignments of the minor parent of each hybrid node within a blob, so its complexity is of the order of n * m * c^2 * c^level where n is the number of tips, m the number of traits and c the number of states.\n\nSee parsimonySoftwired for a faster algorithm, but solving the softwired criterion only.\n\nreferences\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\nUse the recursive helper function parsimonyBottomUpGF!. Use the fields isChild1, isExtBadTriangle to know which nodes are at the root of a blob, and fromBadDiamondI to know which edges are cut (below the minor parent of each hybrid).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.Q","page":"Public","title":"PhyloNetworks.Q","text":"Q(model)\n\nSubstitution rate matrix for a given substitution model: Q[i,j] is the rate of transitioning from state i to state j.\n\n\n\n\n\nFor a BinaryTraitSubstitutionModel, the rate matrix Q is of the form:\n\n-α  α\n β -β\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.randomTrait","page":"Public","title":"PhyloNetworks.randomTrait","text":"randomTrait(model, t, start)\nrandomTrait!(end, model, t, start)\n\nSimulate traits along one edge of length t. start must be a vector of integers, each representing the starting value of one trait. The bang version (ending with !) uses the vector end to store the simulated values.\n\nExamples\n\njulia> m1 = BinaryTraitSubstitutionModel(1.0, 2.0)\nBinary Trait Substitution Model:\nrate 0→1 α=1.0\nrate 1→0 β=2.0\n\njulia> using Random; Random.seed!(12345);\n\njulia> randomTrait(m1, 0.2, [1,2,1,2,2])\n5-element Vector{Int64}:\n 1\n 2\n 1\n 1\n 2\n\n\n\n\n\nrandomTrait(model, net; ntraits=1, keepInternal=true, checkPreorder=true)\n\nSimulate evolution of discrete traits on a rooted evolutionary network based on the supplied evolutionary model. Trait sampling is uniform at the root.\n\noptional arguments:\n\nntraits: number of traits to be simulated (default: 1 trait).\nkeepInternal: if true, export character states at all nodes, including internal nodes. if false, export character states at tips only.\n\noutput:\n\nmatrix of character states with one row per trait, one column per node; these states are indices in model.label, not the trait labels themselves.\nvector of node labels (for tips) or node numbers (for internal nodes) in the same order as columns in the character state matrix\n\nexamples\n\njulia> m1 = BinaryTraitSubstitutionModel(1.0, 2.0, [\"low\",\"high\"]);\n\njulia> net = readTopology(\"(((A:4.0,(B:1.0)#H1:1.1::0.9):0.5,(C:0.6,#H1:1.0::0.1):1.0):3.0,D:5.0);\");\n\njulia> using Random; Random.seed!(235);\n\njulia> trait, lab = randomTrait(m1, net)\n([1 2 … 1 1], [\"-2\", \"D\", \"-3\", \"-6\", \"C\", \"-4\", \"H1\", \"B\", \"A\"])\n\njulia> trait\n1×9 Matrix{Int64}:\n 1  2  1  1  2  2  1  1  1\n\njulia> lab\n9-element Vector{String}:\n \"-2\" \n \"D\"  \n \"-3\" \n \"-6\" \n \"C\"  \n \"-4\" \n \"H1\"\n \"B\"  \n \"A\"  \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.randomTrait!","page":"Public","title":"PhyloNetworks.randomTrait!","text":"randomTrait(model, t, start)\nrandomTrait!(end, model, t, start)\n\nSimulate traits along one edge of length t. start must be a vector of integers, each representing the starting value of one trait. The bang version (ending with !) uses the vector end to store the simulated values.\n\nExamples\n\njulia> m1 = BinaryTraitSubstitutionModel(1.0, 2.0)\nBinary Trait Substitution Model:\nrate 0→1 α=1.0\nrate 1→0 β=2.0\n\njulia> using Random; Random.seed!(12345);\n\njulia> randomTrait(m1, 0.2, [1,2,1,2,2])\n5-element Vector{Int64}:\n 1\n 2\n 1\n 1\n 2\n\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.fitdiscrete","page":"Public","title":"PhyloNetworks.fitdiscrete","text":"fitdiscrete(net, model, tipdata)\nfitdiscrete(net, model, RateVariationAcrossSites, tipdata)\nfitdiscrete(net, model, species, traits)\nfitdiscrete(net, model, RateVariationAcrossSites, species, traits)\nfitdiscrete(net, model, dnadata, dnapatternweights)\nfitdiscrete(net, model, RateVariationAcrossSites, dnadata, dnapatternweights)\nfitdiscrete(net, modSymbol, species, traits)\nfitdiscrete(net, modSymbol, dnadata, dnapatternweights)\n\nCalculate the maximum likelihood (ML) score of a network or tree given one or more discrete characters at the tips. Along each edge, transitions are modelled with a continous time Markov model, whose parameters are estimated (by maximizing the likelihood). At each hybrid node, the trait is assumed to be inherited from either of the two immediate parents according to the parents' average genetic contributions (inheritance γ). The model ignores incomplete lineage sorting. The algorithm extracts all trees displayed in the network.\n\nData can given in one of the following:\n\ntipdata: dictionary taxon => state label, for a single trait.\ntipdata: data frame for a single trait, in which case the taxon names are to appear in column 1 or in a column named \"taxon\" or \"species\", and trait labels are to appear in column 2 or in a column named \"trait\". Here, trait labels should be as they appear in getlabels(model).\nspecies: vector of strings, and traits: DataFrame of traits, with rows in the order corresponding to the order of species names. Again, trait labels should be as they appear in getlabels(model). All traits are assumed to follow the same model, with same parameters.\ndnadata: the first part of the output of readfastatodna, a dataframe of BioSequence DNA sequences, with taxon in column 1 and a column for each site.\ndnapatternweights: the second part of the output of readfastatodna, an array of weights, one weights for each of the site columns. The length of the weight is equal to nsites. If using dnapatternweights, must provide dnadata.\nRateVariationAcrossSites: model for rate variation (optional)\n\nOptional arguments (default):\n\noptimizeQ (true): should model rate parameters be fixed, or should they be optimized?\noptimizeRVAS (true): should the model optimize the parameters for the variability of rates across sites (α and/or p_invariable)?\nNLoptMethod (:LN_COBYLA, derivative-free) for the optimization algorithm. For other options, see the NLopt.\ntolerance values to control when the optimization is stopped: ftolRel (1e-12), ftolAbs (1e-10) on the likelihood, and xtolRel (1e-10), xtolAbs (1e-10) on the model parameters.\nbounds for the alpha parameter of the Gamma distribution of rates across sites: alphamin=0.05, alphamax=50.\nverbose (false): if true, more information is output.\n\nexamples:\n\njulia> net = readTopology(\"(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\");\n\njulia> m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [\"lo\", \"hi\"]);\n\njulia> using DataFrames\n\njulia> dat = DataFrame(species=[\"C\",\"A\",\"B\",\"D\"], trait=[\"hi\",\"lo\",\"lo\",\"hi\"]);\n\njulia> fit1 = fitdiscrete(net, m1, dat)\nPhyloNetworks.StatisticalSubstitutionModel:\nBinary Trait Substitution Model:\n  rate lo→hi α=0.27222\n  rate hi→lo β=0.34981\non a network with 1 reticulations\ndata:\n  4 species\n  1 trait\nlog-likelihood: -2.7277\n\njulia> tips = Dict(\"A\" => \"lo\", \"B\" => \"lo\", \"C\" => \"hi\", \"D\" => \"hi\");\n\njulia> fit2 = fitdiscrete(net, m1, tips; xtolRel=1e-16, xtolAbs=1e-16, ftolRel=1e-16)\nPhyloNetworks.StatisticalSubstitutionModel:\nBinary Trait Substitution Model:\n  rate lo→hi α=0.27222\n  rate hi→lo β=0.34981\non a network with 1 reticulations\ndata:\n  4 species\n  1 trait\nlog-likelihood: -2.7277\n\nNote that a copy of the network is stored in the fitted object, but the internal representation of the network may be different in fit1.net and in the original network net:\n\njulia> net = readTopology(\"(sp1:3.0,(sp2:2.0,(sp3:1.0,sp4:1.0):1.0):1.0);\");\n\njulia> using BioSymbols\n\njulia> tips = Dict(\"sp1\" => BioSymbols.DNA_A, \"sp2\" => BioSymbols.DNA_A, \"sp3\" => BioSymbols.DNA_G, \"sp4\" => BioSymbols.DNA_G);\n\njulia> mJC69 = JC69([0.25], false);\n\njulia> fitJC69 = fitdiscrete(net, mJC69, tips)\nPhyloNetworks.StatisticalSubstitutionModel:\nJukes and Cantor 69 Substitution Model,\n  absolute rate version\n  off-diagonal rates equal to 0.29233/3.\n  rate matrix Q:\n                 A       C       G       T\n         A       *  0.0974  0.0974  0.0974\n         C  0.0974       *  0.0974  0.0974\n         G  0.0974  0.0974       *  0.0974\n         T  0.0974  0.0974  0.0974       *\non a network with 0 reticulations\ndata:\n  4 species\n  1 trait\nlog-likelihood: -4.99274\n\njulia> rv = RateVariationAcrossSites(alpha=1.0, ncat=4)\nRate variation across sites: discretized Gamma\nalpha: 1.0\ncategories for Gamma discretization: 4\nrates: [0.146, 0.513, 1.071, 2.27]\n\njulia> fitdiscrete(net, mJC69, rv, tips; optimizeQ=false, optimizeRVAS=false)\nPhyloNetworks.StatisticalSubstitutionModel:\nJukes and Cantor 69 Substitution Model,\n  absolute rate version\n  off-diagonal rates equal to 0.25/3.\n  rate matrix Q:\n                 A       C       G       T\n         A       *  0.0833  0.0833  0.0833\n         C  0.0833       *  0.0833  0.0833\n         G  0.0833  0.0833       *  0.0833\n         T  0.0833  0.0833  0.0833       *\nRate variation across sites: discretized Gamma\n  alpha: 1.0\n  categories for Gamma discretization: 4\n  rates: [0.146, 0.513, 1.071, 2.27]\non a network with 0 reticulations\ndata:\n  4 species\n  1 trait\nlog-likelihood: -5.2568\n\n\nfixit: add option to allow users to specify root prior, using either equal frequencies or stationary frequencies for trait models.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.maxParsimonyNet","page":"Public","title":"PhyloNetworks.maxParsimonyNet","text":"maxParsimonyNet(T::HybridNetwork, df::DataFrame)\n\nSearch for the most parsimonious network (or tree). A level-1 network is assumed. df should be a data frame containing the species names in column 1, or in a column named species or taxon. Trait data are assumed to be in all other columns. The search starts from topology T, which can be a tree or a network with no more than hmax hybrid nodes (see optional arguments below for hmax).\n\nOutput:\n\nestimated network in file .out (also in .log): best network overall and list of networks from each individual run.\nif any error occurred, file .err provides information (seed) to reproduce the error.\n\nOptional arguments include\n\nhmax: maximum number of hybridizations allowed (default 1)\nruns: number of starting points for the search (default 10); each starting point is T with probability probST=0.3 or a modification of T otherwise (using a NNI move, or a hybrid edge direction change)\nNfail: number of failures (proposed networks with equal or worse score) before the search is aborted. 75 by default: this is quite small, which is okay for a first trial. Larger values are recommended.\noutgroup: outgroup taxon.           It can be a taxon name (String) or Node number (Integer).           If none provided, or if the outgroup conflicts the starting           topology, the function returns an error\nfilename: root name for the output files. Default is \"mp\". If empty (\"\"), files are not created, progress log goes to the screen only (standard out).\nseed: seed to replicate a given search\ncriterion: parsimony score could be hardwired, softwired (default) or parental. Currently,            only softwired is implemented\n\nReferences\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\nFor a roadmap of the functions inside maxParsimonyNet, see maxParsimonyNetRun1!.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.nstates","page":"Public","title":"PhyloNetworks.nstates","text":"nstates(model)\n\nNumber of character states for a given evolution model.\n\n\n\n\n\nFor example, this is 4 for a NucleicAcidSubstitutionModel.\n\njulia> nstates(JC69([0.03], false))\n4\n\njulia> nstates(HKY85([.5], [0.25, 0.25, 0.25, 0.25]))\n4\n\n\n\n\n\nfor a BinaryTraitSubstitutionModel, this is 2:\n\njulia> m1 = BinaryTraitSubstitutionModel([1.0,2.0], [\"low\",\"high\"])\nBinary Trait Substitution Model:\nrate low→high α=1.0\nrate high→low β=2.0\n\njulia> nstates(m1)\n2\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.stationary","page":"Public","title":"PhyloNetworks.stationary","text":"stationary(substitutionmodel)\n\nStationary distribution of a Markov model\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.empiricalDNAfrequencies","page":"Public","title":"PhyloNetworks.empiricalDNAfrequencies","text":"empiricalDNAfrequencies(DNAdata::AbstractDataFrame, DNAweights,\n                        correction=true, useambiguous=true)\n\nEstimate base frequencies in DNA data DNAdata, ordered ACGT.\n\nDNAdata: data frame. All columns are used. If the first column gives species names, find a way to ignore it before calculating empirical frequencies, e.g. empiricalDNAfrequencies(view(DNAdata, :, 2:size(DNAdata, 2))). Data type must be BioSymbols.DNA or Char or String. WARNING: this is checked on the first column only.\nDNAweights: vector of weights, to weigh each column in DNAdata.\ncorrection: if true, add 1 to each count and 4 to the denominator for a more stable estimator, similar to Bayes prior of 1/4 and the Agresti-Coull interval in binomial estimation.\nuseambiguous: if true, ambiguous bases are used (except gaps and Ns). For example, Y adds 0.5 weight to C and 0.5 weight to T.\n\n\n\n\n\n","category":"function"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"using PhyloNetworks\nmkpath(\"../assets/figures\")","category":"page"},{"location":"man/trait_tree/#Continuous-Trait-Evolution","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Once the network is inferred, we can take these species relationships into account when studying the distribution of quantitative traits measured for extant species. This is the goal of phylogenetic comparative methods (PCM). More details can be found on the developments below in Bastide et al. 2018 [B18]","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"We assume a fixed network, correctly rooted, with branch lengths proportional to calendar time. Here, we consider the true network that was used in the previous sections, and which is ultrametric (all the tips are contemporary).","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"truenet = readTopology(\"((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\");","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"As previously, we can plot the network thanks to the RCall package. The name function is only instrumental here, to ensure that the figure is saved in the correct directory when the documentation is built. We only show the commands to actually save the plot in this first example for the interested reader, but we will hide those in the rest of the chapter, for the sake of clarity.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"using PhyloPlots, RCall\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\"\nR\"svg(name('truenet.svg'), width=8, height=4)\"\nR\"par\"(mar=[0,0,0,0])\nplot(truenet, :R, useEdgeLength=true, showGamma=true);\nR\"dev.off()\"\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"(Image: truenet)","category":"page"},{"location":"man/trait_tree/#Model-and-Variance-Matrix","page":"Continuous Trait Evolution","title":"Model and Variance Matrix","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Assuming that the network is known and that the continuous traits evolve like a Brownian Motion (BM) in time, it is possible to compute the expected variance covariance matrix between tip measurements. This can be done using function vcv, whose syntax is inspired from the well known corresponding ape function.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"C = vcv(truenet)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"The matrix is returned as a DataFrame, with columns named by the tips of the network to allow for easy identification. Each row also corresponds to a tip in the network, and rows are ordered in the same way as columns.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"The computation of this matrix is based on the more general function sharedPathMatrix. It is at the core of all the Phylogenetic Comparative Methods described below.","category":"page"},{"location":"man/trait_tree/#Trait-simulation","page":"Continuous Trait Evolution","title":"Trait simulation","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"We start by generating continuous traits to study. We simulate three traits on the network (two independent, one dependent), using a Brownian Motion (BM) model of trait evolution on the network. We start by choosing the parameters of the BM (ancestral mean and variance), by creating objects of class ParamsBM<:ParamsProcess.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"params_trait1 = ParamsBM( 2, 0.5) # BM with mean  2 and variance 0.5\nparams_trait2 = ParamsBM(-2, 1)   # BM with mean -2 and variance 1.0\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"We then simulate the independent traits according to these parameters, using function simulate (fixing the seed, for reproducibility).","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"using Random\nRandom.seed!(18480224);\nsim1 = simulate(truenet, params_trait1) # simulate a BM on truenet\nsim2 = simulate(truenet, params_trait2)\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"This creates objects of class TraitSimulation, from which we can extract the data at the tips, thanks to the method getindex(::TraitSimulation, ::Symbol).","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"trait1 = sim1[:Tips] # trait 1 at the tips (data)\ntrait2 = sim2[:Tips]\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"This extractor creates an Array with one column, and as many lines as the number of tips there are in the phylogeny.  It is sorted in the same order as the tips of the phylogeny used to simulate it.   If needed, we could also extract the simulated values at the internal nodes in the network:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"sim1[:InternalNodes]\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Finally, we generate the last trait correlated with trait 1 (but not trait 2), with phylogenetic noise.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Random.seed!(18700904);\nnoise = simulate(truenet, ParamsBM(0, 0.1)) # phylogenetic residuals\ntrait3 = 10 .+ 2 * trait1 .+ noise[:Tips] # trait to study. independent of trait2\nnothing # hide","category":"page"},{"location":"man/trait_tree/#Phylogenetic-regression","page":"Continuous Trait Evolution","title":"Phylogenetic regression","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Assume that we measured the three traits above, and that we wanted to study the impact of traits 1 and 2 on trait 3. To do that, we can perform a phylogenetic regression.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"In order to avoid confusion, the function takes in a DataFrame, that has an extra column with the names of the tips of the network, labeled tipNames. Here, we generated the traits ourselves, so they are all in the same order.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"using DataFrames\ndat = DataFrame(trait1 = trait1, trait2 = trait2, trait3 = trait3,\n                tipNames = tipLabels(sim1))","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Phylogenetic regression / ANOVA is based on the GLM package, with the network as an extra argument, using function phylolm.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"using StatsModels # for statistical model formulas\nfitTrait3 = phylolm(@formula(trait3 ~ trait1 + trait2), dat, truenet)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"The REML criterion is used by default, for estimating the variance parameter(s). ML could be used instead with option reml=false.   From this, we can see that the intercept, the coefficient for trait 1 and the variance of the noise are correctly estimated (given that there are only 6 taxa). In addition, the Student T test for the coefficient associated with trait 2 has a high p-value, which means that this coefficient is not significantly different from 0. This is consistent with the way we simulated trait 3.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"The function returns an object of type PhyloNetworkLinearModel<:GLM.LinPredModel. It is a subtype of the GLM type LinPredModel, which means that all base functions from Julia StatsBase can be applied to it. See the documentation for this type for a list of all functions that can be used. Some functions allow the user to retrieve directly the estimated parameters of the BM, and are specific to this object.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"sigma2_phylo(fitTrait3) # estimated variance of the BM\nmu_phylo(fitTrait3) # estimated root value of the BM","category":"page"},{"location":"man/trait_tree/#Ancestral-State-Reconstruction","page":"Continuous Trait Evolution","title":"Ancestral State Reconstruction","text":"","category":"section"},{"location":"man/trait_tree/#From-known-parameters","page":"Continuous Trait Evolution","title":"From known parameters","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"If we assume that we know the exact model of evolution that generated the traits, we can do ancestral trait reconstruction. Here, we simulated trait 1 ourselves, so we can use the true process, with the true parameters. In other words, we can reconstruct the state at the internal nodes, given the values at the tips, the known value at the root and the known BM variance.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"ancTrait1 = ancestralStateReconstruction(truenet, trait1, params_trait1)\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Function ancestralStateReconstruction creates an object with type ReconstructedStates. Several extractors can be applied to it:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"expectations(ancTrait1) # predictions\nusing StatsBase # for stderror(), aic(), likelihood() etc.\nstderror(ancTrait1) # associated standard errors\npredint(ancTrait1, level=0.9) # prediction interval (with level 90%)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"We can plot the ancestral states or prediction intervals on the tree, using the nodeLabel argument of the plot function.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"ancExpe = expectationsPlot(ancTrait1); # format expected ancestral states for the plot\nR\"svg(name('ancestral_expe.svg'), width=8, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, :R, nodeLabel = ancExpe);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"(Image: ancestral_expe)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"ancInt = predintPlot(ancTrait1) # format the prediction intervals for the plot\nR\"svg(name('ancestral_predint.svg'), width=8, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet,:R, nodeLabel = ancInt);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"(Image: ancestral_predint)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"The predint and predintPlot functions have an optional argument to state the level of the prediction interval. If not given, the default value is 0.95.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"It is also possible to plot both the reconstructed state and the predicted value on the same plot, using the optional keyword argument withExp. As shown below, we could also use the RCall method from the plot function.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"plot(truenet, :R, nodeLabel = predintPlot(ancTrait1, withExp=true));\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"These plots tend to be quite busy, even for small networks.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"As we know the true ancestral states here, we can compare them to our estimation.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"predictions = DataFrame(infPred=predint(ancTrait1)[1:7, 1],\n                        trueValue=sim1[:InternalNodes],\n                        supPred=predint(ancTrait1)[1:7, 2])","category":"page"},{"location":"man/trait_tree/#From-estimated-parameters","page":"Continuous Trait Evolution","title":"From estimated parameters","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"In real applications though, we do not have access to the true parameters of the process that generated the data. We can estimate it using the previous function. To fit a regular BM, we just need to do a regression of trait 1 against a simple intercept:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"fitTrait1 = phylolm(@formula(trait1 ~ 1), dat, truenet)\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"We can then apply the ancestralStateReconstruction function directly to the fitted object:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"ancTrait1Approx = ancestralStateReconstruction(fitTrait1)\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"The prediction intervals ignore the fact that we estimated the process parameters, so they are less accurate and the function throws a warning. The output is an object of the same ReconstructedStates type as earlier, and the same extractors can be applied to it:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"R\"svg(name('ancestral1.svg'), width=8, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, :R, nodeLabel = expectationsPlot(ancTrait1Approx));\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"(Image: ancestral1)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"For convenience, the two steps described above (fitting against the intercept, and then do ancestral state reconstruction) can be done all at once with a single call of the function ancestralStateReconstruction on a DataFrame with the trait to reconstruct, and the tip labels:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"datTrait1 = DataFrame(trait1 = trait1, tipNames = tipLabels(sim1))\nancTrait1Approx = ancestralStateReconstruction(datTrait1, truenet)\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"R\"svg(name('ancestral2.svg'), width=8, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, :R, nodeLabel = predintPlot(ancTrait1Approx, level=0.9));\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"(Image: ancestral2)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"This produces the exact same results. Here, we chose a level of 90% for the plotted prediction intervals.","category":"page"},{"location":"man/trait_tree/#Data-imputation","page":"Continuous Trait Evolution","title":"Data imputation","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Note that there is no theoretical difference between an internal node, for which we could not measure the value of the trait, and a missing value at a tip of the network. Consequently, the previous ancestralStateReconstruction function can be used to do data imputation. To see this, let's add some missing values in trait 1.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"allowmissing!(datTrait1, :trait1)\ndatTrait1[2, :trait1] = missing; # second row: for taxon C\nancTrait1Approx = ancestralStateReconstruction(datTrait1, truenet)\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"R\"svg(name('ancestral3.svg'), width=8, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, :R, nodeLabel = predintPlot(ancTrait1Approx));\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"(Image: ancestral3)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"A prediction interval is shown for the missing values.","category":"page"},{"location":"man/trait_tree/#With-known-predictors","page":"Continuous Trait Evolution","title":"With known predictors","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"At this point, it might be tempting to apply this function to trait 3 we simulated earlier as a linear combination of trait 1 and a phylogenetic noise. However, this cannot be done directly:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"ancTrait3 = ancestralStateReconstruction(fitTrait3) # Throws an error !","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"This is because the model we used to fit the trait (a regression with one predictor and an intercept) is not compatible with the simple model of Brownian evolution that we assumed for the ancestral state reconstruction. As the predictor used is not known for ancestral states, it is not possible to reconstruct the trait for this particular model.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"The only option we have is to provide the function with the predictor's ancestral states, if they are known. They are known indeed in this toy example that we generated ourselves, so we can reconstruct our trait doing the following:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"ancTrait3 = ancestralStateReconstruction(fitTrait3,\n              [ones(7, 1) sim1[:InternalNodes] sim2[:InternalNodes]])\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"R\"svg(name('ancestral4.svg'), width=8, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, :R, nodeLabel = predintPlot(ancTrait3));\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"(Image: ancestral4)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"where we provided the ancestral predictors as a matrix, containing the intercept, and the known predictor at the nodes. The user must be very careful with this function, as no check is done for the order of the predictors, that must be in the same order as the internal nodes of the phylogeny. As ancestral predictors are often unknown, the use of this functionality is discouraged.","category":"page"},{"location":"man/trait_tree/#Phylogenetic-ANOVA","page":"Continuous Trait Evolution","title":"Phylogenetic ANOVA","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"The phylolm function is based on the lm function from GLM. This means that it inherits from most of its features, and in particular, it can handle formulas with factors or interactions. For example, in lizards, we might want to do a regression of toe length against body length and the region where each species is found, where this region is coded into 4 categories (say). We might also want to include an interaction effect between body length and region. (This model has no biological basis. It is just meant to show the possibilities of the function).","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"To illustrate the use of categorical predictors of particular interest in a network with reticulations, let's assume that some transgressive evolution took place after the hybridization event, so that tips \"A\" and \"B\" have larger mean compared to the others (see [B18] for transgressive evolution after a reticulation event).","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"delta = 5.0; # value of heterosis\nunderHyb = [(n == \"A\" || n == \"B\") for n in tipLabels(sim1)] # tips under hybrid\nunderHyb\nfor i in 1:length(trait3)\n    underHyb[i] && (trait3[i]+=delta) # add delta to tips A and B\nend\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"trait3 # changed: +5 was added by the previous loop to A and B","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"The categorical variable underHyb separates tips \"A\" and \"B\" from the others. We need to consider it as a factor, not a numerical variable. One way is to make it a vector of strings, as done below. An alternative way would be to add and use the CategoricalArrays package, then transform the column underHyb to be categorical (shown in commments).","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"dat = DataFrame(trait1 = trait1, trait2 = trait2, trait3 = trait3,\n                underHyb = string.(underHyb),\n                tipNames = tipLabels(sim1))\n# using CategoricalArrays\n# transform!(dat, :underHyb => categorical, renamecols=false)\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"dat","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Now we can include this reticulation variable in the regression.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"fitTrait = phylolm(@formula(trait3 ~ trait1 + underHyb), dat, truenet)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"In this case, the categorical variable indicating which tips are descendants of the reticulation event is indeed relevant, and the transgressive evolution effect is recovered.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"This is a very simple example of how to include transgressive evolution, but some general functions to test for it, on networks with more than on hybrid, are also available.","category":"page"},{"location":"man/trait_tree/#Pagel's-Lambda","page":"Continuous Trait Evolution","title":"Pagel's Lambda","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"One classical question about trait evolution is the amount of \"phylogenetic signal\" in a dataset, that is, the importance of the tree structure to explain variation in the observed traits. One way of doing measuring that is to use Pagel's lambda transformation of the branch lengths [P99]. This model assumes a BM on a tree where the internal branches are multiplied by a factor λ, while the external branches are modified so that the total height of the tree is constant. Hence, λ varies between 0 (the tree has no influence on the data) and 1 (the tree is unchanged). Using the same branch length transformations, this model can be straightforwardly extended to phylogenetic networks.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"We can illustrate this with the predictor trait we used earlier. We use the same function as before, only indicating the model we want to use:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"fitPagel = phylolm(@formula(trait1 ~ 1), dat, truenet, model=\"lambda\")","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"As it is indeed generated according to a plain BM on the phylogeny, the estimated λ should be close to 1. It can be extracted with function lambda_estim:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"lambda_estim(fitPagel)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"For models in which the covariance is estimated, like Pagel's lambda, model comparisons should use a likelihood ratio test with the function lrtest, because the f-test (see below) is not applicable.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"If the models being compared have different predictors, then models should be fit with maximum likelihood instead of the default REML criterion in order to do a likelihood ratio test: use option reml=false for this.","category":"page"},{"location":"man/trait_tree/#Shifts-and-transgressive-evolution","page":"Continuous Trait Evolution","title":"Shifts and transgressive evolution","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"In the ANOVA section above, we showed how to include transgressive evolution in a simple case. In general, transgressive evolution can be seen as a particular example of a shifted BM on the phylogenetic network.","category":"page"},{"location":"man/trait_tree/#Simulation-of-a-Shifted-BM","page":"Continuous Trait Evolution","title":"Simulation of a Shifted BM","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"In a shifted BM, the trait evolves as a BM on the network most of the time, but shifts on some of the branches. The positions and values of the shifts can be stored in a ShiftNet object. For identifiability reasons, shifts are only allowed on tree-like branches. The position of the shifts can be given using vector of edges. To see this, let's first plot the network with its associated edges and node numbers.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"R\"svg(name('truenet_with_numbers.svg'), width=8, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, :R, useEdgeLength=true, showEdgeNumber=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"(Image: truenet_with_numbers)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Let's say that we want to add a shift with value 5.0 on the branch directly following the hybridization event, in order to model transgressive evolution. We can see on the plot above that this branch is number 6, so we define the following object:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"shift = ShiftNet(truenet.edge[6], 5.0,  truenet)\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Note that the edge numbers and values of a ShiftNet object can be retrieved thanks to functions getShiftEdgeNumber and getShiftValue. The constructor can take a single edge and associated value, like here, or two vectors of edges and matching values.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Because we often need to put shifts only on edges right after hybrids, there is a special function shiftHybrid to do that, so that  we do not have to find out their edges number. Here, the shift object could hence have been defined as:","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"shift = shiftHybrid(5.0,  truenet)","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"The parameters for the simulation are then defined as above, just adding the ShiftNet object as a parameter.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"params_sh = ParamsBM(2, 0.5, shift) # BM with mean 2, variance 0.5, and shifts.\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"The traits are simulated using the same function simulate, and extracted at the tips as before.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Random.seed!(18700904)\nsim_sh = simulate(truenet, params_sh) # simulate a shifted BM on truenet\ntrait_sh = sim_sh[:Tips]              # trait at the tips (data)\nnothing # hide","category":"page"},{"location":"man/trait_tree/#Fit-of-a-Shifted-BM","page":"Continuous Trait Evolution","title":"Fit of a Shifted BM","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Let's assume that we measured trait_sh, and that we want to test whether there were some ancestral hybridizations. To do that, we can use the  custom columns of the descendenceMatrix, that can be directly defined thanks to function regressorHybrid.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"df_shift = regressorHybrid(truenet) # Regressors matching Hybrid Shifts\nnothing # hide","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"This creates a dataframe, with as many columns as the number of hybrids in the network, each named according to the number of the edge after the hybrid. We can use this dataframe as regressors in the phylolm function.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"dat = DataFrame(trait = trait_sh, tipNames = tipLabels(sim_sh))  # Data\ndat = innerjoin(dat, df_shift, on=:tipNames)                     # join the two\nfit_sh = phylolm(@formula(trait ~ shift_6), dat, truenet) # fit","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Here, because there is only one hybrid in the network, we can directly see whether the ancestral transgressive evolution is significant or not thanks to the Student T test on the coefficient associated with shift_6. In more complex cases, it is possible to do a Fisher F test, thanks to the GLM function ftest.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"fit_null = phylolm(@formula(trait ~ 1), dat, truenet) # fit against the null (no shift)\nftest(fit_sh, fit_null)  # nested models","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Here, this test is equivalent to the Fisher F test, and gives the same p-value.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"Note that models need to be ordered by complexity, when given to ftest: either from most complex to most simple, or from most simple to most complex. In the output table, models are listed in the order in which they were given. If the most complex model is given first, as done above, the table lists the most complex H₁ (with shifts) first, and the null model H₀ is listed as the second model.","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"","category":"page"},{"location":"man/trait_tree/#References","page":"Continuous Trait Evolution","title":"References","text":"","category":"section"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"[B18]: Bastide, Solís-Lemus, Kriebel, Sparks, Ané (2018): Phylogenetic Comparative Methods for Phylogenetic Networks with Reticulations. Systematic Biology 67(5):800–820. doi:10.1093/sysbio/syy033","category":"page"},{"location":"man/trait_tree/","page":"Continuous Trait Evolution","title":"Continuous Trait Evolution","text":"[P99]: Pagel M (1999). Inferring the historical patterns of biological evolution. Nature. 401: 877–884. doi:10.1038/44766","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"using PhyloNetworks\nmkpath(\"../assets/figures\")\nraxmltrees = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"raxmltrees.tre\")\nraxmlCF = readTableCF(writeTableCF(countquartetsintrees(readMultiTopology(raxmltrees), showprogressbar=false)...))\nastralfile = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"astral.tre\")\nastraltree = readMultiTopology(astralfile)[102] # 102th tree = last tree here\nnet0 = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net0.out\"))\nnet1 = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net1.out\"))\nnet0.loglik = 53.53150526187732\nnet1.loglik = 28.31506721890958","category":"page"},{"location":"man/dist_reroot/#Comparing-and-manipulating-networks","page":"Network comparison and manipulation","title":"Comparing and manipulating networks","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Examples below follow those in Getting a Network.","category":"page"},{"location":"man/dist_reroot/#Comparing-networks-/-trees","page":"Network comparison and manipulation","title":"Comparing networks / trees","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Is the SNaQ tree (network with h=0) the same as the ASTRAL tree? We can calculate their Robinson-Foulds distance:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"hardwiredClusterDistance(astraltree, net0, false)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"The last option false is to consider topologies as unrooted. The RF distance is 0, so the two unrooted topologies are the same. If we had considered them as rooted, with whatever root they currently have in their internal representation, we would find a difference:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"hardwiredClusterDistance(astraltree, net0, true)","category":"page"},{"location":"man/dist_reroot/#Re-rooting-trees-and-networks","page":"Network comparison and manipulation","title":"Re-rooting trees and networks","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can re-root our networks with the outgroup, O, and then re-compare the ASTRAL tree and the SNaQ tree as rooted topologies (and find no difference):","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"rootatnode!(astraltree, \"O\")\nrootatnode!(net0, \"O\")\nhardwiredClusterDistance(astraltree, net0, true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"using PhyloPlots, RCall\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" \nR\"svg(name('net0_O.svg'), width=4, height=4)\" \nR\"par\"(mar=[0,0,0,0])\nplot(net0, :R);\nR\"dev.off()\" \nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: net0_O)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Note that, as in previous chapters, we use the possibilities of RCall to save the plot. We only show this commands once, but they will be run behind the scene each time a plot is called.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"After trees/networks are rooted with a correct outgroup, their visualization is more meaningful.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Networks can be re-rooted at a given node or along a given edge. Get help (type ?) on the functions rootatnode! and rootonedge! for more info. There are examples in the Bootstrap section.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"If the network is plotted with crossing edges, you may identify ways to rotate the children edges at some nodes to untangle some crossing edges. This can be done using the function rotate!. See an example in the Bootstrap section, or type ? then rotate!.","category":"page"},{"location":"man/dist_reroot/#What-if-the-root-conflicts-with-the-direction-of-a-reticulation?","page":"Network comparison and manipulation","title":"What if the root conflicts with the direction of a reticulation?","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"With 1 hybridization or more, the direction of hybrid edges constrain the position of the root. The root cannot be downstream of hybrid edges. Any hybrid node has to be younger than, or of the same age as both of its parents. So time has to flow \"downwards\" of any hybrid node, and the root cannot be placed \"below\" a hybrid node. An attempt to re-root the network at a position incompatible with hybrid edges will fail, with a RootMismatch error. To show an example, let's use the network below. We plotted the edge numbers, because we will want to use them later to place the root.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"net7taxa = readTopology(\"(C,D,((O,(E,#H7:::0.196):0.314):0.664,(B,((A1,A2))#H7:::0.804):10.0):10.0);\")\nR\"svg(name('reroot_net7taxa_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net7taxa, :R, showGamma=true, showEdgeNumber=true, tipOffset=0.2);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: reroot net7taxa 1)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Let's imagine that the A1 and A2 are our outgroups, and we estimated the network above. According to this network, time must flow from the hybrid node towards A1 and A2. So any attempt to reroot the network with A1 as outgroup, or with A2 as outgroup, or with the A clade (on edge 11), will fail with a RootMismatch error:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"rootatnode!(net7taxa, \"A1\"); # ERROR: RootMismatch: non-leaf node 5 had 0 children. ...\nrootatnode!(net7taxa, \"A2\"); # ERROR: RootMismatch (again)\nrootonedge!(net7taxa, 11);   # ERROR: RootMismatch (again)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"In this case, however, it is possible to root the network on either parent edge of the hybrid node. These edges have numbers 12 and 5, based on the plot above. We get these 2 rooted versions of the network:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"R\"svg(name('reroot_net7taxa_2.svg'), width=7, height=4)\"; # hide\nR\"layout(matrix(1:2,1,2))\";\nR\"par\"(mar=[0,0,0.5,0]); # hide\nrootonedge!(net7taxa, 12);\nplot(net7taxa, :R, showGamma=true, tipOffset=0.2);\nR\"mtext\"(\"rooted on hybrid edge 12 (major)\", line=-1)\nrootonedge!(net7taxa, 5);\nplot(net7taxa, :R, showGamma=true, tipOffset=0.2);\nR\"mtext\"(\"rooted on hybrid edge 5 (minor)\", line=-1);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: reroot net7taxa 2)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"On the second plot, the A clade does not appear to be an outgroup, but this is just because the plot follows the major tree primarily, based the major hybrid edges (those with γ>0.5). We can display the exact same network differently, by changing the γ inheritance values to invert the major/minor consideration of the hybrid edges.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"net7taxa.edge[5] # just to check that it's one of the 2 hybrid edges of interest\nsetGamma!(net7taxa.edge[5], 0.501) # switch major/minor edges\nR\"svg(name('reroot_net7taxa_3.svg'), width=4, height=4)\"; # hide\nR\"layout(matrix(1,1,1))\"; # hide\nR\"par\"(mar=[0,0,0,0]); # hide\nplot(net7taxa, :R, tipOffset=0.2); # not showing gamma values, because we changed them artificially\nR\"mtext\"(\"rooted on hybrid edge 5 (considered major)\", line=-1);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: reroot net7taxa 3)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Conclusion, in this particular example: it is possible to re-root the network to a place where the A clade is indeed an outgroup. But it did require some care, and we discovered that there are 2 acceptable rooting options. The first is more plausible, if we think that the species tree is the major tree, meaning that any gene flow or introgression event replaced less than 50% of the genes in the recipient population.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"In other cases, it may not be possible to re-root the network with a known outgroup. It would be the case if A1 was the only outgroup, and if A2 was an ingroup taxon. In such a case, the outgroup knowledge tells us that our estimated network is wrong. One (or more) reticulation in the network must be incorrect. Its placement might be correct, but then its direction would be incorrect. If the network was estimated via snaq!, check tips about Candidate networks compatible with a known outgroup.","category":"page"},{"location":"man/dist_reroot/#Extracting-the-major-tree","page":"Network comparison and manipulation","title":"Extracting the major tree","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can also compare the networks estimated with h=0 (net0) and h=1 (net1):","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"rootatnode!(net1, \"O\"); # the ; suppresses screen output\nhardwiredClusterDistance(net0, net1, true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"R\"svg(name('net1_O.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, showGamma=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: net1_O)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"They differ by 2 clusters: that's because A is of hybrid descent in net1, not in net0.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"To beyond this hybrid difference, we can extract the major tree from the network with 1 hybridization, that is, delete the hybrid edge supported by less than 50% of genes. Then we can compare this tree with the ASTRAL/SNaQ tree net0.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"tree1 = majorTree(net1); # major tree from net1\nhardwiredClusterDistance(net0, tree1, true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"They are identical (at distance 0), so here the species network with 1 hybrid node is a refinement of the estimated species tree (this needs not be the case always).","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Is the SNaQ network with 1 hybrid node the same as the true network, the one that was initially used to simulate the data?","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(digression on the data: gene trees were simulated under the coalescent along some \"true\" network, then 500 base-pair alignments were simulated along each gene tree with the HKY model, gene trees were estimated from each alignment with RAxML, and these estimated gene trees served as input to both ASTRAL and SNaQ.)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"The true network is shown below, correctly rooted at the outgroup O, and plotted with branch lengths proportional to their values in coalescence units:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"truenet = readTopology(\"((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\");\nhardwiredClusterDistance(net1, truenet, true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"R\"svg(name('truenet.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, :R, useEdgeLength=true, showGamma=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: truenet)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Our estimated network is not the same as the true network:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"the underlying tree is correctly estimated\nthe origin of gene flow is correctly estimated: E\nthe target of gene flow is not correctly estimated: it was the lineage ancestral to (A,B), but it is estimated to be A only.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"For networks, the distance here is the hardwired cluster distance: the number of hardwired clusters found in one network and not in the other. The hardwired cluster associated with an edge is the set of all tips descendant from that edge, i.e. all tips that inherited at least some genetic material from that edge.","category":"page"},{"location":"man/dist_reroot/#Displayed-trees-and-subnetworks","page":"Network comparison and manipulation","title":"Displayed trees and subnetworks","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can extract all trees displayed in a network. These trees are obtained by picking one parent hybrid edge at each hybrid node, and dropping the other parent hybrid edge. We can choose to pick the \"important\" hybrid edges only, with heritability γ at or above a threshold. Below we use a γ threshold of 0, so we get all displayed trees:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"t = displayedTrees(net1, 0.0) # list of trees displayed in network\nwriteTopology(t[1], round=true)\nwriteTopology(t[2], round=true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"If we decide to keep edges with γ>0.2 only, then we are left with a single tree in the list (the major tree). This is because our example has 1 hybrid node with minor γ=0.196.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"t = displayedTrees(net1, 0.2)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can also delete all \"non-important\" reticulations, those with a minor heritability γ below some threshold. The function below changes our network net1, as indicated by its name ending with a !.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"deleteHybridThreshold!(net1, 0.1)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Nothing happened to our network: because its γ is above 0.1. But if we set the threshold to 0.3, then our reticulation disappears:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"deleteHybridThreshold!(net1, 0.3)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"See also function displayedNetworkAt! to get the network with a single reticulation of interest, and eliminate all other reticulations.","category":"page"},{"location":"man/fixednetworkoptim/#Candidate-Networks","page":"Candidate Networks","title":"Candidate Networks","text":"","category":"section"},{"location":"man/fixednetworkoptim/#Optimizing-parameters-for-a-given-network","page":"Candidate Networks","title":"Optimizing parameters for a given network","text":"","category":"section"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"For a given network topology, we can optimize the branch lengths and inheritance probabilities (γ) with the pseudolikelihood. This is useful if we have a few candidate networks to compare. Each network can be optimized individually, and the network with the best pseudolikelihood can be chosen.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"The score being optimized is a pseudo-deviance, i.e. a multiple of the negative log pseudo-likelihood up to an additive constant (the lower the better; a pseudo-deviance of 0 corresponds to a perfect fit).","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"Following our example in Getting a Network, we can optimize parameters on the true network (the one originally used to simulate the data):","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"using PhyloNetworks\nusing Logging # to suppress info messages below\nbaselogger = global_logger()\nmkpath(\"../assets/figures\")\nraxmltrees = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"raxmltrees.tre\")\nraxmlCF = readTableCF(writeTableCF(countquartetsintrees(readMultiTopology(raxmltrees), showprogressbar=false)...))","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"truenet = readTopology(\"((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\");\nnet1alt = topologyMaxQPseudolik!(truenet, raxmlCF);\nwriteTopology(net1alt, round=true)\nnet1alt.loglik # pseudo deviance actually: the lower the better","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"using PhyloPlots, RCall\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('truenet_opt.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0])\nplot(net1alt, :R, showGamma=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"(Image: truenet_opt)","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"We get a score of 29.941, which is comparable to the score of the SNaQ network (net1: 28.315), especially compared to the score of the best tree (net0: 53.532). This begs the question: is the true network within the \"range\" of uncertainty? We can run a Bootstrap analysis to measure uncertainty in our network inference.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"For a more thorough optimization, we may increase the requirements before the search stops (but the optimization will take longer). It makes no difference on this small data set.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"net1par = topologyMaxQPseudolik!(truenet, raxmlCF, ftolRel=1e-10, xtolAbs=1e-10)\nnet1par.loglik # pseudo deviance, actually: the lower the better","category":"page"},{"location":"man/fixednetworkoptim/#Network-Score-with-no-optimization","page":"Candidate Networks","title":"Network Score with no optimization","text":"","category":"section"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"For a network with given branch lengths and γ heritabilies, we can compute the pseudolikelihood (well, a pseudo-deviance) with:","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"topologyQPseudolik!(truenet,raxmlCF);\ntruenet.loglik # again, pseudo deviance","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"This function is not maximizing the pseudolikelihood, it is simply computing the pseudolikelihood (or deviance) for the given branch lengths and probabilities of inheritance. At the moment, both of these functions require that the given network is of level 1 (cycles don't overlap).","category":"page"},{"location":"man/fixednetworkoptim/#Candidate-networks-compatible-with-a-known-outgroup","page":"Candidate Networks","title":"Candidate networks compatible with a known outgroup","text":"","category":"section"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"If the network was estimated via snaq!, it might turn out to be impossible to root our estimated network with a known outgroup (see section What if the root conflicts with the direction of a reticulation?.) At this time, snaq! does not impose any rooting constraint on the network: the search for the lowest score considers all level-1 networks, including those that are incompatible with a known outgroup. (The monophyly of outgroups is not imposed either, like in many other methods.)","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"If the estimated network cannot be rooted with the known outgroup, we can check the .networks output file. It has a list of networks that are slight modifications of the best network, where the modifications changed the direction of one reticulation at a time. For each modified network, the score was calculated. So if we find in this list a modified network that has a score close to that of the best network, and that can be re-rooted with our known root position, then this modified network is a better candidate than the network with the best score.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"Below is what the net1.networks file looks like, after performing the analysis in the section Network Estimation. Scroll to the right to see the scores.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"(C,D,((O,(E,#H7:::0.19558838614943078):0.31352437658618976):0.6640664399202987,(B,(A)#H7:::0.8044116138505693):10.0):10.0);, with -loglik 28.31506721890958 (best network found, remaining sorted by log-pseudolik; the smaller, the better)\n(C,D,((O,(E)#H7:::0.8150784689693145):0.9336405757682176,(B,(A,#H7:::0.18492153103068557):0.25386142779877724):1.8758156446611114):10.0);, with -loglik 31.535560380783814\n(B,#H7:9.90999345612101::0.2555404440833535,(A,(E,(O,((C,D):10.0)#H7:0.3419231810962026::0.7444595559166465):0.19994859441332047):2.5014911511063644):0.7957621793330066);, with -loglik 56.64548310161462\n(C,D,((O,(E,((B)#H7:::0.7957543284159452,A):4.786202415937916):0.004527712280136759):1.7952610454570868,#H7:::0.20424567158405482):10.0);, with -loglik 67.17775727492258\n(C,D,(#H7:::0.32947301811471164,(B,(A,(E,(O)#H7:::0.6705269818852884):1.371799259141243):0.0):6.397073999864152):7.677245926003807);, with -loglik 199.11401961057143","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"We can read this file and look at its list of networks like this:","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"file = \"net1.networks\";\n# or use the example file available with the package:\nfile = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net1.networks\");\nnetlist = readMultiTopology(file) # read the full list of networks in that file","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"Next, we would like to extract the network scores from the file. Below is a one-liner to do this (we make Julia send a sed command to the shell –sorry, Mac or Linux for this.)","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"scoresInString = read(`sed -E 's/.+with -loglik ([0-9]+.[0-9]+).+/\\1/' $file`, String)\nscores = parse.(Float64, split(scoresInString))\n# next: update the \"loglik\" of each network with the score read from the file\nfor i in eachindex(netlist)\n   netlist[i].loglik = scores[i]\n   println(\"net $i in the list: score = \",scores[i])\nend","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"The first network in the list is the best network returned by snaq!. We see that the second network has a score that's not too far, but the other networks have worse scores. The best network and its best modification (second network in the list) are shown below. We chose to show edge numbers, to use them later to re-root the networks.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"R\"svg(name('fixednetworkoptim_othernets1.svg'), width=7, height=4)\" # hide\nR\"layout(matrix(1:2,1,2))\"; # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(netlist[1], :R, showGamma=true, showEdgeNumber=true, tipOffset=0.1);\nR\"mtext\"(\"best net, score=28.3\", line=-1);\nplot(netlist[2], :R, showGamma=true, showEdgeNumber=true, tipOffset=0.1);\nR\"mtext\"(\"direction modified, score=31.5\", line=-1);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"(Image: othernets before reroot)","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"Now imagine that our outgroup is taxon A.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"best network: we would get a \"RootMismatch\" error if we tried to set the root on the external edge 9 to A, with rootatnode!(netlist[1], \"A\") (see section What if the root conflicts with the direction of a reticulation?). But we could root the best network on the major parent edge to A, edge 10 (rooted network on the left below).\nFor the second best network in our list, there are 2 ways to root it with A: on the external edge 8 to A (top right), or on its parent edge 10 (bottom right). These 2 options give quite different rooted versions of the network, one of which requires the existence of an unsampled taxon, sister to BOECD, that would have contributed to introgression into an ancestor of E. The second rooted version says that an ancestor of (or sister to) A contributed to the introgression into the ancestor of E. A is an outgroup in both cases, but the second case is more parsimonious, in the sense that it does not require the existence of an unsampled taxon.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"R\"svg(name('fixednetworkoptim_othernets2.svg'), width=7, height=7)\" # hide\nR\"layout(matrix(c(1,4,2,3),2,2))\"; # hide\nR\"par\"(mar=[0,0,0.5,0]) # hide\nrootonedge!(netlist[1], 10); # root best net to make A outgroup\nrotate!(netlist[1], -4); # to 'un-cross' edges\nrotate!(netlist[1], -6);\nplot(netlist[1], :R, showGamma=true, tipOffset=0.1);\nR\"mtext\"(\"best net, score=28.3\", line=-1);\nglobal_logger(NullLogger()); # hide\nrootatnode!(netlist[2], \"A\"); # net with modified direction: first way to make A outgroup\nglobal_logger(baselogger);   # hide\nplot(netlist[2], :R, showGamma=true, tipOffset=0.1);\nR\"mtext\"(\"second best in list, score=31.5\\nrequires unsampled population\", line=-2);\nrootonedge!(netlist[2], 10) # net with modified direction: second way to make A outgroup\nplot(netlist[2], :R, showGamma=true, tipOffset=0.1);\nR\"mtext\"(\"second best in list, score=31.5\\ndifferent root position\", line=-2);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate Networks","title":"Candidate Networks","text":"(Image: othernets after reroot)","category":"page"},{"location":"man/multiplealleles/#Multiple-alleles-per-species","page":"Multiple Alleles","title":"Multiple alleles per species","text":"","category":"section"},{"location":"man/multiplealleles/#between-species-4-taxon-sets","page":"Multiple Alleles","title":"between-species 4-taxon sets","text":"","category":"section"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"The default setting for SNaQ considers that each allele in a gene tree corresponds to a taxon (a tip) in the network. If instead each allele/individual can be mapped confidently to a species, and if only the species-level network needs to be estimated, then the following functions can be used:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"tm = DataFrame(CSV.File(mappingFile)) # taxon map as a data frame\ntaxonmap = Dict(tm[i,:allele] => tm[i,:species] for i in 1:110) # taxon map as a dictionary","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"The mapping file can be a text (or csv) file with two columns (at least): one column named allele and one named species, mapping each allele name to a species name. Next, read in the gene trees and calculate the quartet CFs at the species level:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"genetrees = readMultiTopology(genetreeFile)\ndf_sp = writeTableCF(countquartetsintrees(genetrees, taxonmap)...)","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"Now df_sp is a data frame containing the quartet concordance factors at the species level only, that is, considering sets made of 4 distinct species, even if the gene trees may have multiple alleles from the same species. For 4 distinct species A,B,C,D, all alleles from each species (A etc.) will be used to calculate the quartet CF. If a given gene tree has n_a alleles from a, n_b alleles from b etc., then each set of 4 alleles is given a weight of 1/(n_a n_b n_c n_d) to calculated of the CF for A,B,C,D (such that the total weight from this particular gene trees is 1). It is save to save this data frame, then use it for snaq! like this:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"CSV.write(\"tableCF_species.csv\", df)      # to save the data frame to a file\nd_sp = readTableCF(\"tableCF_species.csv\") # to get a \"DataCF\" object for use in snaq!.","category":"page"},{"location":"man/multiplealleles/#within-species-4-taxon-sets","page":"Multiple Alleles","title":"within-species 4-taxon sets","text":"","category":"section"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"Four-taxon sets involving 2 individuals per species can provide more information about the underlying network, including external branch length in coalescent units. However, snaq! runs more slowly when using this extra information. To get quartet CFs from sets of 4 individuals in which 2 individuals are from the same species, the following functions should be used:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"df_ind = writeTableCF(countquartetsintrees(genetrees)...) # no mapping here: so quartet CFs across individuals\nCSV.write(\"tableCF_individuals.csv\", df)               # to save to a file\ndf_sp = mapAllelesCFtable(mappingFile, \"tableCF_individuals.csv\");\nd_sp = readTableCF!(df_sp);","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"where the mapping file can be a text (or csv) file with two columns named allele and species, mapping each allele name to a species name. The data in df_ind is the table of concordance factors at the level of individuals. In other words, it list CFs using one row for each set of 4 alleles/individuals.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"mapAllelesCFtable creates a new data frame df_sp of quartet concordance factors at the species level: with the allele names replaced by the appropriate species names.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"Warnings:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"This procedure requires that all alleles from the same individual are given the same name (the individual's 'name') across all genes for which that individual was sequenced.\nFor a four-taxon set A,B,C,D, all the individuals from A, B, C and D are considered, say a1,b1,c1,d1, a2,b1,c1,d1, a1,b2,c1,d1, a2,b2,c1,d1 and so on. The CFs of these 4-taxon sets are averaged together to obtain the CFs at the species level. This procedures gives more weight to genes that have many alleles (because they contribute to more sets of 4 individuals) and less weight to genes that have few alleles.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"The last command modifies this data frame df_sp by deleting rows that are uninformative about between-species relationships, such as rows corresponding to 4 individuals from the same species. The output d_sp of this second command is an object of type DataCF at the species level, which can be used as input for networks estimation with snaq!. But before, it is safe to save the concordance factor of quartets of species, which can be calculated by averaging the CFs of quartets of individuals from the associated species:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"df_sp = writeTableCF(d_sp) # data frame, quartet CFs averaged across individuals of same species\nCSV.write(\"CFtable_species.csv\", df_sp) # save to file","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"Some quartets have the same species repeated twice, representing cases when 2 of the 4 individuals came from the same species. These quartets, with repeated species, are informative about the population size of extant populations, i.e. about the lengths of external branches in coalescent units.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"now we can run snaq:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"net = snaq!(T_sp, d_sp);","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"where T_sp should be a starting topology with one tip per species, labelled with the same species names as the names used in the mapping file.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"If snaq! takes too long that way, we can try a less ambitious estimation that does not estimate the external branch lengths, that is, without using quartets that have 2 individuals from the same species. To do so, we can use the quartet concordance factors at the species level, but filter out the quartets with one (or more) species repeated:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"df_sp = writeTableCF(d_sp) # some quartets have the same species twice\nfunction hasrep(row) # see if a row (4-taxon set) has a species name ending with \"__2\": repeated species\n  occursin(r\"__2$\", row[:tx1]) || occursin(r\"__2$\", row[:tx2]) ||\n    occursin(r\"__2$\", row[:tx3]) || occursin(r\"__2$\", row[:tx4])\nend\ndf_sp_reduced = filter(!hasrep, df_sp) # removes rows with repeated species\ndf_sp_reduced # should have fewer rows than df_sp\nCSV.write(\"CFtable_species_norep.csv\", df_sp_reduced) # to save to file\nd_sp_reduced = readTableCF(df_sp_reduced) # DataCF object, for input to snaq!","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"and now we can run snaq! on the reduced set of quartets without repeats, which should be faster:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple Alleles","title":"Multiple Alleles","text":"net = snaq!(T_sp, d_sp_reduced);","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/#TICR-pipeline","page":"TICR pipeline","title":"TICR pipeline","text":"","category":"section"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"PhyloNetworks' wiki has a step-by-step tutorial, to go from multiple sequence alignments to a table of quartet gene frequencies (concordance factors: CFs), through BUCKy (to integrate out gene tree uncertainty) or through RAxML. To get the raxml.pl perl script to run RAxML on each gene, download the content of that wiki with","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"git clone https://github.com/crsl4/PhyloNetworks.jl.wiki.git","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"then go to the script/ folder.   Full information and code is here. Below is more detail to insert data into the pipeline at various stages, using one of two pipelines, depending on your machine configuration:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"\"no-scheduler\" pipeline: original set of Perl scripts from the TICR pipeline, well suited for a machine or a cluster of machines without a job scheduler. The scripts automatically parallelize the work across the available cores.\n\"slurm\" pipeline: well suited for a cluster where users submit jobs via a job scheduler like SLURM or SGE. The job scheduler does the work of parallelizing the work across available cores. The scripts, in this second pipeline, were created to take full advantage of job scheduler capabilities. They were developed for a cluster running SLURM. Adjustments to the submit scripts will be needed, to adapt to your own SLURM configuration or to the syntax that your job scheduler wants.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/#To-run-MrBayes:-we-already-have-alignments","page":"TICR pipeline","title":"To run MrBayes: we already have alignments","text":"","category":"section"},{"location":"man/ticr_howtogetQuartetCFs/#no-scheduler-pipeline","page":"TICR pipeline","title":"no-scheduler pipeline","text":"","category":"section"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"We don't need to run mdl.pl if we already have aligned gene sequences from separate loci. To run MrBayes on each locus, we can simply create a tarball of the Nexus files we wish to use (fasta won't work at this stage). The command below assumes that we want to use all the files ending with \".nex\" in the current directory, one file per locus:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"tar czf my-genes.tar.gz *.nex","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"Once the tarball has been successfully generated, we can then specify this file as input for mb.pl assuming we have a valid MrBayes block located in the file \"bayes.txt\":","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"mb.pl my-genes.tar.gz -m bayes.txt -o my-genes-mb","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"If we get an error message like mb.pl: Command not found, it might be because mb.pl has no execute permission, or the current directory is not in our \"path\". An easy fix is to run this command instead:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"perl mb.pl my-genes.tar.gz -m bayes.txt -o my-genes-mb","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"The resulting output tarball would now be located in my-genes-mb/my-genes.mb.tar, and can be used normally with bucky.pl, that is, like this:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"bucky.pl my-genes-mb/my-genes.mb.tar -o mygenes-bucky","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"The output, with the table of concordance factors for all sets of 4 taxa, will be in a file named my-genes.CFs.csv inside a directory named mygenes-bucky. That's the file containing the quartet concordance factors to give to SNaQ as input. There is no need to do any of the steps below: they are already done by bucky.pl.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/#slurm-pipeline","page":"TICR pipeline","title":"slurm pipeline","text":"","category":"section"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"SLURM will parallelize the MrBayes runs across genes.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"Navigate in some \"working\" directory where you place:\na folder containing all nexus files, which we will call \"nexusfolder\" below\na text file named mb-block.txt with the MrBayes block to be used\nfor all the genes (containing the options for MrBayes: model of sequence evolution, number of generations etc.). If we want a different MrBayes block for different genes, step 2 should be skipped, and we should instead find some other way to put the specific MrBayes block at the end of each nexus file.\nIn the \"working\" directory above, run the julia script paste-mb-block.jl with \"nexusfolder\" as argument, to tell the script where to find all the nexus files:\njulia path/to/paste-mb-block.jl nexusfolder\nThis script will read all the nexus files in the directory nexusfolder, will create a new directory nexusfolder-block, and will create new nexus files (containing the MrBayes block found in file mb-block.txt) as 1.nex, 2.nex, ... in the new directory. A translate.txt file will also be created to map the original gene file names to the new (numbered) file names. If we named our MrBayes block file differently: we can edit the script and modify it to replace mb-block.txt by our actual file name for the MrBayes block.\nModify the submit script mb-slurm-submit.sh, which will parallelize all the individual-gene MrBayes runs with SLURM:\nchange --array to the correct number of genes\nchange --mail-user to the user's email (if this is an option for your job scheduler)\nreplace the /workspace/software/bin in PATH=\"/workspace/software/bin:$PATH\" to the path where the mb executable is located or put the whole path in the command: /s/mrbayes-3.2.6-1/bin/mb\nIn slurm, we can then submit the MrBayes array job with:\nsbatch mb-slurm-submit.sh","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"With this slurm pipeline, the steps below are needed: keep reading.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/#To-run-mbsum-on-the-output-of-MrBayes-for-each-gene","page":"TICR pipeline","title":"To run mbsum on the output of MrBayes for each gene","text":"","category":"section"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"If we have the output of MrBayes and want to run BUCKy, we must first run mbsum on the output from MrBayes, separately for each gene.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"For a gene with output tree files named gene1.run1.t, gene1.run2.t and gene1.run3.t, and a desired burnin of 1000 trees per tree file, we do this:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"mbsum -n 1000 -o gene1.in gene1.run1.t gene1.run2.t gene1.run3.t","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"This mbsum command will need to be executed for each gene. Then we can continue to the next section to run bucky.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"Alternatively, we can use the julia script mbsum-t-files.jl, and give it as argument the directory that has the output tree files from MrBayes, to run mbsum for all the genes. mbsum is fast, so there is no attempt to parallelize the various mbsum commands.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"julia mbsum-t-files.jl mbfolder outputfolder burnin                # or\njulia --color=yes -- mbsum-t-files.jl mbfolder outputfolder burnin # for colorized messages to the screen","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"where burnin is replaced by the number of trees to ignore in each tree file for burnin. This burnin argument is optional (default: 2501). The outputfolder will contain the output of mbsum.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/#To-run-bucky-on-all-4-taxon-sets:-we-already-have-the-mbsum-output","page":"TICR pipeline","title":"To run bucky on all 4-taxon sets: we already have the mbsum output","text":"","category":"section"},{"location":"man/ticr_howtogetQuartetCFs/#no-scheduler-pipeline-2","page":"TICR pipeline","title":"no-scheduler pipeline","text":"","category":"section"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"If we already ran mbsum on the output from MrBayes, for each individual gene, we can simply create a tarball containing all the mbsum output files. So if we had mbsum output in files named gene1.in, gene2.in, ... , gene100.in, we would want to run something similar to the following command to create the tarball:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"tar czf my-genes-mbsum.tar.gz gene*.in","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"We can now use this tarball along with the -s option in bucky.pl like this:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"bucky.pl my-genes-mbsum.tar.gz -s -o mygenes-bucky","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"Again, if we get an error like bucky.pl: Command not found, we could run instead","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"perl bucky.pl my-genes-mbsum.tar.gz -s -o mygenes-bucky","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"The output, with the table of concordance factors for all sets of 4 taxa, will be in a file named my-genes.CFs.csv inside directory mygenes-bucky. That's the file containing the quartet concordance factors to give to SNaQ as input.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/#slurm-pipeline-2","page":"TICR pipeline","title":"slurm pipeline","text":"","category":"section"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"We want to run bucky on every 4-taxon set. SLURM will parallelize these jobs with the submit script bucky-slurm-submit.sh, which calls the perl script bucky-slurm.pl.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"The perl script bucky-slurm.pl runs bucky on a single 4-taxon set. It takes the following arguments, which must be modified in the submit script bucky-slurm-submit.sh:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"name of the folder containing the mbsum output files (one per locus) from previous step. This folder is named mbsum in the submit script: adapt if needed.\noutput name: -o or --out-dir name of the directory to store output files in. This option is not used in the default submit script\nbucky arguments: -a or --alpha for the prior alpha value, and -n or --ngen number of generations. These options are not used either, in the script: the defaults are used then (α=1, 1 million generations)\ninteger for the given quartet, via option -q. The quartet ID is specified by SLURM with its own array ID: $SLURM_ARRAY_TASK_ID.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"In the submit script that gives instructions to the job scheduler:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"adapt the name of the $SLURM_ARRAY_TASK_ID variable, which captures the task number in the array of tasks, to your scheduler syntax\nchange --array to the correct number of 4-taxon sets. For example, if there are 15 taxa in the dataset, there are 1365 4-taxon sets. To get this number, if you are unsure, use choose(15,4) in R or binomial(15,4) in Julia, but replace 15 by your actual number of individuals.\nchange --mail-user to the user's email (if this is an option for your job scheduler)\nreplace the /workspace/software/bin in PATH=\"/workspace/software/bin:$PATH\" by the path where the bucky executable is located. Also, replace /workspace/claudia/software/TICR/scripts/ by the full path where the bucky-slurm.pl script is located.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"In slurm, we would submit the BUCKy array job with:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"sbatch bucky-slurm-submit.sh","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"At the end, the array job will produce","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"a .concordance file for every 4-taxon set\na .cf file with the parsed output for that same 4-taxon set, in the format needed for the final CF table.","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"The .cf files can be concatenated to produce the file containing the quartet concordance factors across all 4-taxon sets, to give to SNaQ as input:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"cat *.cf > CFtable.csv","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"Alternatively, if the list of .cf files is not easily captured by *.cf (because the list is too long for a shell command), the following julia script can do the concatenation. Just copy-paste the commands below within a Julia session, started from the directory that contains the .cf files:","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"files = String[] # empty vector of strings: will contain the .cf file names later\nfor f in filter(x -> endswith(x, \".cf\"), readdir())\n    push!(files,f)\nend\nprintln(\"found $(length(files)) cf files\") # to check how many .cf output files were found\nopen(\"CFtable.csv\",\"w\") do f_out\n  # write the header:\n  write(f_out, \"taxon1,taxon2,taxon3,taxon4,CF12_34,CF12_34_lo,CF12_34_hi,CF13_24,CF13_24_lo,CF13_24_hi,CF14_23,CF14_23_lo,CF14_23_hi,ngenes\\n\")\n  for file in files\n    @show file # to see the .cf file name: comment this out if that's too much screen output\n    open(file) do f_in\n        line = read(f_in, String)\n        write(f_out, string(line,\"\\n\"))\n    end # closes \"file\" safely\n  end\nend # closes \"CFtable.csv\" safely","category":"page"},{"location":"man/ticr_howtogetQuartetCFs/","page":"TICR pipeline","title":"TICR pipeline","text":"When this is done, we will have a file CFtable.csv containing the quartet concordance factors, to give to SNaQ as input :smiley:","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/#Installation-of-Julia","page":"Installation","title":"Installation of Julia","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Julia is a high-level and interactive programming language (like R or Matlab), but it is also high-performance (like C). To install Julia, follow instructions here. For a quick & basic tutorial on Julia, see learn x in y minutes.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Editors:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Visual Studio Code provides an editor and an integrated development environment (IDE) for Julia: highly recommended!\nJuno provides an IDE for Julia, based on the Atom editor.\nyou can also run Julia within a Jupyter notebook (formerly IPython notebook).","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"IMPORTANT: Julia code is just-in-time compiled. This means that the first time you run a function, it will be compiled at that moment. So, please be patient! Future calls to the function will be much much faster. Trying out toy examples for the first calls is a good idea.","category":"page"},{"location":"man/installation/#Installation-of-the-package-PhyloNetworks","page":"Installation","title":"Installation of the package PhyloNetworks","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To install the package, type inside Julia:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"PhyloNetworks\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The first step can take a few minutes, be patient. If you already installed the package and want the latest registered version, just do this (which will update all of your packages):","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Pkg.update()","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Warning: It is important to update the package regularly as it is undergoing constant development. Join the google group for updates here.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Pkg.update() will install the latest registered version, but there could be other improvements in the master branch of the repository. If you want to update to the latest unregistered version of the package, you can do Pkg.add(PackageSpec(name=\"PhyloNetworks\", rev=\"master\")) just beware that the latest changes could be not as robust. If you want to go back to the registered package, you can do Pkg.free(\"PhyloNetworks\").","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Similarly, you can pin a version of the package Pkg.pin(\"PhyloNetworks\") so that Pkg.update() will not modify it. You can always free a pinned package with Pkg.free(\"PhyloNetworks\"). More on package management here.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The PhyloNetworks package has dependencies like NLopt and DataFrames (see the REQUIRE file for the full list), but everything is installed automatically.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The companion package PhyloPlots has utilities to visualize networks, and for interoperability, such as to export networks to R (which can then be plotted via R). To install:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"PhyloPlots\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"PhyloPlots depends on PhyloNetworks, and has further dependencies like Gadfly and RCall","category":"page"},{"location":"man/installation/#Test-example","page":"Installation","title":"Test example","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To check that your installation worked, type this in Julia to load the package. This is something to type every time you start a Julia session:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using PhyloNetworks;","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This step can also take a while, if Julia needs to pre-compile the code (after a package update for instance). Here is a very small test for the installation of PhyloNetworks.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"net = readTopology(\"(A,(B,(C,D)));\");\ntipLabels(net)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"You can see a list of all the functions with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"varinfo(PhyloNetworks)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"and press ? inside Julia to switch to help mode, followed by the name of a function (or type) to get more details about it.","category":"page"},{"location":"man/installation/#Julia-types","page":"Installation","title":"Julia types","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Each object in Julia has a type. We show here small examples on how to get more info on an object, what's its type, and how to manipulate objects. For example, let's take an object raxmlCF created from reading in some data (see Input for SNaQ):","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"raxmltrees = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"raxmltrees.tre\");\nraxmlCF = readTrees2CF(raxmltrees);","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Typing varinfo() will provide a list of objects and packages in memory, including raxmlCF that we just created. If we want to know the type of a particular object, we do:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"typeof(raxmlCF)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"which shows us that raxmlCF is of type DataCF. If we want to know about the attributes the object has, we can type ? in Julia, followed by DataCF for a description. We can also ask for a list of all its attributes with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"fieldnames(typeof(raxmlCF))","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"For example, we see that one attribute is numQuartets: its the number of 4-taxon subsets in the data. To see what this number is:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"raxmlCF.numQuartets","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"We also noticed an attribute quartet. It is a vector of Quartet objects inside raxmlCF, so","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"raxmlCF.quartet[2].taxon","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"will provide the list of taxon names for the second 4-taxon subset in the data. To see the observed CF, we can type","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"raxmlCF.quartet[2].obsCF","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"We can verify the type with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"typeof(raxmlCF.quartet[2])","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"We can also read a simple network in Julia and print the list of edges","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"str = \"(A,((B,#H1),(C,(D)#H1)));\";\nnet = readTopology(str);\nprintEdges(net)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"We see that the edges do not have branch lengths, and the hybrid edges do not have gamma values. We can set them with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"setLength!(net.edge[1],1.9)\nsetGamma!(net.edge[3],0.8)\nprintEdges(net)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"where 1 and 3 correspond to the position of the given edge to modify in the list of edges. We can only change the gamma value of hybrid edges (not tree edges). Such an attempt below will cause an error with a message to explain that the edge was a tree edge:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"setGamma!(net.edge[4],0.7)\n# should return this:\n# ERROR: cannot change gamma in a tree edge","category":"page"},{"location":"man/parsimony/#Parsimony-on-networks","page":"Parsimony on networks","title":"Parsimony on networks","text":"","category":"section"},{"location":"man/parsimony/#Parsimony-score-of-a-given-network","page":"Parsimony on networks","title":"Parsimony score of a given network","text":"","category":"section"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"We can calculate the parsimony score of a given network topology and a given set of characters. The characters could be in a CSV file in this format:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"taxon trait1 trait2 trait3 trait4 trait5 trait6 ...\nEnglish 1 2 1 1 1 3\n...      ...","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The trait values can be integer numbers, or strings. The data table may have missing data, and may contain extra taxa that we might want to exclude.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"An example file comes with the package, available here or here.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"using PhyloNetworks\nmkpath(\"../assets/figures\")\nusing RCall\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\"\n# net1 = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"swadesh.out\"))\n# we would get net1 from analyzing the complete data, but not available with the package","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"First, we need to read the trait table as a DataFrame object:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"using CSV, DataFrames\ncsvfile = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"Swadesh.csv\");\ndat = CSV.File(csvfile) |> DataFrame;\nfirst(dat, 6) # to see the first 6 rows","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"Then, we need to convert the DataFrame object dat into a vector of species and traits. The species names are in column 1 named taxon, and the traits are in columns 2-11. The trait data need to be converted to a list of vectors, with one vector for each species. An internal function is provided for this:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"species, traits = PhyloNetworks.readCSVtoArray(dat);\nspecies\ntraits","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"Then, we read the network as usual:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"net = readTopology(\"(Spanish,((English)#H1,(Norwegian,(German,#H1))));\");","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"using PhyloPlots, RCall\nR\"svg(name('parsimony-fixed-net.svg'), width=4, height=4)\"; # hide\nR\"par\"(mar = [0,0,0,0]);\nplot(net, :R, xlim=[0.8,7.5]);\nR\"dev.off\"(); # hide\nnothing # hide","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"(Image: parsimony-fixed-net)","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"There are different types of parsimony scores on networks. Currently, we have implemented the softwired criterion only, with two different functions: parsimonySoftwired and parsimonyGF.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The function parsimonySoftwired uses a faster algorithm than parsimonyGF, but can solve the softwired criterion only.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"score = parsimonySoftwired(net, species, traits)\nscore = parsimonyGF(net,species,traits,:softwired)","category":"page"},{"location":"man/parsimony/#Finding-the-most-parsimonious-network","page":"Parsimony on networks","title":"Finding the most parsimonious network","text":"","category":"section"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The function maxParsimonyNet searches for the most parsimonious level-1 network. It uses the parsimonyGF function, with softwired criterion as default, which will be extended to other criteria later.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"Just like snaq!, maxParsimonyNet requires a starting topology, which can be a tree or a level-1 network, and returns a level-1 network. Taxa present in the data but absent from the starting topology will be ignored during the search.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"starttree = readTopology(\"(((English,German),Norwegian),Spanish);\");\nnet1 = maxParsimonyNet(starttree, dat, hmax=1, outgroup=\"Spanish\", rootname=\"swadesh\")","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The example data is very small: only 1 of the 11 traits is parsimony informative, on the 4 taxa specified by the starting topology. So these data happen to be compatible with a tree, and that tree is returned despite allowing for up to 1 reticulation: (Spanish,((English,Norwegian),German));.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"using PhyloNetworks\nmkpath(\"../assets/figures\")\nraxmltrees = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"raxmltrees.tre\")\nraxmlCF = readTrees2CF(raxmltrees, writeTab=false, writeSummary=false)\nastralfile = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"astral.tre\")\nastraltree = readMultiTopology(astralfile)[102] # 102th tree = last tree here\nnet0 = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net0.out\"))\nnet1 = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net1.out\"))\nnet2 = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net2.out\"))\nnet3 = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net3.out\"))\nnet0.loglik = 53.53150526187732\nnet1.loglik = 28.31506721890958\nnet2.loglik = 28.31506721890957\nnet3.loglik = 28.315067218909626","category":"page"},{"location":"man/snaq_plot/#Getting-a-Network","page":"Network estimation and display","title":"Getting a Network","text":"","category":"section"},{"location":"man/snaq_plot/#Network-Estimation","page":"Network estimation and display","title":"Network Estimation","text":"","category":"section"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"SNaQ implements the statistical inference method in Solís-Lemus & Ané 2016. The procedure involves a numerical optimization of branch lengths and inheritance probabilities and a heuristic search in the space of phylogenetic networks.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"After Input for SNaQ, we can estimate the network using the input data raxmlCF and starting from tree (or network) astraltree. We first impose the constraint of at most 0 hybrid node, that is, we ask for a tree.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"net0 = snaq!(astraltree,raxmlCF, hmax=0, filename=\"net0\", seed=1234)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"Part of the screen output shows this:","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"MaxNet is (C,D,((B,A):1.395762055180493,(O,E):0.48453400554506426):10.0);\nwith -loglik 53.53150526187732","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"This parenthetical (extended Newick) description is not very human-friendly, so we plot the tree (more about plotting networks below: Network Visualization ).","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"using PhyloPlots\nusing RCall # hide\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('snaqplot_net0_1.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net0, :R);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"(Image: net0_1)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"We can use this tree as a starting point to search for the best network allowing for at most hmax=1 hybrid node (which is the default).","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"net1 = snaq!(net0, raxmlCF, hmax=1, filename=\"net1\", seed=2345)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"part of screen output:","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"best network and networks with different hybrid/gene flow directions printed to .networks file\nMaxNet is (C,D,((O,(E,#H7:::0.19558838614943078):0.31352437658618976):0.6640664399202987,(B,(A)#H7:::0.8044116138505693):10.0):10.0);\nwith -loglik 28.31506721890958","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"We can visualize the estimated network and its inheritance values γ, which measure the proportion of genes inherited via each parent at a reticulation event (e.g. proportion of genes inherited via gene flow).","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"R\"svg(name('snaqplot_net1_1.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, showGamma=true);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"(Image: net1_1)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"This network has A as a hybrid, 80.4% sister to B, and 19.6% sister to E (which is otherwise sister to O). C & D are sister to each other. We can also check the output files created by snaq!:","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"less(\"net1.err\") # would provide info about errors, if any\nless(\"net1.out\") # main output file with the estimated network from each run\nless(\"net1.networks\") # extra info","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"when viewing these result files with less within Julia, use arrows to scroll down and type q to quit viewing the files. The file net1.networks contains a list of networks that are slight modifications of the best (estimated) network net1. The modifications changed the direction of one reticulation at a time, by moving the placement of one hybrid node to another node inside the same cycle. For each modified network, the pseudolikelihood score was calculated (the loglik or -Ploglik values give a pseudo deviance actually).","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"The function name snaq! ends with ! because it modifies the argument raxmlCF by including the expected CF. Type ? then snaq! to get help on that function.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"The main output file, here net1.out (or snaq.out by default) has the estimated network in parenthetical format, but we can also print it directly to the screen:","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"net1\nwriteTopology(net1)  # writes to screen, full precision for branch lengths and γ\nwriteTopology(net1, round=true, digits=2)\nwriteTopology(net1,di=true) # γ omitted: for dendroscope\nwriteTopology(net1, \"bestnet_h1.tre\") # writes to file: creates or overwrites file\nrm(\"bestnet_h1.tre\") # hide","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"The option di=true is for the parenthetical format used by Dendroscope (without reticulation heritabilities). Copy this parenthetical description and paste it into Dendroscope, or use the plotting function described below.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"We can go on and let the network have up to 2 or 3 hybrid nodes:","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"net2 = snaq!(net1,raxmlCF, hmax=2, filename=\"net2\", seed=3456)\nnet3 = snaq!(net0,raxmlCF, hmax=3, filename=\"net3\", seed=4567)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"and plot them (they are identical and they both have a single reticulation):","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"R\"svg(name('snaqplot_net23.svg'), width=7, height=3)\" # hide\nusing RCall                  # to be able to tweak our plot within R\nR\"layout(matrix(1:2, 1, 2))\" # to get 2 plots into a single figure: 1 row, 2 columns\nR\"par\"(mar=[0,0,1,0])        # for smaller margins\nplot(net2, :R, showGamma=true);\nR\"mtext\"(\"hmax=2\")           # add text annotation: title here\nplot(net3, :R, showGamma=true);\nR\"mtext\"(\"hmax=3\")\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"(Image: net23)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"with this screen output for net2 (only 1 hybrid node found):","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"MaxNet is (C,D,((B,(A)#H7:::0.804411606649347):10.0,(O,(#H7:::0.19558839335065303,E):0.3135243143217013):0.664066456871298):10.0);\nwith -loglik 28.31506721890957","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"and this output for net3 (again, only 1 hybrid found):","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"MaxNet is (D,C,((O,(E,#H7:::0.19558839257941849):0.3135243301652981):0.6640664138384673,(B,(A)#H7:::0.8044116074205815):10.0):10.0);\nwith -loglik 28.315067218909626","category":"page"},{"location":"man/snaq_plot/#parallel-computations","page":"Network estimation and display","title":"parallel computations","text":"","category":"section"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"For network estimation, multiple runs can done in parallel. For example, if your machine has 4 or more processors (or cores), you can tell julia to use 4 processors by starting julia with julia -p 4, or by starting julia the usual way (julia) and then adding processors with:","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"using Distributed\naddprocs(4)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"If we load a package (using PhyloNetworks) before adding processors, then we need to re-load it again so that all processors have access to it:","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"@everywhere using PhyloNetworks","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"After that, running any of the snaq!(...) command will use different cores for different runs, as processors become available. Fewer details are printed to the log file when multiple cores are used in parallel.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"When running bootsnaq, the analysis of each bootstrap replicate will use multiple cores to parallelize separate runs of that particular bootstrap replicate. You may parallelize things further by running bootsnaq multiple times (on separate machines for instance), each time for a small subset of bootstrap replicates, and with a different seed each time.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"We may tell julia to add more processors than our machine has, but we will not receive any performance benefits. At any time during the julia session, nworkers() tells us how many worker processors julia has access to.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"Below is an example of how to use a cluster, to run many independent snaq! searches in parallel on a cluster running the slurm job manager (other managers would require a different, but similar submit file). This example uses 2 files:","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"a julia script file, to do many runs of snaq! in parallel, asking for many cores (default: 10 runs, asking for 10 cores). This julia script can take arguments: the maximum allowed number of hybridizations hmax, and the number of runs (to run 50 runs instead of 10, say).\na submit file, to launch the julia script.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"First: the example julia script, below, is assumed (by the submit file) to be called runSNaQ.jl. It uses a starting tree that is assumed to be available in a file named astraltree.tre, but that could be modified (to use a network with h=1 to start the search with hmax=2 for instance). It also assumes that the quartet concordance factor data are in file tableCF_speciesNames.csv. Again, this file name should be adjusted. To run this julia script for 50 runs and hmax=3, do julia runSNaQ.jl 3 50.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"#!/usr/bin/env julia\n\n# file \"runSNaQ.jl\". run in the shell like this in general:\n# julia runSNaQ.jl hvalue nruns\n# example for h=2 and default 10 runs:\n# julia runSNaQ.jl 2\n# or example for h=3 and 50 runs:\n# julia runSNaQ.jl 3 50\n\nlength(ARGS) > 0 ||\n    error(\"need 1 or 2 arguments: # reticulations (h) and # runs (optional, 10 by default)\")\nh = parse(Int, ARGS[1])\nnruns = 10\nif length(ARGS) > 1\n    nruns = parse(Int, ARGS[2])\nend\noutputfile = string(\"net\", h, \"_\", nruns, \"runs\") # example: \"net2_10runs\"\nseed = 1234 + h # change as desired! Best to have it different for different h\n@info \"will run SNaQ with h=$h, # of runs=$nruns, seed=$seed, output will go to: $outputfile\"\n\nusing Distributed\naddprocs(nruns)\n@everywhere using PhyloNetworks\nnet0 = readTopology(\"astraltree.tre\");\nusing DataFrames, CSV\ndf_sp = DataFrame(CSV.File(\"tableCF_speciesNames.csv\", pool=false); copycols=false);\nd_sp = readTableCF!(df_sp);\nnet = snaq!(net0, d_sp, hmax=h, filename=outputfile, seed=seed, runs=nruns)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"When julia is called on a script, whatever comes after \"julia scriptname\" is given to julia in an array of values. This array is called ARGS. So if we call a script like this: julia runSNaQ.jl 2 then the script will know the arguments through ARGS, which would contain a single element, \"2\". This first element is just a string, at this stage. We want to use it as a number, so we ask julia to parse the string into an integer.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"Second: we need a \"submit\" file to ask a job scheduler like slurm to submit our julia script to a cluster. In the submit file below, the first 5 lines set things up for slurm. They are most likely to be specific to your cluster. The main idea here is to use a slurm \"array\" from 0 to 3, to run our julia script multiple times, 4 times actually: from hmax=0 to hmax=3. Each would do 30 runs (and each would be allocated 30 cores in the submit script below). Then log out of the cluster and go for coffee.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"#!/bin/bash\n#SBATCH -o path/to/slurm/log/file/runsnaq_slurm%a.log\n#SBATCH -J runsnaq\n#SBATCH --array=0-3\n#SBATCH -c 30\n## --array: to run multiple instances of this script,\n##          one for each value in the array.\n##          1 instance = 1 task\n## -J job name\n## -c number of cores (CPUs) per task\n\necho \"slurm task ID = $SLURM_ARRAY_TASK_ID used as hmax\"\necho \"start of SNaQ parallel runs on $(hostname)\"\n# finally: launch the julia script, using Julia executable appropriate for slurm, with full paths:\n/workspace/software/bin/julia --history-file=no -- runSNaQ.jl $SLURM_ARRAY_TASK_ID 30 > net$SLURM_ARRAY_TASK_ID_30runs.screenlog 2>&1\necho \"end of SNaQ run ...\"","category":"page"},{"location":"man/snaq_plot/#choosing-the-number-of-hybridizations","page":"Network estimation and display","title":"choosing the number of hybridizations","text":"","category":"section"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"Each network has a loglik attribute, which is its pseudo deviance: a multiple of the negative log-likelihood up to a constant (the constant is such that the score is 0 if the network fits the data perfectly). The lower the better. We can plot these scores across hybrid values:","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"scores = [net0.loglik, net1.loglik, net2.loglik, net3.loglik]\nR\"svg(name('snaqplot_scores_heuristic.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[2.5,2.5,.5,.5], mgp=[1.4,.4,0], tck=-0.02);  # hide\nR\"plot\"(scores, type=\"b\", ylab=\"network score\", xlab=\"hmax\", col=\"blue\");\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"(Image: scores_heuristic)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"Here the slope heuristic suggests a single hybrid node: the score does not get much better beyond h=1.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"We made the plot via R above. A more Julian way would use a Julia plotting package such as Gadfly or Plots, like this for instance:","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"using Gadfly\nplot(x=collect(0:3), y=scores, Geom.point, Geom.line)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"(btw, cool blog about using ggplot within julia)","category":"page"},{"location":"man/snaq_plot/#Network-Visualization","page":"Network estimation and display","title":"Network Visualization","text":"","category":"section"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"To visualize the estimated network, we can use the companion package PhyloPlots. In the example below, julia creates and sends the plot to R via RCall, so we can tweak the plot in various ways via commands sent to R. To save the plot in a file: we first tell R to create an image file, then we send the plot of the network, then we tell R to wrap up and save its image file.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"using PhyloPlots # to visualize networks\nusing RCall      # to send additional commands to R like this: R\"...\"\nR\"name = function(x) file.path('..', 'assets', 'figures', x)\" # function to create file name in appropriate folder\nR\"svg(name('snaqplot_net1_2.svg'), width=4, height=3)\" # starts image file\nR\"par\"(mar=[0,0,0,0]) # to reduce margins (no margins at all here)\nplot(net1, :R, showGamma=true, showEdgeNumber=true); # network is plotted & sent to file\nR\"dev.off()\"; # wrap up and save image file\nnothing # hide","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"(Image: net1_2)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"The plot function has many options, to annotate nodes and edges. In the example above, hybrid edges were annotated with their γ inheritance values (in blue: light blue for the minor edge with γ<0.5, and dark blue for the major edge with γ>0.5), and edges were annotated with their internal numbers.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"Type ? to switch to the help mode of Julia, then type the name of the function, here plot. Edge colors can be modified, for instance.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"R\"svg(name('snaqplot_net1_3.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, showEdgeLength=true, minorHybridEdgeColor=\"tan\")\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"(Image: net1_3)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"(for a Gadfly-based plot, do using Colors and change the color option to minorHybridEdgeColor=colorant\"tan\")","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"Edge lengths are shown, too. They were estimated in coalescent units: number of generations / effective population size. Some edge lengths are not identifiable, hence not shown.","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"Below is another example, where space was added between the network and the taxon names via the tipOffset option. Also, edge colors were changed, and the nodes numbers are shown (used internally)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"R\"svg(name('snaqplot_net1_4.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1,:R, tipOffset=0.5, showNodeNumber=true, edgeColor=\"tomato4\",\n     minorHybridEdgeColor=\"skyblue\", majorHybridEdgeColor=\"tan\");\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"(Image: net1_4)","category":"page"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"Without the :R argument, a Gadly-based plot will be produced: would open a browser where the plot will appear (unless you use Juno, which would capture and display the plot). To get a pdf version for instance (see Gadfly tutorial for other formats) using Gadfly; p=pdf(...); draw(PDF(\"bestnet_h1.pdf\", 4inch, 4inch),p).","category":"page"},{"location":"man/snaq_plot/#Re-rooting-networks","page":"Network estimation and display","title":"Re-rooting networks","text":"","category":"section"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"SNaQ infers an unrooted semi-directed network. The direction of hybrid edges can be inferred, but the direction of tree edges cannot be inferred. To obtain a representative visualization, it is best to root the network first, using one or more outgroup. Go to Re-rooting trees and networks for this. If your outgroup conflicts with the direction of reticulations in the estimated network, see section Candidate networks compatible with a known outgroup.","category":"page"},{"location":"man/snaq_plot/#Candidate-Network-Evaluation","page":"Network estimation and display","title":"Candidate Network Evaluation","text":"","category":"section"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"From a set of candidate networks, one might simply need to score of each network to pick the best. Here, the score is the negative log pseudo-likelihood, and the lower the better. See the section to get the score of Candidate Networks.","category":"page"},{"location":"man/snaq_plot/#SNaQ-error-reporting","page":"Network estimation and display","title":"SNaQ error reporting","text":"","category":"section"},{"location":"man/snaq_plot/","page":"Network estimation and display","title":"Network estimation and display","text":"Please report any bugs and errors by opening an issue. The easiest way to provide information on the error is by checking the .err file, which will show the number of runs that failed and the corresponding seed to replicate the run. In case of an error, the .err file might look like: Total errors: 1 in seeds [4545]. This file and any information that will help replicating the error will be immensely helpful to fix the error/bug.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"# using Gadfly\nusing PhyloNetworks\nmkpath(\"../assets/figures\")","category":"page"},{"location":"man/bootstrap/#Bootstrap","page":"Bootstrap","title":"Bootstrap","text":"","category":"section"},{"location":"man/bootstrap/#Running-a-bootstrap-analysis","page":"Bootstrap","title":"Running a bootstrap analysis","text":"","category":"section"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"There are two ways to do a bootstrap analysis.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"From quartet CFs with credibility intervals, such as if we used BUCKy. The TICR pipeline outputs a CF table with extra columns for credibility intervals. We could then read that table and get bootstrap networks like this, and tweak options as needed:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"using DataFrames, CSV\ndf = DataFrame(CSV.File(\"tableCF_withCI.csv\"); copycols = false)\nbootnet = bootsnaq(startnetwork, df, hmax=1, filename=\"bootstrap\")","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Alternatively, we can use bootstrap gene trees: one file of bootstrap trees per gene. Here, the input is a text file that lists all the bootstrap files (one per gene). We demonstrate this option here.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"The names of all our bootstrap files are listed in \"BSlistfiles\". (ASTRAL can use the same file to do its own bootstrap, see the wiki for more details). The function readBootstrapTrees can read this list of file names, then read each bootstrap file to get the bootstrap sample for each gene. We can use them to sample input gene trees at random, one per gene, and estimate a network from them. We ask the bootsnaq function to repeat this resampling of bootstrap gene trees several times.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"bootTrees = readBootstrapTrees(\"BSlistfiles\");\nbootnet = bootsnaq(net0, bootTrees, hmax=1, nrep=10, runs=3,\n                   filename=\"bootsnaq\", seed=4321)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"The bootstrap networks are saved in the boostrap.out file, so they can be read in a new session with bootnet = readMultiTopology(\"bootsnap.out\"). To save the bootstrap networks to a different file (perhaps after having re-rooted them with an outgroup), we could do this: writeMultiTopology(bootnet, \"bootstrapNets.tre\").","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"The example above asks for 10 bootstrap replicates, which is definitely too few, to make the example run faster. We might also increase the number of optimization runs (runs) done for each bootstrap replicate. This bootstrap was run with the default 10 runs per replicate, and 100 bootstrap replicates, and the 100 bootstrap networks come with the package:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"bootnet = readMultiTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"bootsnaq.out\"));\nlength(bootnet)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"If we used a specified list of quartets on the original data, we should use that same list for the bootstrap analysis through the option quartetfile.","category":"page"},{"location":"man/bootstrap/#support-for-tree-edges","page":"Bootstrap","title":"support for tree edges","text":"","category":"section"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Now that we have 100 bootstrap networks, we need to summarize what they have in common (highly supported features) and what they don't (areas of uncertainty).","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Before summarizing these bootstrap networks on the best network, it is best to re-read this network to get a reproducible internal numbering of its nodes and edges, used later for mapping bootstrap support to edges.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"net1 = readTopology(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net1.out\"))","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"It turns out that the direction of gene flow is quite uncertain in this example (see below) with a wrong direction inferred sometimes, so we re-root our best network net1 to the base of O,E, for the figures to be less confusing later.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"rootonedge!(net1, 7)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"using PhyloPlots, RCall\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('net1_rotate1_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, showEdgeNumber=true); # edge 7 leads to O+E\nR\"dev.off()\" # hide\nrootonedge!(net1, 7) # makes (O,E) outgroup clade\nR\"svg(name('net1_rotate1_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, showNodeNumber=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"(Image: net1_rotate1 1) (Image: net1_rotate1 2)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Edges cross: but rotating at node -6 should remove this crossing of edges","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"rotate!(net1, -6)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"R\"svg(name('net1_rotate2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, showGamma=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"(Image: net1_rotate2)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"We can now summarize our bootstrap networks. The functions treeEdgesBootstrap and hybridBootstrapSupport read all bootstrap networks and map the edges / nodes onto a reference network: here net1.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"BSe_tree, tree1 = treeEdgesBootstrap(bootnet,net1);","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"This calculates the major tree tree1 displayed in net1, that is, the tree obtained by following the major parent (γ>0.5) of each hybrid node. This tree can be visualized like this, with edge numbers shown for later use.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"R\"svg(name('major_tree.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(tree1, :R, showEdgeNumber=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"(Image: major_tree)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Next, we can look at bootstrap table BSe_tree, which has one row for each tree edge in net1. One column contains the edge number (same as shown in the plot) and another column contains the edge bootstrap support: the proportion of bootstrap replicates in which this edge was found in the major tree of the inferred network. We can see the full bootstrap table and see which tree edges have bootstrap support lower than 100% (none here) with","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"using DataFrames # for showall() below\nshow(BSe_tree, allrows=true, allcols=true)\nfilter(row -> row[:proportion] < 100, BSe_tree)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Finally, we can map the bootstrap proportions onto the network or its main tree by passing the bootstrap table to the edgeLabel option of plot:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"R\"svg(name('boot_tree_net_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(tree1, :R, edgeLabel=BSe_tree);\nR\"dev.off()\" # hide\nR\"svg(name('boot_tree_net_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, edgeLabel=BSe_tree);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"(Image: boot_tree_net 1) (Image: boot_tree_net 2)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"(Here, it is important that the numbers assigned to edges when building the boostrap table –those in net1 at the time– correspond to the current edge numbers in tree1 and net1. That was the purpose of reading the network from the output file of snaq! earlier, for consistency across different Julia sessions.)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"If we wanted to plot only certain bootstrap values, like those below 100% (1.0), we could do this:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"plot(net1, :R, edgeLabel=filter(row -> row[:proportion] < 100, BSe_tree));","category":"page"},{"location":"man/bootstrap/#support-for-hybrid-edges-and-hybrid-nodes","page":"Bootstrap","title":"support for hybrid edges and hybrid nodes","text":"","category":"section"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Summarizing the placement of reticulations is not standard. The function hybridBootstrapSupport attempts to do so. The descendants of a given hybrid node form the \"recipient\" or \"hybrid\" clade, and is obtained after removing all other reticulations. If reticulation is due to gene flow or introgression, the minor hybrid edge (with γ<0.5) represents this event. The descendants of the lineage from which gene flow originated is then a second \"sister\" of the hybrid clade. Because of the reticulation event, the hybrid clade has 2 sister clades, not 1: the major sister (through the major hybrid edge with γ>0.5) and the minor sister (through the minor hybrid edge with γ<0.5). Note that the network says nothing about the process: its shows the relationships only. We can calculate the frequency that each clade is a hybrid clade, or a major or minor sister for some other hybrid, in the bootstrap networks:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"BSn, BSe, BSc, BSgam, BSedgenum = hybridBootstrapSupport(bootnet, net1);","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Let's look at the results. We can list all the clades and the percentage of bootstrap networks (bootstrap support) in which each clade is a hybrid or sister to a hybrid:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"BSn","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"If a clade contains a single taxon, it is listed with its taxon name. The clade found in the best network is listed with its tag, starting with H (e.g. \"H7\"). The name of other clades start with \"c_\" followed by their number in the best network, if they do appear in the best network. The node numbers, as used internally in the best network, are listed in a separate column. They can be used later to display the bootstrap support values onto the network. Various columns give the bootstrap support that each clade is a hybrid, or a (major/minor) sister to a hybrid. The last column gives the bootstrap support for the full relationship in the best network: same hybrid with same two sisters. These bootstrap values are associated with nodes (or possibly, their parent edges).","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"To see what is the clade named \"H7\", for instance:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"BSc # this might be too big\nshow(BSc, allrows=true, allcols=true)\n# BSc[BSc[!,:H7], :taxa] # just a different syntax to subset the data in the same way\nfilter(row -> row[:H7], BSc).taxa","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"We can also get bootstrap values associated with edges, to describe the support that a given hybrid clade has a given sister clade.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"BSe","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Here, each row describes a pair of 2 clades: one being the hybrid, the other being its sister, connected by a hybrid edge. The first rows corresponds to hybrid edges in the best network. Other rows correspond to edges seen in bootstrap networks but not in the reference network.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"BSedgenum","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"lists all the hybrid edges in the best network, two for each hybrid node: the major parent edge and then the minor parent edge. In our case, there is only one reticulation, so only 2 hybrid edges.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"We can plot the bootstrap values of the 2 hybrid edges in the best network:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"R\"svg(name('boot_net_net.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, edgeLabel=BSe[!,[:edge,:BS_hybrid_edge]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"(Image: boot_net_net)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"This is showing the bootstrap support each hybrid edge: percentage of bootstrap trees with an edge from the same sister clade to the same hybrid clade. Alternatively, we could show the bootstrap support for the full reticulation relationships in the network, one at each hybrid node (support for same hybrid with same sister clades). Here, we find that A received gene flow from E (and is sister to B otherwise) in just 32% of bootstrap networks. In another 1% bootstrap, A received gene flow from another source.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"R\"svg(name('boot_net_ret.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, nodeLabel=BSn[!,[:hybridnode,:BS_hybrid_samesisters]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"(Image: boot_net_ret)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Below is example code to place tree edge support and hybrid edge support on the same plot.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"tmp = filter(row -> !ismissing(row[:edge]), BSe) # filter rows\nselect!(tmp, [:edge,:BS_hybrid_edge])            # select 2 columns only\nrename!(tmp, :BS_hybrid_edge => :proportion)     # rename those columns, to match names in BSe_tree\nrename!(tmp, :edge => :edgeNumber)\ntmp = vcat(BSe_tree, tmp)\nplot(net1, edgeLabel=tmp, nodeLabel=BSn[!, [:hybridnode,:BS_hybrid_samesisters]])","category":"page"},{"location":"man/bootstrap/#Who-are-the-hybrids-in-bootstrap-networks?","page":"Bootstrap","title":"Who are the hybrids in bootstrap networks?","text":"","category":"section"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"On a different plot, we can show the bootstrap support for hybrid clades, first mapped to each node with positive hybrid support, and then mapped on the parent edge of these nodes. A is estimated as a hybrid in only 33% of our bootstrap networks. In another 44%, it is the lineage to (E,O) that is estimated as being of hybrid origin.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"R\"svg(name('boot_net_hyb_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, nodeLabel=filter(row->row[:BS_hybrid]>0, BSn)[!,[:hybridnode,:BS_hybrid]]);\nR\"dev.off()\" # hide\nnothing # hide\nR\"svg(name('boot_net_hyb_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, edgeLabel=filter(row->row[:BS_hybrid]>0, BSn)[!,[:edge,:BS_hybrid]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"(Image: boot_net_hyb 1) (Image: boot_net_hyb 2)","category":"page"},{"location":"man/bootstrap/#Where-is-the-origin-of-gene-flow?","page":"Bootstrap","title":"Where is the origin of gene flow?","text":"","category":"section"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"We can plot the support for the various placements of the gene flow origin (minor sister clade), first mapped to each node with positive support for being the origin of gene flow, and then mapped along the parent edge of these nodes. We filtered clades to show those with sister support > 5%:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"R\"svg(name('boot_net_clade_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, nodeLabel=filter(r->r[:BS_minor_sister]>5, BSn)[!,[:node,:BS_minor_sister]]);\nR\"dev.off()\" # hide\nnothing # hide\nR\"svg(name('boot_net_clade_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, :R, edgeLabel=filter(r->r[:BS_minor_sister]>5, BSn)[!,[:edge,:BS_minor_sister]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"(Image: boot_net_clade 1) (Image: boot_net_clade 2)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"In our best network, the lineage to E is estimated as the origin of gene flow, but this is recovered in only 41% of our bootstrap networks. In another 49%, it is the lineage to A that is estimated as the origin of gene flow: so gene flow is estimated in the opposite direction. In this example, there is support for gene flow between (A,B) and (E,O), but there is much uncertainty about its exact placement and about its direction.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Mapping the support for major sister clades might be interesting too:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"plot(net1, nodeLabel=filter(r->r[:BS_major_sister]>5, BSn)[!,[:node,:BS_major_sister]])","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"The estimated heritability γ on hybrid edges in the reference network, when present in a bootstrap network, was also extracted:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"BSgam[1:3,:] # first 3 rows only","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"γ=0 values are for bootstrap replicates that did not have the edge in their network. Basic summaries on γ values for a given edge, say the minor parent, could be obtained like this:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"minimum(BSgam[:,2])\nmaximum(BSgam[:,2])\nusing Statistics # for functions like mean and std (standard deviation)\nmean(BSgam[:,2])\nstd(BSgam[:,2])","category":"page"},{"location":"man/inputdata/#Input-for-SNaQ","page":"Input Data for SNaQ","title":"Input for SNaQ","text":"","category":"section"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"SNaQ is a method implemented in the package to estimate a phylogenetic network from multiple molecular sequence alignments. There are two alternatives for the input data:","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"A list of estimated gene trees for each locus, which can be obtained using MrBayes or RAxML. Or:\nA table of concordance factors (CF), i.e. gene tree frequencies, for each 4-taxon subset. This table can be obtained from BUCKy, to account for gene tree uncertainty","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"This pipeline can be used to obtain the table of quartet CF needed as input for SNaQ (see also the wiki.) It starts from the sequence alignments, runs MrBayes and then BUCKy (both parallelized), producing the table of estimated CFs and their credibility intervals. Additional details on this TICR pipeline describe how to insert data at various stages (e.g. after running MrBayes on each locus).","category":"page"},{"location":"man/inputdata/#Tutorial-data:-gene-trees","page":"Input Data for SNaQ","title":"Tutorial data: gene trees","text":"","category":"section"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"We suggest that you create a special directory for running these examples, where input files can be downloaded and where output files will be created (with estimated networks for instance). Enter this directory and run Julia from there.","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"Suppose you have a file with a list of gene trees in parenthetical format called raxmltrees.tre. You can access the example file of input trees here or here for easier download.","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"Do not copy-paste into a \"smart\" text-editor. Instead, save the file directly into your working directory using \"save link as\" or \"download linked file as\". This file contains 30 gene trees, each in parenthetical format on 6 taxa like this (with rounded branch lengths):","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"(E:0.038,((A:0.014,B:0.010):0.010,(C:0.008,D:0.002):0.010):0.025,O:0.078);","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"If raxmltrees.tre is in your working directory, you can view its content within Julia:","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"less(\"raxmltrees.tre\")","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"or like this, to view the version downloaded with the package:","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"raxmltrees = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"raxmltrees.tre\")\nless(raxmltrees)","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"Just type q to quit viewing this file. You could read in these 30 trees and visualize the third one (say) like this:","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"using PhyloNetworks\nraxmltrees = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"raxmltrees.tre\");\nnothing # hide","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"genetrees = readMultiTopology(raxmltrees);\ngenetrees[3]","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"To visualize any of these input trees, use the PhyloPlots package:","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"using PhyloPlots\nusing RCall # hide\nmkpath(\"../assets/figures\") # hide\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('inputdata_gene3.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0])                          # hide\nplot(genetrees[3], :R); # tree for 3rd gene\nR\"dev.off()\"                                   # hide\nnothing # hide","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"(Image: gene3)","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"To read in all gene trees and directly summarize them by a list of quartet CFs (proportion of input trees with a given quartet):","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"q,t = countquartetsintrees(genetrees); # read in trees, calculate quartet CFs\ndf = writeTableCF(q,t)   # data frame with observed CFs: gene frequencies\nusing CSV\nCSV.write(\"tableCF.csv\", df); # to save the data frame to a file\nraxmlCF = readTableCF(\"tableCF.csv\") # read in the file and produces a \"DataCF\" object\nrm(\"tableCF.csv\") # hide","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"less(\"tableCF.csv\") lets you see the content of the newly created file \"tableCF.csv\", within Julia. Again, type q to quit viewing this file.","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"In this table, each 4-taxon set is listed in one row. The 3 \"CF\" columns gives the proportion of genes that has each of the 3 possible trees on these 4 taxa.","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"For more help on any function, type ? to enter the help mode, then type the name of the function. For example: type ? then countquartetsintrees for information on the various options of that function.","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"When there are many more taxa, the number of quartets might be very large and we might want to use a subset to speed things up. Here, if we wanted to use a random sample of 10 quartets instead of all quartets, we could do:","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"raxmlCF = readTrees2CF(raxmltrees, whichQ=\"rand\", numQ=10, CFfile=\"tableCF10.txt\")","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"Be careful to use a numQ value smaller than the total number of possible 4-taxon subsets, which is n choose 4 on n taxa (e.g. 15 on 6 taxa). To get a predictable random sample, you may set the seed with using Random; Random.seed!(12321) (for instance) prior to sampling the quartets as above. The readTrees2CF is much slower than the function countquartetsintrees to read in trees and calculate the quartet CFs observed in the trees, when we want to get all quartet CFs. But for a small sample of quartets, then readTrees2CF is available.","category":"page"},{"location":"man/inputdata/#Tutorial-data:-quartet-CFs","page":"Input Data for SNaQ","title":"Tutorial data: quartet CFs","text":"","category":"section"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"If we already have a table of quartet concordance factor (CF) values in a file buckyCF.csv in this format","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"Taxon1 Taxon2 Taxon3 Taxon4 CF12_34 CF13_24 CF14_23\nD A E O 0.565 0.0903 0.3447\n...      ...","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"we would read it in one step like this: readTableCF(\"buckyCF.csv\"). An example file comes with the package, available here or here.","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"buckyCFfile = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"buckyCF.csv\");\nbuckyCF = readTableCF(buckyCFfile)","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"The same thing could be done in 2 steps: first to read the file and convert it to a 'DataFrame' object, and then to convert this DataFrame into a DataCF object.","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"using CSV, DataFrames\ndat = DataFrame(CSV.File(buckyCFfile); copycols=false);\nfirst(dat, 6) # to see the first 6 rows\nbuckyCF = readTableCF(dat)\nwriteTableCF(buckyCF)","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"In the input file, columns need to be in the right order: with the first 4 columns giving the names of the taxa in each 4-taxon set. The CF values are assumed to be in columns named \"CF12_34\", etc., or else in columns 5,6,7. If available, a column named \"ngenes\" will be taken to have the the number of genes for each 4-taxon subset.","category":"page"},{"location":"man/inputdata/#Tutorial-data:-starting-tree","page":"Input Data for SNaQ","title":"Tutorial data: starting tree","text":"","category":"section"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"If we have a tree for the data set at hand, it can be used as a starting point for the optimization. From our gene trees, we estimated a species tree with ASTRAL. This tree comes with the package in file astral.tre here. This file has 102 trees: 100 bootstrap species trees, followed by their greedy consensus, followed by the best tree on the original data. It's this last tree that we are most interested in. We can read it with","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"astralfile = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"astral.tre\");\nastraltree = readMultiTopology(astralfile)[102] # 102th tree: last tree here\nR\"svg(name('inputdata_astraltree.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(astraltree, :R, showEdgeLength=true);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"(Image: astraltree)","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"To start its search, SNaQ will need a network of \"level 1\". All trees and all networks with 1 hybridization are of level 1. To make sure that a network with 2 or more hybridizations is of level 1, we can read it in with readTopologyLevel1 (which also unroots the tree, resolves polytomies, replaces missing branch lengths by 1 for starting values etc.):","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"T=readTopologyLevel1(\"startNetwork.txt\")","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"(here startNetwork.txt is a hypothetical file: replace this by the name of a file that contains your network of interest.)","category":"page"},{"location":"man/inputdata/","page":"Input Data for SNaQ","title":"Input Data for SNaQ","text":"Next: Getting a Network","category":"page"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"using PhyloNetworks\nusing DataFrames, CSV","category":"page"},{"location":"man/nj/#Neighbor-joining","page":"Neighbour Joining","title":"Neighbor joining","text":"","category":"section"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"A tree can be inferred from pairwise distances using the neighbor joining algorithm (Satou & Nei 1987)","category":"page"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"The nj function takes a data frame of pairwise distances as input and constructs a tree using the neighbor joining method.  The column names (headers) are used as taxon names.  Rows are assumed to correspond to taxa in the same order as they do in columns.","category":"page"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"D = DataFrame(CSV.File(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"caudata_dist.txt\")); copycols=false);\ntree = nj(D)","category":"page"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"There is also a method PhyloNetworks.nj!, which takes a distance matrix and a vector of the names as argument.  This function, however, would modify D.  One also has to make sure the vector of names match the columns/rows of the distance matrix.","category":"page"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"using PhyloNetworks","category":"page"},{"location":"man/fitdiscreteDNA/#fitting-DNA-on-a-network","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"","category":"section"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"The methods below model each DNA site as a trait, assuming that sites are unlinked, that is, they evolve independently of each other. In other words, this is a \"concatenation\" approach where sites from the same locus do not share information about their evolutionary path. This is appropriate if recombination is assumed to have occurred within genes.","category":"page"},{"location":"man/fitdiscreteDNA/#DNA-evolution:-data-and-models","page":"fitting DNA on a network","title":"DNA evolution: data and models","text":"","category":"section"},{"location":"man/fitdiscreteDNA/#reading-in-an-alignment","page":"fitting DNA on a network","title":"reading in an alignment","text":"","category":"section"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"As for trait evolution, fitdiscrete can be used. It can be given data in a variety of ways. For DNA, this is one way:","category":"page"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"# read in network\ndna_net = readTopology(\"((((((((((((((Ae_caudata_Tr275:1.0,Ae_caudata_Tr276:1.0):1.0,Ae_caudata_Tr139:1.0):1.0)#H1:1.0::0.6,((((((Ae_longissima_Tr241:1.0,Ae_longissima_Tr242:1.0):1.0,Ae_longissima_Tr355:1.0):1.0,(Ae_sharonensis_Tr265:1.0,Ae_sharonensis_Tr264:1.0):1.0):1.0,((Ae_bicornis_Tr408:1.0,Ae_bicornis_Tr407:1.0):1.0,Ae_bicornis_Tr406:1.0):1.0):1.0,((Ae_searsii_Tr164:1.0,Ae_searsii_Tr165:1.0):1.0,Ae_searsii_Tr161:1.0):1.0):1.0)#H2:1.0::0.6):1.0,(((Ae_umbellulata_Tr266:1.0,Ae_umbellulata_Tr257:1.0):1.0,Ae_umbellulata_Tr268:1.0):1.0,#H1:1.0::0.4):1.0):1.0,((Ae_comosa_Tr271:1.0,Ae_comosa_Tr272:1.0):1.0,(((Ae_uniaristata_Tr403:1.0,Ae_uniaristata_Tr357:1.0):1.0,Ae_uniaristata_Tr402:1.0):1.0,Ae_uniaristata_Tr404:1.0):1.0):1.0):1.0,(((Ae_tauschii_Tr352:1.0,Ae_tauschii_Tr351:1.0):1.0,(Ae_tauschii_Tr180:1.0,Ae_tauschii_Tr125:1.0):1.0):1.0,(#H2:1.0::0.4,((((Ae_mutica_Tr237:1.0,Ae_mutica_Tr329:1.0):1.0,Ae_mutica_Tr244:1.0):1.0,Ae_mutica_Tr332:1.0):1.0)#H4:1.0::0.6):1.0):1.0):1.0,(((T_boeoticum_TS8:1.0,(T_boeoticum_TS10:1.0,T_boeoticum_TS3:1.0):1.0):1.0,T_boeoticum_TS4:1.0):1.0,((T_urartu_Tr315:1.0,T_urartu_Tr232:1.0):1.0,(T_urartu_Tr317:1.0,T_urartu_Tr309:1.0):1.0):1.0):1.0):1.0,(((((Ae_speltoides_Tr320:1.0,Ae_speltoides_Tr323:1.0):1.0,Ae_speltoides_Tr223:1.0):1.0,Ae_speltoides_Tr251:1.0):1.0):1.0,#H4:1.0::0.4):1.0):1.0):1.0,Ta_caputMedusae_TB2:1.0):1.0,S_vavilovii_Tr279:1.0):1.0,Er_bonaepartis_TB1:1.0):1.0,H_vulgare_HVens23:1.0);\");\n# read in alignment in FASTA format\nfastafile = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"Ae_bicornis_Tr406_Contig10132.aln\");\ndna_dat, dna_weights = readfastatodna(fastafile, true);\ndna_dat\ndna_weights","category":"page"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"Here, dna_dat is a single data frame containing both species names and trait data (site patterns). The alignment was summarized by listing each observed site pattern only once in dna_dat. dna_weights is a vector of weights, containing the number of times that each site pattern was observed.","category":"page"},{"location":"man/fitdiscreteDNA/#sequence-substitution-models","page":"fitting DNA on a network","title":"sequence substitution models","text":"","category":"section"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"DNA-specific substitution models have 4 states: the 4 nucleotides from BioSymbols (listed here). Each model has a relative and an absolute version.","category":"page"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":":JC69 Jukes & Cantor 1969 model: one single rate for all transitions. The relative version has values -1 along the diagonal of the rate matrix (1 expected transition / unit of time). The absolute version has an extra parameter to scale the rate matrix.\n:HKY85 Hasegawa, Kishino & Yano 1985: treats transitions differently from transversions. The relative is scaled to predict an average of 1 transition / unit of time.","category":"page"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"We may allow for rate variation across sites using the :RV option.","category":"page"},{"location":"man/fitdiscreteDNA/#likelihood-of-a-fixed-network","page":"fitting DNA on a network","title":"likelihood of a fixed network","text":"","category":"section"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"In the examples below, none of the rate parameters are optimized, so we get to see the default starting values.","category":"page"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"d1 = fitdiscrete(dna_net, :JC69, dna_dat, dna_weights, :RV; optimizeQ=false, optimizeRVAS=false)\nd2 = fitdiscrete(dna_net, :HKY85, dna_dat, dna_weights, :RV; optimizeQ=false, optimizeRVAS=false)","category":"page"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"When allowing for rate variation across sites, the default α is 1.","category":"page"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"In the more interesting examples below, we optimize the evolutionary rates and the way rates vary across sites (which is the default).","category":"page"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"d3 = fitdiscrete(dna_net, :JC69, dna_dat, dna_weights, :RV; ftolAbs=0.1, xtolAbs=0.01)","category":"page"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"Lenient tolerance parameters ftolAbs etc. have been chosen here to make this example faster. Note that the fitted object contains a separate version of the input network, where any taxon without data has been pruned, and where branch length numbers may have been modified.","category":"page"},{"location":"man/fitdiscreteDNA/","page":"fitting DNA on a network","title":"fitting DNA on a network","text":"d3.net","category":"page"},{"location":"#PhyloNetworks.jl","page":"Home","title":"PhyloNetworks.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PhyloNetworks is a Julia package for the manipulation, visualization, inference of phylogenetic networks, and their use for trait evolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"How to get help","category":"page"},{"location":"","page":"Home","title":"Home","text":"the package wiki has a step-by-step tutorial, done for the 2019 MBL workshop, with background on networks and explanations.\nthe google group has answers to common questions.\nthe Manual below has a quick tutorial (navigation on the left).\nthe Index further below has the full list of documented functions.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Claudia Solís-Lemus, Paul Bastide and Cécile Ané (2017). PhyloNetworks: a package for phylogenetic networks. Molecular Biology and Evolution 34(12):3292–3298. doi:10.1093/molbev/msx235\nBastide, Solís-Lemus, Kriebel, Sparks, Ané (2018). Phylogenetic Comparative Methods for Phylogenetic Networks with Reticulations. Systematic Biology, 67(5):800–820. doi:10.1093/sysbio/syy033.\nClaudia Solís-Lemus and Cécile Ané (2016). Inferring Phylogenetic Networks with Maximum Pseudolikelihood under Incomplete Lineage Sorting. PLoS Genet 12(3):e1005896. doi:10.1371/journal.pgen.1005896","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/installation.md\",\n    \"man/inputdata.md\",\n    \"man/ticr_howtogetQuartetCFs.md\",\n    \"man/snaq_plot.md\",\n    \"man/dist_reroot.md\",\n    \"man/fixednetworkoptim.md\",\n    \"man/expectedCFs.md\",\n    \"man/bootstrap.md\",\n    \"man/multiplealleles.md\",\n    \"man/trait_tree.md\",\n    \"man/parsimony.md\",\n    \"man/fitdiscrete.md\",\n    \"man/nj.md\"\n]\nDepth = 3","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\", \"lib/internals.md\"]\nDepth = 2","category":"page"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\", \"lib/internals.md\"]\nOrder = [:function]","category":"page"},{"location":"#Types","page":"Home","title":"Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\", \"lib/internals.md\"]\nOrder = [:type]","category":"page"}]
}
