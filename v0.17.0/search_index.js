var documenterSearchIndex = {"docs":
[{"location":"man/parsimony/#Parsimony-on-networks","page":"Parsimony on networks","title":"Parsimony on networks","text":"","category":"section"},{"location":"man/parsimony/#Parsimony-score-of-a-given-network","page":"Parsimony on networks","title":"Parsimony score of a given network","text":"","category":"section"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"We can calculate the parsimony score of a given network topology and a given set of characters. The characters could be in a CSV file in this format:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"taxon trait1 trait2 trait3 trait4 trait5 trait6 ...\nEnglish 1 2 1 1 1 3\n...      ...","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The trait values can be integer numbers, or strings. The data table may have missing data, and may contain extra taxa that we might want to exclude.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"An example file comes with the package, available here or here.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"using PhyloNetworks\nmkpath(\"../assets/figures\")\nusing RCall\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\"\n# net1 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"swadesh.out\"))\n# we would get net1 from analyzing the complete data, but not available with the package","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"First, we need to read the trait table as a DataFrame object:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"using CSV, DataFrames\ncsvfile = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"Swadesh.csv\");\ndat = CSV.File(csvfile) |> DataFrame;\nfirst(dat, 6) # to see the first 6 rows","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"Then, we need to convert the DataFrame object dat into a vector of species and traits. The species names are in column 1 named taxon, and the traits are in columns 2-11. The trait data need to be converted to a list of vectors, with one vector for each species. An internal function is provided for this:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"species, traits = PhyloNetworks.readcsvtoarray(dat);\nspecies\ntraits","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"Then, we read the network as usual:","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"net = readnewick(\"(Spanish,((English)#H1,(Norwegian,(German,#H1))));\");","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"using PhyloPlots, RCall\nR\"svg(name('parsimony-fixed-net.svg'), width=4, height=4)\"; # hide\nR\"par\"(mar = [0,0,0,0]);\nplot(net, xlim=[0.8,7.5]);\nR\"dev.off\"(); # hide\nnothing # hide","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"(Image: parsimony-fixed-net)","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"There are different types of parsimony scores on networks. Currently, we have implemented the softwired criterion only, with two different functions: parsimonysoftwired and parsimonyGF.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The function parsimonysoftwired uses a faster algorithm than parsimonyGF, but can solve the softwired criterion only.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"score = parsimonysoftwired(net, species, traits)\nscore = parsimonyGF(net,species,traits,:softwired)","category":"page"},{"location":"man/parsimony/#Finding-the-most-parsimonious-network","page":"Parsimony on networks","title":"Finding the most parsimonious network","text":"","category":"section"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"warning: feature to be re-implemented\nThe search for the most parsimonious network is no longer available. It will be re-implemented, and without the level-1 restriction. Please use version 0.16 of PhyloNetworks to access this older functionality, until a better one is made available.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The function maxParsimonyNet searches for the most parsimonious level-1 network. It uses the parsimonyGF function, with softwired criterion as default, which may be extended to other criteria later.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"maxParsimonyNet requires a starting topology, which can be a tree or a level-1 network, and returns a level-1 network. Taxa present in the data but absent from the starting topology will be ignored during the search.","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"starttree = readnewick(\"(((English,German),Norwegian),Spanish);\");\nnet1 = maxParsimonyNet(starttree, dat, hmax=1, outgroup=\"Spanish\", rootname=\"swadesh\")","category":"page"},{"location":"man/parsimony/","page":"Parsimony on networks","title":"Parsimony on networks","text":"The example data is very small: only 1 of the 11 traits is parsimony informative, on the 4 taxa specified by the starting topology. So these data happen to be compatible with a tree, and that tree is returned despite allowing for up to 1 reticulation: (Spanish,((English,Norwegian),German));.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"using PhyloNetworks\nmkpath(\"../assets/figures\")","category":"page"},{"location":"man/dist_reroot/#Comparing-and-manipulating-networks","page":"Network comparison and manipulation","title":"Comparing and manipulating networks","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Examples below use networks available from the package. We can load them as follows. astraltree is a tree estimated using ASTRAL, net0 is a network estimated using SNaQ under the constraint of 0 reticulation, so it's also a tree, and net1 is a network estimated under the constraint of 1 reticulation, so not a tree.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"All of them are to be interpreted as semidirected networks, because their root is not identifiable by the method used to estimate them. This affects how we want them.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"astralfile = joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"astral.tre\")\nastraltree = readmultinewick(astralfile)[102] # 102th tree = last tree here\nnet0 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net0.out\"))\nnet1 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net1.out\"))\nnothing # hide","category":"page"},{"location":"man/dist_reroot/#Robinson-Foulds-distance-for-trees","page":"Network comparison and manipulation","title":"Robinson-Foulds distance for trees","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Do the 2 trees astraltree and net0 have the same topology, unrooted? We can calculate the Robinson-Foulds distance between them, using a function that extends the Robinson-Foulds distance to general networks (more on this below).","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"hardwiredclusterdistance(astraltree, net0, false)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"The last option false is to consider topologies as unrooted. The RF distance is 0, so the two unrooted topologies are the same. If we had considered them as rooted, with whatever root they currently have in their internal representation, we would find a difference:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"hardwiredclusterdistance(astraltree, net0, true)","category":"page"},{"location":"man/dist_reroot/#Re-rooting-trees-and-networks","page":"Network comparison and manipulation","title":"Re-rooting trees and networks","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can re-root our networks with the outgroup, O, and then re-compare the ASTRAL tree and the SNaQ tree as rooted topologies (and find no difference):","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"rootatnode!(astraltree, \"O\")\nrootatnode!(net0, \"O\")\nhardwiredclusterdistance(astraltree, net0, true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"using PhyloPlots, RCall\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\"\nR\"svg(name('net0_O.svg'), width=4, height=4)\"\nR\"par\"(mar=[0,0,0,0])\nplot(net0);\nR\"dev.off()\"\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: net0_O)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Note that we use the possibilities of RCall to save the plot. We only show these commands once, but they will be run behind the scene each time a plot is called.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"After trees/networks are rooted with a correct outgroup, their visualization is more meaningful.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Networks can be re-rooted at a given node or along a given edge. Get help (type ?) on the functions rootatnode! and rootonedge! for more info. There are examples in the Network support section.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"If the network is plotted with crossing edges, you may identify ways to rotate the children edges at some nodes to untangle some crossing edges. This can be done using the function rotate!. See an example in the Network support section, or type ? then rotate!.","category":"page"},{"location":"man/dist_reroot/#Does-the-root-conflict-with-the-direction-of-a-reticulation?","page":"Network comparison and manipulation","title":"Does the root conflict with the direction of a reticulation?","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"With 1 hybridization or more, the direction of hybrid edges constrain the position of the root. The root cannot be downstream of hybrid edges. Any hybrid node has to be younger than, or of the same age as both of its parents. So time has to flow \"downwards\" of any hybrid node, and the root cannot be placed \"below\" a hybrid node. An attempt to re-root the network at a position incompatible with hybrid edges will fail, with a RootMismatch error. To show an example, let's use the network below. We plotted the edge numbers, because we will want to use them later to place the root.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"net7taxa = readnewick(\"(C,D,((O,(E,#H7:::0.196):0.314):0.664,(((A1,A2))#H7:::0.804,B):10.0):10.0);\")\nR\"svg(name('reroot_net7taxa_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net7taxa, showgamma=true, showedgenumber=true, tipoffset=0.2);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: reroot net7taxa 1)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Let's imagine that A1 and A2 are our outgroups, and we estimated the network above. According to this network, time must flow from the hybrid node towards A1 and A2. So any attempt to reroot the network with A1 as outgroup, or with A2 as outgroup, or with the A clade (on edge 11), will fail with a RootMismatch error:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"rootatnode!(net7taxa, \"A1\"); # ERROR: RootMismatch: non-leaf node 5 had 0 children. ...\nrootatnode!(net7taxa, \"A2\"); # ERROR: RootMismatch (again)\nrootonedge!(net7taxa, 10);   # ERROR: RootMismatch (again)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"In this case, however, it is possible to root the network on either parent edge of the hybrid node. These edges have numbers 12 and 5, based on the plot above. We get these 2 rooted versions of the network:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"R\"svg(name('reroot_net7taxa_2.svg'), width=7, height=4)\"; # hide\nR\"layout(matrix(1:2,1,2))\";\nR\"par\"(mar=[0,0,0.5,0]); # hide\nrootonedge!(net7taxa, 11);\nrotate!(net7taxa, -5)\nplot(net7taxa, showgamma=true, tipoffset=0.2, shownodenumber=true);\nR\"mtext\"(\"rooted on hybrid edge 11 (major)\", line=-1)\nrootonedge!(net7taxa, 5);\nplot(net7taxa, showgamma=true, tipoffset=0.2);\nR\"mtext\"(\"rooted on hybrid edge 5 (minor)\", line=-1);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: reroot net7taxa 2)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"On the second plot, the A clade does not appear to be an outgroup, but this is just because the plot follows the major tree primarily, based the major hybrid edges (those with γ>0.5). We can display the exact same network differently, by changing the γ inheritance values to invert the major/minor consideration of the hybrid edges.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"net7taxa.edge[5] # just to check that it's one of the 2 hybrid edges of interest\nsetgamma!(net7taxa.edge[5], 0.501) # switch major/minor edges\nR\"svg(name('reroot_net7taxa_3.svg'), width=4, height=4)\"; # hide\nR\"layout(matrix(1,1,1))\"; # hide\nR\"par\"(mar=[0,0,0,0]); # hide\nplot(net7taxa, tipoffset=0.2); # not showing gamma values, because we changed them artificially\nR\"mtext\"(\"rooted on hybrid edge 5 (considered major)\", line=-1);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: reroot net7taxa 3)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Conclusion, in this particular example: it is possible to re-root the network to a place where the A clade is indeed an outgroup. But it did require some care, and we discovered that there are 2 acceptable rooting options. The first is more plausible, if we think that the species tree is the major tree, meaning that any gene flow or introgression event replaced less than 50% of the genes in the recipient population.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"In other cases, it may not be possible to re-root the network with a known outgroup. It would be the case if A1 was the only outgroup, and if A2 was an ingroup taxon. In such a case, the outgroup knowledge tells us that our estimated network is wrong. One (or more) reticulation in the network must be incorrect. Its placement might be correct, but then its direction would be incorrect.","category":"page"},{"location":"man/dist_reroot/#Extracting-the-major-tree","page":"Network comparison and manipulation","title":"Extracting the major tree","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can also compare the networks estimated with h=0 (net0) and h=1 (net1):","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"rootatnode!(net1, \"O\"); # the ; suppresses screen output\nhardwiredclusterdistance(net0, net1, true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"R\"svg(name('net1_O.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, showgamma=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: net1_O)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"They differ by 2 clusters: that's because A is of hybrid descent in net1 (descendant of each hybrid edge), not in net0.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"To beyond this hybrid difference, we can extract the major tree from the network with 1 hybridization, that is, delete the hybrid edge supported by less than 50% of genes. Then we can compare this tree with the ASTRAL/SNaQ tree net0.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"tree1 = majortree(net1); # major tree from net1\nhardwiredclusterdistance(net0, tree1, true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"They are identical (at distance 0), so here the species network with 1 hybrid node is a refinement of the estimated species tree (this needs not be the case always).","category":"page"},{"location":"man/dist_reroot/#Hardwired-cluster-distance","page":"Network comparison and manipulation","title":"Hardwired-cluster distance","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Is net1, the SNaQ network with 1 hybrid node, the same as the true network, the network that was initially used to simulate the data?","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Digression on this example's data: gene trees were simulated under the coalescent along some \"true\" network, then 500 base-pair alignments were simulated along each gene tree with the HKY model, gene trees were estimated from each alignment with RAxML, and these estimated gene trees served as input to both ASTRAL and SNaQ.)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"The \"true\" network is shown below, correctly rooted at the outgroup O, and plotted with branch lengths proportional to their values in coalescence units:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"truenet = readnewick(\"((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\");","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"R\"svg(name('truenet_sim.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, useedgelength=true, showgamma=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"(Image: truenet)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can compare two networks using the hardwired-cluster dissimilarity.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"This dissimilarity counts the number of hardwired clusters present in one network but absent in the other.\nThe hardwired cluster associated with an edge is the set of all tips descendant from that edge, i.e. all tips that inherited at least some genetic material from that edge.\nEach edge is associated with its hardwired cluster of descendants, and also with a \"tree\" tag or \"hybrid\" tag depending on the edge type.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"info: distance versus dissimilarity\nWhen comparing level-1 networks, or tree-child networks more generally, the hardwired-cluster dissimilarity is a distance: d(N, N') = 0 exactly when N and N' have the same topology. (Cardona et al. 2009, Bai et al. Maxfield et al. 2024). Unfortunately, this is not generally true for complex network: there are networks at hardwired-cluster 'distance' 0, that have different topologies. But no dissimilarity measure can both be fast to calculate and be a distance on the full space of phylogenetic networks (Cardona et al. 2014).","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"hardwiredclusterdistance(net1, truenet, true) # true: yes consider these networks as rooted","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Our estimated network is at distance 4 (not 0), so it is different from the true network (there was estimation error). From the plots, we see that:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"the underlying tree is correctly estimated\nthe origin of gene flow is correctly estimated: E\nthe target of gene flow is not correctly estimated: it was the lineage ancestral to (A,B), but it is estimated to be A only.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"The 4 cluster differences correspond to the 2 hybrid edges in net1 (whose cluster is A) plus the 2 hybrid edges in truenet (whose cluster is AB).","category":"page"},{"location":"man/dist_reroot/#Displayed-trees-and-subnetworks","page":"Network comparison and manipulation","title":"Displayed trees and subnetworks","text":"","category":"section"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can extract all trees displayed in a network. These trees are obtained by picking one parent hybrid edge at each hybrid node, and dropping the other parent hybrid edge. We can choose to pick the \"important\" hybrid edges only, with heritability γ at or above a threshold. Below we use a γ threshold of 0, so we get all displayed trees:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"t = displayedtrees(net1, 0.0) # list of trees displayed in network\nwritenewick(t[1], round=true)\nwritenewick(t[2], round=true)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"If we decide to keep edges with γ>0.2 only, then we are left with a single tree in the list (the major tree). This is because our example has 1 hybrid node with minor γ=0.196.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"t = displayedtrees(net1, 0.2)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"We can also delete all \"non-important\" reticulations, those with a minor heritability γ below some threshold. The function below changes our network net1, as indicated by its name ending with a !.","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"deletehybridthreshold!(net1, 0.1)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"Nothing happened to our network: because its γ is above 0.1. But if we set the threshold to 0.3, then our reticulation disappears:","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"deletehybridthreshold!(net1, 0.3)","category":"page"},{"location":"man/dist_reroot/","page":"Network comparison and manipulation","title":"Network comparison and manipulation","text":"See also function displayednetworkat! to get the network with a single reticulation of interest, and eliminate all other reticulations.","category":"page"},{"location":"lib/internals/#internal-documentation","page":"Internals","title":"internal documentation","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Documentation for PhyloNetworks's internal functions. These functions are not exported and their access (API) should not be considered stable. But they can still be used, like this for example: PhyloNetworks.foo() for a function named foo().","category":"page"},{"location":"lib/internals/#functions-and-types","page":"Internals","title":"functions & types","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [PhyloNetworks]\nPublic  = false\nOrder   = [:type,:function,:constant]","category":"page"},{"location":"lib/internals/#PhyloNetworks.ANode","page":"Internals","title":"PhyloNetworks.ANode","text":"ANode\n\nAbstract node. An object of type EdgeT has a node attribute, which is an vector of 2 objects of some subtype of ANode. The concrete type Node is a subtype of ANode, and has an edge attribute, which is vector of Edge objects (where Edge is an alias for EdgeT{Node}).\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.EdgeT","page":"Internals","title":"PhyloNetworks.EdgeT","text":"EdgeT{node type}\nEdge = EdgeT{Node}\nEdge(number, length=1.0)\n\nData structure for an edge and its various attributes. Most notably:\n\nnumber (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example\nnode: vector of Nodes, normally just 2 of them\nischild1 (boolean): true if node[1] is the child node of the edge, false if node[1] is the parent node of the edge\nlength: branch length\nhybrid (boolean): whether the edge is a tree edge or a hybrid edge (in which case ischild1 is important, even if the network is semi-directed)\ngamma: proportion of genetic material inherited by the child node via the edge; 1.0 for a tree edge\nismajor (boolean): whether the edge is the major path to the child node; true for tree edges, since a tree edge is the only path to its child node; normally true if gamma>0.5.\ncontainroot (boolean): is the interior of this edge a valid rooting position? That is, if we added a node on the edge, could we direct all edges away from this new node to root the semidirected network and get a valid rooted network?\n\nand other fields, used very internally\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.MatrixTopologicalOrder","page":"Internals","title":"PhyloNetworks.MatrixTopologicalOrder","text":"MatrixTopologicalOrder\n\nMatrix associated to a HybridNetwork in which rows and/or columns correspond to nodes in the network. In this matrix, nodes are indexed by their topological order. For example, if rows list nodes in network net, then V[i,:] corresponds to node net.vec_node[i].\n\nThe following functions and extractors can be applied to it: tiplabels, obj[:Tips], obj[:InternalNodes], obj[:TipsNodes]. See documentation for getindex(::MatrixTopologicalOrder, ::Symbol)).\n\nA MatrixTopologicalOrder object has field V (the matrix of interest) and fields for mapping indices in V to node numbers nodeNumbersTopOrder, internalNodeNumbers, tipNumbers, tipNames, indexation. Type in \"?MatrixTopologicalOrder.field\" to get documentation on a specific field.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.Node","page":"Internals","title":"PhyloNetworks.Node","text":"Node(number, leaf)\nNode(number, leaf, hybrid)\n\nData structure for a node and its various attributes. Most notably:\n\nnumber (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example\nleaf (boolean): whether the node is a leaf (with data typically) or an internal node (no data typically)\nname (string): taxon name for leaves; internal node may or may not have a name\nedge: vector of Edges that the node is attached to; 1 if the node is a leaf, 2 if the node is the root, 3 otherwise, and potentially more if the node has a polytomy\nhybrid (boolean): whether the node is a hybrid node (with 2 or more parents) or a tree node (with a single parent)\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.Partition","page":"Internals","title":"PhyloNetworks.Partition","text":"Partition\n\nData structure for a collection of edges. Used in SNaQ for groups of edges in the same cycle. Fields:\n\ncycle: vector of Int\nedges: vector of Edge\n\nTodo: use this to store the output of the blob decomposition, because biconnected components partition edges.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.TopologyConstraint","page":"Internals","title":"PhyloNetworks.TopologyConstraint","text":"Type for various topological constraints, such as:\n\na set of taxa forming a clade in the major tree\na set of individuals belonging to the same species\na set of taxa forming a clade in any one of the displayed trees\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.TopologyConstraint-Tuple{UInt8, Vector{String}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.TopologyConstraint","text":"TopologyConstraint(type::UInt8, taxonnames::Vector{String}, net::HybridNetwork)\n\nCreate a topology constraint from user-given type, taxon names, and network. There are 3 types of constraints:\n\ntype 1: A set of tips that forms a species.\ntype 2: A set of tips that forms a clade in the major tree. Note that the root matters. Constraining a set of species to be an outgroup is equivalent to constraining the ingroup to form a clade.\ntype 3: A set of tips that forms a clade in any one of the displayed trees.\n\nNote: currently, with type-1 constraints, hybridizations are prevented from coming into or going out of a species group.\n\nexamples\n\njulia> net = readnewick(\"(((2a,2b),(((((1a,1b,1c),4),(5)#H1),(#H1,(6,7))))#H2),(#H2,10));\");\n\njulia> c_species1 = PhyloNetworks.TopologyConstraint(0x01, [\"1a\",\"1b\",\"1c\"], net)\nSpecies constraint, on tips: 1a, 1b, 1c\n stem edge number 7\n crown node number -9\n\njulia> c_species2 = PhyloNetworks.TopologyConstraint(0x01, [\"2a\",\"2b\"], net)\nSpecies constraint, on tips: 2a, 2b\n stem edge number 3\n crown node number -4\n\njulia> nni!(net , net.edge[3], true, true, [c_species2]) === nothing # we get nothing: would break species 2\ntrue\n\njulia> # the following gives an error, because 4,5 do not form a clade in \"net\"\n       # PhyloNetworks.TopologyConstraint(0x02, [\"4\",\"5\"], net)\n\njulia> c_clade145 = PhyloNetworks.TopologyConstraint(0x02, [\"1a\",\"1b\",\"1c\",\"4\",\"5\"], net)\nClade constraint, on tips: 1a, 1b, 1c, 4, 5\n stem edge number 12\n crown node number -7\n\njulia> nni!(net , net.edge[12], true, true, [c_species1, c_clade145]) # we get nothing (failed NNI): would break the clade\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#Base.getindex","page":"Internals","title":"Base.getindex","text":"getindex(obj::MatrixTopologicalOrder,\n         d::Symbol,[ indTips, nonmissing])\n\nGet submatrices of a MatrixTopologicalOrder object. In obj.V, row and/column i corresponds to the ith node in topological order. In contrast, in matrix obj[:tips] for example, row and/or column i corresponds to the ith tip when tips are listed in the same order as in the network's original .node vector.\n\nArguments:\n\nobj::MatrixTopologicalOrder: the matrix from which to extract.\nd::Symbol: a symbol specifying which sub-matrix to extract. Can be:\n:Tips columns and/or rows corresponding to the tips\n:InternalNodes columns and/or rows corresponding to the internal nodes Includes tips not listed in indTips or missing data according to nonmissing.\n:TipsNodes columns corresponding to internal nodes, and row to tips (works only is indexation=\"b\")\nindTips::Vector{Int}: optional argument precising a specific order for the tips (internal use).\nnonmissing::BitArray{1}: optional argument saying which tips have data (internal use).  Tips with missing data are treated as internal nodes.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks._getnodeheights","page":"Internals","title":"PhyloNetworks._getnodeheights","text":"_getnodeheights(net::HybridNetwork, fixmissing::Bool,\n                inconsistencyhandler::Function, checkpreorder::Bool=true)\n\nHelper to determine time-consistency and calculate node heights (distance from the root), used by getnodeheights for example.\n\noutput: (isconsistent, nodes_distance_from_root)\n\nArguments:\n\nfixmissing:\nif false, any missing hybrid edge length will cause a warning, the network is not modified, and the best-case is assumed to determine time-consistency (as explained below)\nif true, will attempt to find values for missing lengths of hybrid edges, if any, to make the network time-consistent, placing hybrid nodes as close to the root as possible (as this gives most chances to find a time-consistent assignment of all missing hybrid edge lengths). If there is a time-consistent assignment, then the network is modified (with missing hybrid edge lengths set to time-consistent values). Otherwise, the network is not modified.\nThis option is passed to update_getnodeheights_hybrid! that handles 1 hybrid node at a time.\ninconsistencyhandler: function to check & handle time-consistency as desired as a given hybrid node h, and to decide if the traversal should continue. It should take as input:\na vector of ≥1 candicate heights for h from parent edges with non-missing length, and\na vector of ≥0 heights of parent nodes whose child edge to h has no length\nisconsistent: a boolean that is modified to false if the network is not time-consistent at h (unless an error is thrown anyway!).\nThis handler function decides what to do if the candidate heights are not all equal (the network is time-inconsistent), and if the values to be assigned to missing edge lengths would be negative. Its output should be: (keepgoing_boolean, hybrid_node_height).\nExamples: timeinconsistency_error is conservative and throws an error in both cases. timeinconsistency_average is lenient: only throws warnings, but keeps going and returns γ-weighted average node heights\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork, DataFrames.DataFrame}","page":"Internals","title":"PhyloNetworks.addAlternativeHybridizations!","text":"addAlternativeHybridizations!(net::HybridNetwork, BSe::DataFrame;\n                              cutoff::Number=10, top::Int=3)\n\nModify the network net (the best estimated network) by adding some of the hybridizations present in the bootstrap networks. By default, it will only add hybrid edges with more than 10% bootstrap support (cutoff) and it will only include the top 3 hybridizations (top) sorted by bootstrap support.\n\nThe dataframe BSe is also modified. In the original BSe, supposedly obtained with hybridclades_support, hybrid edges that do not appear in the best network have a missing number. After hybrid edges from bootstrap networks are added, BSe is modified to include the edge numbers of the newly added hybrid edges. To distinguish hybrid edges present in the original network versus new edges, an extra column of true/false values is also added to BSe, named \"alternative\", with true for newly added edges absent from the original network.\n\nThe hybrid edges added to net are added as minor edges, to keep the underlying major tree topology.\n\nexample\n\njulia> bootnet = readmultinewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\", \"bootsnaq.out\")); # vector of 10 networks\n\njulia> bestnet = readnewick(\"((O,(E,#H7:::0.196):0.314):0.332,(((A)#H7:::0.804,B):10.0,(C,D):10.0):0.332);\");\n\njulia> BSn, BSe, BSc, BSgam, BSedgenum = hybridclades_support(bootnet, bestnet);\n\njulia> BSe[1:6,[:edge,:hybrid_clade,:sister_clade,:BS_hybrid_edge]]\n6×4 DataFrame\n Row │ edge     hybrid_clade  sister_clade  BS_hybrid_edge \n     │ Int64?   String        String        Float64        \n─────┼─────────────────────────────────────────────────────\n   1 │       7  H7            B                       33.0\n   2 │       3  H7            E                       32.0\n   3 │ missing  c_minus3      c_minus8                44.0\n   4 │ missing  c_minus3      H7                      44.0\n   5 │ missing  E             O                       12.0\n   6 │ missing  c_minus6      c_minus8                 9.0\n\njulia> PhyloNetworks.addAlternativeHybridizations!(bestnet, BSe)\n\njulia> BSe[1:6,[:edge,:hybrid_clade,:sister_clade,:BS_hybrid_edge,:alternative]]\n6×5 DataFrame\n Row │ edge     hybrid_clade  sister_clade  BS_hybrid_edge  alternative \n     │ Int64?   String        String        Float64         Bool        \n─────┼──────────────────────────────────────────────────────────────────\n   1 │       7  H7            B                       33.0        false\n   2 │       3  H7            E                       32.0        false\n   3 │      16  c_minus3      c_minus8                44.0         true\n   4 │      19  c_minus3      H7                      44.0         true\n   5 │      22  E             O                       12.0         true\n   6 │ missing  c_minus6      c_minus8                 9.0        false\n\njulia> # using PhyloPlots; plot(bestnet, edgelabel=BSe[:,[:edge,:BS_hybrid_edge]]);\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addHybridBetweenClades!-Tuple{HybridNetwork, Number, Number}","page":"Internals","title":"PhyloNetworks.addHybridBetweenClades!","text":"addHybridBetweenClades!(net::HybridNetwork, hybnum::Number, sisnum::Number)\n\nModify net by adding a minor hybrid edge from \"donor\" to \"recipient\", where \"donor\" is the major parent edge e1 of node number hybnum and \"recipient\" is the major parent edge e2 of node number sisnum. The new nodes are currently inserted at the middle of these parent edges.\n\nIf a hybrid edge from e1 to e2 would create a directed cycle in the network, then this hybrid cannot be added. In that case, the donor edge e1 is moved up if its parent is a hybrid node, to ensure that the sister clade to the new hybrid would be a desired (the descendant taxa from e1) and a new attempt is made to create a hybrid edge.\n\nOutput: number of the new hybrid edge, or nothing if the desired hybridization is not possible.\n\nSee also: addhybridedge! (used by this method) and directionalconflict to check that net would still be a DAG.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addhybridedge!","page":"Internals","title":"PhyloNetworks.addhybridedge!","text":"addhybridedge!(\n    net::HybridNetwork,\n    edge1::Edge,\n    edge2::Edge,\n    hybridpartnernew::Bool,\n    edgelength::Float64=-1.0,\n    gamma::Float64=-1.0\n)\n\nAdd hybridization to net coming from edge1 going into edge2. 2 new nodes and 3 new edges are created: edge1 are edge2 are both cut into 2 edges, and a new edge is created linking the 2 new \"middle\" nodes, pointing from edge1 to edge2. The new node in the middle of edge1 is a tree node. The new node in the middle of edge2 is a hybrid node. Its parent edges are the newly created hybrid edge (with γ = gamma, missing by default), and either the newly edge \"above\" edge2 if hybridpartnernew=true, or the old edge2 otherwise (which would reverse the direction of edge2 and others).\n\nShould be called from the other method, which performs a bunch of checks. Updates containroot attributes for edges below the new hybrid node.\n\nOutput: new hybrid node (middle of the old edge2) and new hybrid edge.\n\nexamples\n\njulia> net = readnewick(\"((S8,(((S1,(S5)#H1),(#H1,S6)))#H2),(#H2,S10));\");\n\njulia> hybnode, hybedge = PhyloNetworks.addhybridedge!(net, net.edge[13], net.edge[8], true, 0.0, 0.2)\n(PhyloNetworks.Node:\n number:9\n name:H3\n hybrid node\n attached to 3 edges, numbered: 8 16 17\n, PhyloNetworks.EdgeT{PhyloNetworks.Node}:\n number:17\n length:0.0\n minor hybrid edge with gamma=0.2\n attached to 2 node(s) (parent first): 8 9\n)\n\n\njulia> writenewick(net)\n\"((S8,(((S1,(S5)#H1),((#H1,S6))#H3:::0.8))#H2),(#H2,(S10,#H3:0.0::0.2)));\"\n\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.addhybridedge!-Tuple{HybridNetwork, Bool, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.addhybridedge!","text":"addhybridedge!(\n    [rng::AbstractRNG,]\n    net::HybridNetwork,\n    nohybridladder::Bool,\n    no3cycle::Bool,\n    constraints::Vector{TopologyConstraint}=TopologyConstraint[];\n    maxattempts::Int=10,\n    fixroot::Bool=false\n)\n\nRandomly choose two edges in net then: add hybrid edge from edge 1 to edge 2 of length 0.01. The two halves of edge 1 (and of edge 2) have equal lengths. The hybrid partner edge (top half of edge 2, if fixroot is true) will point towards the newly-created node on the middle of the original edge 2, and have an inheritance γ randomly uniformly chosen in (0,0.5).\n\nIf the resulting network is a DAG, satisfies the constraint(s), does not contain any 3-cycle (if no3cycle=true), and does not have a hybrid ladder (if nohybridladder=true) then the proposal is successful: net is modified, and the function returns the newly created hybrid node and newly created hybrid edge.\n\nIf the resulting network is not acceptable, then a new set of edges is proposed (using a blacklist) until one is found acceptable, or until a maximum number of attempts have been made (maxattempts). If none of the attempted proposals are successful, nothing is returned (without causing an error).\n\nAfter a pair of edges is picked, the \"top\" half of edge2 is proposed as the partner hybrid edge with probability 0.8 if fixroot is false, (to avoid changing the direction of edge2 with more than 50% chance) and with probability 1.0 if fixroot is true. If this choice does not work and if fixroot is false, the other half of edge2 is proposed as the partner hybrid edge. Note that choosing the \"bottom\" half of edge2 as the partner edge requires to flip the direction of edge 2, and to move the root accordingly (to the original child of edge2).\n\nexamples\n\njulia> net = readnewick(\"((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));\");\n\njulia> using Random\n\njulia> Random.seed!(170);\n\njulia> PhyloNetworks.addhybridedge!(net, true, true)\n(PhyloNetworks.Node:\n number:9\n name:H3\n hybrid node\n attached to 3 edges, numbered: 5 16 17\n, PhyloNetworks.EdgeT{PhyloNetworks.Node}:\n number:17\n length:0.01\n minor hybrid edge with gamma=0.32771460911632916\n attached to 2 node(s) (parent first): 8 9\n)\n\njulia> writenewick(net, round=true, digits=2)\n\"((S1,(((#H1,S4),((S2,(S3)#H1))#H3:::0.67))#H2),((#H2,S5),#H3:0.01::0.33));\"\n\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addindividuals!-Tuple{HybridNetwork, AbstractString, Vector{<:AbstractString}}","page":"Internals","title":"PhyloNetworks.addindividuals!","text":"addindividuals!(net::HybridNetwork, species::AbstractString, individuals::Vector)\n\nAdd individuals to their species leaf as a star, and return the corresponding species constraint. nothing is returned in 2 cases:\n\nif individuals contains only 1 individual, in which case the name of the leaf for that species is replaced by the name of its one individual representative\nif species is not found in the network\n\nSpaces in individuals' names are eliminated, see cleantaxonname.\n\nCalled by mapindividuals.\n\nexamples\n\njulia> net = readnewick(\"(S8,(((S1,S4),(S5)#H1),(#H1,S6)));\");\n\njulia> PhyloNetworks.addindividuals!(net, \"S1\", [\"S1A\", \"S1B\", \"S1C\"])\nSpecies constraint, on tips: S1A, S1B, S1C\n stem edge number 2\n crown node number 2\n\njulia> writenewick(net) # 3 new nodes, S1 now internal: not a tip\n\"(S8,((((S1A,S1B,S1C)S1,S4),(S5)#H1),(#H1,S6)));\"\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.addleaf!","page":"Internals","title":"PhyloNetworks.addleaf!","text":"addleaf!(net::HybridNetwork, node::Node, leafname::String, edgelength::Float64=-1.0)\naddleaf!(net::HybridNetwork, edge::Edge, leafname::String, edgelength::Float64=-1.0)\n\nAdd a new external edge between node or between the \"middle\" of edge and a newly-created leaf, of name leafname. By default, the new edge length is missing (-1).\n\noutput: newly created leaf node.\n\nexamples\n\njulia> net = readnewick(\"((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));\");\n\njulia> net.node[6].name # leaf S4\n\"S4\"\n\njulia> PhyloNetworks.addleaf!(net, net.node[6], \"4a\"); # adding leaf to a node\n\njulia> writenewick(net, internallabel=true)\n\"((S1,(((S2,(S3)#H1),(#H1,(4a)S4)))#H2),(#H2,S5));\"\n\njulia> PhyloNetworks.addleaf!(net, net.node[6], \"4b\");\n\njulia> writenewick(net, internallabel=true)\n\"((S1,(((S2,(S3)#H1),(#H1,(4a,4b)S4)))#H2),(#H2,S5));\"\n\njulia> net = readnewick(\"((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));\");\n\njulia> [n.name for n in net.edge[7].node] # external edge to S4\n2-element Vector{String}:\n \"S4\"\n \"\"  \n\njulia> PhyloNetworks.addleaf!(net, net.edge[7], \"4a\"); # adding leaf to an edge\n\njulia> writenewick(net, internallabel=true)\n\"((S1,(((S2,(S3)#H1),(#H1,(S4,4a))))#H2),(#H2,S5));\"\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.adjacentedges-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.adjacentedges","text":"adjacentedges(centeredge::Edge)\n\nVector of all edges that share a node with centeredge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.allowrootbelow!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.allowrootbelow!","text":"allowrootbelow!(net::HybridNetwork)\n\nSet containroot to true for each edge below the root node, then traverses net in preorder to update containroot of all edges (stopping at hybrid nodes): see the other methods. Assumes correct ischild1 edge field.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.allowrootbelow!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.allowrootbelow!","text":"allowrootbelow!(e::Edge)\nallowrootbelow!(n::Node, parent_edge_of_n::Edge)\n\nSet containroot to true for edge e and all edges below, recursively. The traversal stops whenever a hybrid node is encountered: if the child of e is a hybrid node (that is, if e is a hybrid edge) or if n is a hybrid node, then the edges below e or n are not traversed.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.assignhybridnames!","text":"assignhybridnames!(net)\n\nAssign names to hybrid nodes in the network net. Hybrid nodes with an empty name field (\"\") are modified with a name that does not conflict with other hybrid names in the network. The preferred name is \"H3\" if the node number is 3 or -3, but an index other than 3 would be used if \"H3\" were the name of another node already.\n\nIf two hybrid nodes have non-empty and equal names, the name of one of them is changed and re-assigned as described above (with a warning).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.biconnectedcomponent_entrynodes","page":"Internals","title":"PhyloNetworks.biconnectedcomponent_entrynodes","text":"biconnectedcomponent_entrynodes(net, bcc, preorder=true)\n\nArray containing the entry node of the each biconnected component in bcc. bcc is supposed to contain the biconnected components as output by biconnectedcomponents, that is, an array of array of edges.\n\nThese entry nodes depend on the rooting (whereas the BCC only depend on the unrooted graph). They are either the root of the network or cut node (articulation points).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.biconnectedcomponent_exitnodes","page":"Internals","title":"PhyloNetworks.biconnectedcomponent_exitnodes","text":"biconnectedcomponent_exitnodes(net, bcc, preorder=true)\n\nArray containing an array of the exit node(s) of the each biconnected component in bcc. bcc is supposed to contain the biconnected components as output by biconnectedcomponents, that is, an array of array of edges.\n\nThese exit nodes depend on the rooting (whereas the BCC only depend on the unrooted graph). The degree of a blob is the number of exit nodes + 1 if the blob doesn't contain the root (its entry node is a cut node), or + 0 if the blob contains the root (which enters into the blob but isn't a cut node).\n\nWarning (or positive side effect?): the edge .inte1 attribute is modified. It stores the index (in bcc) of the biconnected component that an edge belongs to. If an edge doesn't belong in any (e.g. if trivial blobs are ignored), then its .inte1 is set to -1.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.blobinfo","page":"Internals","title":"PhyloNetworks.blobinfo","text":"blobinfo(network, ignoreTrivial=true)\n\nCalculate the biconnected components (blobs) using function biconnectedcomponents then:\n\nset node field booln4 to true at the root of each non-trivial blob (and at the network root), false otherwise. (a better name for the field would be something like \"isBlobRoot\".)\noutput:\narray of nodes that are the roots of each non-trivial blob, and the network root. If the root of the full network is not part of a non-trivial blob, a corresponding blob is added to the list.\narray of arrays: for each non-trivial blob, array of major hybrid edges in that blob.\narray of arrays: same as #2 but for minor hybrid edges, with hybrids listed in the same order, for each blob.\n\nBlobs are ordered in reverse topological ordering (aka post order). If ignoreTrivial is true, trivial components are ignored.\n\nkeyword argument: checkpreorder, true by default. If false, the ischild1 edge field and the net.vec_node network field are supposed to be correct.\n\nwarning: see biconnectedcomponents for node attributes modified during the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.breakedge!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.breakedge!","text":"breakedge!(edge::Edge, net::HybridNetwork)\n\nBreak an edge into 2 edges, each of length half that of original edge, creating a new node of degree 2. Useful to root network along an edge. Return the new node and the new edge, which is the \"top\" half of the original starting edge. These new node & edge are pushed last in net.node and net.edge.\n\nIf the starting edge was:\n\nn1  --edge-->  n2\n\nthen we get this:\n\nn1  --newedge-->  newnode  --edge-->  n2\n\nischild1 and containroot are updated, but not internal fields (e.g. not those used by SNaQ for level-1 networks).\n\nexamples\n\njulia> net = readnewick(\"(((S8,S9),((((S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\");\n\njulia> length(net.node)\n19\n\njulia> net.edge[4] # edge 4 goes from node -8 to 3\nPhyloNetworks.EdgeT{PhyloNetworks.Node}:\n number:4\n length:-1.0\n attached to 2 node(s) (parent first): -8 3\n\n\njulia> newnode, newedge = PhyloNetworks.breakedge!(net.edge[4], net);\n\njulia> length(net.node) # one more than before\n20\n\njulia> newedge # new edge 21 goes from node -8 and 11 (new)\nPhyloNetworks.EdgeT{PhyloNetworks.Node}:\n number:21\n length:-1.0\n attached to 2 node(s) (parent first): -8 11\n\n\njulia> net.edge[4] # original edge 4 now goes from node 11 (new) to 3\nPhyloNetworks.EdgeT{PhyloNetworks.Node}:\n number:4\n length:-1.0\n attached to 2 node(s) (parent first): 11 3\n\n\njulia> writenewick(net) # note extra pair of parentheses around S1\n\"(((S8,S9),((((S4,(S1)),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\"\n\nSee also: fuseedgesat!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.checkNumHybEdges!","text":"checkNumHybEdges!(net)\n\nCheck for consistency between hybrid-related attributes in the network:\n\nfor each hybrid node: 2 or more hybrid edges\nexception: allows for a leaf to be attached to a single hybrid edge\nexactly 2 incoming parent hybrid edges\n\nRun after storeHybrids!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.check_nonmissing_nonnegative_edgelengths","page":"Internals","title":"PhyloNetworks.check_nonmissing_nonnegative_edgelengths","text":"check_nonmissing_nonnegative_edgelengths(net, str=\"\")\n\nThrow an Exception if net has undefined edge lengths (coded as -1.0) or negative edge lengths. The error message indicates the number of the offending edge(s), followed by str.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.checkspeciesnetwork!-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}","page":"Internals","title":"PhyloNetworks.checkspeciesnetwork!","text":"checkspeciesnetwork!(network::HybridNetwork,\n                     constraints::Vector{TopologyConstraint})\n\nCheck that the network satisfies a number of requirements:\n\nno polytomies, other than at species constraints: throws an error otherwise\nno unnecessary nodes: fuse edges at nodes with degree two, including at the root (hence the bang: net may be modified)\ntopology constraints are met.\n\nOutput: true if all is good, false if one or more clades are violated.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.cleantaxonname-Tuple{AbstractString}","page":"Internals","title":"PhyloNetworks.cleantaxonname","text":"cleantaxonname(taxonname::AbstractString)\n\nReturn a String with leading and trailing spaces removed, and interior spaces replaced by underscores: good for using as tip names in a network without causing future error when reading the newick description of the network.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.constraintviolated-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}","page":"Internals","title":"PhyloNetworks.constraintviolated","text":"constraintviolated(network::HybridNetwork,\n                   constraints::Vector{TopologyConstraint})\n\nTrue if network violates one (or more) of the constraints of type 1 (individuals in a species group) or type 2 (must be clades in the major tree). Warning: constraints of type 3 are not implemented. See TopologyConstraint for constraint types.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.deleteEdge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.deleteEdge!","text":"deleteEdge!(net::HybridNetwork,  e::Edge; part=true)\n\nDelete edge e from net.edge and update net.numedges. If part is true, update the network's partition field.\n\nWarning: if part is true (the default), then net is assumed to be of level-1, with valid internal fields e.inte1 (to track which cycle e may be in) and valid net.partition, which then gets updated.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.deleteNode!-Tuple{HybridNetwork, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.deleteNode!","text":"deleteNode!(net::HybridNetwork, n::Node)\n\nDelete node n from a network, i.e. removes it from net.node, and from net.hybrid or net.leaf as appropriate. Update attributes numnodes, numtaxa, numhybrids.\n\nWarning: if the root is deleted, the new root is arbitrarily set to the first node in the list. This is intentional to save time because this function is used frequently in snaq!, which handles semi-directed (unrooted) networks.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.deletehybridedge!","page":"Internals","title":"PhyloNetworks.deletehybridedge!","text":"deletehybridedge!(net::HybridNetwork, edge::Edge,\n                  nofuse=false, unroot=false,\n                  multgammas=false, simplify=true, keeporiginalroot=false)\n\nDelete a hybrid edge from net and return the network. The network does not have to be of level 1 and may contain polytomies, although each hybrid node must have exactly 2 parents. Branch lengths are updated, allowing for missing values.\n\nIf nofuse is false, when edge is removed, its child (hybrid) node is removed and its partner hybrid edge is removed. Its child edge is retained (below the hybrid node), fused with the former partner, with new length: old length + length of edge's old partner. Any 2-cycle is simplified into a single edge, unless simplify is false.\n\nIf nofuse is true, edges with descendant leaves are kept as is, and are not fused. Nodes are retained during edge removal, provided that they have at least one descendant leaf. The hybrid edge that is partner to edge becomes a tree edge, but has its γ value unchanged (it is not set to 1), since it is not merged with its child edge after removal of the reticulation.   Also, 2-cycles are not simplified if nofuse is true. That is, if we get 2 hybrid edges both from the same parent to the same child, these hybrid edges are retained without being fused into a single tree edge.\n\nIf unroot is false and if the root is up for deletion during the process, it will be kept if it's of degree 2 or more. A root node of degree 1 will be deleted unless keeporiginalroot is true.\n\nIf multgammas is true: inheritance weights are kept by multiplying together the inheritance γ's of edges that are merged. For example, if there is a hybrid ladder, the partner hybrid edge remains a hybrid edge (with a new partner), and its γ is the product of the two hybrid edges that have been fused. So it won't add up to 1 with its new partner's γ.\n\nIf keeporiginalroot is true, a root of degree one will not be deleted.\n\nWarnings:\n\ncontainroot is updated, but this requires correct ischild1 fields\nif the parent of edge is the root and if nofuse is false, the root is moved to keep the network unrooted with a root of degree two.\ndoes not update attributes needed for snaq! (like inte1, edge.z, edge.y etc.)\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.descendants","page":"Internals","title":"PhyloNetworks.descendants","text":"descendants(edge::Edge, internal::Bool=false)\n\nReturn the node numbers of the descendants of a given edge: all descendant nodes if internal is true (internal nodes and tips), or descendant tips only otherwise (defaults).\n\nedge should belong in a rooted network for which ischild1 is up-to-date. Run directedges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.\n\nExamples\n\njulia> net5 = \"(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));\" |> readnewick |> directedges! ;\n\njulia> PhyloNetworks.descendants(net5.edge[12], true) # descendants of 12th edge: all of them\n7-element Vector{Int64}:\n -6\n -7\n  4\n  6\n  5\n -9\n  7\n\njulia> PhyloNetworks.descendants(net5.edge[12]) # descendant leaves only\n3-element Vector{Int64}:\n 4\n 5\n 7\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.directionalconflict-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool}","page":"Internals","title":"PhyloNetworks.directionalconflict","text":"directionalconflict(parent::Node, edge::Edge, hybridpartnernew::Bool)\n\nCheck if creating a hybrid edge down of parent node into the middle of edge would create a directed cycle in net, i.e. not a DAG. The proposed hybrid would go in the direction of edge down its child node if hybridpartnernew is true. Otherwise, both halves of edge would have their direction reversed, for the hybrid to go towards the original parent node of edge. Does not modify the network.\n\nOutput: true if a conflict would arise (non-DAG), false if no conflict.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.displayednetworks!","page":"Internals","title":"PhyloNetworks.displayednetworks!","text":"displayednetworks!(net::HybridNetwork, node::Node, keepNode=false,\n                   unroot=false, multgammas=false, keeporiginalroot=false)\n\nExtracts the two networks that simplify a given network at a given hybrid node: deleting either one or the other parent hybrid edge. If nofuse is true, the original edges (and nodes) are kept in both networks, provided that they have one or more descendant leaves. If unroot is true, the root will be deleted if it becomes of degree 2. If keeporiginalroot is true, the root is retained even if it is of degree 1.\n\nthe original network is modified: the minor edge removed.\nreturns one HybridNetwork object: the network with the major edge removed\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.edgerelation-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.edgerelation","text":"edgerelation(e::Edge, node::Node, origin::Edge)\n\nReturn a symbol:\n\n:origin if e is equal to origin, and otherwise:\n:parent if e is a parent of node,\n:child if e is a child of node\n\nusing the ischild1 attribute of edges. Useful when e iterates over all edges adjacent to node and when origin is one of the edges adjacent to node, to known the order in which these edges come.\n\nexample:\n\nlabs = [edgerelation(e, u, uv) for e in u.edge] # assuming u is a node of edge uv\nparentindex = findfirst(isequal(:parent), labs) # could be 'nothing' if no parent\nchildindices = findall( isequal(:child), labs)  # vector. could be empty\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.fliphybrid!","page":"Internals","title":"PhyloNetworks.fliphybrid!","text":"fliphybrid!(\n    net::HybridNetwork,\n    hybridnode::Node,\n    minor::Bool=true,\n    nohybridladder::Bool=false,\n    constraints::Vector{TopologyConstraint}=TopologyConstraint[]\n)\n\nFlip the direction of a single hybrid edge: the minor parent edge of hybridnode by default, or the major parent edge if minor is false. The parent node of the hybrid edge becomes the new hybrid node. The former hybrid edge partner is converted to a tree edge (with γ=1), and hybridnode becomes a tree node.\n\nFor the flip to be admissible, the new network must be a semi-directed phylogenetic network: with a root such that the rooted version is a DAG. If nohybridladder is false (default), the flip may create a hybrid ladder If nohybridladder is true and if the flip would create a hybrid ladder, then the flip is not admissible. A hybrid ladder is when a hybrid child of another hybrid.\n\nThe new hybrid partner is an edge adjacent to the new hybrid node, such that the flip is admissible (so it must be a tree edge). The flipped edge retains its original γ. The new hybrid edge is assigned inheritance 1-γ.\n\nOutput: (newhybridnode, flippededge, oldchildedge) if the flip is admissible, nothing otherwise.\n\nThe network is unchanged if the flip is not admissible. If the flip is admissible, the root position may be modified, and the direction of tree edges (via ischild1) is modified accordingly. If the root needs to be modified, then the new root is set to the old hybrid node.\n\nThe index of the new hybrid node in net.hybrid is equal to that of the old hybridnode.\n\nWarning: Undoing this move may not recover the original root if the root position was modified.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.fliphybrid!-Tuple{HybridNetwork, Bool, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.fliphybrid!","text":"fliphybrid!(\n    [rng::AbstractRNG,]\n    net::HybridNetwork,\n    minor::Bool,\n    nohybridladder::Bool=false,\n    constraints::Vector{TopologyConstraint}=TopologyConstraint[]\n)\n\nCycle through hybrid nodes in random order until an admissible flip is found. At this hybrid node, flip the indicated hybrid parent edge (minor or major).\n\nIf an admissible flip is found, return the tuple: newhybridnode, flippededge, oldchildedge. Otherwise, return nothing.\n\nThe flip can be undone with fliphybrid!(net, newhybridnode, minor, constraints), or fliphybrid!(net, newhybridnode, !flippededge.ismajor, constraints) more generally, such as if the flipped edge had its γ modified after the original flip.\n\nWarnings\n\nif the root needed to be reset and if the original root was of degree 2, then a node of degree 2 remains in the modified network.\nundoing the flip may not recover the original root in case the root position was modified during the original flip.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.fuseedgesat!","page":"Internals","title":"PhyloNetworks.fuseedgesat!","text":"fuseedgesat!(i::Integer,net::HybridNetwork, multgammas::Bool=false)\n\nRemoves ith node in net.node, if it is of degree 2. The parent and child edges of this node are fused. If either of the edges is hybrid, the hybrid edge is retained. Otherwise, the edge with the lower edge number is retained.\n\nReverts the action of breakedge!.\n\nreturns the fused edge.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.getTipSubmatrix-Tuple{Matrix, HybridNetwork}","page":"Internals","title":"PhyloNetworks.getTipSubmatrix","text":"getTipSubmatrix(M, net; indexation=:both)\n\nExtract submatrix of M, with rows and/or columns corresponding to tips in the network, ordered like in net.leaf. In M, rows and/or columns are assumed ordered as in net.vec_node.\n\nindexation: one of :rows, :cols or :both: are nodes numbers indexed in the matrix by rows, by columns, or both? Subsetting is taken accordingly.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getconnectingedge-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.getconnectingedge","text":"getconnectingedge(node1::Node, node2::Node)\n\nEdge shared by (or connecting) node1 and node2, that is: edge incident to both nodes. An error is thrown if the 2 nodes are not connected.\n\nSee also isconnected\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.getlengths-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}","page":"Internals","title":"PhyloNetworks.getlengths","text":"getlengths(edges::Vector{Edge})\n\nVector of edge lengths for a vector of edges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hardwiredclusterdistance_unrooted-Tuple{HybridNetwork, HybridNetwork}","page":"Internals","title":"PhyloNetworks.hardwiredclusterdistance_unrooted","text":"hardwiredclusterdistance_unrooted(net1::HybridNetwork, net2::HybridNetwork)\n\nMiminum hardwired cluster dissimilarity between the two networks, considered as unrooted (or semi-directed). This dissimilarity is defined as the minimum rooted distance, over all root positions that are compatible with the direction of hybrid edges. Called by hardwiredclusterdistance.\n\nTo avoid repeating identical clusters, all degree-2 nodes are deleted before starting the comparison. Since rooting the network at a leaf creates a root node of degree 2 and an extra cluster, leaves are excluded from possible rooting positions.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hashybridladder-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.hashybridladder","text":"hashybridladder(net::HybridNetwork)\n\nReturn true if net contains a hybrid ladder: where a hybrid node's child is itself a hybrid node. This makes the network not treechild, assuming it is fully resolved. (One of the nodes does not have any tree-node child).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hybrid3cycle-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.hybrid3cycle","text":"hybrid3cycle(edge1::Edge, edge2::Edge)\n\nCheck if proposed hybrid edge from edge1 into edge2 would create a 3 cycle, that is, if edge1 and edge2 have a node in common. (This move cannot create a 2-cycles because new nodes would be created in the middle of edges 1 and 2.)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.hybridEdges","text":"hybridEdges(node::Node, e::Edge)\n\nReturn the 2 edges connected to node other than e, in the same order as node.edge, except that e absent from the list.\n\nDespite what the name suggest, node need not be a hybrid node! node is assumed to have 3 edges, though.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.hybridEdges","text":"hybridEdges(node::Node)\n\nReturn the 3 edges attached to node in a specific order [e1,e2,e3]. Warning: assume a level-1 network with up-to-date node fields booln1 (tracking whether the node is incident to a hybrid edge and edge) and field intn1 (tracking the number given to the cycle in which the node might be).\n\nIf node is a hybrid node:\n\ne1 is the major hybrid parent edge of node\ne2 is the minor hybrid parent edge\ne3 is the tree edge, child of node.\n\nIf node is a tree node parent of one child hybrid edge:\n\ne1 is the hybrid edge, child of node\ne2 is the tree edge that belongs to the cycle created by e1\ne3 is the other tree edge attached to node (not in a cycle)\n\nOtherwise:\n\ne3 is an external edge from node to a leaf, if one exists.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.inheritanceweight-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.inheritanceweight","text":"inheritanceweight(tree::HybridNetwork)\n\nReturn the log inheritance weight of a network or tree (as provided by displayedtrees with nofuse = true for instance). For a tree displayed in a network, its inheritance weight is the log of the product of γ's of all edges retained in the tree. To avoid underflow, the log is calculated: i.e. sum of log(γ) across retained edges.\n\nIf any edge has a negative γ, it is assumed to mean that its γ is missing, and the function returns missing.\n\nExample\n\njulia> net = readnewick(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\");\n\njulia> trees = displayedtrees(net,0.0; nofuse=true);\n\njulia> PhyloNetworks.inheritanceweight.(trees)\n2-element Vector{Float64}:\n -0.105361\n -2.30259 \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.initializeweightsfromleaves!-Tuple{AbstractArray, HybridNetwork, Any, Any, Symbol}","page":"Internals","title":"PhyloNetworks.initializeweightsfromleaves!","text":"initializeweightsfromleaves!(w, net, tips, stateset, criterion)\n\nModify weight in w: to Inf for w[n, i] if the \"tips\" data has a state different from the lineage state of index i at node number n. Assumes that w was initialized to 0 for the leaves.\n\ncriterion: should be one of :softwired, :parental or :hardwired.\n\nsoftwired parsimony: lineage states are in this order: ∅,{1},{2},{3},...,{nstates}\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.initializeweightsfromleaves_softwired!-Tuple{AbstractArray, HybridNetwork, Any, Any}","page":"Internals","title":"PhyloNetworks.initializeweightsfromleaves_softwired!","text":"initializeweightsfromleaves_softwired!(w, net, tips, charset)\n\nModify weight in w: to Inf for w[n, s] if the \"tips\" data has a state different from s at node number n. Assumes that w was initialized to 0 for the leaves.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.isconnected-Tuple{Any, Any}","page":"Internals","title":"PhyloNetworks.isconnected","text":"isconnected(node1::Node, node2::Node)\n\nCheck if two nodes are connected by an edge. Return true if connected, false if not connected.\n\nSee also getconnectingedge\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.isdescendant-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.isdescendant","text":"isdescendant(des:Node, anc::Node)\n\nReturn true if des is a strict descendant of anc, using ischild1 fields to determine the direction of edges. See isdescendant_undirected for a version that does not use ischild1.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.isdescendant_undirected-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.isdescendant_undirected","text":"isdescendant_undirected(des:Node, ancestor::Node, parentedge)\n\nReturn true if des is a strict descendant of ancestor when starting from edge parentedge and going towards ancestor onward, regardless of the field ischild1 of tree edges; false otherwise.\n\nThis is useful to know how descendant relationships would change as a result of reverting the direction of a tree edge, without actually modifying the direction (ischild1) of any edge.\n\nparentedge should be connected to ancestor (not checked). The direction of hybrid edges is respected (via ischild1), that is, the traversal does not go from the child to the parent of a hybrid edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.ladderpartition-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.ladderpartition","text":"ladderpartition(tree::HybridNetwork)\n\nFor each node in tree, calculate the clade below each child edge of the node, and each clade moving up the \"ladder\" from the node to the root. The output is a tuple of 2 vectors (node) of vector (clade) of vectors (taxon in clade): below,above. More specifically, for node number n, below[n] is generally of vector of 2 clades: one for the left child and one for the right child of the node (unless the node is of degree 2 or is a polytomy). above[n] contains the grade of clades above node number n.\n\nWARNING: assumes that\n\nnode numbers and edge numbers can be used as indices, that is, be all distinct, positive, covering exactly 1:#nodes and 1:#edges.\nedges are corrected directed (ischild1 is up-to-date) and nodes have been pre-ordered already (field vec_node up-to-date).\n\nexamples\n\njulia> tree = readnewick(\"(O,A,((B1,B2),(E,(C,D))));\");\n\njulia> PhyloNetworks.resetnodenumbers!(tree; checkpreorder=true, type=:postorder)\n\njulia> printnodes(tree)\nnode leaf  hybrid name i_cycle edges'numbers\n1    true  false  O    -1      1   \n2    true  false  A    -1      2   \n3    true  false  B1   -1      3   \n4    true  false  B2   -1      4   \n8    false false       -1      3    4    5   \n5    true  false  E    -1      6   \n6    true  false  C    -1      7   \n7    true  false  D    -1      8   \n9    false false       -1      7    8    9   \n10   false false       -1      6    9    10  \n11   false false       -1      5    10   11  \n12   false false       -1      1    2    11  \n\njulia> below, above = PhyloNetworks.ladderpartition(tree);\n\njulia> below\n12-element Vector{Vector{Vector{Int64}}}:\n [[1]]                      \n [[2]]                      \n [[3]]                      \n [[4]]                      \n [[5]]                      \n [[6]]                      \n [[7]]                      \n [[3], [4]]                 \n [[6], [7]]                 \n [[5], [6, 7]]              \n [[3, 4], [5, 6, 7]]        \n [[1], [2], [3, 4, 5, 6, 7]]\n\njulia> for n in 8:12\n         println(\"clades below node \", n, \": \", join(below[n], \" \"))\n       end\nclades below node 8: [3] [4]\nclades below node 9: [6] [7]\nclades below node 10: [5] [6, 7]\nclades below node 11: [3, 4] [5, 6, 7]\nclades below node 12: [1] [2] [3, 4, 5, 6, 7]\n\njulia> above[8:12] # clades sister to and above nodes 8 through 12:\n5-element Vector{Vector{Vector{Int64}}}:\n [[5, 6, 7], [1], [2]]\n [[5], [3, 4], [1], [2]]\n [[3, 4], [1], [2]]     \n [[1], [2]]             \n []                     \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.leaststableancestor","page":"Internals","title":"PhyloNetworks.leaststableancestor","text":"leaststableancestor(net, preorder=true)\n\nReturn (lsa, lsa_index) where lsa is the least stable ancestor node (LSA) in net, and lsa_index is the index of lsa in net.vec_node. The LSA the lowest node n with the following property: any path between any leaf and the root must go through n. All such nodes with this property are ancestral to the LSA (and therefore must have an index that is lower or equal to lsa_index).\n\nException: if the network has a single leaf, the output lsa is the leaf's parent node, to maintain one external edge between the root and the leaf.\n\nWarning: uses biconnectedcomponents and biconnectedcomponent_exitnodes, therefore share the same caveats regarding the use of fields .inte1 and .intn1 (for edges and nodes), .intn2 (for nodes) etc. As a positivie side effect, the biconnected components can be recovered via the edges' .inte1 field –including the trivial blobs (cut edges).\n\nSee also: deleteaboveLSA!\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.majoredgelength-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.majoredgelength","text":"majoredgelength(net::HybridNetwork)\n\nGenerate vector of edge lengths of major net edges organized in the same order as the edge matrix created via majoredgematrix. Considers values of -1.0 as missing values, recognized as NA in R. Output: vector allowing for missing values.\n\nAssume vec_node was updated, to list nodes in pre-order.\n\nExamples\n\njulia> net = readnewick(\"(((A:3.1,(B:0.2)#H1:0.3::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);\");\n\njulia> directedges!(net); preorder!(net);\n\njulia> PhyloNetworks.majoredgelength(net)\n8-element Vector{Union{Missing, Float64}}:\n  missing\n 0.7     \n  missing\n 1.1     \n  missing\n 3.1     \n 0.3     \n 0.2     \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.majoredgematrix","text":"majoredgematrix(net::HybridNetwork)\n\nMatrix of major edges from net where edge[i,1] is the number of the parent node of edge i and edge[i,2] is the number of the child node of edge i. Assume vec_node was updated, to list nodes in pre-order.\n\nExamples\n\njulia> net = readnewick(\"(A,(B,(C,D)));\");\n\njulia> PhyloNetworks.resetnodenumbers!(net);\n\njulia> PhyloNetworks.majoredgematrix(net)\n6×2 Matrix{Int64}:\n 5  1\n 5  6\n 6  2\n 6  7\n 7  3\n 7  4\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.makemissing!-Tuple{AbstractVector}","page":"Internals","title":"PhyloNetworks.makemissing!","text":"makemissing!(x::AbstractVector)\n\nTurn to missing any element of x exactly equal to -1.0. Used for branch lengths and γs. x needs to accept missing values. If not, this can be done with allowmissing(x).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.mapindividuals-Tuple{HybridNetwork, String}","page":"Internals","title":"PhyloNetworks.mapindividuals","text":"mapindividuals(net::HybridNetwork, mappingFile::String)\n\nReturn a network expanded from net, where species listed in the mapping file are replaced by individuals mapped to that species. If a species has only 1 individual, the name of the leaf for that species is replaced by the name of its one individual representative. If a species has 2 or more individuals, the leaf for that species is expanded into a \"star\" (polytomy if 3 or more individuals) with a tip for each individual. If a species is in the network but not listed in the mapping file, the tip for that species is left as is. Species listed in the mapping file but not present in the network are ignored.\n\nThe mapping file should be readable by CSV.File and contain two columns: one for the species names and one for the individual (or allele) names. fixit: make this function more flexible by accepting column names\n\nOutput: individual-level network and vector of species constraint(s).\n\nexamples\n\njulia> species_net = readnewick(\"(((S8,S9),((((S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\");\n\njulia> filename = joinpath(dirname(Base.find_package(\"PhyloNetworks\")), \"..\", \"examples\", \"mappingIndividuals.csv\");\n\njulia> filename |> read |> String |> print # to see what the mapping file contains\nspecies,individual\nS1,S1A\nS1,S1B\nS1,S1C\n\njulia> individual_net, species_constraints = PhyloNetworks.mapindividuals(species_net, filename);\n\njulia> writenewick(individual_net, internallabel=true)\n\"(((S8,S9),(((((S1A,S1B,S1C)S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\"\n\njulia> species_constraints\n1-element Vector{PhyloNetworks.TopologyConstraint}:\n Species constraint, on tips: S1A, S1B, S1C\n stem edge number 4\n crown node number 3\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.maxParsimonyNet-Tuple{HybridNetwork, DataFrames.DataFrame}","page":"Internals","title":"PhyloNetworks.maxParsimonyNet","text":"maxParsimonyNet(T::HybridNetwork, df::DataFrame)\n\nwarning: feature to be re-implemented\nThis function has been disabled. It will be re-implemented, without the level-1 restriction. Please use version 0.16 of PhyloNetworks to access this older functionality, until a better one is made available.\n\nSearch for the most parsimonious network (or tree). A level-1 network is assumed. df should be a data frame containing the species names in column 1, or in a column named species or taxon. Trait data are assumed to be in all other columns. The search starts from topology T, which can be a tree or a network with no more than hmax hybrid nodes (see optional arguments below for hmax).\n\nOutput:\n\nestimated network in file .out (also in .log): best network overall and list of networks from each individual run.\nif any error occurred, file .err provides information (seed) to reproduce the error.\n\nOptional arguments include\n\nhmax: maximum number of hybridizations allowed (default 1)\nruns: number of starting points for the search (default 10); each starting point is T with probability probST=0.3 or a modification of T otherwise (using a NNI move, or a hybrid edge direction change)\nNfail: number of failures (proposed networks with equal or worse score) before the search is aborted. 75 by default: this is quite small, which is okay for a first trial. Larger values are recommended.\noutgroup: outgroup taxon.           It can be a taxon name (String) or Node number (Integer).           If none provided, or if the outgroup conflicts the starting           topology, the function returns an error\nfilename: root name for the output files. Default is \"mp\". If empty (\"\"), files are not created, progress log goes to the screen only (standard out).\nseed: seed to replicate a given search\ncriterion: parsimony score could be hardwired, softwired (default) or parental. Currently,            only softwired is implemented\n\nReferences\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.minorreticulationgamma","text":"minorreticulationgamma(net::HybridNetwork)\n\nVector of minor edge gammas (inheritance probabilities) organized in the same order as in the matrix created via minorreticulationmatrix. Considers values of -1.0 as missing values, recognized as NA in R. Output: vector allowing for missing values.\n\nExamples\n\njulia> net = readnewick(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\");\n\njulia> PhyloNetworks.minorreticulationgamma(net)\n1-element Vector{Union{Float64, Missings.Missing}}:\n 0.1\n\n\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.minorreticulationlength","text":"minorreticulationlength(net::HybridNetwork)\n\nVector of lengths for the minor hybrid edges, organized in the same order as in the matrix created via minorreticulationmatrix. Replace values of -1.0 with missing values recognized by R. Output: vector allowing for missing values.\n\nExamples\n\njulia> net = readnewick(\"(((A:3.1,(B:0.2)#H1:0.4::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);\");\n\njulia> PhyloNetworks.minorreticulationlength(net)\n1-element Vector{Union{Missing, Float64}}:\n 0.3\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.minorreticulationmatrix","text":"minorreticulationmatrix(net::HybridNetwork)\n\nMatrix of integers, representing the minor hybrid edges in net. edge[i,1] is the number of the parent node of the ith minor hybrid edge, and edge[i,2] is the number of its child node. Node numbers may be negative, unless they were modified by resetnodenumbers!. Assumes correct ischild1 fields.\n\nExamples\n\njulia> net = readnewick(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\");\njulia> PhyloNetworks.minorreticulationmatrix(net)\n1×2 Matrix{Int64}:\n -6  3\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.moveroot!-Tuple{HybridNetwork, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.moveroot!","text":"moveroot!(\n    [rng::AbstractRNG,]\n    net::HybridNetwork,\n    constraints::Vector{TopologyConstraint}=TopologyConstraint[]\n)\n\nMove the root to a randomly chosen non-leaf node that is different from the current root, and not within a constraint clade or species. Output: true if successul, nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.nj!","page":"Internals","title":"PhyloNetworks.nj!","text":"nj!(D::Matrix{Float64}, names::AbstractVector{<:AbstractString}=String[];\n    force_nonnegative_edges::Bool=false)\n\nConstruct a phylogenetic tree from the input distance matrix and vector of names (as strings), using the Neighbour-Joinging algorithm (Satou & Nei 1987). The order of the names argument should match that of the row (and column) of the matrix D. With force_nonnegative_edges being true, any negative edge length is changed to 0.0 (with a message).\n\nWarning: D is modified.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.nnimax-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.nnimax","text":"nnimax(e::Edge)\n\nReturn the number of NNI moves around edge e, assuming that the network is semi-directed. Return 0 if e is not internal, and more generally if either node attached to e does not have 3 edges.\n\nOutput: UInt8 (e.g. 0x02)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.norootbelow!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.norootbelow!","text":"norootbelow!(e::Edge)\n\nSet containroot to false for edge e and all edges below, recursively. The traversal stops if e.containroot is already false, assuming that containroot is already false all the way below down that edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.pairwisetaxondistance_gradient-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.pairwisetaxondistance_gradient","text":"pairwisetaxondistance_gradient(net; checkEdgeNumber=true, nodeAges=[])\n\n3-dim array: gradient of pairwise distances between all nodes. (internal and leaves); gradient with respect to edge lengths if nodeAges is empty; with respect to node ages otherwise. Assume correct net.vec_node (preorder).   This gradient depends on the network's topology and γ's only, not on branch lengths or node ages (distances are linear in either).\n\nWARNING: edge numbers need to range between 1 and #edges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsenewick_edgedata!-Tuple{IO, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.parsenewick_edgedata!","text":"parsenewick_edgedata!(s::IO, edge, numberOfLeftParentheses::Array{Int,1})\n\nHelper function for readnewick_subtree!. Modifies e according to the specified edge length and gamma values in the tree topology. Advances the stream s past any existing edge data. Edges in a topology may optionally be followed by \":edgeLen:bootstrap:gamma\" where edgeLen, bootstrap, and gamma are decimal values. Nexus-style comments [&...], if any, are ignored.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsenewick_getfloat!-Tuple{IO, Int64, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.parsenewick_getfloat!","text":"parsenewick_getfloat!(s::IO, int, numLeft::Array{Int,1})\n\nHelper function for parsenewick_edgedata!. Read a single floating point edge data value in a tree topology. Ignore (and skip) nexus-style comments before & after the value (see readnexus_comment).\n\nReturn -1.0 if no value exists before the next colon, return the value as a float otherwise. Modifies s by advancing past the next colon character. Only call this function to read a value when you know a numerical value exists!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsenewick_hybridnode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, String, HybridNetwork, Vector{String}}","page":"Internals","title":"PhyloNetworks.parsenewick_hybridnode!","text":"parsenewick_hybridnode!(node, parentNode, hybridName, net, hybrids)\n\nHelper function for readnewick_subtree!. Create the parent edge for node. Return this edge, and the hybrid node retained (node or its clone in the newick string). Insert new edge and appropriate node into net and hybrids accordingly. Handles any type of given hybrid node. Called after a # has been found in a tree topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsenewick_remainingsubtree!-Tuple{IO, Vector{Int64}, HybridNetwork, Vector{String}}","page":"Internals","title":"PhyloNetworks.parsenewick_remainingsubtree!","text":"parsenewick_remainingsubtree!(s::IO, numLeft, net, hybrids)\n\nCreate internal node. Helper for readnewick_subtree!, which creates the parent edge of the node created by parsenewick_remainingsubtree!: readnewick_subtree! calls parsenewick_remainingsubtree!, and vice versa. Called once a ( has been read in a tree topology and reads until the corresponding ) has been found. This function performs the recursive step for readnewick_subtree!. Advances s past the subtree, adds discovered nodes and edges to net, and hybrids.\n\nDoes not read the node name and the edge information of the subtree root: this is done by readnewick_subtree!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsenewick_treenode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, HybridNetwork}","page":"Internals","title":"PhyloNetworks.parsenewick_treenode!","text":"parsenewick_treenode!(node, parentNode, net)\n\nHelper function for readnewick_subtree!. Insert the input tree node and associated edge (created here) into net.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyGF_bottomup!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, Vararg{AbstractArray, 4}}","page":"Internals","title":"PhyloNetworks.parsimonyGF_bottomup!","text":"parsimonyGF_bottomup!(node, blobroot, nchar, w, scores,\n                     costmatrix1, costmatrix2)\n\nCompute the MP scores (one for each assignment of the blob root state) given the descendants of a blob, conditional on the states at predefined parents of hybrids in the blobs (one parent per hybrid) as described in\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\n\nAssumes a set of state guesses, ie correct initialization of w for predefined hybrid parents, and correct boole2 field for the children edges of these predefined parents. boole2 is true for edges that are cut.\n\nThe field booln4 is used to know which nodes are at the root of a blob. The field ischild1 is used (and assumed correct). Field intn1 is assumed to store the # of detached parents (with guessed states)\n\nnchar: number of characters considered at internal lineages. For softwired parsimony, this is # states + 1, because characters at internal nodes are ∅, {1}, {2}, etc. For parental parsimony, this is 2^#states -1, because characters are all sets on {1,2,...} except for the empty set ∅.\ncostmatrix1[i,j] and costmatrix2[k][i,j]: 2d array and vector of 2d arrays containing the cost of going to character j starting from character i when the end node has a single parent, or the cost of a child node having character j when its parents have characters k and i. These cost matrices are pre-computed depending on the parsimony criterion (softwired, hardwired, parental etc.)\n\nused by parsimonyGF.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyfitch-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T","page":"Internals","title":"PhyloNetworks.parsimonyfitch","text":"parsimonyfitch(net, tipdata)\n\nCalculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network. Tip data can be given in a data frame, in which case the taxon names are to appear in column 1 or in a column named \"taxon\" or \"species\", and trait values are to appear in column 2 or in a column named \"trait\". Alternatively, tip data can be given as a dictionary taxon => trait.\n\nalso return the union of all optimized character states at each internal node as obtained by Fitch algorithm, where the union is taken over displayed trees with the MP score.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyfitch_bottomup!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}, Vector{Int64}}} where T","page":"Internals","title":"PhyloNetworks.parsimonyfitch_bottomup!","text":"parsimonyfitch_bottomup!(node, states, score)\n\nBottom-up phase (from tips to root) of the Fitch algorithm: assign sets of character states to internal nodes based on character states at tips. Polytomies okay. Assumes a tree (no reticulation) and correct ischild1 attribute.\n\noutput: dictionary with state sets and most parsimonious score\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyfitch_summary-Union{Tuple{T}, Tuple{HybridNetwork, Dict{Int64, Set{T}}}} where T","page":"Internals","title":"PhyloNetworks.parsimonyfitch_summary","text":"parsimonyfitch_summary(tree, nodestates)\n\nsummarize character states at nodes, assuming a tree\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonyfitch_topdown!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}}} where T","page":"Internals","title":"PhyloNetworks.parsimonyfitch_topdown!","text":"parsimonyfitch_topdown!(node, states)\n\nTop-down phase (root to tips) of the Fitch algorithm: constrains character states at internal nodes based on the state of the root. Assumes a tree: no reticulation.\n\noutput: dictionary with state sets\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.parsimonysoftwired_bottomup!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, AbstractArray, AbstractArray}","page":"Internals","title":"PhyloNetworks.parsimonysoftwired_bottomup!","text":"parsimonysoftwired_bottomup!(node, blobroot, states, w, scores)\n\nComputing the MP scores (one for each assignment of the root state) of a swicthing as described in Algorithm 1 in the following paper:\n\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\nAssumes a switching (ie correct boole2 field) and correct ischild1 field. The field booln4 is used to know which nodes are at the root of a blob.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.postorder_nodeupdate!","page":"Internals","title":"PhyloNetworks.postorder_nodeupdate!","text":"traversal_postorder(nodes, init_function,\n    tip_function, internalnode_function, parameters...)\npostorder_nodeupdate!(node_index, nodes, output_array,\n    tip_function, internalnode_function, parameters...)\n\nGeneric tool to apply a post-order (or reverse topological ordering) algorithm, acting on a matrix where rows & columns correspond to nodes. Used by descendencematrix.\n\noutput: matrix output_array.\n\narguments:\n\nnodes: array of nodes in the network, pre-ordered, typically the internal net.vec_node after applying preorder!(net). This array is traversed in reverse order.\noutput_array: output object, of type Matrix, named V below\ninit_function: to initialize the output array, taking (nodes, parameters...) as arguments\ntip_function: to do whatever needs to be done to V at a leaf node, using (V, tip_index, parameters...) as arguments\ninternalnode_function: to do whatever needs to be done to V at an internal node, using arguments (V, node_index, childnodes_index_vector, childedges_vector, parameters...)\n\nThe last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.\n\nSee also traversal_preorder, and traversalupdate_default! for a default function that does nothing to V and returns true, with an adequate signature to be used here.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.preorder_nodeupdate!","page":"Internals","title":"PhyloNetworks.preorder_nodeupdate!","text":"traversal_preorder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters...)\ntraversal_preorder!(nodes, output_array, root_function, tree_node_function,\n                   hybrid_node_function, parameters...)\npreorder_nodeupdate!(node_index, nodes, output_array, root_function, tree_node_function,\n               hybrid_node_function, parameters...)\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by sharedpathmatrix and by pairwisetaxondistancematrix, for example. preorder_nodeupdate! is a helper that calls the root / tree node / hybrid node function as appropriate.\n\noutput: array object output_array.\n\narguments:\n\nnodes: array of nodes in the network, pre-ordered, typically the internal net.vec_node after applying preorder!(net)\noutput_array: output object, of type AbstractArray, named V below\ninit_function: to initialize the output array, taking (nodes, parameters...) as arguments\nroot_function: to do whatever needs to be done to V at the root, using (V, rootnode_index, parameters...) as arguments\ntree_node_function: to do whatever needs to be done to V at a tree node, using (V, treenode_index, parentnode_index, parentedge, parameters...) as arguments\nhybrid_node_function: to do whatever needs to be done to V at a hybrid node, using arguments (V, hybnode_index, parentnodes_index_vector, parentedges_vector, parameters...)\n\nThe last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.\n\nSee also traversal_postorder, and traversalupdate_default! for a default function that does nothing to V and returns true, with an adequate signature to be used here.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.problem4cycle-NTuple{4, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.problem4cycle","text":"problem4cycle(β::Node, δ::Node, α::Node, γ::Node)\n\nCheck if the focus edge uv has a 4 cycle that could lead to a 3 cycle after an chosen NNI. Return true if there is a problem 4 cycle, false if none.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readcsvtoarray-Tuple{DataFrames.DataFrame}","page":"Internals","title":"PhyloNetworks.readcsvtoarray","text":"readcsvtoarray(dat::DataFrame)\nreadcsvtoarray(filename::String)\n\nRead a CSV table containing both species names and data, create two separate arrays: one for the species names, a second for the data, in a format that parsimonyGF needs.\n\nWarning:\n\nit will try to find a column 'taxon' or 'species' for the taxon names. If none found, it will assume the taxon names are in column 1.\nwill use all other columns as characters\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readfastatoarray","page":"Internals","title":"PhyloNetworks.readfastatoarray","text":"readfastatoarray(filename::AbstractString, sequencetype=BioSequences.LongDNA{4})\n\nRead a fasta-formatted file. Return a tuple species, sequences where species is a vector of Strings with identifier names, and sequences is a vector of BioSequences, each of type sequencetype (DNA by default).\n\nWarnings:\n\nassumes a semi-sequential format, not interleaved. More specifically, each taxon name should appear only once. For this one time, the corresponding sequence may be broken across several lines though.\nfails if all sequences aren't of the same length\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.readnewick_nodename-Tuple{IO, Char, HybridNetwork, Vector{Int64}}","page":"Internals","title":"PhyloNetworks.readnewick_nodename","text":"readnewick_nodename(s::IO, c::Char, net, numLeft)\n\nAuxiliary function to read a taxon name during newick parsing. output: tuple (number, name, pound_boolean)\n\nNames may have numbers: numbers are treated as strings. Accepts # as part of the name (but excludes it from the name), in which case pound_boolean is true. # is used in extended newick to flag hybrid nodes.\n\nNexus-style comments following the node name, if any, are read and ignored.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readnewick_subtree!-Tuple{IO, PhyloNetworks.Node, Vector{Int64}, HybridNetwork, Vector{String}}","page":"Internals","title":"PhyloNetworks.readnewick_subtree!","text":"readnewick_subtree!(s::IO, parentNode, numLeft, net, hybrids)\n\nRecursive helper method for readnewick: read a subtree from an extended Newick topology. input s: IOStream/IOBuffer.\n\nReads additional info formatted as: :length:bootstrap:gamma. Allows for name of internal nodes without # after closing parenthesis: (1,2)A. Warning if hybrid edge without γ, or if γ (ignored) without hybrid edge\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readnexus_assigngammas!-Tuple{HybridNetwork, Dict}","page":"Internals","title":"PhyloNetworks.readnexus_assigngammas!","text":"readnexus_assigngammas!(net, d::Dict)\n\nAssign d[i] as the .gamma value of the minor parent edge of hybrid \"Hi\", if this hybrid node name is found, and if its minor parent doesn't already have a non-missing γ. See readnexus_extractgamma\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readnexus_comment-Tuple{IO, Char}","page":"Internals","title":"PhyloNetworks.readnexus_comment","text":"readnexus_comment(s::IO, c::Char)\n\nRead (and do nothing with) nexus-style comments: [& ... ]   Assumption: 'c' is the next character to be read from s.   Output: nothing.\n\nComments can appear after (or instead of) a node or leaf name, before or after an edge length, and after another comment.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readnexus_extractgamma-Tuple{Any}","page":"Internals","title":"PhyloNetworks.readnexus_extractgamma","text":"readnexus_extractgamma(nexus_string)\n\nExtract γ from comments and return a dictionary hybrid number ID => γ, from one single phylogeny given as a string. The output from BEAST2 uses this format for reticulations at minor edges, as output by bacter (Vaughan et al. 2017):\n\n#11[&conv=0, relSize=0.08, ...\n\nor as output by SpeciesNetwork (Zhang et al. 2018):\n\n#H11[&gamma=0.08]\n\nThe function below assumes that the \"H\" was already added back if not present already (from bacter), like this:\n\n#H11[&conv=0, relSize=0.19, ...\n\nThe bacter format is tried first. If this format doesn't give any match, then the SpeciesNetwork format is tried next.   See readnexus_assigngammas!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.readnexus_translatetable-Tuple{Any}","page":"Internals","title":"PhyloNetworks.readnexus_translatetable","text":"readnexus_translatetable(io)\n\nRead translate table from IO object io, whose first non-empty line should contain \"translate\". Then each line should have \"number name\" and the end of the table is indicated by a ;. Output tuple:\n\nline that was last read, and is not part of the translate table, taken from io\ntranslate: boolean, whether a table was successfully read\nid2name: dictionary mapping number to name.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.removeHybrid!","text":"removeHybrid!(net::Network, n::Node)\n\nDelete a hybrid node n from net.hybrid, and update net.numHybrid. The actual node n is not deleted. It is kept in the full list net.node. Very internal function, used by deletehybridedge! and others.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.remove_edgelengthsgammas!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.remove_edgelengthsgammas!","text":"remove_edgelengthsgammas!(net::HybridNetwork)\n\nReset all edge lengths and all hybrid edge γs to be missing (coded as -1.0).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.resetedgenumbers!","page":"Internals","title":"PhyloNetworks.resetedgenumbers!","text":"resetedgenumbers!(net::HybridNetwork, verbose=true)\n\nCheck that edge numbers of net are consecutive numbers from 1 to the total number of edges. If not, reset the edge numbers to be so.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.resetnodenumbers!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.resetnodenumbers!","text":"resetnodenumbers!(net::HybridNetwork; checkpreorder=true, type=:ape)\n\nChange internal node numbers of net to consecutive numbers from 1 to the total number of nodes.\n\nkeyword arguments:\n\ntype: default is :ape, to get numbers that satisfy the conditions assumed by the ape R package: leaves are 1 to n, the root is n+1, and internal nodes are higher consecutive integers. If :postorder, nodes are numbered in post-order, with leaves from 1 to n (and the root last). If :internalonly, leaves are unchanged. Only internal nodes are modified, to take consecutive numbers from (max leaf number)+1 and up. With this last option, the post-ordering of nodes is by-passed.\ncheckpreorder: if false, the ischild1 edge field and the net.vec_node network field are supposed to be correct (to get nodes in preorder). This is not needed when type=:internalonly.\n\nExamples\n\njulia> net = readnewick(\"(A,(B,(C,D)));\");\n\njulia> PhyloNetworks.resetnodenumbers!(net)\n\njulia> printnodes(net) # first column \"node\": root is 5\nnode leaf  hybrid name i_cycle edges'numbers\n1    true  false  A    -1      1   \n2    true  false  B    -1      2   \n3    true  false  C    -1      3   \n4    true  false  D    -1      4   \n7    false false       -1      3    4    5   \n6    false false       -1      2    5    6   \n5    false false       -1      1    6   \n\njulia> net = readnewick(\"(A,(B,(C,D)));\");\n\njulia> PhyloNetworks.resetnodenumbers!(net; type=:postorder)\n\njulia> printnodes(net) # first column \"node\": root is 7\nnode leaf  hybrid name i_cycle edges'numbers\n1    true  false  A    -1      1   \n2    true  false  B    -1      2   \n3    true  false  C    -1      3   \n4    true  false  D    -1      4   \n5    false false       -1      3    4    5   \n6    false false       -1      2    5    6   \n7    false false       -1      1    6   \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.resolvetreepolytomy!","page":"Internals","title":"PhyloNetworks.resolvetreepolytomy!","text":"resolvetreepolytomy!(net::HybridNetwork, n::Node, e1::Edge, e2::Edge)\n\nCreate new node v and new edge n --> v, detach edges e1 and e2 from n to connect them to v instead. Return the new edge, whose child is v.\n\nWarning: assumes that n is incident to both e1 and e2. It is best if these edges are originally children of n because the new edge is directed from n to the newly created node.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.resolvetreepolytomy!-Tuple{HybridNetwork, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.resolvetreepolytomy!","text":"resolvetreepolytomy!(net::HybridNetwork, n::Node)\n\nCreate new nodes and edges from a tree node n, until it has degree 3. It is best if the network's tree edges are correctly directed beforehand.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.rezip_canonical!-Tuple{Vector{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}","page":"Internals","title":"PhyloNetworks.rezip_canonical!","text":"rezip_canonical!(hybridnodes::Vector{Node}, childedges::Vector{Edge},\n                 originallengths::Vector{Float64})\n\nUndo unzip_canonical!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.samplebootstrap_multiloci-Tuple{Vector{Vector{HybridNetwork}}}","page":"Internals","title":"PhyloNetworks.samplebootstrap_multiloci","text":"samplebootstrap_multiloci(vector of tree lists; seed=0, generesampling=false, row=0)\nsamplebootstrap_multiloci!(tree list, vector of tree lists; seed=0, generesampling=false, row=0)\n\nSample bootstrap gene trees, 1 tree per gene. Set the seed with keyword argument seed, which is 0 by default. When seed=0, the actual seed is set using the clock. Assumes a vector of vectors of networks (see readmultinewick_files), each one of length 1 or more (error if one vector is empty, tested in bootsnaq).\n\nsite resampling: always, from sampling one bootstrap tree from each given list. This tree is sampled at random unless row>0 (see below).\ngene resampling: if generesampling=true (default is false), genes (i.e. lists) are sampled with replacement.\nrow=i: samples the ith bootstrap tree for each gene. row is turned back to 0 if gene resampling is true.\n\noutput: one vector of trees. the modifying function (!) modifies the input tree list and returns it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.setmultiplegammas!-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}","page":"Internals","title":"PhyloNetworks.setmultiplegammas!","text":"setmultiplegammas!(edges::Vector{Edge}, γs::Vector{Float64})\n\nSet the inheritance of the ith edge to the ith γ value, calling setgamma!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.shrink2cycleat!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool}","page":"Internals","title":"PhyloNetworks.shrink2cycleat!","text":"shrink2cycleat!(net::HybridNetwork, minor::Edge, major::Edge, unroot::Bool)\n\nRemove minor edge then update the branch length of the remaining major edge. Called by shrink2cycles!\n\nAssumption: minor and major do form a 2-cycle. That is, they start and end at the same node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.shrink3cycleat!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.Node, Bool}","page":"Internals","title":"PhyloNetworks.shrink3cycleat!","text":"shrink3cycleat!(net::HybridNetwork, hybrid::Node, edge1::Edge, edge2::Edge,\n                node1::Node, node2::Node, unroot::Bool)\n\nReplace a 3-cycle at a given hybrid node by a single node, if any. Assumption: edge1 (node1) and edge2 (node2) are the parent edges (nodes) of hybrid. Return true if a 3-cycle is found and removed, false otherwise. There is a 3-cycle if nodes 1 & 2 are connected, by an edge called e3 below.\n\nThere are two cases, with differing effects on the γ inheritance values and branch lengths.\n\nHybrid case: the 3-cycle is shrunk to a hybrid node, which occurs if either node 1 or 2 is a hybrid node (that is, e3 is hybrid). If e3 goes from node 1 to node 2, the 3-cycle (left) is shrunk as on the right:\n\n\\eA      /eB           \\eA  /eB\n 1--e3->2       γ1+γ2γ3 \\  / γ2(1-γ3)\n  \\    /               hybrid\n γ1\\  /γ2\n  hybrid\n\nwith new branch lengths: new tA = tA + (γ1.t1 + γ2γ3.(t2+t3))/(γ1+γ2γ3), new tB = tB + t2, provided that γ1, γ2=1-γ1, and γ3 are not missing. If one of them is missing then γ1 and γ2 remain as is, and e3 is deleted naively, such that new tA = tA + t1 and new tB = tB + t2. If γ's are not missing but one of t1,t2,t3 is missing, then the γ's are updated to γ1+γ2γ3 and γ2(1-γ3), but t's are update naively.\n\nTree case: the 3-cycle is shrunk to a tree node, which occurs if node 1 & 2 are both tree nodes (that is, e3 is a tree edge). If eC is the child edge of hybrid, the 3-cycle (left) is shrunk as on the right:\n\n\\eA                  \\eA\n 1--e3--2--eB--       \\\n  \\    /               n--eB--\n γ1\\  /γ2              |\n  hybrid               |eC\n    |\n    |eC\n\nwith new branch lengths: new tA = tA + γ2.t3, new tB = tB + γ1.t3, new tC = tC + γ1.t1 + γ2.t2, provided that γ1, γ2=1-γ1, t1, t2 and t3 are not missing. If one is missing, then e1 is deleted naively such that tB is unchanged, new tC = tC + t2 and new tA = tA + t3.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.shrinkedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.shrinkedge!","text":"shrinkedge!(net::HybridNetwork, edge::Edge)\n\nDelete edge from net, provided that it is a non-external tree edge. Specifically: delete its child node (as determined by ischild1) and connect all edges formerly incident to this child node to the parent node of edge, thus creating a new polytomy, unless the child was of degree 2.\n\nWarning: it's best for ischild1 to be in sync with the root for this. If not, the shrinking may fail (if edge is a tree edge but its \"child\" is a hybrid) or the root may change arbitrarily (if the child of edge is the root).\n\nOutput: true if the remaining node (parent of edge) becomes a hybrid node with more than 1 child after the shrinking; false otherwise (e.g. no polytomy was created, or the new polytomy is below a tree node)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.startingBL!","page":"Internals","title":"PhyloNetworks.startingBL!","text":"startingBL!(net::HybridNetwork,\n            trait::AbstractVector{Vector{Union{Missings.Missing,Int}}},\n            siteweight::AbstractVector{Float64}=ones(length(trait[1])))\n\nCalibrate branch lengths in net by minimizing the mean squared error between the JC-adjusted pairwise distance between taxa, and network-predicted pairwise distances, using calibratefrompairwisedistances!. The network is not forced to be time-consistent nor ultrametric. To avoid one source of non-identifiability, the network is \"zipped\" by forcing minor hybrid edges to have length 0.\n\nsiteweight[k] gives the weight of site (or site pattern) k (default: all 1s).\n\nAssumptions:\n\nall species have the same number of traits (sites): length(trait[i]) constant\ntrait[i] is for leaf with node.number = i in net, and trait[i][j] = k means that leaf number i has state index k for trait j. These indices are those used in a substitution model (see PhyloTraits.jl): kth value of getlabels(model).\n\nOther:\n\nHamming distances are calculated for each pair, ignoring any site in which one of 2 values is missing. The total number of differences is then divided by the total weight of all sites, ignoring that some of them may have been missing for the pair. This is an inexact rescaling of the hamming distance, assuming a small proportion of missing values for each pair.\nTheoretically, Hamming distances are < 0.75 with four states, or < (n-1)/n for n states. If not, all pairwise hamming distances are scaled by .75/(m*1.01) where m is the maximum observed hamming distance, to make them all < 0.75. The JC correction calculates: dJC = - 0.75 log(1-dhamming/0.75) for n=4 states\nAt the end, any edge length smaller than 1.0e-10 is reset to 0.0001, to avoid the 0 boundary.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.startree_newick","page":"Internals","title":"PhyloNetworks.startree_newick","text":"startree_newick(n, l)\n\nString for the Newick parenthetical description of the star tree with n tips, and all branch lengths equal to l.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.symmetricnet_newick","page":"Internals","title":"PhyloNetworks.symmetricnet_newick","text":"symmetricnet_newick(n::Int, h::Int, γ::Real)\n\nCreate a string for a symmetric network with 2^n tips, numbered from 1 to 2^n, with a symmetric major tree, whose branch lengths are all equal. 2^(n-h) hybrids are added from level h to h-1 \"symmetrically\". The network is time-consistent and ultrametric, with a total height of 1.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.symmetricnet_newick-Tuple{Int64, Int64, Int64, Real, Real}","page":"Internals","title":"PhyloNetworks.symmetricnet_newick","text":"symmetricnet_newick(n::Int, i::Int, j::Int, γ::Real, l::Real)\n\nNewick string for a network with a symmetric major tree with 2^n tips, numbered from 1 to 2^n. All the branch lengths of the major tree are set to l. One hybrid branch, going from level i to level j is added, cutting in half each initial edge in the tree. The new edge has length l and inheritance γ.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.symmetrictree_newick","page":"Internals","title":"PhyloNetworks.symmetrictree_newick","text":"symmetrictree_newick(n::Int, ell::Real, i=1)\n\nString for the Newick parenthetical description of a symmetric tree with 2^n tips, numbered from i to i+2^n-1. All branch lengths are set equal to ell. The tree can be created later by reading the string with readnewick.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.synchronizepartnersdata!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node}","page":"Internals","title":"PhyloNetworks.synchronizepartnersdata!","text":"synchronizepartnersdata!(e::Edge, n::Node)\n\nSynchronize γ and ismajor for edges e and its partner, both hybrid edges with the same child n:\n\nif one γ is missing and the other is not: set the missing γ to 1 - the other\nγ's should sum up to 1.0\nupdate ismajor to match the γ information: the major edge is the one with γ > 0.5.\n\nWarnings: does not check that e is a hybrid edge, nor that n is the child of e.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.timeinconsistency_average-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Ref{Bool}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}} where T<:Real","page":"Internals","title":"PhyloNetworks.timeinconsistency_average","text":"timeinconsistency_average(\n    candidate_nodeheights,\n    missingparent_heights,\n    isconsistent::Ref{Bool},\n    parent_edges,\n    nonmissingparent_j;\n    atol::Real=1e-8, rtol::Real=√eps(Float64))\n\nCalculate the γ-weighted average node height of a given hybrid node h, based on the candidate node heights from its parents with non-missing edge lengths.\n\nIf some of these parent edges have a missing γ, then equal weights are used and a warning is issued.\nIf the hybrid node's average height (calculate from non-missing lengths) turns out to be lower than one of the parent's height with a missing length (such that this parent edge would need to be assigned a negative value) then a warning is issued.\n\nOutcome:\n\nupdate isconsistent to false if the candidate node heights are not all equal or if some missing edge length would have to be assigned a negative value to make the network time-consistent\nreturns (true, nodeheight)\n\nAssumption: candidate_nodeheight is not empty, that is, the node has at least one parent edge with a non-missing length.\n\nSee also _getnodeheights and getnodeheights_average\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.timeinconsistency_check","page":"Internals","title":"PhyloNetworks.timeinconsistency_check","text":"timeinconsistency_error(\n    candidate_nodeheights,\n    missingparent_heights,\n    args...;\n    atol::Real=1e-8, rtol::Real=√eps(Float64))\ntimeinconsistency_check\n\nCheck that all candidate node heights are approximately equal to one another, and that this shared value nodeheight is higher (farther from the root) than the height of parents connected by edge of missing length missingparent_heights to ensure that these edge lengths would be assigned non-negative values.\n\nIf any of these conditions is not met, timeinconsistency_error throws an error. Otherwise, it returns (true, nodeheight) where true means that the network is (or could be) time-consistent at the node being considered. timeinconsistency_check returns (is_timeconsistent, nodeheight) but does not throw an error the is_timeconsistent if false (for either reason).\n\nAssumption: candidate_nodeheight is not empty, that is, the node has at least one parent edge with a non-missing length.\n\nSee also _getnodeheights\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.timeinconsistency_error-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Vararg{Any}}} where T<:Real","page":"Internals","title":"PhyloNetworks.timeinconsistency_error","text":"timeinconsistency_error(\n    candidate_nodeheights,\n    missingparent_heights,\n    args...;\n    atol::Real=1e-8, rtol::Real=√eps(Float64))\ntimeinconsistency_check\n\nCheck that all candidate node heights are approximately equal to one another, and that this shared value nodeheight is higher (farther from the root) than the height of parents connected by edge of missing length missingparent_heights to ensure that these edge lengths would be assigned non-negative values.\n\nIf any of these conditions is not met, timeinconsistency_error throws an error. Otherwise, it returns (true, nodeheight) where true means that the network is (or could be) time-consistent at the node being considered. timeinconsistency_check returns (is_timeconsistent, nodeheight) but does not throw an error the is_timeconsistent if false (for either reason).\n\nAssumption: candidate_nodeheight is not empty, that is, the node has at least one parent edge with a non-missing length.\n\nSee also _getnodeheights\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.timeinconsistency_majortree-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Ref{Bool}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}} where T<:Real","page":"Internals","title":"PhyloNetworks.timeinconsistency_majortree","text":"timeinconsistency_majortree(\n    candidate_nodeheights,\n    missingparent_heights,\n    isconsistent::Ref{Bool},\n    parent_edges,\n    nonmissingparent_j;\n    atol::Real=1e-8, rtol::Real=√eps(Float64))\n\nCalculate node height of a given hybrid node h, based on the its major parent node height, if its major parent edge has a non-missing length. If missing, then the non-missing edge length with the largest γ is used and a warning is issued. If all parent edges have missing γ values then an error is thrown.\n\nOutcome:\n\nupdate isconsistent to false if the candidate node heights are not all equal or if some missing edge length would have to be assigned a negative value to make the network time-consistent\nreturns (true, nodeheight)\n\nAssumption: candidate_nodeheight is not empty, that is, the node has at least one parent edge with a non-missing length.\n\nSee also _getnodeheights and getnodeheights_average\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.traversal_postorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.traversal_postorder","text":"traversal_postorder(nodes, init_function,\n    tip_function, internalnode_function, parameters...)\npostorder_nodeupdate!(node_index, nodes, output_array,\n    tip_function, internalnode_function, parameters...)\n\nGeneric tool to apply a post-order (or reverse topological ordering) algorithm, acting on a matrix where rows & columns correspond to nodes. Used by descendencematrix.\n\noutput: matrix output_array.\n\narguments:\n\nnodes: array of nodes in the network, pre-ordered, typically the internal net.vec_node after applying preorder!(net). This array is traversed in reverse order.\noutput_array: output object, of type Matrix, named V below\ninit_function: to initialize the output array, taking (nodes, parameters...) as arguments\ntip_function: to do whatever needs to be done to V at a leaf node, using (V, tip_index, parameters...) as arguments\ninternalnode_function: to do whatever needs to be done to V at an internal node, using arguments (V, node_index, childnodes_index_vector, childedges_vector, parameters...)\n\nThe last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.\n\nSee also traversal_preorder, and traversalupdate_default! for a default function that does nothing to V and returns true, with an adequate signature to be used here.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.traversal_preorder!","page":"Internals","title":"PhyloNetworks.traversal_preorder!","text":"traversal_preorder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters...)\ntraversal_preorder!(nodes, output_array, root_function, tree_node_function,\n                   hybrid_node_function, parameters...)\npreorder_nodeupdate!(node_index, nodes, output_array, root_function, tree_node_function,\n               hybrid_node_function, parameters...)\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by sharedpathmatrix and by pairwisetaxondistancematrix, for example. preorder_nodeupdate! is a helper that calls the root / tree node / hybrid node function as appropriate.\n\noutput: array object output_array.\n\narguments:\n\nnodes: array of nodes in the network, pre-ordered, typically the internal net.vec_node after applying preorder!(net)\noutput_array: output object, of type AbstractArray, named V below\ninit_function: to initialize the output array, taking (nodes, parameters...) as arguments\nroot_function: to do whatever needs to be done to V at the root, using (V, rootnode_index, parameters...) as arguments\ntree_node_function: to do whatever needs to be done to V at a tree node, using (V, treenode_index, parentnode_index, parentedge, parameters...) as arguments\nhybrid_node_function: to do whatever needs to be done to V at a hybrid node, using arguments (V, hybnode_index, parentnodes_index_vector, parentedges_vector, parameters...)\n\nThe last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.\n\nSee also traversal_postorder, and traversalupdate_default! for a default function that does nothing to V and returns true, with an adequate signature to be used here.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PhyloNetworks.traversal_preorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Function, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.traversal_preorder","text":"traversal_preorder(nodes, init_function, root_function, tree_node_function,\n                  hybrid_node_function, parameters...)\ntraversal_preorder!(nodes, output_array, root_function, tree_node_function,\n                   hybrid_node_function, parameters...)\npreorder_nodeupdate!(node_index, nodes, output_array, root_function, tree_node_function,\n               hybrid_node_function, parameters...)\n\nGeneric tool to apply a pre-order (or topological ordering) algorithm. Used by sharedpathmatrix and by pairwisetaxondistancematrix, for example. preorder_nodeupdate! is a helper that calls the root / tree node / hybrid node function as appropriate.\n\noutput: array object output_array.\n\narguments:\n\nnodes: array of nodes in the network, pre-ordered, typically the internal net.vec_node after applying preorder!(net)\noutput_array: output object, of type AbstractArray, named V below\ninit_function: to initialize the output array, taking (nodes, parameters...) as arguments\nroot_function: to do whatever needs to be done to V at the root, using (V, rootnode_index, parameters...) as arguments\ntree_node_function: to do whatever needs to be done to V at a tree node, using (V, treenode_index, parentnode_index, parentedge, parameters...) as arguments\nhybrid_node_function: to do whatever needs to be done to V at a hybrid node, using arguments (V, hybnode_index, parentnodes_index_vector, parentedges_vector, parameters...)\n\nThe last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.\n\nSee also traversal_postorder, and traversalupdate_default! for a default function that does nothing to V and returns true, with an adequate signature to be used here.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.traversalupdate_default!-Tuple{AbstractArray, Int64, Vararg{Any}}","page":"Internals","title":"PhyloNetworks.traversalupdate_default!","text":"traversalupdate_default!(::AbstractArray, ::Int, args...)\n\nReturns true. With its signature, this function can be used as a default update function at any node (root/tree/hybrid) in traversal_preorder or traversal_postorder, if we need a function that does nothing and keeps the traversal going.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}","page":"Internals","title":"PhyloNetworks.unzip_canonical!","text":"unzip_canonical!(net::HybridNetwork)\n\nUnzip all reticulations: set the length of child edge to 0, and increase the length of both parent edges by the original child edge's length, to obtain the canonical version of the network according to Pardi & Scornavacca (2015).\n\nOutput: vector of hybrid node in postorder, vector of child edges whose length is constrained to be 0, and vector of their original branch lengths to re-zip if needed using rezip_canonical!.\n\nAssumption: net.hybrid is correct, but a preordering of all nodes is not assumed.\n\nNote: This unzipping is not as straightforward as it might seem, because of \"nested\" zippers: when the child of a hybrid node is itself a hybrid node. The unzipping is propagated all the way through.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.unzipat_canonical!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"PhyloNetworks.unzipat_canonical!","text":"unzipat_canonical!(hyb::Node, childedge::Edge)\n\nUnzip the reticulation a node hyb. See unzip_canonical!. Warning: no check that hyb has a single child.\n\nOutput: constrained edge (child of hyb) and its original length.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.updateconstraintfields!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.updateconstraintfields!","text":"updateconstraintfields!(constraints::Vector{TopologyConstraint}, net::HybridNetwork)\n\nUpdate fields stem edge and crown node to match the given net.\n\nAssumes that the constraints are still met in net, and that nodes & edges are numbered identically in net as in the network used to create all constraints.\n\nfixit: remove the assumption that constraints are still met, since an NNI near the crown of a constrained clade might change the crown node and / or the stem edge (u and v exchange).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.updateconstraints!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}","page":"Internals","title":"PhyloNetworks.updateconstraints!","text":"updateconstraints!(constraints::Vector{TopologyConstraint}, net::HybridNetwork)\n\nUpdate the set taxonnum in each constraint, assuming that the stem edge and the crown node are still correct, and that their descendants are still correct. May be needed if the node and edge numbers were modified by resetnodenumbers! or resetedgenumbers!.\n\nWarning: does not check that the names of leaves with numbers in taxonnum are taxonnames.\n\njulia> net = readnewick(\"(((2a,2b),(((((1a,1b,1c),4),(5)#H1),(#H1,(6,7))))#H2),(#H2,10));\");\n\njulia> c_species1 = PhyloNetworks.TopologyConstraint(0x01, [\"1a\",\"1b\",\"1c\"], net)\nSpecies constraint, on tips: 1a, 1b, 1c\n stem edge number 7\n crown node number -9\n\njulia> c_species1.taxonnums\nSet{Int64} with 3 elements:\n  5\n  4\n  3\n\njulia> c_clade145 = PhyloNetworks.TopologyConstraint(0x02, [\"1a\",\"1b\",\"1c\",\"4\",\"5\"], net)\nClade constraint, on tips: 1a, 1b, 1c, 4, 5\n stem edge number 12\n crown node number -7\n\njulia> PhyloNetworks.resetnodenumbers!(net)\n\njulia> net.node[4].number = 111;\n\njulia> PhyloNetworks.updateconstraints!([c_species1, c_clade145], net)\n\njulia> c_species1\nSpecies constraint, on tips: 1a, 1b, 1c\n stem edge number 7\n crown node number 21\n\njulia> c_species1.taxonnums\nSet{Int64} with 3 elements:\n  5\n  4\n  111\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#index","page":"Internals","title":"index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"using PhyloNetworks\nmkpath(\"../assets/figures\")\nnet1 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net1.out\"))\nrotate!(net1, -6)","category":"page"},{"location":"man/net_plot/#Network-Visualization","page":"Network visualization","title":"Network Visualization","text":"","category":"section"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"To visualize a network, we can use the companion package PhyloPlots. Its manual has more examples, beyond the basic examples provided here.","category":"page"},{"location":"man/net_plot/#text-parenthetical-format:-extended-newick","page":"Network visualization","title":"text parenthetical format: extended newick","text":"","category":"section"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"To get started, we load a few networks that we will later visualize. They are available in files that come with the package.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"net2 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net2.out\"))\nnet3 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net3.out\"))","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"These networks are stored in extended newick parenthetical format, widely used by various software packages. This format encodes the network's topology, edge lengths, and edge inheritance γ for hybrid edges. These γ values measure the proportion of genes inherited via each parent at a reticulation event.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"A hybrid edge with γ=0.804 means that its child node (a hybrid or admixed population) received 80.4% of its genetic material from that edge.\nThe other parent hybrid edge of this hybrid population should have γ=0.196. If the event was introgression, then this means that 19.6% of genetic material was inherited by gene flow.   Generally, the γ values of all partners contributing to a given admixed population sum up to 100%.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Let's see this newick format, printed to the screen or written to a file:","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"net1\nwritenewick(net2)  # writes to screen, full precision for branch lengths and γ\nwritenewick(net2, round=true, digits=2)\nwritenewick(net2, di=true) # γ omitted: for dendroscope\nwritenewick(net2, \"mynetwork_net2.tre\") # writes to file: creates or overwrites file\nrm(\"mynetwork_net2.tre\") # hide","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"The option di=true is for the parenthetical format used by Dendroscope (without reticulation heritabilities). Copy this parenthetical description and paste it into Dendroscope, or use the plotting function described below.","category":"page"},{"location":"man/net_plot/#visualize-the-network-topology-and-γ-inheritance","page":"Network visualization","title":"visualize the network topology and γ inheritance","text":"","category":"section"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"The newick format is great for computers, but not quite for human eyes. Are our 2 networks similar? Below, we plot them side-by-side, using extra commands that use the RCall package (more on that later).","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"The key command here is plot, with option showgamma=true to plot γ values below each hybrid edge.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"using PhyloPlots\nusing RCall                  # to be able to tweak our plot within R\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('snaqplot_net23.svg'), width=7, height=3)\" # hide\nR\"layout(matrix(1:2, 1, 2))\" # to get 2 plots into a single figure: 1 row, 2 columns\nR\"par\"(mar=[0,0,1,0])        # for smaller margins\nplot(net2, showgamma=true);\nR\"mtext\"(\"hmax=2\")           # add text annotation: title here\nplot(net3, showgamma=true);\nR\"mtext\"(\"hmax=3\")\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"(Image: net23)","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Both networks have a single reticulation. In both, A is of hybrid origin, 80.4% sister to B, and 19.6% sister to E (which is otherwise sister to O). C & D are sister to each other, if we were to re-root the networks along the edge tha leads to ABEO.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"So, these 2 networks appear identical. Are they really? To be sure, we can calculate the hardwired-cluster distance between them, which extends the Robinson-Foulds distance on trees. See Comparing and manipulating networks for more on this dissimilarity.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"hardwiredclusterdistance(net2, net3, false) # rooted=false: to consider net2 and net3 as semidirected","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Indeed, these networks have the same semidirected topology.","category":"page"},{"location":"man/net_plot/#saving-the-plot","page":"Network visualization","title":"saving the plot","text":"","category":"section"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"In the example below, julia creates and sends the plot to R via RCall, so we can tweak the plot in various ways via commands sent to R. To save the plot in a file: we first tell R to create an image file, then we send the plot of the network, then we tell R to wrap up and save its image file.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"using PhyloPlots # to visualize networks\nusing RCall      # to send additional commands to R like this: R\"...\"\nimagefilename = \"../assets/figures/snaqplot_net1_2.svg\"\nR\"svg\"(imagefilename, width=4, height=3) # starts image file\nR\"par\"(mar=[0,0,0,0]) # to reduce margins (no margins at all here)\nplot(net1, showgamma=true, showedgenumber=true); # network is plotted & sent to file\nR\"dev.off()\"; # wrap up and save image file\nnothing # hide","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"(Image: net1_2)","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"The plot function has many options, to annotate nodes and edges. In the example above, hybrid edges were annotated with their γ inheritance values (in blue: light blue for the minor edge with γ<0.5, and dark blue for the major edge with γ>0.5), and edges were annotated with their internal numbers.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"We also used the option showedgenumber=true to see the edge numbers used internally. They is sometimes useful to re-root the network on some particular edge, for example.","category":"page"},{"location":"man/net_plot/#styles-and-options","page":"Network visualization","title":"styles and options","text":"","category":"section"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"To see the list of all options, type ? to switch to the help mode of Julia, then type the name of the function, here plot.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Below are two visualizations. The first uses the default style (:fulltree) and modified edge colors. The second uses the :majortree style. That style doesn't have an arrow by default for minor hybrid edges, but we can ask for one by specifying a positive arrow length.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"R\"svg(name('snaqplot_net1_3.svg'), width=7, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nR\"layout(matrix(1:2,1,2))\";\nplot(net1, showedgelength=true, minorhybridedgecolor=\"tan\");\nplot(net1, style=:majortree, arrowlen=0.07);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"(Image: net1_3)","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Edge lengths are shown, too. They were estimated in coalescent units: number of generations / effective population size. Some edge lengths are not identifiable, hence missing.","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"Below is another example, where space was added between the network and the taxon names via the tipoffset option. Also, edge colors were changed, and the nodes numbers are shown (used internally)","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"R\"svg(name('snaqplot_net1_4.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, tipoffset=0.5, shownodenumber=true, edgecolor=\"tomato4\",\n     minorhybridedgecolor=\"skyblue\", majorhybridedgecolor=\"tan\");\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/net_plot/","page":"Network visualization","title":"Network visualization","text":"(Image: net1_4)","category":"page"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"using PhyloNetworks\nusing DataFrames, CSV","category":"page"},{"location":"man/nj/#Neighbor-joining","page":"Neighbour Joining","title":"Neighbor joining","text":"","category":"section"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"A tree can be inferred from pairwise distances using the neighbor joining algorithm (Satou & Nei 1987)","category":"page"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"The nj function takes a data frame of pairwise distances as input and constructs a tree using the neighbor joining method.  The column names (headers) are used as taxon names.  Rows are assumed to correspond to taxa in the same order as they do in columns.","category":"page"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"D = DataFrame(CSV.File(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"caudata_dist.txt\")); copycols=false);\ntree = nj(D)","category":"page"},{"location":"man/nj/","page":"Neighbour Joining","title":"Neighbour Joining","text":"There is also a method PhyloNetworks.nj!, which takes a distance matrix and a vector of the names as argument.  This function, however, would modify D.  One also has to make sure the vector of names match the columns/rows of the distance matrix.","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"using PhyloNetworks","category":"page"},{"location":"man/netmanipulation/#Network-manipulation","page":"Network manipulation","title":"Network manipulation","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"The package contains many utilities to extract information about phylogenetic networks, and to modify networks. Functions that are not exported are more likely to experience breaking changes in future versions, but can be used by prefixing their name with PhyloNetworks. .","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"Below is a list of the most useful functions. They typically assume a bicombining network, that is, a network in which each hybrid node has exactly 2 parents (never more).","category":"page"},{"location":"man/netmanipulation/#Getting-information-on-a-network","page":"Network manipulation","title":"Getting information on a network","text":"","category":"section"},{"location":"man/netmanipulation/#overall-network-information","page":"Network manipulation","title":"overall network information","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"tiplabels for taxon labels\ngetroot gives the root node\npairwisetaxondistancematrix for average distances\nvcv for the variance-covariance matrix between taxa under a Brownian Motion model along the network, and sharedpathmatrix for the variance-covariance between all nodes (not just leaves)\nistimeconsistent: true or false, to know if for all nodes, the various paths from the root to that node have the same length (as expected if length was proportional to time)\ngetnodeages assuming the network is time-consistent and ultrametric\ndisplayedtrees or majortree to get the displayed trees or major tree, respectively\nhardwiredclusters to get all clusters of taxa on a network\nbiconnectedcomponents and PhyloNetworks.blobinfo give information about the blobs found within a network; also PhyloNetworks.biconnectedcomponent_entrynodes, PhyloNetworks.biconnectedcomponent_exitnodes, and blobdecomposition\ntreeedgecomponents are the components after removing hybrid edges\ncheckroot! to check that the graph is a valid semidirected network with a root node in a admissible rooting position","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"The following functions all compute distances from the root to each node. Their differ in how they handle time inconsistency: when the distance from the root to a node varies across multiple paths from the root to that node.","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"getnodeheights\ngetnodeheights_average\ngetnodeheights_majortree","category":"page"},{"location":"man/netmanipulation/#node-information","page":"Network manipulation","title":"node information","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To learn about nodes and how some might be related or connected, one can use:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"PhyloNetworks.isdescendant and PhyloNetworks.isconnected  can be used to learn about the relationship between two nodes\nhassinglechild\ngetparent or getparents if the node is a hybrid\ngetparentminor\ngetchild or getchildren if the node has more than one child\nisrootof","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To learn about the edges connected to a given node, one can use:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"getchildedge\nPhyloNetworks.getconnectingedge\ngetparentedge\ngetparentedgeminor for a hybrid node","category":"page"},{"location":"man/netmanipulation/#edge-information","page":"Network manipulation","title":"edge information","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To learn about the nodes related connected to a given edge, one can use the following functions: ","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"PhyloNetworks.descendants for the clade (\"hardwired cluster\") below an edge\ngetparent\ngetchild\ngetpartneredge gives the hybrid partner of an edge, if it is the parent edge of a hybrid node.\nisparentof, ischildof can inform whether an edge and node are connected\nhardwiredcluster to get the cluster of taxa below a particular edge","category":"page"},{"location":"man/netmanipulation/#Modifying-a-network","page":"Network manipulation","title":"Modifying a network","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To modify some of the core components of a network:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"rootonedge!, rootatnode!: very useful to root with an outgroup, and rotate! to improve plots\nnni! to perform a semidirected nearest neighbor interchange\nPhyloNetworks.fliphybrid! to flip the direction of a hybrid edge\nPhyloNetworks.unzip_canonical! to \"unzip\" (or zip down) all reticulations, or PhyloNetworks.rezip_canonical! to undo.\nsetlength! and setlengths! to change the length of one or more edges, and setgamma! to change a hybrid edge inheritance γ","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To remove components from a network:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"deleteleaf!\ndeleteaboveLSA!: the \"least stable ancestor\" may be different from the root\ndeletehybridthreshold! to simplify a network by deleting edges with small γ's\nPhyloNetworks.shrinkedge! to contract an edge\nremovedegree2nodes! to suppress degree-2 nodes\nshrink3cycles! and shrink2cycles! to contract \"cycles\" of 2 or 3 edges, which deletes 1 reticulation\nPhyloNetworks.deletehybridedge! to remove one hybrid edge.","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To add components to a network:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"PhyloNetworks.addleaf!\nPhyloNetworks.addhybridedge!","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To modify some internal attributes, that don't affect the network topology or edge parameters:","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"nameinternalnodes!\nPhyloNetworks.resetnodenumbers! and PhyloNetworks.resetedgenumbers!","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"To calibrate a network (modify its edge lengths):","category":"page"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"calibratefrompairwisedistances!. This documentation has little about calibration so far, but see this tutorial","category":"page"},{"location":"man/netmanipulation/#Comparing-two-networks","page":"Network manipulation","title":"Comparing two networks","text":"","category":"section"},{"location":"man/netmanipulation/","page":"Network manipulation","title":"Network manipulation","text":"hardwiredclusterdistance: extends the Robinson-Foulds distance. It's a dissimilarity measure on networks: a dissimilarity of 0 does not guarantee that the 2 networks have the same topology in general. But it does if the networks are in some classes (e.g. trees, level-1, tree-child, and others).","category":"page"},{"location":"lib/public/#public-documentation","page":"Public","title":"public documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for PhyloNetworks's public (exported) interface.","category":"page"},{"location":"lib/public/#functions-and-types","page":"Public","title":"functions & types","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [PhyloNetworks]\nPrivate = false\nOrder   = [:function,:type]","category":"page"},{"location":"lib/public/#PhyloNetworks.biconnectedcomponents","page":"Public","title":"PhyloNetworks.biconnectedcomponents","text":"biconnectedcomponents(network, ignoreTrivial=false)\n\nCalculate biconnected components (aka \"blobs\") using Tarjan's algorithm.\n\nOutput: array of arrays of edges.\n\nthe length of the array is the number of blobs\neach element is an array of all the edges inside a given blob.\n\nThese blobs are returned in post-order, but within a blob, edges are not necessarily sorted in topological order. If ignoreTrivial is true, trivial components (of a single edge) are not returned. The network is assumed to be connected.\n\nWarnings: for nodes, fields k and intn1 are modified during the algorithm. They are used to store the node's \"index\" (time of visitation), \"lowpoint\", and the node's \"parent\", as defined by the order in which nodes are visited. For edges, field boole2 is modified, to store whether the edge has been already been visited or not.\n\nReferences:\n\np. 153 of Tarjan (1972). Depth first search and linear graph algorithms, SIAM Journal on Computing, 1(2):146-160\non geeksforgeeks, there is an error (as of 2018-01-30): elif v != parent[u] and low[u] > disc[v]: (python version) should be replaced by elif v != parent[u] and disc[u] > disc[v]:\nnice explanation at this url\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.biconnectedcomponents-NTuple{5, Any}","page":"Public","title":"PhyloNetworks.biconnectedcomponents","text":"biconnectedcomponents(node, index, S, blobs, ignoreTrivial)\n\nHelper recursive function starting at a node (not a network). index is an array containing a single integer, thus mutable: order in which nodes are visited.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.blobdecomposition-Tuple{Any}","page":"Public","title":"PhyloNetworks.blobdecomposition","text":"blobdecomposition!(network)\nblobdecomposition(network)\n\nFind blobs using biconnectedcomponents; find their roots using blobinfo; create a forest in the form of a disconnected network (for efficiency), by deconnecting the root of each non-trivial blob from its parent. The root of each blob corresponds to a new leaf (in another tree of the forest): the number of the blob's root is given to the newly created leaf.\n\nThe first (bang) version modifies the network and returns the array of blob roots. The second version copies the network then returns a tuple: the forest and the array of blob roots.\n\nWarnings:\n\nthe forest is represented by a single HybridNetwork object, on which most functions don't work (like writenewick, plotting etc.) because the network is disconnected (to make the forest). Revert back to low-level functions, e.g. printedges and printnodes.\nsee biconnectedcomponents for node attributes modified during the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.calibratefrompairwisedistances!-Tuple{HybridNetwork, Matrix{Float64}, Vector{<:AbstractString}}","page":"Public","title":"PhyloNetworks.calibratefrompairwisedistances!","text":"calibratefrompairwisedistances!(net, distances::Matrix{Float64},\n    taxon_names::Vector{<:AbstractString})\n\nCalibrate the network to match (as best as possible) input pairwise distances between taxa, such as observed from sequence data. taxon_names should provide the list of taxa, in the same order in which they they are considered in the distances matrix. The optimization criterion is the sum of squares between the observed distances, and the distances from the network (weighted average of tree distances, weighted by γ's). The network's edge lengths are modified.\n\nWarning: for many networks, mutiple calibrations can fit the pairwise distance data equally well (lack of identifiability). This function will output one of these equally good calibrations.\n\noptional arguments (default):\n\ncheckpreorder (true)\nforceMinorLength0 (false) to force minor hybrid edges to have a length of 0\nultrametric (true) to force the network to be\ntime-consistent: all paths from the root to a given node must have the same length, so the age of this node is well-defined, and\nultrametric: all tips are at the same distance from the root, so have the same age.\nNLoptMethod (:LD_MMA) for the optimization algorithm. Other options include :LN_COBYLA (derivative-free); see NLopt package.\ntolerance values to control when the optimization is stopped: ftolRel (1e-12), ftolAbs (1e-10) on the criterion, and xtolRel (1e-10), xtolAbs (1e-10) on branch lengths / divergence times.\nverbose (false)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.checkroot!-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.checkroot!","text":"checkroot!(net)\ncheckroot!(net::HybridNetwork, membership::Dict{Node, Int})\n\nSet the root of net to an appropriate node and update the edges containroot field appropriately, using the membership output by treeedgecomponents. A node is appropriate to serve as root if it belongs in the root tree-edge component, that is, the root of the tree-edge component graph.\n\nIf the current root is appropriate, it is left as is. The direction of edges (via ischild1) is also left as is, assuming it was in synch with the existing root.\nOtherwise, the root is set to the first appropriate node in net.node, that is not a leaf. Then edges are directed away from this root.\n\nA RootMismatch error is thrown if net is not a valid semidirected phylogenetic network (i.e. it is not possible to root the network in a way compatible with the given hybrid edges).\n\nOutput: the membership ID of the root component. The full set of nodes in the root component can be obtained as shown below. Warning: only use the output component ID after calling the second version checkroot!(net, membership).\n\njulia> net = readnewick(\"(#H1:::0.1,#H2:::0.2,(((b)#H1)#H2,a));\");\n\njulia> membership = treeedgecomponents(net);\n\njulia> rootcompID = checkroot!(net, membership);\n\njulia> rootcomp = keys(filter(p -> p.second == rootcompID, membership));\n\njulia> sort([n.number for n in rootcomp]) # number of nodes in the root component\n3-element Vector{Int64}:\n -3\n -2\n  4\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.cladewiseorder!-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.cladewiseorder!","text":"cladewiseorder!(net::HybridNetwork)\n\nUpdate the internal attribute net.vec_int1. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges' direction needs to be correct before calling cladewiseorder!, using directedges!\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.deleteaboveLSA!","page":"Public","title":"PhyloNetworks.deleteaboveLSA!","text":"deleteaboveLSA!(net, preorder=true)\n\nDelete edges and nodes above (ancestral to) the least stable ancestor (LSA) of the leaves in net. See leaststableancestor for the definition of the LSA. Output: modified network net.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.deletehybridthreshold!","page":"Public","title":"PhyloNetworks.deletehybridthreshold!","text":"deletehybridthreshold!(net::HybridNetwork, threshold::Float64,\n                       nofuse=false, unroot=false, multgammas=false,\n                       keeporiginalroot=false)\n\nDeletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.\n\nif threshold<0.5: delete minor hybrid edges with γ < threshold (or with a missing γ, for any threshold > -1.0)\nif threshold=0.5: delete all minor hybrid edges (i.e normally with γ < 0.5, if γ non-missing)\nnofuse: if true, do not fuse edges and keep original nodes.\nunroot: if false, the root will not be deleted if it becomes of degree 2.\nmultgammas: if true, the modified edges have γ values equal to the proportion of genes that the extracted subnetwork represents. For an edge e in the modified network, the inheritance γ for e is the product of γs of all edges in the original network that have been merged into e.\n\n-keeporiginalroot: if true, the root will be retained even if of degree 1.\n\nWarnings:\n\nby default, nofuse is false, partner hybrid edges are fused with their child edge and have their γ changed to 1.0. If nofuse is true: the γ's of partner hybrid edges are unchanged.\nassumes correct ismajor fields, and correct ischild1 fields to update containroot.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.deleteleaf!-Tuple{HybridNetwork, PhyloNetworks.Node}","page":"Public","title":"PhyloNetworks.deleteleaf!","text":"deleteleaf!(HybridNetwork, leafName::AbstractString; ...)\ndeleteleaf!(HybridNetwork, Node; ...)\ndeleteleaf!(HybridNetwork, Integer; index=false, ...)\n\nDelete a node from the network, possibly from its name, number, or index in the network's array of nodes. The first two versions require that the node is a leaf. The third version does not require that the node is a leaf: If it has degree 3 or more, nothing happens. If it has degree 1 or 2, then it is deleted.\n\nkeyword arguments\n\nsimplify: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.\n\nunroot: if true, a root of degree 1 or 2 is deleted. If false, the root is deleted if it is of degree 1 (no root edge is left), but is kept if it is of degree 2. Deleting all leaves in an outgroup clade or grade will leave the ingroup rooted (that is, the new root will be of degree 2).\n\nnofuse: if true, keep nodes (and edges) provided that they have at least one descendant leaf, even if they are of degree 2. This will keep two-cycles (forcing simplify to false). Nodes without any descendant leaves are deleted. If nofuse is false, edges adjacent to degree-2 nodes are fused.\n\nmultgammas: if true, the fused edge has γ equal to the product of the hybrid edges that have been fused together, which may result in tree edges with γ<1, or with reticulations in which the two parent γ don't add up to 1.\n\nkeeporiginalroot: if true, keep the root even if it is of degree one (forcing unroot to be false).\n\nWarning: does not update edges' containroot nor internal attributes (e.g. those used by SNaQ for level-1 networks). Does not require branch lengths, and designed to work on networks of all levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.descendencematrix-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.descendencematrix","text":"descendencematrix(net::HybridNetwork; checkpreorder::Bool=true)\n\nDescendence matrix between all the nodes of a network: object D of type MatrixTopologicalOrder in which D[i,j] is the proportion of genetic material in node i that can be traced back to node j. If D[i,j]>0 then j is a descendent of i (and j is an ancestor of i). The network is assumed to be pre-ordered if checkpreorder is false. If checkpreorder is true (default), preorder! is run on the network beforehand.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.directedges!-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.directedges!","text":"directedges!(net::HybridNetwork; checkMajor::Bool=true)\n\nUpdates the edges' attribute ischild1, according to the root placement. Also updates edges' attribute containroot, for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if checkMajor is true.\n\nWarnings:\n\nAssumes that ischild1 is correct on hybrid edges (to avoid changing the identity of which nodes are hybrids and which are not).\nDoes not check for cycles (to maintain a network's DAG status)\n\nReturns the network. Throws a 'RootMismatch' Exception if the root was found to conflict with the direction of any hybrid edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.displayednetworkat!","page":"Public","title":"PhyloNetworks.displayednetworkat!","text":"displayednetworkat!(net::HybridNetwork, node::Node, nofuse=false,\n                    unroot=false, multgammas=false)\n\nDelete all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before. If nofuse is true, edges are not fused (degree-2 nodes are kept).\n\nWarning: assume correct ismajor fields.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.displayedtrees-Tuple{HybridNetwork, Float64}","page":"Public","title":"PhyloNetworks.displayedtrees","text":"displayedtrees(net::HybridNetwork, gamma::Float64; nofuse::Bool=false,\n               unroot::Bool=false, multgammas::Bool=false,\n               keeporiginalroot::Bool=false)\n\nExtracts all trees displayed in a network, following hybrid edges with heritability >= γ threshold (or >0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than γ. Returns an array of trees, as HybridNetwork objects.\n\nnofuse: if true, do not fuse edges (keep degree-2 nodes) during hybrid edge removal.   unroot: if false, the root will not be deleted if it becomes of degree 2 unless   keeporiginalroot is true.   multgammas: if true, the edges in the displayed trees have γ values   equal to the proportion of genes that the edge represents, even though all   these edges are tree edges. The product of all the γ values across all edges   is the proportion of genes that the tree represents. More specifically,   edge e in a given displayed tree has γ equal to the product of γs   of all edges in the original network that have been merged into e.   keeporiginalroot: if true, keep root even if of degree 1.\n\nWarnings:\n\nif nofuse is true: the retained partner hybrid edges have their γ values unchanged, but their ismajor is changed to true\nassume correct ismajor attributes.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Public","title":"PhyloNetworks.getchild","text":"getchild(edge)\ngetchild(node)\ngetchildren(node)\n\nGet child(ren) node(s).\n\ngetchild: single child node of edge, or of node after checking that node has a single child.\ngetchildren: vector of all children nodes of node.\n\ngetchildedge(node)\n\nSingle child edge of node. Checks that it's a single child.\n\nWarning: these functions rely on correct edge direction, via their ischild1 field.\n\nSee also: getparent, getpartneredge, isparentof, hassinglechild.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.getchildedge","page":"Public","title":"PhyloNetworks.getchildedge","text":"getchild(edge)\ngetchild(node)\ngetchildren(node)\n\nGet child(ren) node(s).\n\ngetchild: single child node of edge, or of node after checking that node has a single child.\ngetchildren: vector of all children nodes of node.\n\ngetchildedge(node)\n\nSingle child edge of node. Checks that it's a single child.\n\nWarning: these functions rely on correct edge direction, via their ischild1 field.\n\nSee also: getparent, getpartneredge, isparentof, hassinglechild.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getchildren","page":"Public","title":"PhyloNetworks.getchildren","text":"getchild(edge)\ngetchild(node)\ngetchildren(node)\n\nGet child(ren) node(s).\n\ngetchild: single child node of edge, or of node after checking that node has a single child.\ngetchildren: vector of all children nodes of node.\n\ngetchildedge(node)\n\nSingle child edge of node. Checks that it's a single child.\n\nWarning: these functions rely on correct edge direction, via their ischild1 field.\n\nSee also: getparent, getpartneredge, isparentof, hassinglechild.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getnodeages-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.getnodeages","text":"getnodeages(net)\n\nvector of node ages in pre-order, as in vec_node.\n\nWarnings: net is assumed to\n\nhave been preordered before (to calculate vec_node)\nbe time-consistent (all paths to the root to a given hybrid have the same length)\nbe ultrametric (all leaves have the same age: 0)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.getnodeheights","page":"Public","title":"PhyloNetworks.getnodeheights","text":"getnodeheights(net, checkpreorder::Bool=true)\ngetnodeheights!(net, checkpreorder::Bool=true)\n\nVector of node heights, that is: the distance of each node to the root. An error is thrown if the network is not time-consistent. A network is time-consistent if, for any node v, all paths from the root to v have the same length. (It is sufficient to check this condition at hybrid nodes). Ultrametricity is not assumed: tips need not all be at the same distance from the root. If checkpreorder=false, assumes the network has already been preordered with preorder!.\n\nIf a tree edge has a missing length (coded as -1), both functions throw an error. In general, there may be an exponential number of ways to assign tree edge lengths that make the network time-consistent.\n\ngetnodeheights sends a warning upon finding a missing hybrid edge length, otherwises proceeds as getnodeheights! but without modifying the network. getnodeheights! will attempt to assign values to missing lengths, for hybrid edges only, so as to make the network time-consistent.\n\nIf a hybrid edge e has a missing length, getnodeheights! proceeds as follows at its child hybrid node h:\n\nIf all of h's parent edges lack a length: the shortest non-negative lengths are assigned to make the network time-consistent at h. In particular, one of the partner edges is assigned length 0, and h is made as old as possible, that is, as close to the root as possible: the reticulation is \"zipped-up\".\nOtherwise: the length of e is set to the unique value that makes the network time-consistent at h, based on the partner edge's length. If this value is negative, then an error is thrown.\n\nOutput: vector of node heights, one per node, in the same order as in net.vec_node.\n\nSee also: istimeconsistent and getnodeheights_average.\n\nExamples:\n\njulia> net = readnewick(\"(((C:1,(A:1)#H1:1.5::0.7):1,(#H1:0.3::0.3,E:2.0):2.2):1.0,O:5.2)root;\");\n\njulia> # using PhyloPlots; plot(net, useedgelength=true, showedgelength=true, shownodenumber=true); # to see\n\njulia> nodeheight = getnodeheights(net)\n9-element Vector{Float64}:\n 0.0\n 5.2\n 1.0\n 3.2\n 5.2\n 2.0\n 3.5\n 4.5\n 3.0\n\njulia> [node.number => (height, node.name) for (height,node) in zip(nodeheight, net.vec_node)]\n9-element Vector{Pair{Int64, Tuple{Float64, String}}}:\n -2 => (0.0, \"root\")\n  5 => (5.2, \"O\")\n -3 => (1.0, \"\")\n -6 => (3.2, \"\")\n  4 => (5.2, \"E\")\n -4 => (2.0, \"\")\n  3 => (3.5, \"H1\")\n  2 => (4.5, \"A\")\n  1 => (3.0, \"C\")\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getnodeheights!","page":"Public","title":"PhyloNetworks.getnodeheights!","text":"getnodeheights(net, checkpreorder::Bool=true)\ngetnodeheights!(net, checkpreorder::Bool=true)\n\nVector of node heights, that is: the distance of each node to the root. An error is thrown if the network is not time-consistent. A network is time-consistent if, for any node v, all paths from the root to v have the same length. (It is sufficient to check this condition at hybrid nodes). Ultrametricity is not assumed: tips need not all be at the same distance from the root. If checkpreorder=false, assumes the network has already been preordered with preorder!.\n\nIf a tree edge has a missing length (coded as -1), both functions throw an error. In general, there may be an exponential number of ways to assign tree edge lengths that make the network time-consistent.\n\ngetnodeheights sends a warning upon finding a missing hybrid edge length, otherwises proceeds as getnodeheights! but without modifying the network. getnodeheights! will attempt to assign values to missing lengths, for hybrid edges only, so as to make the network time-consistent.\n\nIf a hybrid edge e has a missing length, getnodeheights! proceeds as follows at its child hybrid node h:\n\nIf all of h's parent edges lack a length: the shortest non-negative lengths are assigned to make the network time-consistent at h. In particular, one of the partner edges is assigned length 0, and h is made as old as possible, that is, as close to the root as possible: the reticulation is \"zipped-up\".\nOtherwise: the length of e is set to the unique value that makes the network time-consistent at h, based on the partner edge's length. If this value is negative, then an error is thrown.\n\nOutput: vector of node heights, one per node, in the same order as in net.vec_node.\n\nSee also: istimeconsistent and getnodeheights_average.\n\nExamples:\n\njulia> net = readnewick(\"(((C:1,(A:1)#H1:1.5::0.7):1,(#H1:0.3::0.3,E:2.0):2.2):1.0,O:5.2)root;\");\n\njulia> # using PhyloPlots; plot(net, useedgelength=true, showedgelength=true, shownodenumber=true); # to see\n\njulia> nodeheight = getnodeheights(net)\n9-element Vector{Float64}:\n 0.0\n 5.2\n 1.0\n 3.2\n 5.2\n 2.0\n 3.5\n 4.5\n 3.0\n\njulia> [node.number => (height, node.name) for (height,node) in zip(nodeheight, net.vec_node)]\n9-element Vector{Pair{Int64, Tuple{Float64, String}}}:\n -2 => (0.0, \"root\")\n  5 => (5.2, \"O\")\n -3 => (1.0, \"\")\n -6 => (3.2, \"\")\n  4 => (5.2, \"E\")\n -4 => (2.0, \"\")\n  3 => (3.5, \"H1\")\n  2 => (4.5, \"A\")\n  1 => (3.0, \"C\")\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getnodeheights_average","page":"Public","title":"PhyloNetworks.getnodeheights_average","text":"getnodeheights_average(net, checkpreorder::Bool=true; warn=true)\n\nVector of average node heights, that is: the average distance from the root to each node. The average is a weighted average with weights taken to be the hybrid edges' inheritance values γ, if available. Equal weights are used at hybrid nodes with some parents lacking a γ inheritance value (with a warning).\n\nmissing edge lengths:\n\nAn error is thrown if a tree edge has a missing edge length.\nIf all parent hybrid edges have missing lengths at a given hybrid node, then the hybrid node is assumed to be as close to the root as possible, that is, the reticulation is assumed \"zipped-up\" with one of its hybrid edges of length 0.\nIf some but not all parent hybrid edges have a missing length, then the average node height is calculated based on the non-missing parents only. If the hybrid node height turns out to be lower than one of the parent's height (such that some missing length would need to be negative) then a warning is issued.\n\nA warning is issued, unless warn=false, if the network is not time-consistent.\n\nSee also: istimeconsistent, getnodeheights, and getnodeheights_majortree](@ref).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getnodeheights_majortree","page":"Public","title":"PhyloNetworks.getnodeheights_majortree","text":"getnodeheights_majortree(net, checkpreorder::Bool=true; warn=true)\n\nVector of node heights from the major tree, that is: the distance from the root to each node when considering the major tree for node heights. \n\nmissing edge lengths:\n\nAn error is thrown if a tree edge has a missing edge length.\nIf all parent hybrid edges have missing lengths at a given hybrid node, then the hybrid node is assumed to be as close to the root as possible, that is, the reticulation is assumed \"zipped-up\" with one of its hybrid edges of length 0.\nIf a major hybrid edge has a missing length, then the hybrid node height will be calculated using the node height and edge length of the minor parent with the largest inheritance γ (with a warning). If the major hybrid edge lacks a length and all non-missing minor edges lack an inheritance γ or have the same value, then an error is thrown.\n\nA warning is issued, unless warn=false, if the network is not time-consistent.\n\nSee also: istimeconsistent, getnodeheights and getnodeheights_average.\n\n#node heights of time-consistent networks are the same \njulia> consistent_net = readnewick(\"((A:2.5,#H1:1.5::0.4):0.25,(C:1.5,(B:1)#H1:0.5::0.6):1.25);\");\n\njulia> heights = getnodeheights(consistent_net)\n7-element Vector{Float64}:\n 0.0\n 1.25\n 2.75\n 0.25\n 1.75\n 2.75\n 2.75\n\njulia> heights_average = getnodeheights_average(consistent_net);\n\njulia> heights_major = getnodeheights_majortree(consistent_net);\n\njulia> heights == heights_average == heights_major  \ntrue\n\n#inconsistent networks give different results\njulia> inconsistent_net = readnewick(\"((A:2.5,#H1:1.5::0.4):0.25,(C:1.5,(B:1)#H1:2.5::0.6):1.25);\");\n\njulia> getnodeheights_average(inconsistent_net;warn=false)\n7-element Vector{Float64}:\n 0.0\n 1.25\n 2.75\n 0.25\n 2.95\n 3.95\n 2.75\n\njulia> getnodeheights_majortree(inconsistent_net;warn=false) \n7-element Vector{Float64}:\n 0.0\n 1.25\n 2.75\n 0.25\n 3.75\n 4.75\n 2.75\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Public","title":"PhyloNetworks.getparent","text":"getparent(edge)\ngetparent(node)\ngetparentminor(node)\ngetparents(node)\n\nGet parental node(s).\n\ngetparent: major (or only) parent node of edge or node\ngetparentminor: minor parent node of node\ngetparents: vector of all parent nodes of node.\n\ngetparentedge(node)\ngetparentedgeminor(node)\n\nGet one parental edge of a node.\n\ngetparentedge: major parent edge. For a tree node, it's its only parent edge.\ngetparentedgeminor: minor parent edge, if node is hybrid (with an error if node has no minor parent).\n\nIf node has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.\n\nWarning: these functions use the field ischild1 of edges.\n\nSee also: getchild, getpartneredge.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.getparentedge","page":"Public","title":"PhyloNetworks.getparentedge","text":"getparent(edge)\ngetparent(node)\ngetparentminor(node)\ngetparents(node)\n\nGet parental node(s).\n\ngetparent: major (or only) parent node of edge or node\ngetparentminor: minor parent node of node\ngetparents: vector of all parent nodes of node.\n\ngetparentedge(node)\ngetparentedgeminor(node)\n\nGet one parental edge of a node.\n\ngetparentedge: major parent edge. For a tree node, it's its only parent edge.\ngetparentedgeminor: minor parent edge, if node is hybrid (with an error if node has no minor parent).\n\nIf node has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.\n\nWarning: these functions use the field ischild1 of edges.\n\nSee also: getchild, getpartneredge.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getparentedgeminor","page":"Public","title":"PhyloNetworks.getparentedgeminor","text":"getparent(edge)\ngetparent(node)\ngetparentminor(node)\ngetparents(node)\n\nGet parental node(s).\n\ngetparent: major (or only) parent node of edge or node\ngetparentminor: minor parent node of node\ngetparents: vector of all parent nodes of node.\n\ngetparentedge(node)\ngetparentedgeminor(node)\n\nGet one parental edge of a node.\n\ngetparentedge: major parent edge. For a tree node, it's its only parent edge.\ngetparentedgeminor: minor parent edge, if node is hybrid (with an error if node has no minor parent).\n\nIf node has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.\n\nWarning: these functions use the field ischild1 of edges.\n\nSee also: getchild, getpartneredge.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getparentminor","page":"Public","title":"PhyloNetworks.getparentminor","text":"getparent(edge)\ngetparent(node)\ngetparentminor(node)\ngetparents(node)\n\nGet parental node(s).\n\ngetparent: major (or only) parent node of edge or node\ngetparentminor: minor parent node of node\ngetparents: vector of all parent nodes of node.\n\ngetparentedge(node)\ngetparentedgeminor(node)\n\nGet one parental edge of a node.\n\ngetparentedge: major parent edge. For a tree node, it's its only parent edge.\ngetparentedgeminor: minor parent edge, if node is hybrid (with an error if node has no minor parent).\n\nIf node has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.\n\nWarning: these functions use the field ischild1 of edges.\n\nSee also: getchild, getpartneredge.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getparents","page":"Public","title":"PhyloNetworks.getparents","text":"getparent(edge)\ngetparent(node)\ngetparentminor(node)\ngetparents(node)\n\nGet parental node(s).\n\ngetparent: major (or only) parent node of edge or node\ngetparentminor: minor parent node of node\ngetparents: vector of all parent nodes of node.\n\ngetparentedge(node)\ngetparentedgeminor(node)\n\nGet one parental edge of a node.\n\ngetparentedge: major parent edge. For a tree node, it's its only parent edge.\ngetparentedgeminor: minor parent edge, if node is hybrid (with an error if node has no minor parent).\n\nIf node has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.\n\nWarning: these functions use the field ischild1 of edges.\n\nSee also: getchild, getpartneredge.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.getpartneredge-Tuple{Any}","page":"Public","title":"PhyloNetworks.getpartneredge","text":"getpartneredge(edge::Edge)\ngetpartneredge(edge::Edge, node::Node)\n\nEdge that is the hybrid partner of edge, meaning that is has the same child node as edge. This child node is given as an argument in the second method. Assumptions, not checked:\n\nno in-coming polytomy: a node has 0, 1 or 2 parents, no more\nwhen node is given, it is assumed to be the child of edge (the first method calls the second).\n\nSee also: getparent, getchild\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.getroot-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.getroot","text":"getroot(net)\n\nNode used to root net. If net is to be considered as semi-directed or unrooted, this root node is used to write the networks' Newick parenthetical description or for network traversals.\n\nSee also: isrootof\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hardwiredcluster-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Union{AbstractVector{Int64}, AbstractVector{String}}}","page":"Public","title":"PhyloNetworks.hardwiredcluster","text":"hardwiredcluster(edge::Edge, taxa::Union{AbstractVector{String},AbstractVector{Int}})\nhardwiredcluster!(v::Vector{Bool}, edge::Edge, taxa)\nhardwiredcluster!(v::Vector{Bool}, edge::Edge, taxa, visited::Vector{Int})\n\nCalculate the hardwired cluster of edge, coded as a vector of booleans: true for taxa that are descendent of the edge, false for other taxa (including missing taxa).\n\nThe edge should belong in a rooted network for which ischild1 is up-to-date. Run directedges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.\n\nvisited: vector of node numbers, of all visited nodes.\n\nExamples:\n\njulia> net5 = \"(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));\" |> readnewick |> directedges! ;\n\njulia> taxa = net5 |> tiplabels # ABC EF D\n6-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n \"E\"\n \"F\"\n \"D\"\n\njulia> hardwiredcluster(net5.edge[12], taxa) # descendants of 12th edge = CEF\n6-element Vector{Bool}:\n 0\n 0\n 1\n 1\n 1\n 0\n\nSee also hardwiredclusterdistance and hardwiredclusters\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hardwiredclusterdistance-Tuple{HybridNetwork, HybridNetwork, Bool}","page":"Public","title":"PhyloNetworks.hardwiredclusterdistance","text":"hardwiredclusterdistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)\n\nHardwired cluster distance between the topologies of net1 and net2, that is, the number of hardwired clusters found in one network and not in the other (with multiplicity, see below).\n\nIf the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, then both networks are considered as semi-directed.\n\nNetworks are assumed bicombining (each hybrid has exactly 2 parents, no more).\n\nDissimilarity vs distance\n\nThis is not a distance per se on the full space of phylogenetic networks: there are pairs of distinct networks for which this dissimilarity is 0. But it is a distance on some classes of networks, such as the class of tree-child networks that are \"normal\" (without shortcuts), or the class of tree-child networks that can be assigned node ages such that hybrid edges have length 0 and tree edges have non-negative lengths. See Cardona, Rossello & Valiente (2008), Cardona, Llabres, Rossello & Valiente (2008), and Huson, Rupp, Scornavacca (2010).\n\nExample\n\njulia> net1 = readnewick(\"(t6,(t5,((t4,(t3,((t2,t1))#H1)),#H1)));\");\n\njulia> taxa = sort(tiplabels(net1)); # t1 through t6, sorted alphabetically\n\njulia> # using PhyloPlots; plot(net1, showedgenumber=true);\n\njulia> # in matrix below: column 1: edge number. last column: tree (10) vs hybrid (11) edge\n       # middle columns: for 'taxa': t1,...t6. 1=descendant, 0=not descendant\n       hardwiredclusters(net1, taxa)\n6×8 Matrix{Int64}:\n 13  1  1  1  1  1  0  10\n 12  1  1  1  1  0  0  10\n 10  1  1  1  1  0  0  10\n  9  1  1  1  0  0  0  10\n  8  1  1  0  0  0  0  11\n  7  1  1  0  0  0  0  10\n\njulia> net2 = readnewick(\"(t6,(t5,((t4,(t3)#H1),(#H1,(t1,t2)))));\");\n\njulia> hardwiredclusters(net2, taxa)\n6×8 Matrix{Int64}:\n 13  1  1  1  1  1  0  10\n 12  1  1  1  1  0  0  10\n  6  0  0  1  1  0  0  10\n  5  0  0  1  0  0  0  11\n 11  1  1  1  0  0  0  10\n 10  1  1  0  0  0  0  10\n\njulia> hardwiredclusterdistance(net1, net2, true) # true: as rooted networks\n4\n\nWhat is a hardwired cluster?\n\nEach edge in a network is associated with its hardwired cluster, that is, the set of all its descendant taxa (leaves). The set of hardwired cluster of a network is the set of its edges' hardwired clusters. The dissimilarity d_hard defined in Huson, Rupp, Scornavacca (2010) is the number of hardwired clusters that are in one network but not in the other.\n\nThis implementation is a slightly more discriminative version of d_hard, where each cluster is counted with multiplicity and annotated with its edge's hybrid status, as follows:\n\nExternal edges are not counted (they are tree edges to a leaf, shared by all phylogenetic networks).\nA cluster is counted for each edge for which it's the hardwired cluster.\nAt a given hybrid node, both hybrid partner edges have the same cluster, so this cluster is only counted once for both partners.\nA given cluster is matched between the two networks only if it's the cluster from a tree edge in both networks, or from a hybrid edge in both networks.\n\nIn the example above, net1 has a shortcut (hybrid edge 11) resulting in 2 tree edges (12 and 10) with the same cluster {t1,t2,t3,t4}. So cluster {t1,t2,t3,t4} has multiplicity 2 in net1. net2 also has this cluster, but only associated with 1 tree edge, so this cluster contributes (2-1)=1 towards the hardwired cluster distance between the two networks. The distance of 4 corresponds to these 4 clusters:\n\n{t1,t2,t3,t4}: twice in net1, once in net2\n{t3,t4}: absent in net1, once in net2\n{t1,t2}: twice in net1 (from a hybrid edge & a tree edge), once in net2\n{t3}: absent in net1 (because external edges are not counted), once in net2 (from a hybrid edge).\n\nDegree-2 nodes cause multiple edges to have the same cluster, so counting clusters with multiplicity distinguishes a network with extra degree-2 nodes from the \"same\" network after these nodes have been suppressed (e.g. with PhyloNetworks.fuseedgesat! or PhyloNetworks.shrinkedge!).\n\nNetworks as semi-directed\n\nIf rooted is false and one of the phylogenies is not a tree (1+ reticulations), then all degree-2 nodes are removed before comparing the hardwired clusters, and the minimum distance is returned over all possible ways to root the networks at internal nodes.\n\nSee also: hardwiredclusters, hardwiredcluster\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hardwiredclusters-Tuple{HybridNetwork, Union{AbstractVector{Int64}, AbstractVector{String}}}","page":"Public","title":"PhyloNetworks.hardwiredclusters","text":"hardwiredclusters(net::HybridNetwork, taxon_labels)\n\nReturns a matrix describing all the hardwired clusters in a network, with taxa listed in same order as in taxon_labels to describe their membership in each cluster. Allows for missing taxa, with entries all 0.\n\nWarnings:\n\nclusters are rooted, so the root must be correct.\neach hybrid node is assumed to have exactly 2 parents (no more).\n\nEach row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).\n\nfirst column: edge number\nnext columns: 0/1. 1=descendant of edge, 0=not a descendant, or missing taxon.\nlast column:  10/11 values. 10=tree edge, 11=hybrid edge\n\nSee also hardwiredclusterdistance and hardwiredcluster.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hassinglechild-Tuple{PhyloNetworks.Node}","page":"Public","title":"PhyloNetworks.hassinglechild","text":"hassinglechild(node)\n\ntrue if node has a single child, based on the edges' ischild1 field; false otherwise.\n\nSee also: getchild, getparent\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hybridclades_support-Tuple{Vector{HybridNetwork}, HybridNetwork}","page":"Public","title":"PhyloNetworks.hybridclades_support","text":"hybridclades_support(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)\n\nMatch hybrid nodes in a reference network with those in an array of networks, like bootstrap networks or in a posterior sample of networks. All networks must be fully resolved, and on the same taxon set. If rooted=true, all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).\n\nTwo hybrid edges in two networks are said to match if they share the same \"hybrid\" clade (or recipient) and the same \"donor clade\", which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with γ>0.5) and one is its minor sister (following the major hybrid edge with γ<0.5).\n\nTo calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If rooted=false, sister clades are considered as bipartitions.\n\nOutput:\n\na \"node\" data frame (see below)\nan \"edge\" data frame (see below)\na \"clade\" data frame to describe the make up of all clades found as hybrids or sisters, starting with a column taxa that lists all taxa. All other columns correspond to a given clade and contain true/false values. true means that a given taxon belongs in a given clade. For a clade named H1, for instance, and if the data frame was named cla, the list of taxa in this clade can be obtained with cla[:taxa][cla[:H1]].\nan array of gamma values, with one row for each network in the sample and two columns (major/minor) for each hybrid edge in the reference network. If this hybrid edge was found in the sampled network (i.e. same hybrid and sister clades, after removal of all other hybrid nodes), its inheritcance gamma value is recorded here. Otherwise, the gamma entry is 0.0.\na vector with the number of each hybrid edge in the reference network, in the same order as for the columns in the array of gamma values above.\n\nThe \"node\" data frame has one row per clade and 9 columns giving:\n\n:clade: the clade's name, like the taxon name (if a hybrid is a single taxon) or the hybrid tag (like 'H1') in the reference network\n:node: the node number in the reference network. missing if the clade is not in this network.\n:hybridnode: typically the same node number as above, except for hybrid clades in the reference network. For those, the hybrid node number is listed here.\n:edge: number of the parent edge, parent to the node in column 2, if found in the ref network. missing otherwise.\n:BS_hybrid: percentage of sample networks in which the clade is found to be a hybrid clade.\n:BS_sister: percentage of sample networks in which the clade is found to be sister to some hybrid clade (sum of the next 2 columns)\n:BS_major_sister: percentage of sample networks in which the clade is found to be the major sister to some hybrid clade\n:BS_minor_sister: same as previous, but minor\n:BS_hybrid_samesisters: percentage of sample networks in which the clade is found to be a hybrid and with the same set of sister clades as in the reference network. Applies to hybrid clades found in the reference network only, missing for all other clades.\n\nThe \"edge\" data frame has one row for each pair of clades, and 8 columns:\n\n:edge: hybrid edge number, if the edge appears in the reference network. missing otherwise.\n:hybrid_clade: name of the clade found to be a hybrid, descendent of 'edge'\n:hybrid: node number of that clade, if it appears in the reference network. missing otherwise.\n:sister_clade: name of the clade that is sister to 'edge', i.e. be sister to a hybrid\n:sister: node number of that clade, if in the ref network.\n:BS_hybrid_edge: percentage of sample networks in which 'edge' is found to be a hybrid  edge, i.e. when the clade in the 'hybrid' column is found to be a hybrid and the clade in  the 'sister' column is one of its sisters.\n:BS_major: percentage of sample networks in which 'edge' is found to be a major hybrid  edge, i.e. when 'hybrid' is found to be a hybrid clade and 'sister' is found to be its  major sister.\n:BS_minor: same as previous, but minor\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.hybridlambdaformat-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.hybridlambdaformat","text":"hybridlambdaformat(net::HybridNetwork; prefix=\"I\")\n\nOutput net as a string in the format that the Hybrid-Lambda simulator expects, namely:\n\nall internal nodes are named, including the root, with names that are unique and start with a letter.\nhybrid nodes are written as H6#γ1:length1 and H6#γ1:length2 instead of #H6:length1::γ1 and #H6:length2::γ2 (note the samme γ value expected by Hybrid-Lambda)\n\nThis is a modified version of the extended Newick format.\n\nOptional keyword argument prefix: must start with a letter, other than \"H\". Internal nodes are given names like \"I1\", \"I2\", etc. Existing internal non-hybrid node names are replaced, which is crucial if some of them don't start with a letter (e.g. in case node names are bootstrap values). See nameinternalnodes! to add node names.\n\nexamples\n\njulia> net = readnewick(\"((a:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);\");\n\njulia> hybridlambdaformat(net) # net is unchanged here\n\"((a:1.0,(b:1.0)H1#0.8:1.0)I1:5.0,(H1#0.8:0.0,c:1.0)I2:1.0)I3;\"\n\njulia> # using PhyloPlots; plot(net, shownodenumber=true) # shows that node -2 is the root\n\njulia> rotate!(net, -2)\n\njulia> writenewick(net) # now the minor edge with γ=0.2 appears first\n\"((#H1:0.0::0.2,c:1.0):1.0,(a:1.0,(b:1.0)#H1:1.0::0.8):5.0);\"\n\njulia> hybridlambdaformat(net)\n\"((H1#0.2:0.0,c:1.0)I2:1.0,(a:1.0,(b:1.0)H1#0.2:1.0)I1:5.0)I3;\"\n\njulia> net = readnewick(\"((((B)#H1:::.6)#H2,((D,C,#H2:::0.8),(#H1,A))));\"); # 2 reticulations, no branch lengths\n\njulia> writenewick(net, round=true)\n\"(#H2:::0.2,((D,C,((B)#H1:::0.6)#H2:::0.8),(#H1:::0.4,A)));\"\n\njulia> hybridlambdaformat(net; prefix=\"int\")\n\"(H2#0.2,((D,C,((B)H1#0.6)H2#0.2)int1,(H1#0.6,A)int2)int3)int4;\"\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.ischildof","page":"Public","title":"PhyloNetworks.ischildof","text":"isparentof(node, edge)\nischildof(node, edge)\n\ntrue if node is the tail / head, or parent / child, of edge; false otherwise. Assumes that the edge's direction is correct, meaning its field ischild1 is reliable (in sync with the rooting).\n\nSee also: getparent, getchild, isrootof\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.isexternal","page":"Public","title":"PhyloNetworks.isexternal","text":"isrootof(node, net)\n\ntrue if node is the root of net (or used as such for network traversals in case the network is considered as semi-directed); false otherwise.\n\nisleaf(node)\nisexternal(edge)\n\ntrue if node is a leaf or edge is adjacent to a leaf, false otherwise.\n\nSee also: getroot, getparent, getchild\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.isleaf","page":"Public","title":"PhyloNetworks.isleaf","text":"isrootof(node, net)\n\ntrue if node is the root of net (or used as such for network traversals in case the network is considered as semi-directed); false otherwise.\n\nisleaf(node)\nisexternal(edge)\n\ntrue if node is a leaf or edge is adjacent to a leaf, false otherwise.\n\nSee also: getroot, getparent, getchild\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.isparentof-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Public","title":"PhyloNetworks.isparentof","text":"isparentof(node, edge)\nischildof(node, edge)\n\ntrue if node is the tail / head, or parent / child, of edge; false otherwise. Assumes that the edge's direction is correct, meaning its field ischild1 is reliable (in sync with the rooting).\n\nSee also: getparent, getchild, isrootof\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.isrootof-Tuple{PhyloNetworks.Node, HybridNetwork}","page":"Public","title":"PhyloNetworks.isrootof","text":"isrootof(node, net)\n\ntrue if node is the root of net (or used as such for network traversals in case the network is considered as semi-directed); false otherwise.\n\nisleaf(node)\nisexternal(edge)\n\ntrue if node is a leaf or edge is adjacent to a leaf, false otherwise.\n\nSee also: getroot, getparent, getchild\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.istimeconsistent","page":"Public","title":"PhyloNetworks.istimeconsistent","text":"istimeconsistent(net, checkpreorder::Bool=true)\n\nTrue (resp. false) if net network is (resp. is not) time-consistent. A network is time-consistent if for any node v, all paths from the root to v have the same length. It is sufficient to check this condition at nodes v that are hybrid nodes.\n\nSee also getnodeheights and getnodeheights_average.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.majortree-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.majortree","text":"majortree(net::HybridNetwork; nofuse::Bool=false, unroot::Bool=false,\n          keeporiginalroot::Bool=false)\n\nExtract the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node.\n\nnofuse: if true, edges and degree-2 nodes are retained during edge removal. Otherwise, at each reticulation the child edge (below the hybrid node) is retained: the major hybrid edge is fused with it.\n\nunroot: is true, the root will be deleted if it becomes of degree 2.\n\nkeeporiginalroot: the network's root is kept even if it becomes of degree 1.\n\nWarnings:\n\nif nofuse is true: the hybrid edges that are retained (without fusing) have their γ values unchanged, but their ismajor is changed to true\nassume correct ismajor attributes.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.minortreeat","page":"Public","title":"PhyloNetworks.minortreeat","text":"minortreeat(net::HybridNetwork, hybindex::Integer, nofuse=false, unroot::Bool=false)\n\nExtract the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i=hybindex), where the minor hybrid edge is kept instead of the major hybrid edge. If nofuse is true, edges are not fused (degree-2 nodes are kept). If unroot is true, the root will be deleted if it becomes of degree 2.\n\nWarning: assume correct ismajor fields.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.nameinternalnodes!","page":"Public","title":"PhyloNetworks.nameinternalnodes!","text":"nameinternalnodes!(net::HybridNetwork, prefix=\"i\")\n\nAdd names to nodes in net that don't already have a name. Leaves already have names; but if not, they will be given names as well. New node names will be of the form \"prefixk\" where k is an integer. So by default, new node names will be of the form \"i1\", \"i2\", etc.\n\nexamples\n\njulia> net = readnewick(\"((a:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);\");\n\njulia> nameinternalnodes!(net, \"I\") # by default, shown without internal node names\nHybridNetwork, Rooted Network\n7 edges\n7 nodes: 3 tips, 1 hybrid nodes, 3 internal tree nodes.\ntip labels: a, b, c\n((a:1.0,(b:1.0)#H1:1.0::0.8)I1:5.0,(#H1:0.0::0.2,c:1.0)I2:1.0)I3;\n\njulia> writenewick(net; internallabel=false) # by default, writenewick shows internal names if they exist\n\"((a:1.0,(b:1.0)#H1:1.0::0.8):5.0,(#H1:0.0::0.2,c:1.0):1.0);\"\n\njulia> net = readnewick(\"((int5:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);\"); # one taxon name starts with \"int\"\n\njulia> nameinternalnodes!(net, \"int\");\n\njulia> writenewick(net)\n\"((int5:1.0,(b:1.0)#H1:1.0::0.8)int6:5.0,(#H1:0.0::0.2,c:1.0)int7:1.0)int8;\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.nj-Tuple{DataFrames.DataFrame}","page":"Public","title":"PhyloNetworks.nj","text":"nj(D::DataFrame; force_nonnegative_edges::Bool=false)\n\nConstruct a tree from a distance matrix by neighbor joining, where D is a DataFrame of the distance matrix, with taxon names taken from the header of the data frame. The rows are assumed to correspond to tips in the tree in the same order as they do in columns. With force_nonnegative_edges being true, any negative edge length is changed to 0.0 (with a message).\n\nFor the algorithm, see Satou & Nei 1987.\n\nSee nj! for using a matrix as input.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.nni!-Tuple{HybridNetwork, Vararg{Any}}","page":"Public","title":"PhyloNetworks.nni!","text":"nni!([rng::AbstractRNG,]\n     net::HybridNetwork,\n     e::Edge,\n     nohybridladder::Bool=true,\n     no3cycle::Bool=true,\n     constraints::Vector{TopologyConstraint}=TopologyConstraint[]\n)\n\nAttempt to perform a nearest neighbor interchange (NNI) around edge e, randomly chosen among all possible NNIs (e.g 3, sometimes more depending on e) satisfying the constraints, and such that the new network is a DAG. The number of possible NNI moves around an edge depends on whether the edge's parent/child nodes are tree or hybrid nodes. This is calculated by nnimax.\n\nThe option no3cycle forbids moves that would create a 3-cycle in the network. When no3cycle = false, 2-cycle and 3-cycles may be generated.\n\nNote that the defaults values are for positional (not keyword) arguments, so two or more arguments can be used, but in a specific order: nni!(net, e) or nni!(net, e, nohybridladder), nni!(net, e, nohybridladder, no3cycle), nni!(net, e, nohybridladder, no3cycle, contraints).\n\nAssumptions:\n\nThe starting network does not have 3-cycles, if no3cycle=true. No check for the presence of 2- and 3-cycles in the input network.\nThe edges' field ischild1 is correct in the input network. (This field will be correct in the output network.)\n\nOutput: information indicating how to undo the move or nothing if all NNIs failed.\n\nexamples\n\njulia> str_network = \"(((S8,S9),(((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\";\n\njulia> net = readnewick(str_network);\n\njulia> # using Random; Random.seed!(3); ## commented out for doctest reproducibility across julia versions, but users can use this line to set the seed in their analyses.\n\njulia> undoinfo = nni!(net, net.edge[3], true, true); # true's to avoid hybrid ladders and 3-cycles\n\nIn the next example, we use a stable RNG to make the example reproducible across julia versions. However, this particular RNG is not recommended. The RNG used by default is better (e.g. much more efficient).\n\njulia> str_network = \"(((S8,S9),(((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));\";\n\njulia> net = readnewick(str_network);\n\njulia> # using Pkg; Pkg.add(\"StableRNGs\") # to install StableRNGs if not done earlier\n\njulia> using StableRNGs\n\njulia> rng = StableRNG(791);\n\njulia> undoinfo = nni!(rng, net, net.edge[3], true, true); # true's to avoid hybrid ladders and 3-cycles\n\njulia> writenewick(net)\n\"((S9,((((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2,S8)),(#H2,S10));\"\n\njulia> nni!(undoinfo...);\n\njulia> writenewick(net) == str_network # net back to original topology: the NNI was \"undone\"\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.nni!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Public","title":"PhyloNetworks.nni!","text":"nni!(αu::Edge, u::Node, uv::Edge, v::Node, vδ::Edge)\nnni!(αu,u,uv,v,vδ, flip::Bool, inner::Bool, indices)\n\nTransform a network locally around the focus edge uv with the following NNI, that detaches u-β and grafts it onto vδ:\n\nα - u -- v ------ δ\n    |    |\n    β    γ\n\nα ------ v -- u - δ\n         |    |\n         γ    β\n\nflip boolean indicates if the uv edge was flipped inner boolean indicates if edges αu and uv both point toward node u, i.e. α->u<-v<-δ. If this is true, we flip the hybrid status of αu and vδ.\n\nindices give indices for nodes and edges uinαu, αuinu, vδinv, and vinvδ. These are interpreted as:\n\nu_in_αu: the index for u in the edge αu\nαu_in_u: the index for αu in node u\nvδ_in_v: the index for vδ in node v\nv_in_vδ: the index for v in edge vδ\n\nWarnings:\n\nNo check of assumed adjacencies\nNot implemented for cases that are not necessary thanks to symmetry, such as cases covered by nni!(vδ, v, uv, u, αu) or nni!(βu, u, v, vγ). More specifically, these cases are not implemented (and not checked):\nu not hybrid & v hybrid\nu hybrid, v not hybrid, α -> u <- v -> δ\nBecause of this, nni(αu,u,uv,v,vδ, ...) should not be used directly; use instead nni!(uv, move_number).\nnni!(undoinfo...) restores the topology, but edges below hybrid nodes will have length 0.0 even if they didn't before.\n\nNode numbers and edge numbers are not modified. Edge uv keeps its direction unchanged unless the directions were α -> u -> v -> δ or α <- u <- v <- δ, in which case the direction of uv is flipped.\n\nThe second version's input has the same signature as the output, but will undo the NNI more easily. This means that if output = nni!(input), then nni!(output...) is valid and undoes the first operation.\n\nRight now, branch lengths are not modified except when below a hybrid node. Future versions might implement options to modify branch lengths.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.nni!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, UInt8, Bool, Bool}","page":"Public","title":"PhyloNetworks.nni!","text":"nni!(uv::Edge, nummove::UInt8, nohybridladder::Bool, no3cycle::Bool)\n\nModify a network with a nearest neighbor interchange (NNI) around its edge uv. Return the information necessary to undo the NNI, or nothing if the move was not successful (such as if the resulting graph was not acyclic (not a DAG) or if the focus edge is adjacent to a polytomy). If the move fails, the network is not modified. nummove specifies which of the available NNIs is performed.\n\nrooted-NNI options according to Gambette et al. (2017), fig. 8:\n\nBB: 2 moves, both to BB, if directed edges. 8 moves if undirected.\nRR: 2 moves, both to RR.\nBR: 3 moves, 1 RB & 2 BRs, if directed. 6 moves if e is undirected.\nRB: 4 moves, all 4 BRs.\n\nThe extra options are due to assuming a semi-directed network, whereas Gambette et al (2017) describe options for rooted networks. On a semi-directed network, there might be a choice of how to direct the edges that may contain the root, e.g. choice of e=uv versus vu, and choice of labelling adjacent nodes as α/β (BB), or as α/γ (BR).\n\nnohybridladder = true prevents moves that would create a hybrid ladder in the network, that is, 2 consecutive hybrid nodes (one parent of the other). no3cycle = true prevents NNI moves that would make a 3-cycle, and assumes that the input network does not have any 2- or 3-cycles. If no3cycle is false, 3-cycles can be generated, but NNIs generating 2-cycles are prevented.\n\nThe edge field ischild1 is assumed to be correct in the overall network (that is, in sync with the network's field .rooti).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.pairwisetaxondistancematrix-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.pairwisetaxondistancematrix","text":"pairwisetaxondistancematrix(net; keepInternal=false,\n                            checkpreorder=true, nodeAges=[])\npairwisetaxondistancematrix!(M, net, nodeAges)\n\nReturn the matrix M of pairwise distances between nodes in the network:\n\nbetween all nodes (internal and leaves) if keepInternal=true, in which case the nodes are listed in M in the order in which they appear in net.vec_node\nbetween taxa only otherwise, in which case the nodes are listed in M in the order in which they appear in tiplabels(net) (i.e. same order as in net.leaf)\n\nThe second form modifies M in place, assuming all nodes.\n\nThe distance between the root and a given hybrid node (to take an example) is the weighted average of path lengths from the root to that node, where each path is weighted by the product of γs of all edges on that path. This distance measures the average genetic distance across the genome, if branch lengths are in substitutions/site.\n\noptional arguments:\n\ncheckpreorder: if true, net.vec_node is updated to get a topological ordering of nodes.\nnodeAges: if not provided, i.e. empty vector, the network is not modified.   If provided and non-empty, nodeAges should list node ages in the pre-order in which nodes are listed in vec_node (including leaves), and edge lengths in net are modified accordingly.\n\nProviding node ages hence makes the network time consistent: such that all paths from the root to a given hybrid node have the same length. If node ages are not provided, the network need not be time consistent.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.parsimonyGF-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}, Tuple{HybridNetwork, Dict{String, T}, Symbol}} where T","page":"Public","title":"PhyloNetworks.parsimonyGF","text":"parsimonyGF(net, tip_dictionary, criterion=:softwired)\nparsimonyGF(net, species, sequenceData, criterion=:softwired)\n\nCalculate the most parsimonious score of a network given discrete characters at the tips using a general framework (Van Iersel et al. 2018) allowing for various parsimony criteria: softwired (default), hardwired, parental etc. Only softwired is implemented at the moment.\n\nData can given in one of the following:\n\ntipdata: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named \"taxon\" or \"species\", and  trait values are to appear in column 2 or in a column named \"trait\".\ntipdata: dictionary taxon => state, for a single trait.\nspecies: array of strings, and sequences: array of sequences,   in the order corresponding to the order of species names.\n\nalgorithm\n\nThe complexity of the algorithm is exponential in the level of the network, that is, the maximum number of hybridizations in a single blob, or biconnected component (Fischer et al. 2015). The function loops over all the state assignments of the minor parent of each hybrid node within a blob, so its complexity is of the order of n * m * c^2 * c^level where n is the number of tips, m the number of traits and c the number of states.\n\nSee parsimonysoftwired for a faster algorithm, but solving the softwired criterion only.\n\nreferences\n\nLeo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\nUse the recursive helper function parsimonyGF_bottomup!. Use the fields ischild1, booln4 to know which nodes are at the root of a blob, and boole2 to know which edges are cut (below the minor parent of each hybrid).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.parsimonysoftwired-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T","page":"Public","title":"PhyloNetworks.parsimonysoftwired","text":"parsimonysoftwired(net, tipdata)\nparsimonysoftwired(net, species, sequences)\n\nCalculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network.\n\nData can given in one of the following:\n\ntipdata: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named \"taxon\" or \"species\", and  trait values are to appear in column 2 or in a column named \"trait\".\ntipdata: dictionary taxon => state, for a single trait.\nspecies: array of strings, and sequences: array of sequences,  in the order corresponding to the order of species names.\n\nalgorithm\n\nThe dynamic programming algorithm by Fischer et al. (2015) is used. The function loops over all the displayed subtrees within a blob (biconnected component), so its complexity is of the order of n * m * c^2 * 2^level where n is the number of tips, m the number of traits, c the number of states, and level is the level of the network: the maximum number of hybridizations within a blob.\n\nSee parsimonyGF for a different algorithm, slower but extendable to other parsimony criteria.\n\nreferences\n\nFischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.preorder!-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.preorder!","text":"preorder!(net::HybridNetwork)\n\nUpdate attribute net.vec_node in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges' direction needs to be correct before calling preorder!, using directedges!\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.printedges-Tuple{Any}","page":"Public","title":"PhyloNetworks.printedges","text":"printedges(net)\nprintedges(io::IO, net)\n\nPrint information on the edges of a HybridNetwork net: edge number, numbers of nodes attached to it, edge length, whether it's a hybrid edge, its γ inheritance value, whether it's a major edge, if it could contain the root (this field is not always updated, though) and one more attribute pertaining to level-1 networks used in SNaQ: in which cycle it is contained (-1 if no cycle).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.printnodes-Tuple{Any}","page":"Public","title":"PhyloNetworks.printnodes","text":"printnodes(net)\nprintnodes(io, net)\n\nPrint information on the nodes of a HybridNetwork net: node number, whether it's a leaf, whether it's a hybrid node, it's name (label), its intn1 field (for level-1 networks in SNaQ: number given to the cycle in which the node might be, -1 if the node it not in a cycle cycle), and the list of edges attached to it, by their numbers.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.readfastatodna","page":"Public","title":"PhyloNetworks.readfastatodna","text":"readfastatodna(filename::String, countPatterns::Bool=false)\n\nRead a fasta file to a dataframe containing a column for each site. If countPatterns is true, calculate weights and remove identical site patterns to reduce matrix dimension.\n\nReturn a tuple containing:\n\ndata frame of BioSequence DNA sequences, with taxon names in column 1 followed by a column for each site pattern, in columns 2-npatterns;\narray of weights, one weight for each of the site columns. The length of the weight vector is equal to npatterns.\n\nWarning: assumes a semi-sequential format, not interleaved, where each taxon name appears only once. For this one time, the corresponding sequence may be broken across several lines though.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readmultinewick","page":"Public","title":"PhyloNetworks.readmultinewick","text":"readmultinewick(filename::AbstractString, fast=true)\nreadmultinewick(newicktrees_list::Vector{<:AbstractString})\n\nRead a list of networks in parenthetical format, either from a file (one network per line) if the input is a string giving the path to the file, or from a vector of strings with each string corresponding to a newick-formatted topology. By default (fast=true), Functors.fmap is used for repeatedly reading the newick trees into of HybridNetwork-type objects. The option fast=false corresponds to the behavior up until v0.14.3: with a file name as input, it prints a message (without failing) when a phylogeny cannot be parsed, and allows for empty lines. Each network is read with readnewick.\n\nReturn an array of HybridNetwork objects.\n\nExamples\n\njulia> multitreepath = joinpath(dirname(Base.find_package(\"PhyloNetworks\")), \"..\", \"examples\", \"multitrees.newick\");\njulia> multitree = readmultinewick(multitreepath) # vector of 25 HybridNetworks\njulia> multitree = readmultinewick(multitreepath, false) # same but slower & safer\njulia> treestrings = readlines(multitreepath) # vector of 25 strings\njulia> multitree = readmultinewick(treestrings)\njulia> readmultinewick(treestrings, false) # same, but slower\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.readmultinewick_files-Tuple{AbstractString}","page":"Public","title":"PhyloNetworks.readmultinewick_files","text":"readmultinewick_files(listfile; relative2listfile=true)\n\nRead the list of file names in listfile, then read all the trees in each of these files. Output: vector of vectors of trees (networks with h>0 allowed).\n\nlistfile should be the name of a file containing the path/name to multiple bootstrap files, one on each line (no header). Each named bootstrap file should contain multiple trees, one per line (such as bootstrap trees from a single gene).\n\nThe path/name to each bootstrap file should be relative to listfile. Otherwise, use option relative2listfile=false, in which case the file names are interpreted as usual: relative to the user's current directory if not given as absolute paths.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.readnewick-Tuple{AbstractString}","page":"Public","title":"PhyloNetworks.readnewick","text":"readnewick(file name)\nreadnewick(parenthetical description)\nreadnewick(IO)\n\nRead tree or network topology from parenthetical format (extended Newick). If the root node has a single child: ignore (i.e. delete from the topology) the root node and its child edge.\n\nInput: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description. Nexus-style comments ([&...]) are ignored, and may be placed after (or instead) of a node name, and before/after an edge length.\n\nA root edge, not enclosed within a pair a parentheses, is ignored. If the root node has a single edge, this one edge is removed.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.readnexus_treeblock","page":"Public","title":"PhyloNetworks.readnexus_treeblock","text":"readnexus_treeblock(filename, treereader=readnewick, args...;\n                    reticulate=true, stringmodifier=[r\"#(\\d+)\" => s\"#H\\1\"])\n\nRead the first \"trees\" block of a nexus-formatted file, using the translate table if present, and return a vector of HybridNetworks. Information inside [&...] are interpreted as comments and are discarded by the default tree reader. Optional arguments args are passed to the tree reader.\n\nFor the nexus format, see Maddison, Swofford & Maddison (1997).\n\nUnless reticulate is false, the following is done to read networks with reticulations.\n\nPrior to reading each phylogeny, each instance of #number is replaced by #Hnumber to fit the standard extended Newick format at hybrid nodes. This behavior can be changed with option stringmodifier, which should be a vector of pairs accepted by replace.\n\nInheritance γ values are assumed to be given within \"comment\" blocks at minor hybrid edges (cut as tips to form the extended Newick) like this for example, as output by bacter (Vaughan et al. 2017):\n\n#11[&conv=0, relSize=0.08, ...\n\nor like this, as output by SpeciesNetwork (Zhang et al. 2018):\n\n#H11[&gamma=0.08]\n\nIn this example, the corresponding edge to hybrid H11 has γ=0.08.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.removedegree2nodes!","page":"Public","title":"PhyloNetworks.removedegree2nodes!","text":"removedegree2nodes!(net::HybridNetwork, keeproot::Bool=false)\n\nDelete all nodes of degree two in net, fusing the two adjacent edges together each time, and return the network. If the network has a degree-2 root and keeproot is false, then the root is eliminated as well, leaving the network unrooted. The only exception to this rule is if the root is incident to 2 (outgoing) hybrid edges. Removing the root should leave a loop-edge (equal end point), which we don't want to do, to preserve the paths in the original network. In this case, the root is maintained even if keeproot is false. If keeproot is true, then the root is kept even if it's of degree 2.\n\nSee fuseedgesat!.\n\njulia> net = readnewick(\"(((((S1,(S2)#H1),(#H1,S3)))#H2),(#H2,S4));\");\n\njulia> PhyloNetworks.breakedge!(net.edge[3], net); # create a degree-2 node along hybrid edge\n\njulia> PhyloNetworks.breakedge!(net.edge[3], net); # another one: 2 in a row\n\njulia> PhyloNetworks.breakedge!(net.edge[10], net); # another one, elsewhere\n\njulia> writenewick(net) # extra pairs of parentheses\n\"((#H2,S4),(((((S1,(((S2)#H1))),(#H1,S3)))#H2)));\"\n\njulia> removedegree2nodes!(net);\n\njulia> writenewick(net) # even the root is gone\n\"(#H2,S4,(((S1,(S2)#H1),(#H1,S3)))#H2);\"\n\njulia> net = readnewick(\"((((C:0.9)I1:0.1)I3:0.1,((A:1.0)I2:0.4)I3:0.6):1.4,(((B:0.2)H1:0.6)I2:0.5)I3:2.1);\");\n\njulia> removedegree2nodes!(net, true);\n\njulia> writenewick(net, round=true) # the root was kept\n\"((C:1.1,A:2.0):1.4,B:3.4);\"\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.rootatnode!-Tuple{HybridNetwork, PhyloNetworks.Node}","page":"Public","title":"PhyloNetworks.rootatnode!","text":"rootatnode!(HybridNetwork, nodeNumber::Integer; index::Bool=false)\nrootatnode!(HybridNetwork, Node)\nrootatnode!(HybridNetwork, nodeName::AbstractString)\n\nRoot the network/tree object at the node with name 'nodeName' or number 'nodeNumber' (by default) or with index 'nodeNumber' if index=true. Attributes ischild1 and containroot are updated along the way. Use plot(net, shownodenumber=true, showedgelength=false) to visualize and identify a node of interest. (see package PhyloPlots)\n\nReturn the network.\n\nWarnings:\n\nIf the node is a leaf, the root will be placed along the edge adjacent to the leaf. This might add a new node.\nIf the desired root placement is incompatible with one or more hybrids, then\nthe original network is restored with its old root and edges' direction.\na RootMismatch error is thrown.\n\nSee also: rootonedge!.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.rootonedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Public","title":"PhyloNetworks.rootonedge!","text":"rootonedge!(HybridNetwork, edgeNumber::Integer; index::Bool=false)\nrootonedge!(HybridNetwork, Edge)\n\nRoot the network/tree along an edge with number edgeNumber (by default) or with index edgeNumber if index=true. Attributes ischild1 and containroot are updated along the way.\n\nThis adds a new node and a new edge to the network. Use plot(net, showedgenumber=true, showedgelength=false) to visualize and identify an edge of interest. (see package PhyloPlots)\n\nSee also: rootatnode!.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.rotate!-Tuple{HybridNetwork, Integer}","page":"Public","title":"PhyloNetworks.rotate!","text":"rotate!(net::HybridNetwork, nodeNumber::Integer; orderedEdgeNum::Array{Int,1})\n\nRotates the order of the node's children edges. Useful for plotting, to remove crossing edges. If node is a tree node with no polytomy, the 2 children edges are switched and the optional argument orderedEdgeNum is ignored.\n\nUse plot(net, shownodenumber=true, showedgenumber=false) to map node and edge numbers on the network, as shown in the examples below. (see package PhyloPlots)\n\nWarning: assumes that edges are correctly directed (ischild1 updated). This is done by plot(net). Otherwise run directedges!(net).\n\nExample\n\njulia> net = readnewick(\"(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\");\njulia> using PhyloPlots\njulia> plot(net, shownodenumber=true)\njulia> rotate!(net, -4)\njulia> plot(net)\njulia> net=readnewick(\"(4,((1,(2)#H7:::0.864):2.069,(6,5):3.423):0.265,(3,#H7:::0.136):10.0);\");\njulia> plot(net, shownodenumber=true, showedgenumber=true)\njulia> rotate!(net, -1, orderedEdgeNum=[1,12,9])\njulia> plot(net, shownodenumber=true, showedgenumber=true)\njulia> rotate!(net, -3)\njulia> plot(net)\n\nNote that LinearAlgebra also exports a function named rotate! in Julia v1.5. If both packages need to be used in Julia v1.5 or higher, usage of rotate! needs to be qualified, such as with PhyloNetworks.rotate!.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.setgamma!","page":"Public","title":"PhyloNetworks.setgamma!","text":"setgamma!(Edge, new γ, change_other=true)\n\nSet inheritance probability γ for an edge, which must be a hybrid edge. The new γ needs to be in [0,1]. The γ of the \"partner\" hybrid edge is changed accordingly, to 1-γ. The field ismajor is also changed accordingly. If the new γ is approximately 0.5, Edge is set to the major parent, its partner is set to the minor parent.\n\nIf net is a HybridNetwork object, printedges(net) will show the list of edges and their γ's. The γ of the third hybrid edge (say) can be changed to 0.2 with setgamma!(net.edge[3],0.2). This will automatically set γ of the partner hybrid edge to 0.8.\n\nThe last argument is true by default. If false: the partner edge is not updated. This is useful if the new γ is 0.5, and the partner's γ is already 0.5, in which case the ismajor attributes can remain unchanged.\n\nSee also PhyloNetworks.setmultiplegammas!\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.setlength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Any}","page":"Public","title":"PhyloNetworks.setlength!","text":"setlength!(edge::Edge, new_length)\n\nAssign new length to edge. new_length should be non-negative, or missing (or -1, interpreted as missing).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.setlengths!-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}","page":"Public","title":"PhyloNetworks.setlengths!","text":"setlengths!(edges::Vector{Edge}, lengths::AbstractVector)\n\nAssign new lengths to a vector of edges. Checks that the new edge lengths are non-negative or missing (or -1 to be interpreted as missing).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.sharedpathmatrix-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.sharedpathmatrix","text":"sharedpathmatrix(net::HybridNetwork; checkpreorder::Bool=true)\n\nThis function computes the shared path matrix between all the nodes of a network. It assumes that the network is in the pre-order. If checkpreorder is true (default), then it runs function preorder! on the network beforehand.\n\nReturns an object of type MatrixTopologicalOrder.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.shrink2cycles!","page":"Public","title":"PhyloNetworks.shrink2cycles!","text":"shrink2cycles!(net::HybridNetwork, unroot::Bool=false)\n\nIf net contains a 2-cycle, collapse the cycle into one edge of length tA + γt1+(1-γ)t2 + tB (see below), and return true. Return false otherwise. A 2-cycle is a set of 2 parallel hybrid edges, from the same parent node to the same hybrid child node.\n\n       A                A\n       | tA             |\n     parent             |\n       | \\              |\nt2,1-γ |  | t1,γ        | tA + γ*t1 + (1-γ)*t2 + tB\n       | /              |\n     hybrid             |\n       | tB             |\n       B                B\n\nIf any of the lengths or gammas associated with a 2-cycle are missing, the combined length is missing. If γ is missing, branch lengths are calculated using γ=0.5.\n\nIf unroot is false and the root is up for deletion, it will be kept only if it is has degree 2 or more. If unroot is true and the root is up for deletion, it will be kept only if it has degree 3 or more. A root node with degree 1 will be deleted in both cases.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.shrink3cycles!","page":"Public","title":"PhyloNetworks.shrink3cycles!","text":"shrink3cycles!(net::HybridNetwork, unroot::Bool=false)\n\nRemove all 2- and 3-cycles from a network.\n\nReturn true if net contains a 2-cycle or a 3-cycle; false otherwise. A 3-cycle (2-cycle) is a set of 3 (2) nodes that are all connected. One of them must be a hybrid node, since net is a DAG.\n\nIf unroot is false and the root is up for deletion, it will be kept only if it is has degree 2 or more. If unroot is true and the root is up for deletion, it will be kept only if it has degree 3 or more. A root node with degree 1 will be deleted in both cases.\n\nSee shrink3cycleat! for details on branch lengths and inheritance values.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloNetworks.tiplabels-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.tiplabels","text":"tiplabels(x)\n\nVector of taxon names at the leaves, defined for objects of various types: HybridNetwork, MatrixTopologicalOrder.\n\nFor a network, the taxon names are coerced to strings.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.treeedgecomponents-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.treeedgecomponents","text":"treeedgecomponents(net::HybridNetwork)\n\nReturn the tree-edge components of the semidirected network as a membership dictionary Node => Int. Nodes with the same membership integer value are in the same tree-edge component. The tree-edge components of a network are the connected components of the network when all hybrid edges are removed.\n\nA RootMismatch error is thrown if there exists a cycle in any of the tree-edge components, or if a tree-edge component has more than one \"entry\" hybrid node.\n\nWarnings:\n\nsince Nodes are mutable, the network should not be modified until usage of the output membership dictionary is over.\nthe component IDs are not predicable, but will be consecutive integers from 1 to the number of components.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.treeedges_support-Tuple{Vector{HybridNetwork}, HybridNetwork}","page":"Public","title":"PhyloNetworks.treeedges_support","text":"treeedges_support(sample_net::Vector{HybridNetwork}, ref_net::HybridNetwork)`\n\nRead a sample of networks sample_net (such as a bootstrap sample or a posterior sample) and a reference network (ref_net), and calculate the support for the tree edges in the reference network. All minor hybrid edges (γ<0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.\n\noutput:\n\na data frame with one row per tree edge and two columns: edge number, bootstrap support (as a percentage)\nthe major tree from the reference network, where minor hybrid edges (with γ<0.5) have been removed.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.vcv-Tuple{HybridNetwork}","page":"Public","title":"PhyloNetworks.vcv","text":"vcv(net::HybridNetwork; model::AbstractString=\"BM\",\n                        corr::Bool=false,\n                        checkpreorder::Bool=true)\n\nThis function computes the variance covariance matrix between the tips of the network, assuming a Brownian model of trait evolution (with unit variance). If optional argument corr is set to true, then the correlation matrix is returned instead.\n\nThe function returns a DataFrame object, with columns named by the tips of the network.\n\nThe calculation of the covariance matrix requires a pre-ordering of nodes to be fast. If checkpreorder is true (default), then preorder! is run on the network beforehand. Otherwise, the network is assumed to be already in pre-order.\n\nThis function internally calls sharedpathmatrix, which computes the variance matrix between all the nodes of the network.\n\nExamples\n\njulia> tree_str = \"(((t2:0.14,t4:0.33):0.59,t3:0.96):0.14,(t5:0.70,t1:0.18):0.90);\";\n\njulia> tree = readnewick(tree_str);\n\njulia> C = vcv(tree)\n5×5 DataFrame\n Row │ t2       t4       t3       t5       t1      \n     │ Float64  Float64  Float64  Float64  Float64 \n─────┼─────────────────────────────────────────────\n   1 │    0.87     0.73     0.14      0.0     0.0\n   2 │    0.73     1.06     0.14      0.0     0.0\n   3 │    0.14     0.14     1.1       0.0     0.0\n   4 │    0.0      0.0      0.0       1.6     0.9\n   5 │    0.0      0.0      0.0       0.9     1.08\n\n\nThe following block needs ape to be installed (not run):\n\njulia> using RCall # Comparison with ape vcv function\n\njulia> R\"ape::vcv(ape::read.tree(text = $tree_str))\"\nRCall.RObject{RCall.RealSxp}\n     t2   t4   t3  t5   t1\nt2 0.87 0.73 0.14 0.0 0.00\nt4 0.73 1.06 0.14 0.0 0.00\nt3 0.14 0.14 1.10 0.0 0.00\nt5 0.00 0.00 0.00 1.6 0.90\nt1 0.00 0.00 0.00 0.9 1.08\n\n\nThe covariance can also be calculated on a network (for the model, see Bastide et al. 2018)\n\njulia> net = readnewick(\"((t1:1.0,#H1:0.1::0.30):0.5,((t2:0.9)#H1:0.2::0.70,t3:1.1):0.4);\");\n\njulia> C = vcv(net)\n3×3 DataFrame\n Row │ t1       t2       t3      \n     │ Float64  Float64  Float64 \n─────┼───────────────────────────\n   1 │    1.5     0.15      0.0\n   2 │    0.15    1.248     0.28\n   3 │    0.0     0.28      1.5\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.writemultinewick-Tuple{Vector{HybridNetwork}, AbstractString}","page":"Public","title":"PhyloNetworks.writemultinewick","text":"writemultinewick(nets, file_name; append=false)\nwritemultinewick(nets, IO)\n\nWrite an array of networks in parenthetical extended Newick format, one network per line. Use the option append=true to append to the file. Otherwise, the default is to create a new file or overwrite it, if it already existed. Each network is written with writenewick.\n\nExamples\n\njulia> net = [readnewick(\"(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10);\"),\n              readnewick(\"(A,(B,C));\"),readnewick(\"(E,F);\"),readnewick(\"(G,H,F);\")];\n\njulia> writemultinewick(net, \"fournets.net\") # to (over)write to file \"fournets.net\"\njulia> writemultinewick(net, \"fournets.net\", append=true) # to append to this file\njulia> writemultinewick(net, stdout)         # to write to the screen (standard out)\n(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10.0);\n(A,(B,C));\n(E,F);\n(G,H,F);\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.writenewick-Tuple{HybridNetwork, AbstractString}","page":"Public","title":"PhyloNetworks.writenewick","text":"writenewick(net)\nwritenewick(net, filename)\nwritenewick(net, IO)\n\nWrite the parenthetical extended Newick format of a network, as a string, to a file or to an IO buffer / stream. Optional arguments (default values):\n\ndi (false): write in format for Dendroscope\nround (false): rounds branch lengths and heritabilities γ\ndigits (3): digits after the decimal place for rounding\nappend (false): if true, appends to the file\ninternallabel (true): if true, writes internal node labels\n\nIf the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.\n\nUses lower-level function writesubtree!.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.writesubtree!-NTuple{5, Any}","page":"Public","title":"PhyloNetworks.writesubtree!","text":"writesubtree!(IO, node, edge, dendroscope::Bool, namelabel::Bool,\n              round_branch_lengths::Bool, digits::Integer, internallabel::Bool)\n\nWrite the extended newick format of the sub-network rooted at node and assuming that edge is a parent of node.\n\nIf the parent edge is nothing, the edge attribute ischild1 is used and assumed to be correct to write the subtree rooted at node. This is useful to write a subtree starting at a non-root node. Example:\n\nnet = readnewick(\"(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);\")\ndirectedges!(net)\ns = IOBuffer()\nwritesubtree!(s, net.node[7], nothing, false, true)\nString(take!(s))\n\nUsed by writenewick.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.writesubtree!-Tuple{IO, HybridNetwork, Bool, Bool, Bool, Integer, Bool}","page":"Public","title":"PhyloNetworks.writesubtree!","text":"writesubtree!(IO, network, dendroscope::Bool, namelabel::Bool,\n              round_branch_lengths::Bool, digits::Integer,\n              internallabel::Bool)\n\nWrite to IO the extended newick format (parenthetical description) of a network. If written for dendroscope, inheritance γ's are not written. If namelabel is true, taxa are labelled by their names; otherwise taxa are labelled by their number IDs. If unspecified, branch lengths and γ's are rounded to 3 digits. Use internallabel=false to suppress the labels of internal nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloNetworks.HybridNetwork","page":"Public","title":"PhyloNetworks.HybridNetwork","text":"HybridNetwork\n\nSubtype of abstract Network type. Explicit network or tree with the following attributes:\n\nnumtaxa: number of taxa, that is, number of are leaves (or tips). Leaves are required to be attached to a single edge.\nnumnodes: total number of nodes: tips and internal nodes\nnumedges: total number of edges\nnumhybrids: total number of hybrid nodes\nedge: vector of Edges\nnode: vector of Nodes\nrooti: index of the root in vector 'node'. May be artificial in a semidirected network, but is necessary for printing and traversal purposes.\nhybrid: vector of Nodes: those are are hybrid nodes\nleaf: vector of Nodes: those that are leaves\nfscore: score after fitting network to data, i.e. parsimony score, or multipe of the negative log pseudodeviance for SNaQ\nisrooted: true or false\npartition: vector of Partition\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#index","page":"Public","title":"index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"#PhyloNetworks.jl","page":"Home","title":"PhyloNetworks.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PhyloNetworks is a Julia package with core utilities for phylogenetic networks. Phylogenetic networks represent the evolutionary relationships between a set of organisms, e.g. populations, species, languages, cultures etc. They provide an explicit representation of splitting events (when populations diverge from one another) and of merging events (when populations mix together due to migration of individuals, hybridization, polyploidization, recombination, etc.). Phylogenetic networks are called admixture graphs in population genetics, when merging events are interpreted as admixture between populations. They can also summarize ancestral recombination graphs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PhyloNetworks is a core package that supports reading, writing, manipulating phylogenetic networks, and other standard tools. It is used by other packages for more specialized tasks, such as","category":"page"},{"location":"","page":"Home","title":"Home","text":"PhyloPlots to visualize phylogenetic networks,\nSNaQ for the inference of phylogenetic networks from quartet concordance factors (qCF),\nQuartetNetworkGoodnessFit to calculate quartet concordance factors expected from a general network and test the adequacy of a network to qCF data,\nPhyloTraits for the inference of trait evolution along a phylogenetic network,\nPhyloCoalSimulations to simulate gene trees under a coalescent process along a phylogenetic networks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"How to get help","category":"page"},{"location":"","page":"Home","title":"Home","text":"the package wiki has a step-by-step tutorial, done for the MBL workshop (last revised 2022), with background on networks and explanations.\ntutorial for comparative methods, including network calibration (2023 workshop)\nthe google group has answers to common questions.\nthe Manual and below has a quick tutorial (navigation on the left).\nthe Library further below has the full list of documented functions.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See their bibtex format.","category":"page"},{"location":"","page":"Home","title":"Home","text":"for the package in particular, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Claudia Solís-Lemus, Paul Bastide and Cécile Ané (2017). PhyloNetworks: a package for phylogenetic networks. Molecular Biology and Evolution 34(12):3292–3298. doi:10.1093/molbev/msx235","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/installation.md\",\n    \"man/netmanipulation.md\",\n    \"man/net_plot.md\",\n    \"man/dist_reroot.md\",\n    \"man/network_support.md\",\n    \"man/parsimony.md\",\n    \"man/nj.md\"\n]\nDepth = 3","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For help on individual functions, see the library:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/public.md\",\n    \"lib/internals.md\",\n]\nDepth = 3","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Julia is a high-level and interactive programming language (like R or Matlab), but it is also high-performance (like C). To install Julia, follow instructions here. For a quick & basic tutorial on Julia, see learn x in y minutes.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Editors:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Visual Studio Code provides an editor and an integrated development environment (IDE) for Julia: highly recommended! Positron is a great (and similar) alternative.\nInstall the Julia extension in VS Code or Positron.\nWe can also run Julia in a Pluto notebook. Pluto.jl is a great to get started with Julia.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Julia code is just-in-time compiled. This means that the first time we run a function, it will be compiled at that moment. Future calls to the function will be much faster. Trying out toy examples for the first calls is a good idea.","category":"page"},{"location":"man/installation/#Install-PhyloNetworks","page":"Installation","title":"Install PhyloNetworks","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To install the package, type inside Julia:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"PhyloNetworks\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you already installed the package and want the latest registered version, do this to update all of your packages:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Pkg.update()","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"It is important to update the package regularly as it is undergoing constant development. Join the google group for updates here.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Pkg.update() will install the latest registered version, but there could be other improvements in the master branch of the repository. If you want to update to the latest unregistered version of the package, you can do Pkg.add(PackageSpec(name=\"PhyloNetworks\", rev=\"master\")) just beware that the latest changes could be not as robust. If you want to go back to the registered package, you can do Pkg.free(\"PhyloNetworks\").","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Similarly, you can pin a version of the package Pkg.pin(\"PhyloNetworks\") so that Pkg.update() will not modify it. You can always free a pinned package with Pkg.free(\"PhyloNetworks\"). More on package management here.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The PhyloNetworks package has dependencies like NLopt and DataFrames (see the Project.toml file for the full list), but everything is installed automatically.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The companion package PhyloPlots has utilities to visualize networks, and for interoperability, such as to export networks to R (which can then be plotted via R). To install:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"PhyloPlots\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"PhyloPlots depends on PhyloNetworks, and has further dependencies like RCall","category":"page"},{"location":"man/installation/#Test-example","page":"Installation","title":"Test example","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To check that your installation worked, type this in Julia to load the package. This is something to type every time you start a Julia session:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using PhyloNetworks;","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This step can also take a while, to pre-compile the code (after a package update for instance). Here is a very small test for the installation of PhyloNetworks.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"net = readnewick(\"(A,(B,(C,D)));\");\ntiplabels(net)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"You can see a list of all the functions with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"varinfo(PhyloNetworks)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"and press ? inside Julia to switch to help mode, followed by the name of a function (or type) to get more details about it.","category":"page"},{"location":"man/installation/#Julia-types","page":"Installation","title":"Julia types","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Each object in Julia has a type. We show here small examples on how to get more info on an object. If we want to know the type of a particular object, use typeof For example, let's read a list of gene trees. First, we need the file name.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"raxmltreefile = joinpath(dirname(dirname(pathof(PhyloNetworks))), \"examples\",\"raxmltrees.tre\")\ntypeof(raxmltreefile)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The object raxmltreefile is a basic string (of letters). Let's create our list of gene trees by reading this file.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"genetrees = readmultinewick(raxmltreefile); # the semicolon suppresses info on the result\ntypeof(genetrees)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"which shows us that genetrees is of type Vector{HybridNetwork}, that is, a vector containing networks. If we want to know about the attributes the object has, we can type ? in Julia, followed by HybridNetwork for a description.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Typing varinfo() will provide a list of objects and packages in memory, including raxmltreefile and genetrees that we just created.","category":"page"},{"location":"man/installation/#Quick-start","page":"Installation","title":"Quick start","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Here we could check the length of our list of gene trees, as a sanity check to make sure we have all gene trees we expected, and check that the third tree has whatever taxon names we expected:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"length(genetrees)\ntiplabels(genetrees[3])","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"We can also see some basic information on the third gene tree, say:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"genetrees[3]","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To visualize any of these gene trees, use the PhyloPlots package:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using PhyloPlots\nusing RCall # hide\nmkpath(\"../assets/figures\") # hide\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('inputdata_gene3.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0])                          # hide\nplot(genetrees[3]); # tree for 3rd gene\nR\"dev.off()\"                                   # hide\nnothing # hide","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"(Image: gene3)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"We can also read a network from a newick formatted string, and, for example, print a list of its edges:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"newickstring = \"(A,((B,#H1),(C,(D)#H1)));\";\nnet = readnewick(newickstring);\nprintedges(net)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"We see that the edges do not have branch lengths, and the hybrid edges do not have gamma (inheritance) values. We can set them with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"setlength!(net.edge[1], 1.9)\nsetgamma!(net.edge[3],  0.8)\nprintedges(net)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"where 1 and 3 correspond to the position of the given edge to modify in the list of edges. We can only change the γ value of hybrid edges, not tree edges (for which γ=1 necessarily). Such an attempt below will cause an error with a message to explain that the edge was a tree edge:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"setgamma!(net.edge[4], 0.7)\n# should return this:\n# ERROR: cannot change gamma in a tree edge","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"using PhyloNetworks\nmkpath(\"../assets/figures\")","category":"page"},{"location":"man/network_support/#Network-support","page":"Network support","title":"Network support","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We show here how to summarize a sample of networks. This may be used to get bootstrap support or posterior probabilities for network features, if the sample of networks comes from a bootstrap analysis (as possible with SNaQ) or if it's a posterior sample of networks from a Bayesian analysis.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"To demonstrate summarizing a sample of networks, we use here a sample of 100 networks, obtained by running 100 bootstrap replicates of SNaQ. The file containing the 100 networks comes with the package:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"bootnet = readmultinewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"bootsnaq.out\"));\nlength(bootnet)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We seek to summarize what these 100 networks have in common (highly supported features) and what they don't (areas of uncertainty). Unlike for trees, there are a variety of features that we may summarize in a network. Below we show how to calculate support for tree edges, for a clade to be of hybrid origin, or for a clade to be sister to a hybrid clade, or combinations.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We also assume that we have a reference network, such as the best-fitting network on the original (non-bootstrapped) data, or some other \"consensus\" network. We focus on features (tree edges and clades) in this reference network and quantify the support for these features in the sample of networks.","category":"page"},{"location":"man/network_support/#support-for-tree-edges","page":"Network support","title":"support for tree edges","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"To summarize our sample of 100 networks on our reference network, it is best to re-read this network to get a reproducible internal numbering of its nodes and edges, used later for mapping support to edges. As our reference network, we use here a network with 1 reticulation (best-fitting network on the original data):","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"net1 = readnewick(joinpath(dirname(pathof(PhyloNetworks)), \"..\",\"examples\",\"net1.out\"))","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"It turns out that the direction of gene flow is quite uncertain in this example (see below) with a wrong direction inferred sometimes, so we re-root our reference network net1 to the base of O,E, for the figures to be less confusing later.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"rootonedge!(net1, 7)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"using PhyloPlots, RCall\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('net1_rotate1_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, showedgenumber=true); # edge 7 leads to O+E\nR\"dev.off()\" # hide\nrootonedge!(net1, 7) # makes (O,E) outgroup clade\nR\"svg(name('net1_rotate1_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, shownodenumber=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: net1_rotate1 1) (Image: net1_rotate1 2)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Edges cross: but rotating at node -6 should remove this crossing of edges","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"rotate!(net1, -6)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('net1_rotate2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, showgamma=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: net1_rotate2)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We can now summarize our sample of networks. The functions treeedges_support and hybridclades_support read all networks in the sample and map the edges / nodes onto a reference network, here net1.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSe_tree, tree1 = treeedges_support(bootnet,net1);","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"This calculates the major tree tree1 displayed in net1, that is, the tree obtained by following the major parent (γ>0.5) of each hybrid node. This tree can be visualized like this, with edge numbers shown for later use.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('major_tree.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(tree1, showedgenumber=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: major_tree)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Next, we can look at the support table BSe_tree, which has one row for each tree edge in net1. One column contains the edge number (same as shown in the plot) and another column contains the edge (bootstrap) support: the proportion of sample networks in which this edge was found in the major tree of that network. We can see the full support table and see which tree edges have support lower than 100% (none here) with","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"using DataFrames # for showall() below\nshow(BSe_tree, allrows=true, allcols=true)\nfilter(row -> row[:proportion] < 100, BSe_tree)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Finally, we can map the support values onto the reference network or its main tree by passing the support table to the edgelabel option of plot:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('boot_tree_net_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(tree1, edgelabel=BSe_tree);\nR\"dev.off()\" # hide\nR\"svg(name('boot_tree_net_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, edgelabel=BSe_tree);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: boot_tree_net 1) (Image: boot_tree_net 2)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Here, it is important that the numbers assigned to edges when building the boostrap table –those in net1 at the time– correspond to the current edge numbers in tree1 and net1. That was the purpose of reading the network from the output file of snaq! earlier, for consistency across different Julia sessions.)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"If we wanted to plot only certain support values, like those below 100% (1.0), we could do this:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"plot(net1, edgelabel=filter(row -> row[:proportion] < 100, BSe_tree));","category":"page"},{"location":"man/network_support/#support-for-hybrid-edges","page":"Network support","title":"support for hybrid edges","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Summarizing the placement of reticulations is not standard. The function hybridclades_support attempts to do so.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"The descendants of a given hybrid node form the \"recipient\" or \"hybrid\" clade, and is obtained after removing all other reticulations.\nTo remove the reticulations other than one of interest, their minor hybrid parent edge (with γ<0.5) is removed. If a reticulation is due to introgression, this minor edge may be interpreted as the \"gene flow\" edge.\nThe descendants of the lineage from which gene flow originated is then a second \"sister\" of the hybrid clade.   Because of the reticulation event, the hybrid clade has 2 sister clades, not 1: the major sister (through the major hybrid edge with γ>0.5) and the minor sister (through the minor hybrid edge with γ<0.5).","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Note that the network says nothing about the process: its shows the relationships only. We can calculate the frequency that each clade is a hybrid clade, or a major or minor sister for some other hybrid, in the sample of networks:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSn, BSe, BSc, BSgam, BSedgenum = hybridclades_support(bootnet, net1);","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Let's look at the results. We can list all the clades and the percentage of sample networks (support) in which each clade is a hybrid or sister to a hybrid:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSn","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"If a clade contains a single taxon, it is listed with its taxon name. The clade found in the best network is listed with its tag, starting with H (e.g. \"H7\"). The name of other clades start with \"c_\" followed by their number in the best network, if they do appear in the best network. The node numbers, as used internally in the best network, are listed in a separate column. They can be used later to display the support values onto the network. Various columns give the support that each clade is a hybrid, or a (major/minor) sister to a hybrid. The last column gives the support for the full relationship in the best network: same hybrid with same two sisters. These support values are associated with nodes (or possibly, their parent edges).","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"To see what is the clade named \"H7\", for instance:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSc # this might be too big\nshow(BSc, allrows=true, allcols=true)\n# BSc[BSc[!,:H7], :taxa] # just a different syntax to subset the data in the same way\nfilter(row -> row[:H7], BSc).taxa","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We can also get support values associated with edges, to describe the support that a given hybrid clade has a given sister clade.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSe","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Here, each row describes a pair of 2 clades: one being the hybrid, the other being its sister, connected by a hybrid edge. The first rows corresponds to hybrid edges in the best network. Other rows correspond to edges seen in the sample of networks but not in the reference network.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSedgenum","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"lists all the hybrid edges in the best network, two for each hybrid node: the major parent edge and then the minor parent edge. In our case, there is only one reticulation, so only 2 hybrid edges.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We can plot the support values of the 2 hybrid edges in the best network:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('boot_net_net.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, edgelabel=BSe[:,[:edge,:BS_hybrid_edge]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: boot_net_net)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"This is showing the support for each hybrid edge: the percentage of networks in the sample, with an edge from the same sister clade to the same hybrid clade. Alternatively, we could show the support for the full reticulation relationships in the network, one at each hybrid node (support for same hybrid with same sister clades). Here, we find that A received gene flow from E (and is sister to B otherwise) in just 32% of sampled networks. In another 1% of sampled networks, A received gene flow from another source.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('boot_net_ret.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, nodelabel=BSn[!,[:hybridnode,:BS_hybrid_samesisters]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: boot_net_ret)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Below is example code to place tree edge support and hybrid edge support on the same plot.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"tmp = filter(row -> !ismissing(row[:edge]), BSe) # filter rows\nselect!(tmp, [:edge,:BS_hybrid_edge])            # select 2 columns only\nrename!(tmp, :BS_hybrid_edge => :proportion)     # rename those columns, to match names in BSe_tree\nrename!(tmp, :edge => :edgeNumber)\ntmp = vcat(BSe_tree, tmp)\nplot(net1, edgelabel=tmp, nodelabel=BSn[:, [:hybridnode,:BS_hybrid_samesisters]])","category":"page"},{"location":"man/network_support/#support-for-hybrid-clades","page":"Network support","title":"support for hybrid clades","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"On a different plot, we can show the support for hybrid clades, first mapped to each node with positive hybrid support, and then mapped on the parent edge of these nodes. A is estimated as a hybrid in only 33% of our sampled networks. In another 44%, it is the lineage to (E,O) that is estimated as being of hybrid origin.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('boot_net_hyb_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, nodelabel=filter(row->row[:BS_hybrid]>0, BSn)[!,[:hybridnode,:BS_hybrid]]);\nR\"dev.off()\" # hide\nnothing # hide\nR\"svg(name('boot_net_hyb_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, edgelabel=filter(row->row[:BS_hybrid]>0, BSn)[!,[:edge,:BS_hybrid]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: boot_net_hyb 1) (Image: boot_net_hyb 2)","category":"page"},{"location":"man/network_support/#support-for-the-origin-of-gene-flow","page":"Network support","title":"support for the origin of gene flow","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"We can plot the support for the various placements of the gene flow origin (minor sister clade), first mapped to each node with positive support for being the origin of gene flow, and then mapped along the parent edge of these nodes. We filtered clades to show those with sister support > 5%:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"R\"svg(name('boot_net_clade_1.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, nodelabel=filter(r->r[:BS_minor_sister]>5, BSn)[!,[:node,:BS_minor_sister]]);\nR\"dev.off()\" # hide\nnothing # hide\nR\"svg(name('boot_net_clade_2.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net1, edgelabel=filter(r->r[:BS_minor_sister]>5, BSn)[!,[:edge,:BS_minor_sister]]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"(Image: boot_net_clade 1) (Image: boot_net_clade 2)","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"In our best network, the lineage to E is estimated as the origin of gene flow, but this is recovered in only 41% of our sampled networks. In another 49%, it is the lineage to A that is the origin of gene flow: in these networks, gene flow is in the opposite direction compared to our reference network. In this example, there is support for gene flow between (A,B) and (E,O), but there is much uncertainty about its exact placement and about its direction.","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"Mapping the support for major sister clades might be interesting too:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"plot(net1, nodelabel=filter(r->r[:BS_major_sister]>5, BSn)[!,[:node,:BS_major_sister]])","category":"page"},{"location":"man/network_support/#summarizing-heritabilities-in-a-network-sample","page":"Network support","title":"summarizing heritabilities in a network sample","text":"","category":"section"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"For each hybrid edge in the reference network, when present in a sampled network, its heritability γ in the sampled network was also extracted:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"BSgam[1:3,:] # first 3 rows only","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"γ=0 values are for sampled networks that did not have the edge. Basic summaries on γ values for a given edge, say the minor parent, could be obtained like this:","category":"page"},{"location":"man/network_support/","page":"Network support","title":"Network support","text":"minimum(BSgam[:,2])\nmaximum(BSgam[:,2])\nusing Statistics # for functions like mean and std (standard deviation)\nmean(BSgam[:,2])\nstd(BSgam[:,2])","category":"page"}]
}
