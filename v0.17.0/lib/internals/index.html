<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · PhyloNetworks.jl</title><meta name="title" content="Internals · PhyloNetworks.jl"/><meta property="og:title" content="Internals · PhyloNetworks.jl"/><meta property="twitter:title" content="Internals · PhyloNetworks.jl"/><meta name="description" content="Documentation for PhyloNetworks.jl."/><meta property="og:description" content="Documentation for PhyloNetworks.jl."/><meta property="twitter:description" content="Documentation for PhyloNetworks.jl."/><meta property="og:url" content="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/internals/"/><meta property="twitter:url" content="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/internals/"/><link rel="canonical" href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/internals/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="PhyloNetworks.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="PhyloNetworks.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PhyloNetworks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/installation/">Installation</a></li><li><a class="tocitem" href="../../man/netmanipulation/">Network manipulation</a></li><li><a class="tocitem" href="../../man/net_plot/">Network visualization</a></li><li><a class="tocitem" href="../../man/dist_reroot/">Network comparison and manipulation</a></li><li><a class="tocitem" href="../../man/network_support/">Network support</a></li><li><a class="tocitem" href="../../man/parsimony/">Parsimony on networks</a></li><li><a class="tocitem" href="../../man/nj/">Neighbour Joining</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../public/">Public</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#functions-and-types"><span>functions &amp; types</span></a></li><li><a class="tocitem" href="#index"><span>index</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/PhyloNetworks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/master/docs/src/lib/internals.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="internal-documentation"><a class="docs-heading-anchor" href="#internal-documentation">internal documentation</a><a id="internal-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#internal-documentation" title="Permalink"></a></h1><p>Documentation for <code>PhyloNetworks</code>&#39;s internal functions. These functions are not exported and their access (API) should not be considered stable. But they can still be used, like this for example: <code>PhyloNetworks.foo()</code> for a function named <code>foo()</code>.</p><h2 id="functions-and-types"><a class="docs-heading-anchor" href="#functions-and-types">functions &amp; types</a><a id="functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#functions-and-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.ANode" href="#PhyloNetworks.ANode"><code>PhyloNetworks.ANode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ANode</code></pre><p>Abstract node. An object of type <a href="#PhyloNetworks.EdgeT"><code>EdgeT</code></a> has a <code>node</code> attribute, which is an vector of 2 objects of some subtype of <code>ANode</code>. The concrete type <a href="#PhyloNetworks.Node"><code>Node</code></a> is a subtype of <code>ANode</code>, and has an <code>edge</code> attribute, which is vector of <a href="#PhyloNetworks.EdgeT"><code>Edge</code></a> objects (where Edge is an alias for EdgeT{Node}).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/types.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.EdgeT" href="#PhyloNetworks.EdgeT"><code>PhyloNetworks.EdgeT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EdgeT{node type}
Edge = EdgeT{Node}
Edge(number, length=1.0)</code></pre><p>Data structure for an edge and its various attributes. Most notably:</p><ul><li><code>number</code> (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example</li><li><code>node</code>: vector of <a href="#PhyloNetworks.Node"><code>Node</code></a>s, normally just 2 of them</li><li><code>ischild1</code> (boolean): <code>true</code> if <code>node[1]</code> is the child node of the edge, false if <code>node[1]</code> is the parent node of the edge</li><li><code>length</code>: branch length</li><li><code>hybrid</code> (boolean): whether the edge is a tree edge or a hybrid edge (in which case <code>ischild1</code> is important, even if the network is semi-directed)</li><li><code>gamma</code>: proportion of genetic material inherited by the child node via the edge; 1.0 for a tree edge</li><li><code>ismajor</code> (boolean): whether the edge is the major path to the child node; <code>true</code> for tree edges, since a tree edge is the only path to its child node; normally true if <code>gamma&gt;0.5</code>.</li><li><code>containroot</code> (boolean): is the interior of this edge a valid rooting position? That is, if we added a node on the edge, could we direct all edges away from this new node to root the semidirected network and get a valid rooted network?</li></ul><p>and other fields, used very internally</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/types.jl#L14-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.MatrixTopologicalOrder" href="#PhyloNetworks.MatrixTopologicalOrder"><code>PhyloNetworks.MatrixTopologicalOrder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MatrixTopologicalOrder</code></pre><p>Matrix associated to a <a href="../public/#PhyloNetworks.HybridNetwork"><code>HybridNetwork</code></a> in which rows and/or columns correspond to nodes in the network. In this matrix, nodes are indexed by their topological order. For example, if rows list nodes in network <code>net</code>, then <code>V[i,:]</code> corresponds to node <code>net.vec_node[i]</code>.</p><p>The following functions and extractors can be applied to it: <a href="../public/#PhyloNetworks.tiplabels-Tuple{HybridNetwork}"><code>tiplabels</code></a>, <code>obj[:Tips]</code>, <code>obj[:InternalNodes]</code>, <code>obj[:TipsNodes]</code>. See documentation for <a href="#Base.getindex"><code>getindex(::MatrixTopologicalOrder, ::Symbol)</code></a>).</p><p>A <code>MatrixTopologicalOrder</code> object has field <code>V</code> (the matrix of interest) and fields for mapping indices in <code>V</code> to node numbers <code>nodeNumbersTopOrder</code>, <code>internalNodeNumbers</code>, <code>tipNumbers</code>, <code>tipNames</code>, <code>indexation</code>. Type in &quot;?MatrixTopologicalOrder.field&quot; to get documentation on a specific field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/recursion_matrices.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.Node" href="#PhyloNetworks.Node"><code>PhyloNetworks.Node</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Node(number, leaf)
Node(number, leaf, hybrid)</code></pre><p>Data structure for a node and its various attributes. Most notably:</p><ul><li><code>number</code> (integer): serves as unique identifier; remains unchanged when the network is modified, with a nearest neighbor interchange for example</li><li><code>leaf</code> (boolean): whether the node is a leaf (with data typically) or an internal node (no data typically)</li><li><code>name</code> (string): taxon name for leaves; internal node may or may not have a name</li><li><code>edge</code>: vector of <a href="#PhyloNetworks.EdgeT"><code>Edge</code></a>s that the node is attached to; 1 if the node is a leaf, 2 if the node is the root, 3 otherwise, and potentially more if the node has a polytomy</li><li><code>hybrid</code> (boolean): whether the node is a hybrid node (with 2 or more parents) or a tree node (with a single parent)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/types.jl#L103-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.Partition" href="#PhyloNetworks.Partition"><code>PhyloNetworks.Partition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Partition</code></pre><p>Data structure for a collection of edges. Used in SNaQ for groups of edges in the same cycle. Fields:</p><ul><li><code>cycle</code>: vector of <code>Int</code></li><li><code>edges</code>: vector of <code>Edge</code></li></ul><p>Todo: use this to store the output of the blob decomposition, because biconnected components partition edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/types.jl#L148-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.TopologyConstraint" href="#PhyloNetworks.TopologyConstraint"><code>PhyloNetworks.TopologyConstraint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Type for various topological constraints, such as:</p><ol><li>a set of taxa forming a clade in the major tree</li><li>a set of individuals belonging to the same species</li><li>a set of taxa forming a clade in any one of the displayed trees</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.TopologyConstraint-Tuple{UInt8, Vector{String}, HybridNetwork}" href="#PhyloNetworks.TopologyConstraint-Tuple{UInt8, Vector{String}, HybridNetwork}"><code>PhyloNetworks.TopologyConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TopologyConstraint(type::UInt8, taxonnames::Vector{String}, net::HybridNetwork)</code></pre><p>Create a topology constraint from user-given type, taxon names, and network. There are 3 types of constraints:</p><ul><li>type 1: A set of tips that forms a species.</li><li>type 2: A set of tips that forms a clade in the major tree. Note that the root matters. Constraining a set of species to be an outgroup is equivalent to constraining the ingroup to form a clade.</li><li>type 3: A set of tips that forms a clade in any one of the displayed trees.</li></ul><p>Note: currently, with type-1 constraints, hybridizations are prevented from coming into or going out of a species group.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((2a,2b),(((((1a,1b,1c),4),(5)#H1),(#H1,(6,7))))#H2),(#H2,10));&quot;);

julia&gt; c_species1 = PhyloNetworks.TopologyConstraint(0x01, [&quot;1a&quot;,&quot;1b&quot;,&quot;1c&quot;], net)
Species constraint, on tips: 1a, 1b, 1c
 stem edge number 7
 crown node number -9

julia&gt; c_species2 = PhyloNetworks.TopologyConstraint(0x01, [&quot;2a&quot;,&quot;2b&quot;], net)
Species constraint, on tips: 2a, 2b
 stem edge number 3
 crown node number -4

julia&gt; nni!(net , net.edge[3], true, true, [c_species2]) === nothing # we get nothing: would break species 2
true

julia&gt; # the following gives an error, because 4,5 do not form a clade in &quot;net&quot;
       # PhyloNetworks.TopologyConstraint(0x02, [&quot;4&quot;,&quot;5&quot;], net)

julia&gt; c_clade145 = PhyloNetworks.TopologyConstraint(0x02, [&quot;1a&quot;,&quot;1b&quot;,&quot;1c&quot;,&quot;4&quot;,&quot;5&quot;], net)
Clade constraint, on tips: 1a, 1b, 1c, 4, 5
 stem edge number 12
 crown node number -7

julia&gt; nni!(net , net.edge[12], true, true, [c_species1, c_clade145]) # we get nothing (failed NNI): would break the clade</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L50-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(obj::MatrixTopologicalOrder,
         d::Symbol,[ indTips, nonmissing])</code></pre><p>Get submatrices of a <a href="#PhyloNetworks.MatrixTopologicalOrder"><code>MatrixTopologicalOrder</code></a> object. In <code>obj.V</code>, row and/column <code>i</code> corresponds to the <code>i</code>th node in topological order. In contrast, in matrix <code>obj[:tips]</code> for example, row and/or column <code>i</code> corresponds to the <code>i</code>th tip when tips are listed in the same order as in the network&#39;s original <code>.node</code> vector.</p><p>Arguments:</p><ul><li><code>obj::MatrixTopologicalOrder</code>: the matrix from which to extract.</li><li><code>d::Symbol</code>: a symbol specifying which sub-matrix to extract. Can be:<ul><li><code>:Tips</code> columns and/or rows corresponding to the tips</li><li><code>:InternalNodes</code> columns and/or rows corresponding to the internal nodes Includes tips not listed in <code>indTips</code> or missing data according to <code>nonmissing</code>.</li><li><code>:TipsNodes</code> columns corresponding to internal nodes, and row to tips (works only is indexation=&quot;b&quot;)</li></ul></li><li><code>indTips::Vector{Int}</code>: optional argument precising a specific order for the tips (internal use).</li><li><code>nonmissing::BitArray{1}</code>: optional argument saying which tips have data (internal use).  Tips with missing data are treated as internal nodes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/recursion_matrices.jl#L69-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks._getnodeheights" href="#PhyloNetworks._getnodeheights"><code>PhyloNetworks._getnodeheights</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_getnodeheights(net::HybridNetwork, fixmissing::Bool,
                inconsistencyhandler::Function, checkpreorder::Bool=true)</code></pre><p>Helper to determine time-consistency and calculate node heights (distance from the root), used by <a href="../public/#PhyloNetworks.getnodeheights"><code>getnodeheights</code></a> for example.</p><p>output: <code>(isconsistent, nodes_distance_from_root)</code></p><p>Arguments:</p><ul><li><p><code>fixmissing</code>:</p><ul><li>if <code>false</code>, any missing hybrid edge length will cause a warning, the network is <em>not</em> modified, and the best-case is assumed to determine time-consistency (as explained below)</li><li>if <code>true</code>, will attempt to find values for missing lengths of <em>hybrid</em> edges, if any, to make the network time-consistent, placing hybrid nodes as close to the root as possible (as this gives most chances to find a time-consistent assignment of all missing hybrid edge lengths). If there is a time-consistent assignment, then the network is modified (with missing hybrid edge lengths set to time-consistent values). Otherwise, the network is not modified.</li></ul><p>This option is passed to <code>update_getnodeheights_hybrid!</code> that handles 1 hybrid node at a time.</p></li><li><p><code>inconsistencyhandler</code>: function to check &amp; handle time-consistency as desired as a given hybrid node <code>h</code>, and to decide if the traversal should continue. It should take as input:</p><ul><li>a vector of ≥1 candicate heights for <code>h</code> from parent edges with non-missing length, and</li><li>a vector of ≥0 heights of parent nodes whose child edge to <code>h</code> has no length</li><li><code>isconsistent</code>: a boolean that is modified to <code>false</code> if the network is not time-consistent at <code>h</code> (unless an error is thrown anyway!).</li></ul><p>This handler function decides what to do if the candidate heights are not all equal (the network is time-inconsistent), and if the values to be assigned to missing edge lengths would be negative. Its output should be: <code>(keepgoing_boolean, hybrid_node_height)</code>.</p><p>Examples: <a href="#PhyloNetworks.timeinconsistency_error-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Vararg{Any}}} where T&lt;:Real"><code>timeinconsistency_error</code></a> is conservative and throws an error in both cases. <a href="#PhyloNetworks.timeinconsistency_average-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Ref{Bool}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}} where T&lt;:Real"><code>timeinconsistency_average</code></a> is lenient: only throws warnings, but keeps going and returns γ-weighted average node heights</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1133-L1178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork, DataFrames.DataFrame}" href="#PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork, DataFrames.DataFrame}"><code>PhyloNetworks.addAlternativeHybridizations!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addAlternativeHybridizations!(net::HybridNetwork, BSe::DataFrame;
                              cutoff::Number=10, top::Int=3)</code></pre><p>Modify the network <code>net</code> (the best estimated network) by adding some of the hybridizations present in the bootstrap networks. By default, it will only add hybrid edges with more than 10% bootstrap support (<code>cutoff</code>) and it will only include the top 3 hybridizations (<code>top</code>) sorted by bootstrap support.</p><p>The dataframe <code>BSe</code> is also modified. In the original <code>BSe</code>, supposedly obtained with <code>hybridclades_support</code>, hybrid edges that do not appear in the best network have a missing number. After hybrid edges from bootstrap networks are added, <code>BSe</code> is modified to include the edge numbers of the newly added hybrid edges. To distinguish hybrid edges present in the original network versus new edges, an extra column of true/false values is also added to <code>BSe</code>, named &quot;alternative&quot;, with true for newly added edges absent from the original network.</p><p>The hybrid edges added to <code>net</code> are added as minor edges, to keep the underlying major tree topology.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bootnet = readmultinewick(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;,&quot;examples&quot;, &quot;bootsnaq.out&quot;)); # vector of 10 networks

julia&gt; bestnet = readnewick(&quot;((O,(E,#H7:::0.196):0.314):0.332,(((A)#H7:::0.804,B):10.0,(C,D):10.0):0.332);&quot;);

julia&gt; BSn, BSe, BSc, BSgam, BSedgenum = hybridclades_support(bootnet, bestnet);

julia&gt; BSe[1:6,[:edge,:hybrid_clade,:sister_clade,:BS_hybrid_edge]]
6×4 DataFrame
 Row │ edge     hybrid_clade  sister_clade  BS_hybrid_edge 
     │ Int64?   String        String        Float64        
─────┼─────────────────────────────────────────────────────
   1 │       7  H7            B                       33.0
   2 │       3  H7            E                       32.0
   3 │ missing  c_minus3      c_minus8                44.0
   4 │ missing  c_minus3      H7                      44.0
   5 │ missing  E             O                       12.0
   6 │ missing  c_minus6      c_minus8                 9.0

julia&gt; PhyloNetworks.addAlternativeHybridizations!(bestnet, BSe)

julia&gt; BSe[1:6,[:edge,:hybrid_clade,:sister_clade,:BS_hybrid_edge,:alternative]]
6×5 DataFrame
 Row │ edge     hybrid_clade  sister_clade  BS_hybrid_edge  alternative 
     │ Int64?   String        String        Float64         Bool        
─────┼──────────────────────────────────────────────────────────────────
   1 │       7  H7            B                       33.0        false
   2 │       3  H7            E                       32.0        false
   3 │      16  c_minus3      c_minus8                44.0         true
   4 │      19  c_minus3      H7                      44.0         true
   5 │      22  E             O                       12.0         true
   6 │ missing  c_minus6      c_minus8                 9.0        false

julia&gt; # using PhyloPlots; plot(bestnet, edgelabel=BSe[:,[:edge,:BS_hybrid_edge]]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/addHybrid.jl#L289-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.addHybridBetweenClades!-Tuple{HybridNetwork, Number, Number}" href="#PhyloNetworks.addHybridBetweenClades!-Tuple{HybridNetwork, Number, Number}"><code>PhyloNetworks.addHybridBetweenClades!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addHybridBetweenClades!(net::HybridNetwork, hybnum::Number, sisnum::Number)</code></pre><p>Modify <code>net</code> by adding a minor hybrid edge from &quot;donor&quot; to &quot;recipient&quot;, where &quot;donor&quot; is the major parent edge <code>e1</code> of node number <code>hybnum</code> and &quot;recipient&quot; is the major parent edge <code>e2</code> of node number <code>sisnum</code>. The new nodes are currently inserted at the middle of these parent edges.</p><p>If a hybrid edge from <code>e1</code> to <code>e2</code> would create a directed cycle in the network, then this hybrid cannot be added. In that case, the donor edge <code>e1</code> is moved up if its parent is a hybrid node, to ensure that the sister clade to the new hybrid would be a desired (the descendant taxa from <code>e1</code>) and a new attempt is made to create a hybrid edge.</p><p>Output: number of the new hybrid edge, or <code>nothing</code> if the desired hybridization is not possible.</p><p>See also: <a href="#PhyloNetworks.addhybridedge!"><code>addhybridedge!</code></a> (used by this method) and <a href="#PhyloNetworks.directionalconflict-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool}"><code>directionalconflict</code></a> to check that <code>net</code> would still be a DAG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/addHybrid.jl#L382-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.addhybridedge!" href="#PhyloNetworks.addhybridedge!"><code>PhyloNetworks.addhybridedge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addhybridedge!(
    net::HybridNetwork,
    edge1::Edge,
    edge2::Edge,
    hybridpartnernew::Bool,
    edgelength::Float64=-1.0,
    gamma::Float64=-1.0
)</code></pre><p>Add hybridization to <code>net</code> coming from <code>edge1</code> going into <code>edge2</code>. 2 new nodes and 3 new edges are created: <code>edge1</code> are <code>edge2</code> are both cut into 2 edges, and a new edge is created linking the 2 new &quot;middle&quot; nodes, pointing from <code>edge1</code> to <code>edge2</code>. The new node in the middle of <code>edge1</code> is a tree node. The new node in the middle of <code>edge2</code> is a hybrid node. Its parent edges are the newly created hybrid edge (with γ = gamma, missing by default), and either the newly edge &quot;above&quot; <code>edge2</code> if <code>hybridpartnernew=true</code>, or the old <code>edge2</code> otherwise (which would reverse the direction of <code>edge2</code> and others).</p><p>Should be called from the other method, which performs a bunch of checks. Updates <code>containroot</code> attributes for edges below the new hybrid node.</p><p>Output: new hybrid node (middle of the old <code>edge2</code>) and new hybrid edge.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;((S8,(((S1,(S5)#H1),(#H1,S6)))#H2),(#H2,S10));&quot;);

julia&gt; hybnode, hybedge = PhyloNetworks.addhybridedge!(net, net.edge[13], net.edge[8], true, 0.0, 0.2)
(PhyloNetworks.Node:
 number:9
 name:H3
 hybrid node
 attached to 3 edges, numbered: 8 16 17
, PhyloNetworks.EdgeT{PhyloNetworks.Node}:
 number:17
 length:0.0
 minor hybrid edge with gamma=0.2
 attached to 2 node(s) (parent first): 8 9
)


julia&gt; writenewick(net)
&quot;((S8,(((S1,(S5)#H1),((#H1,S6))#H3:::0.8))#H2),(#H2,(S10,#H3:0.0::0.2)));&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/addHybrid.jl#L141-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.addhybridedge!-Tuple{HybridNetwork, Bool, Vararg{Any}}" href="#PhyloNetworks.addhybridedge!-Tuple{HybridNetwork, Bool, Vararg{Any}}"><code>PhyloNetworks.addhybridedge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addhybridedge!(
    [rng::AbstractRNG,]
    net::HybridNetwork,
    nohybridladder::Bool,
    no3cycle::Bool,
    constraints::Vector{TopologyConstraint}=TopologyConstraint[];
    maxattempts::Int=10,
    fixroot::Bool=false
)</code></pre><p>Randomly choose two edges in <code>net</code> then: add hybrid edge from edge 1 to edge 2 of length 0.01. The two halves of edge 1 (and of edge 2) have equal lengths. The hybrid partner edge (top half of edge 2, if fixroot is true) will point towards the newly-created node on the middle of the original edge 2, and have an inheritance γ randomly uniformly chosen in (0,0.5).</p><p>If the resulting network is a DAG, satisfies the constraint(s), does not contain any 3-cycle (if <code>no3cycle=true</code>), and does not have a hybrid ladder (if <code>nohybridladder=true</code>) then the proposal is successful: <code>net</code> is modified, and the function returns the newly created hybrid node and newly created hybrid edge.</p><p>If the resulting network is not acceptable, then a new set of edges is proposed (using a blacklist) until one is found acceptable, or until a maximum number of attempts have been made (<code>maxattempts</code>). If none of the attempted proposals are successful, <code>nothing</code> is returned (without causing an error).</p><p>After a pair of edges is picked, the &quot;top&quot; half of edge2 is proposed as the partner hybrid edge with probability 0.8 if <code>fixroot</code> is false, (to avoid changing the direction of edge2 with more than 50% chance) and with probability 1.0 if <code>fixroot</code> is true. If this choice does not work and if <code>fixroot</code> is false, the other half of edge2 is proposed as the partner hybrid edge. Note that choosing the &quot;bottom&quot; half of edge2 as the partner edge requires to flip the direction of edge 2, and to move the root accordingly (to the original child of edge2).</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));&quot;);

julia&gt; using Random

julia&gt; Random.seed!(170);

julia&gt; PhyloNetworks.addhybridedge!(net, true, true)
(PhyloNetworks.Node:
 number:9
 name:H3
 hybrid node
 attached to 3 edges, numbered: 5 16 17
, PhyloNetworks.EdgeT{PhyloNetworks.Node}:
 number:17
 length:0.01
 minor hybrid edge with gamma=0.32771460911632916
 attached to 2 node(s) (parent first): 8 9
)

julia&gt; writenewick(net, round=true, digits=2)
&quot;((S1,(((#H1,S4),((S2,(S3)#H1))#H3:::0.67))#H2),((#H2,S5),#H3:0.01::0.33));&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/addHybrid.jl#L4-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.addindividuals!-Tuple{HybridNetwork, AbstractString, Vector{&lt;:AbstractString}}" href="#PhyloNetworks.addindividuals!-Tuple{HybridNetwork, AbstractString, Vector{&lt;:AbstractString}}"><code>PhyloNetworks.addindividuals!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addindividuals!(net::HybridNetwork, species::AbstractString, individuals::Vector)</code></pre><p>Add individuals to their species leaf as a star, and return the corresponding species constraint. <code>nothing</code> is returned in 2 cases:</p><ul><li>if <code>individuals</code> contains only 1 individual, in which case the name of the leaf for that species is replaced by the name of its one individual representative</li><li>if <code>species</code> is not found in the network</li></ul><p>Spaces in individuals&#39; names are eliminated, see <a href="#PhyloNetworks.cleantaxonname-Tuple{AbstractString}"><code>cleantaxonname</code></a>.</p><p>Called by <a href="#PhyloNetworks.mapindividuals-Tuple{HybridNetwork, String}"><code>mapindividuals</code></a>.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(S8,(((S1,S4),(S5)#H1),(#H1,S6)));&quot;);

julia&gt; PhyloNetworks.addindividuals!(net, &quot;S1&quot;, [&quot;S1A&quot;, &quot;S1B&quot;, &quot;S1C&quot;])
Species constraint, on tips: S1A, S1B, S1C
 stem edge number 2
 crown node number 2

julia&gt; writenewick(net) # 3 new nodes, S1 now internal: not a tip
&quot;(S8,((((S1A,S1B,S1C)S1,S4),(S5)#H1),(#H1,S6)));&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L827-L855">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.addleaf!" href="#PhyloNetworks.addleaf!"><code>PhyloNetworks.addleaf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addleaf!(net::HybridNetwork, node::Node, leafname::String, edgelength::Float64=-1.0)
addleaf!(net::HybridNetwork, edge::Edge, leafname::String, edgelength::Float64=-1.0)</code></pre><p>Add a new external edge between <code>node</code> or between the &quot;middle&quot; of <code>edge</code> and a newly-created leaf, of name <code>leafname</code>. By default, the new edge length is missing (-1).</p><p>output: newly created leaf node.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));&quot;);

julia&gt; net.node[6].name # leaf S4
&quot;S4&quot;

julia&gt; PhyloNetworks.addleaf!(net, net.node[6], &quot;4a&quot;); # adding leaf to a node

julia&gt; writenewick(net, internallabel=true)
&quot;((S1,(((S2,(S3)#H1),(#H1,(4a)S4)))#H2),(#H2,S5));&quot;

julia&gt; PhyloNetworks.addleaf!(net, net.node[6], &quot;4b&quot;);

julia&gt; writenewick(net, internallabel=true)
&quot;((S1,(((S2,(S3)#H1),(#H1,(4a,4b)S4)))#H2),(#H2,S5));&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;((S1,(((S2,(S3)#H1),(#H1,S4)))#H2),(#H2,S5));&quot;);

julia&gt; [n.name for n in net.edge[7].node] # external edge to S4
2-element Vector{String}:
 &quot;S4&quot;
 &quot;&quot;  

julia&gt; PhyloNetworks.addleaf!(net, net.edge[7], &quot;4a&quot;); # adding leaf to an edge

julia&gt; writenewick(net, internallabel=true)
&quot;((S1,(((S2,(S3)#H1),(#H1,(S4,4a))))#H2),(#H2,S5));&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L334-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.adjacentedges-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloNetworks.adjacentedges-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.adjacentedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjacentedges(centeredge::Edge)</code></pre><p>Vector of all edges that share a node with <code>centeredge</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1904-L1908">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.allowrootbelow!-Tuple{HybridNetwork}" href="#PhyloNetworks.allowrootbelow!-Tuple{HybridNetwork}"><code>PhyloNetworks.allowrootbelow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allowrootbelow!(net::HybridNetwork)</code></pre><p>Set <code>containroot</code> to <code>true</code> for each edge below the root node, then traverses <code>net</code> in preorder to update <code>containroot</code> of all edges (stopping at hybrid nodes): see the other methods. Assumes correct <code>ischild1</code> edge field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L1172-L1179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.allowrootbelow!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloNetworks.allowrootbelow!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.allowrootbelow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allowrootbelow!(e::Edge)
allowrootbelow!(n::Node, parent_edge_of_n::Edge)</code></pre><p>Set <code>containroot</code> to <code>true</code> for edge <code>e</code> and all edges below, recursively. The traversal stops whenever a hybrid node is encountered: if the child of <code>e</code> is a hybrid node (that is, if <code>e</code> is a hybrid edge) or if <code>n</code> is a hybrid node, then the edges below <code>e</code> or <code>n</code> are <em>not</em> traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L1149-L1157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}" href="#PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}"><code>PhyloNetworks.assignhybridnames!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assignhybridnames!(net)</code></pre><p>Assign names to hybrid nodes in the network <code>net</code>. Hybrid nodes with an empty <code>name</code> field (&quot;&quot;) are modified with a name that does not conflict with other hybrid names in the network. The preferred name is &quot;H3&quot; if the node number is 3 or -3, but an index other than 3 would be used if &quot;H3&quot; were the name of another node already.</p><p>If two hybrid nodes have non-empty and equal names, the name of one of them is changed and re-assigned as described above (with a warning).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1522-L1533">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.biconnectedcomponent_entrynodes" href="#PhyloNetworks.biconnectedcomponent_entrynodes"><code>PhyloNetworks.biconnectedcomponent_entrynodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">biconnectedcomponent_entrynodes(net, bcc, preorder=true)</code></pre><p>Array containing the entry node of the each biconnected component in <code>bcc</code>. <code>bcc</code> is supposed to contain the biconnected components as output by <a href="../public/#PhyloNetworks.biconnectedcomponents"><code>biconnectedcomponents</code></a>, that is, an array of array of edges.</p><p>These entry nodes depend on the rooting (whereas the BCC only depend on the unrooted graph). They are either the root of the network or cut node (articulation points).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/graph_components.jl#L113-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.biconnectedcomponent_exitnodes" href="#PhyloNetworks.biconnectedcomponent_exitnodes"><code>PhyloNetworks.biconnectedcomponent_exitnodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">biconnectedcomponent_exitnodes(net, bcc, preorder=true)</code></pre><p>Array containing an array of the exit node(s) of the each biconnected component in <code>bcc</code>. <code>bcc</code> is supposed to contain the biconnected components as output by <a href="../public/#PhyloNetworks.biconnectedcomponents"><code>biconnectedcomponents</code></a>, that is, an array of array of edges.</p><p>These exit nodes depend on the rooting (whereas the BCC only depend on the unrooted graph). The degree of a blob is the number of exit nodes + 1 if the blob doesn&#39;t contain the root (its entry node is a cut node), or + 0 if the blob contains the root (which enters into the blob but isn&#39;t a cut node).</p><p><em>Warning</em> (or positive side effect?): the edge <code>.inte1</code> attribute is modified. It stores the index (in <code>bcc</code>) of the biconnected component that an edge belongs to. If an edge doesn&#39;t belong in any (e.g. if trivial blobs are ignored), then its <code>.inte1</code> is set to -1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/graph_components.jl#L143-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.blobinfo" href="#PhyloNetworks.blobinfo"><code>PhyloNetworks.blobinfo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">blobinfo(network, ignoreTrivial=true)</code></pre><p>Calculate the biconnected components (blobs) using function <a href="../public/#PhyloNetworks.biconnectedcomponents"><code>biconnectedcomponents</code></a> then:</p><ul><li>set node field <code>booln4</code> to true at the root of each non-trivial blob (and at the network root), false otherwise. (a better name for the field would be something like &quot;isBlobRoot&quot;.)</li><li>output:<ol><li>array of nodes that are the roots of each non-trivial blob, and the network root. If the root of the full network is not part of a non-trivial blob, a corresponding blob is added to the list.</li><li>array of arrays: for each non-trivial blob, array of major hybrid edges in that blob.</li><li>array of arrays: same as #2 but for minor hybrid edges, with hybrids listed in the same order, for each blob.</li></ol></li></ul><p>Blobs are ordered in reverse topological ordering (aka post order). If <code>ignoreTrivial</code> is true, trivial components are ignored.</p><p>keyword argument: <code>checkpreorder</code>, true by default. If false, the <code>ischild1</code> edge field and the <code>net.vec_node</code> network field are supposed to be correct.</p><p><strong>warning</strong>: see <a href="../public/#PhyloNetworks.biconnectedcomponents"><code>biconnectedcomponents</code></a> for node attributes modified during the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/graph_components.jl#L188-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.breakedge!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, HybridNetwork}" href="#PhyloNetworks.breakedge!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, HybridNetwork}"><code>PhyloNetworks.breakedge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">breakedge!(edge::Edge, net::HybridNetwork)</code></pre><p>Break an edge into 2 edges, each of length half that of original edge, creating a new node of degree 2. Useful to root network along an edge. Return the new node and the new edge, which is the &quot;top&quot; half of the original starting edge. These new node &amp; edge are pushed last in <code>net.node</code> and <code>net.edge</code>.</p><p>If the starting edge was:</p><pre><code class="nohighlight hljs">n1  --edge--&gt;  n2</code></pre><p>then we get this:</p><pre><code class="nohighlight hljs">n1  --newedge--&gt;  newnode  --edge--&gt;  n2</code></pre><p><code>ischild1</code> and <code>containroot</code> are updated, but not internal fields (e.g. not those used by SNaQ for level-1 networks).</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((S8,S9),((((S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));&quot;);

julia&gt; length(net.node)
19

julia&gt; net.edge[4] # edge 4 goes from node -8 to 3
PhyloNetworks.EdgeT{PhyloNetworks.Node}:
 number:4
 length:-1.0
 attached to 2 node(s) (parent first): -8 3


julia&gt; newnode, newedge = PhyloNetworks.breakedge!(net.edge[4], net);

julia&gt; length(net.node) # one more than before
20

julia&gt; newedge # new edge 21 goes from node -8 and 11 (new)
PhyloNetworks.EdgeT{PhyloNetworks.Node}:
 number:21
 length:-1.0
 attached to 2 node(s) (parent first): -8 11


julia&gt; net.edge[4] # original edge 4 now goes from node 11 (new) to 3
PhyloNetworks.EdgeT{PhyloNetworks.Node}:
 number:4
 length:-1.0
 attached to 2 node(s) (parent first): 11 3


julia&gt; writenewick(net) # note extra pair of parentheses around S1
&quot;(((S8,S9),((((S4,(S1)),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));&quot;</code></pre><p>See also: <a href="#PhyloNetworks.fuseedgesat!"><code>fuseedgesat!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L134-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}" href="#PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}"><code>PhyloNetworks.checkNumHybEdges!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkNumHybEdges!(net)</code></pre><p>Check for consistency between hybrid-related attributes in the network:</p><ul><li>for each hybrid node: 2 or more hybrid edges</li><li>exception: allows for a leaf to be attached to a single hybrid edge</li><li>exactly 2 incoming parent hybrid edges</li></ul><p>Run after <code>storeHybrids!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L586-L594">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.check_nonmissing_nonnegative_edgelengths" href="#PhyloNetworks.check_nonmissing_nonnegative_edgelengths"><code>PhyloNetworks.check_nonmissing_nonnegative_edgelengths</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_nonmissing_nonnegative_edgelengths(net, str=&quot;&quot;)</code></pre><p>Throw an Exception if <code>net</code> has undefined edge lengths (coded as -1.0) or negative edge lengths. The error message indicates the number of the offending edge(s), followed by <code>str</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L916-L922">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.checkspeciesnetwork!-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}" href="#PhyloNetworks.checkspeciesnetwork!-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}"><code>PhyloNetworks.checkspeciesnetwork!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkspeciesnetwork!(network::HybridNetwork,
                     constraints::Vector{TopologyConstraint})</code></pre><p>Check that the network satisfies a number of requirements:</p><ul><li>no polytomies, other than at species constraints: throws an error otherwise</li><li>no unnecessary nodes: fuse edges at nodes with degree two, including at the root (hence the bang: <code>net</code> may be modified)</li><li>topology constraints are met.</li></ul><p>Output: true if all is good, false if one or more clades are violated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L745-L756">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.cleantaxonname-Tuple{AbstractString}" href="#PhyloNetworks.cleantaxonname-Tuple{AbstractString}"><code>PhyloNetworks.cleantaxonname</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cleantaxonname(taxonname::AbstractString)</code></pre><p>Return a String with leading and trailing spaces removed, and interior spaces replaced by underscores: good for using as tip names in a network without causing future error when reading the newick description of the network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L876-L882">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.constraintviolated-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}" href="#PhyloNetworks.constraintviolated-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}"><code>PhyloNetworks.constraintviolated</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constraintviolated(network::HybridNetwork,
                   constraints::Vector{TopologyConstraint})</code></pre><p>True if <code>network</code> violates one (or more) of the constraints of type 1 (individuals in a species group) or type 2 (must be clades in the major tree). Warning: constraints of type 3 are not implemented. See <a href="#PhyloNetworks.TopologyConstraint"><code>TopologyConstraint</code></a> for constraint types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L145-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.deleteEdge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloNetworks.deleteEdge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.deleteEdge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deleteEdge!(net::HybridNetwork,  e::Edge; part=true)</code></pre><p>Delete edge <code>e</code> from <code>net.edge</code> and update <code>net.numedges</code>. If <code>part</code> is true, update the network&#39;s partition field.</p><p><em>Warning</em>: if <code>part</code> is true (the default), then <code>net</code> is assumed to be of level-1, with valid internal fields <code>e.inte1</code> (to track which cycle <code>e</code> may be in) and valid <code>net.partition</code>, which then gets updated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L562-L571">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.deleteNode!-Tuple{HybridNetwork, PhyloNetworks.Node}" href="#PhyloNetworks.deleteNode!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>PhyloNetworks.deleteNode!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deleteNode!(net::HybridNetwork, n::Node)</code></pre><p>Delete node <code>n</code> from a network, i.e. removes it from net.node, and from net.hybrid or net.leaf as appropriate. Update attributes <code>numnodes</code>, <code>numtaxa</code>, <code>numhybrids</code>.</p><p>Warning: if the root is deleted, the new root is arbitrarily set to the first node in the list. This is intentional to save time because this function is used frequently in snaq!, which handles semi-directed (unrooted) networks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L529-L540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.deletehybridedge!" href="#PhyloNetworks.deletehybridedge!"><code>PhyloNetworks.deletehybridedge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deletehybridedge!(net::HybridNetwork, edge::Edge,
                  nofuse=false, unroot=false,
                  multgammas=false, simplify=true, keeporiginalroot=false)</code></pre><p>Delete a hybrid <code>edge</code> from <code>net</code> and return the network. The network does not have to be of level 1 and may contain polytomies, although each hybrid node must have exactly 2 parents. Branch lengths are updated, allowing for missing values.</p><p>If <code>nofuse</code> is false, when <code>edge</code> is removed, its child (hybrid) node is removed and its partner hybrid edge is removed. Its child edge is retained (below the hybrid node), fused with the former partner, with new length: old length + length of <code>edge</code>&#39;s old partner. Any 2-cycle is simplified into a single edge, unless <code>simplify</code> is false.</p><p>If <code>nofuse</code> is true, edges with descendant leaves are kept as is, and are not fused. Nodes are retained during edge removal, provided that they have at least one descendant leaf. The hybrid edge that is partner to <code>edge</code> becomes a tree edge, but has its γ value unchanged (it is not set to 1), since it is not merged with its child edge after removal of the reticulation.   Also, 2-cycles are not simplified if <code>nofuse</code> is true. That is, if we get 2 hybrid edges both from the same parent to the same child, these hybrid edges are retained without being fused into a single tree edge.</p><p>If <code>unroot</code> is false and if the root is up for deletion during the process, it will be kept if it&#39;s of degree 2 or more. A root node of degree 1 will be deleted unless <code>keeporiginalroot</code> is true.</p><p>If <code>multgammas</code> is true: inheritance weights are kept by multiplying together the inheritance γ&#39;s of edges that are merged. For example, if there is a hybrid ladder, the partner hybrid edge remains a hybrid edge (with a new partner), and its γ is the product of the two hybrid edges that have been fused. So it won&#39;t add up to 1 with its new partner&#39;s γ.</p><p>If <code>keeporiginalroot</code> is true, a root of degree one will not be deleted.</p><p>Warnings:</p><ul><li><code>containroot</code> is updated, but this requires correct <code>ischild1</code> fields</li><li>if the parent of <code>edge</code> is the root and if <code>nofuse</code> is false, the root is moved to keep the network unrooted with a root of degree two.</li><li>does <em>not</em> update attributes needed for snaq! (like inte1, edge.z, edge.y etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L837-L881">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.descendants" href="#PhyloNetworks.descendants"><code>PhyloNetworks.descendants</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">descendants(edge::Edge, internal::Bool=false)</code></pre><p>Return the node numbers of the descendants of a given edge: all descendant nodes if <code>internal</code> is true (internal nodes and tips), or descendant tips only otherwise (defaults).</p><p><code>edge</code> should belong in a rooted network for which <code>ischild1</code> is up-to-date. Run <code>directedges!</code> beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net5 = &quot;(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));&quot; |&gt; readnewick |&gt; directedges! ;

julia&gt; PhyloNetworks.descendants(net5.edge[12], true) # descendants of 12th edge: all of them
7-element Vector{Int64}:
 -6
 -7
  4
  6
  5
 -9
  7

julia&gt; PhyloNetworks.descendants(net5.edge[12]) # descendant leaves only
3-element Vector{Int64}:
 4
 5
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/compareNetworks.jl#L222-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.directionalconflict-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool}" href="#PhyloNetworks.directionalconflict-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool}"><code>PhyloNetworks.directionalconflict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">directionalconflict(parent::Node, edge::Edge, hybridpartnernew::Bool)</code></pre><p>Check if creating a hybrid edge down of <code>parent</code> node into the middle of <code>edge</code> would create a directed cycle in <code>net</code>, i.e. not a DAG. The proposed hybrid would go in the direction of <code>edge</code> down its child node if <code>hybridpartnernew</code> is true. Otherwise, both halves of <code>edge</code> would have their direction reversed, for the hybrid to go towards the original parent node of <code>edge</code>. Does <em>not</em> modify the network.</p><p>Output: <code>true</code> if a conflict would arise (non-DAG), <code>false</code> if no conflict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/addHybrid.jl#L261-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.displayednetworks!" href="#PhyloNetworks.displayednetworks!"><code>PhyloNetworks.displayednetworks!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">displayednetworks!(net::HybridNetwork, node::Node, keepNode=false,
                   unroot=false, multgammas=false, keeporiginalroot=false)</code></pre><p>Extracts the two networks that simplify a given network at a given hybrid node: deleting either one or the other parent hybrid edge. If <code>nofuse</code> is true, the original edges (and nodes) are kept in both networks, provided that they have one or more descendant leaves. If <code>unroot</code> is true, the root will be deleted if it becomes of degree 2. If <code>keeporiginalroot</code> is true, the root is retained even if it is of degree 1.</p><ul><li>the original network is modified: the minor edge removed.</li><li>returns one HybridNetwork object: the network with the major edge removed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/compareNetworks.jl#L515-L528">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.edgerelation-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloNetworks.edgerelation-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.edgerelation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edgerelation(e::Edge, node::Node, origin::Edge)</code></pre><p>Return a symbol:</p><ul><li><code>:origin</code> if <code>e</code> is equal to <code>origin</code>, and otherwise:</li><li><code>:parent</code> if <code>e</code> is a parent of <code>node</code>,</li><li><code>:child</code> if <code>e</code> is a child of <code>node</code></li></ul><p>using the <code>ischild1</code> attribute of edges. Useful when <code>e</code> iterates over all edges adjacent to <code>node</code> and when <code>origin</code> is one of the edges adjacent to <code>node</code>, to known the order in which these edges come.</p><p>example:</p><pre><code class="language-julia hljs">labs = [edgerelation(e, u, uv) for e in u.edge] # assuming u is a node of edge uv
parentindex = findfirst(isequal(:parent), labs) # could be &#39;nothing&#39; if no parent
childindices = findall( isequal(:child), labs)  # vector. could be empty</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L343-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.fliphybrid!" href="#PhyloNetworks.fliphybrid!"><code>PhyloNetworks.fliphybrid!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fliphybrid!(
    net::HybridNetwork,
    hybridnode::Node,
    minor::Bool=true,
    nohybridladder::Bool=false,
    constraints::Vector{TopologyConstraint}=TopologyConstraint[]
)</code></pre><p>Flip the direction of a single hybrid edge: the minor parent edge of <code>hybridnode</code> by default, or the major parent edge if <code>minor</code> is false. The parent node of the hybrid edge becomes the new hybrid node. The former hybrid edge partner is converted to a tree edge (with γ=1), and <code>hybridnode</code> becomes a tree node.</p><p>For the flip to be admissible, the new network must be a semi-directed phylogenetic network: with a root such that the rooted version is a DAG. If <code>nohybridladder</code> is false (default), the flip may create a hybrid ladder If <code>nohybridladder</code> is true and if the flip would create a hybrid ladder, then the flip is not admissible. A hybrid ladder is when a hybrid child of another hybrid.</p><p>The new hybrid partner is an edge adjacent to the new hybrid node, such that the flip is admissible (so it must be a tree edge). The flipped edge retains its original γ. The new hybrid edge is assigned inheritance 1-γ.</p><p>Output: <code>(newhybridnode, flippededge, oldchildedge)</code> if the flip is admissible, <code>nothing</code> otherwise.</p><p>The network is unchanged if the flip is not admissible. If the flip is admissible, the root position may be modified, and the direction of tree edges (via <code>ischild1</code>) is modified accordingly. If the root needs to be modified, then the new root is set to the old hybrid node.</p><p>The index of the new hybrid node in <code>net.hybrid</code> is equal to that of the old <code>hybridnode</code>.</p><p>Warning: Undoing this move may not recover the original root if the root position was modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L995-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.fliphybrid!-Tuple{HybridNetwork, Bool, Vararg{Any}}" href="#PhyloNetworks.fliphybrid!-Tuple{HybridNetwork, Bool, Vararg{Any}}"><code>PhyloNetworks.fliphybrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fliphybrid!(
    [rng::AbstractRNG,]
    net::HybridNetwork,
    minor::Bool,
    nohybridladder::Bool=false,
    constraints::Vector{TopologyConstraint}=TopologyConstraint[]
)</code></pre><p>Cycle through hybrid nodes in random order until an admissible flip is found. At this hybrid node, flip the indicated hybrid parent edge (minor or major).</p><p>If an admissible flip is found, return the tuple: newhybridnode, flippededge, oldchildedge. Otherwise, return nothing.</p><p>The flip can be undone with <code>fliphybrid!(net, newhybridnode, minor, constraints)</code>, or <code>fliphybrid!(net, newhybridnode, !flippededge.ismajor, constraints)</code> more generally, such as if the flipped edge had its γ modified after the original flip.</p><p><em>Warnings</em></p><ul><li>if the root needed to be reset and if the original root was of degree 2, then a node of degree 2 remains in the modified network.</li><li>undoing the flip may not recover the original root in case the root position was modified during the original flip.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L947-L973">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.fuseedgesat!" href="#PhyloNetworks.fuseedgesat!"><code>PhyloNetworks.fuseedgesat!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fuseedgesat!(i::Integer,net::HybridNetwork, multgammas::Bool=false)</code></pre><p>Removes <code>i</code>th node in net.node, if it is of degree 2. The parent and child edges of this node are fused. If either of the edges is hybrid, the hybrid edge is retained. Otherwise, the edge with the lower edge number is retained.</p><p>Reverts the action of <a href="#PhyloNetworks.breakedge!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, HybridNetwork}"><code>breakedge!</code></a>.</p><p>returns the fused edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L222-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.getTipSubmatrix-Tuple{Matrix, HybridNetwork}" href="#PhyloNetworks.getTipSubmatrix-Tuple{Matrix, HybridNetwork}"><code>PhyloNetworks.getTipSubmatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getTipSubmatrix(M, net; indexation=:both)</code></pre><p>Extract submatrix of M, with rows and/or columns corresponding to tips in the network, ordered like in <code>net.leaf</code>. In M, rows and/or columns are assumed ordered as in <code>net.vec_node</code>.</p><p>indexation: one of <code>:rows</code>, <code>:cols</code> or <code>:both</code>: are nodes numbers indexed in the matrix by rows, by columns, or both? Subsetting is taken accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/pairwiseDistanceLS.jl#L85-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.getconnectingedge-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}" href="#PhyloNetworks.getconnectingedge-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}"><code>PhyloNetworks.getconnectingedge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getconnectingedge(node1::Node, node2::Node)</code></pre><p>Edge shared by (or connecting) <code>node1</code> and <code>node2</code>, that is: edge incident to both nodes. An error is thrown if the 2 nodes are not connected.</p><p>See also <a href="#PhyloNetworks.isconnected-Tuple{Any, Any}"><code>isconnected</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L458-L465">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.getlengths-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}" href="#PhyloNetworks.getlengths-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}"><code>PhyloNetworks.getlengths</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getlengths(edges::Vector{Edge})</code></pre><p>Vector of edge lengths for a vector of <code>edges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1609-L1613">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.hardwiredclusterdistance_unrooted-Tuple{HybridNetwork, HybridNetwork}" href="#PhyloNetworks.hardwiredclusterdistance_unrooted-Tuple{HybridNetwork, HybridNetwork}"><code>PhyloNetworks.hardwiredclusterdistance_unrooted</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hardwiredclusterdistance_unrooted(net1::HybridNetwork, net2::HybridNetwork)</code></pre><p>Miminum hardwired cluster dissimilarity between the two networks, considered as unrooted (or semi-directed). This dissimilarity is defined as the minimum rooted distance, over all root positions that are compatible with the direction of hybrid edges. Called by <a href="../public/#PhyloNetworks.hardwiredclusterdistance-Tuple{HybridNetwork, HybridNetwork, Bool}"><code>hardwiredclusterdistance</code></a>.</p><p>To avoid repeating identical clusters, all degree-2 nodes are deleted before starting the comparison. Since rooting the network at a leaf creates a root node of degree 2 and an extra cluster, leaves are excluded from possible rooting positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/compareNetworks.jl#L868-L881">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.hashybridladder-Tuple{HybridNetwork}" href="#PhyloNetworks.hashybridladder-Tuple{HybridNetwork}"><code>PhyloNetworks.hashybridladder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hashybridladder(net::HybridNetwork)</code></pre><p>Return true if <code>net</code> contains a hybrid ladder: where a hybrid node&#39;s child is itself a hybrid node. This makes the network not treechild, assuming it is fully resolved. (One of the nodes does not have any tree-node child).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1616-L1623">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.hybrid3cycle-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloNetworks.hybrid3cycle-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.hybrid3cycle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hybrid3cycle(edge1::Edge, edge2::Edge)</code></pre><p>Check if proposed hybrid edge from <code>edge1</code> into <code>edge2</code> would create a 3 cycle, that is, if <code>edge1</code> and <code>edge2</code> have a node in common. (This move cannot create a 2-cycles because new nodes would be created in the middle of edges 1 and 2.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/addHybrid.jl#L249-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.hybridEdges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hybridEdges(node::Node, e::Edge)</code></pre><p>Return the 2 edges connected to <code>node</code> other than <code>e</code>, in the same order as <code>node.edge</code>, except that <code>e</code> absent from the list.</p><p>Despite what the name suggest, <code>node</code> need not be a hybrid node! <code>node</code> is assumed to have 3 edges, though.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L783-L792">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}" href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.hybridEdges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hybridEdges(node::Node)</code></pre><p>Return the 3 edges attached to <code>node</code> in a specific order [e1,e2,e3]. <strong>Warning</strong>: assume a level-1 network with up-to-date node fields <code>booln1</code> (tracking whether the node is incident to a hybrid edge and edge) and field <code>intn1</code> (tracking the number given to the cycle in which the node might be).</p><p>If <code>node</code> is a hybrid node:</p><ul><li>e1 is the major hybrid parent edge of <code>node</code></li><li>e2 is the minor hybrid parent edge</li><li>e3 is the tree edge, child of <code>node</code>.</li></ul><p>If <code>node</code> is a tree node parent of one child hybrid edge:</p><ul><li>e1 is the hybrid edge, child of <code>node</code></li><li>e2 is the tree edge that belongs to the cycle created by e1</li><li>e3 is the other tree edge attached to <code>node</code> (not in a cycle)</li></ul><p>Otherwise:</p><ul><li>e3 is an external edge from <code>node</code> to a leaf, if one exists.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L707-L731">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.inheritanceweight-Tuple{HybridNetwork}" href="#PhyloNetworks.inheritanceweight-Tuple{HybridNetwork}"><code>PhyloNetworks.inheritanceweight</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inheritanceweight(tree::HybridNetwork)</code></pre><p>Return the <em>log</em> inheritance weight of a network or tree (as provided by <a href="../public/#PhyloNetworks.displayedtrees-Tuple{HybridNetwork, Float64}"><code>displayedtrees</code></a> with <code>nofuse</code> = true for instance). For a tree displayed in a network, its inheritance weight is the log of the product of γ&#39;s of all edges retained in the tree. To avoid underflow, the log is calculated: i.e. sum of log(γ) across retained edges.</p><p>If any edge has a negative γ, it is assumed to mean that its γ is missing, and the function returns <code>missing</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;);

julia&gt; trees = displayedtrees(net,0.0; nofuse=true);

julia&gt; PhyloNetworks.inheritanceweight.(trees)
2-element Vector{Float64}:
 -0.105361
 -2.30259 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/compareNetworks.jl#L590-L614">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.initializeweightsfromleaves!-Tuple{AbstractArray, HybridNetwork, Any, Any, Symbol}" href="#PhyloNetworks.initializeweightsfromleaves!-Tuple{AbstractArray, HybridNetwork, Any, Any, Symbol}"><code>PhyloNetworks.initializeweightsfromleaves!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initializeweightsfromleaves!(w, net, tips, stateset, criterion)</code></pre><p>Modify weight in w: to Inf for w[n, i] if the &quot;tips&quot; data has a state different from the lineage state of index i at node number n. Assumes that w was initialized to 0 for the leaves.</p><p>criterion: should be one of <code>:softwired</code>, <code>:parental</code> or <code>:hardwired</code>.</p><ul><li>softwired parsimony: lineage states are in this order: ∅,{1},{2},{3},...,{nstates}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/parsimony.jl#L816-L825">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.initializeweightsfromleaves_softwired!-Tuple{AbstractArray, HybridNetwork, Any, Any}" href="#PhyloNetworks.initializeweightsfromleaves_softwired!-Tuple{AbstractArray, HybridNetwork, Any, Any}"><code>PhyloNetworks.initializeweightsfromleaves_softwired!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initializeweightsfromleaves_softwired!(w, net, tips, charset)</code></pre><p>Modify weight in w: to Inf for w[n, s] if the &quot;tips&quot; data has a state different from s at node number n. Assumes that w was initialized to 0 for the leaves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/parsimony.jl#L354-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.isconnected-Tuple{Any, Any}" href="#PhyloNetworks.isconnected-Tuple{Any, Any}"><code>PhyloNetworks.isconnected</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isconnected(node1::Node, node2::Node)</code></pre><p>Check if two nodes are connected by an edge. Return true if connected, false if not connected.</p><p>See also <a href="#PhyloNetworks.getconnectingedge-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}"><code>getconnectingedge</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L476-L483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.isdescendant-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}" href="#PhyloNetworks.isdescendant-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}"><code>PhyloNetworks.isdescendant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdescendant(des:Node, anc::Node)</code></pre><p>Return true if <code>des</code> is a strict descendant of <code>anc</code>, using <code>ischild1</code> fields to determine the direction of edges. See <a href="#PhyloNetworks.isdescendant_undirected-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>isdescendant_undirected</code></a> for a version that does not use <code>ischild1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/compareNetworks.jl#L278-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.isdescendant_undirected-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloNetworks.isdescendant_undirected-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.isdescendant_undirected</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdescendant_undirected(des:Node, ancestor::Node, parentedge)</code></pre><p>Return <code>true</code> if <code>des</code> is a strict descendant of <code>ancestor</code> when starting from edge <code>parentedge</code> and going towards <code>ancestor</code> onward, regardless of the field <code>ischild1</code> of tree edges; <code>false</code> otherwise.</p><p>This is useful to know how descendant relationships would change as a result of reverting the direction of a tree edge, without actually modifying the direction (<code>ischild1</code>) of any edge.</p><p><code>parentedge</code> should be connected to <code>ancestor</code> (not checked). The direction of hybrid edges is respected (via <code>ischild1</code>), that is, the traversal does not go from the child to the parent of a hybrid edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/compareNetworks.jl#L314-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.ladderpartition-Tuple{HybridNetwork}" href="#PhyloNetworks.ladderpartition-Tuple{HybridNetwork}"><code>PhyloNetworks.ladderpartition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ladderpartition(tree::HybridNetwork)</code></pre><p>For each node in <code>tree</code>, calculate the clade below each child edge of the node, and each clade moving up the &quot;ladder&quot; from the node to the root. The output is a tuple of 2 vectors (node) of vector (clade) of vectors (taxon in clade): <code>below,above</code>. More specifically, for node number <code>n</code>, <code>below[n]</code> is generally of vector of 2 clades: one for the left child and one for the right child of the node (unless the node is of degree 2 or is a polytomy). <code>above[n]</code> contains the grade of clades above node number <code>n</code>.</p><p>WARNING: assumes that</p><ol><li>node numbers and edge numbers can be used as indices, that is, be all distinct, positive, covering exactly 1:#nodes and 1:#edges.</li><li>edges are corrected directed (<code>ischild1</code> is up-to-date) and nodes have been pre-ordered already (field <code>vec_node</code> up-to-date).</li></ol><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tree = readnewick(&quot;(O,A,((B1,B2),(E,(C,D))));&quot;);

julia&gt; PhyloNetworks.resetnodenumbers!(tree; checkpreorder=true, type=:postorder)

julia&gt; printnodes(tree)
node leaf  hybrid name i_cycle edges&#39;numbers
1    true  false  O    -1      1   
2    true  false  A    -1      2   
3    true  false  B1   -1      3   
4    true  false  B2   -1      4   
8    false false       -1      3    4    5   
5    true  false  E    -1      6   
6    true  false  C    -1      7   
7    true  false  D    -1      8   
9    false false       -1      7    8    9   
10   false false       -1      6    9    10  
11   false false       -1      5    10   11  
12   false false       -1      1    2    11  

julia&gt; below, above = PhyloNetworks.ladderpartition(tree);

julia&gt; below
12-element Vector{Vector{Vector{Int64}}}:
 [[1]]                      
 [[2]]                      
 [[3]]                      
 [[4]]                      
 [[5]]                      
 [[6]]                      
 [[7]]                      
 [[3], [4]]                 
 [[6], [7]]                 
 [[5], [6, 7]]              
 [[3, 4], [5, 6, 7]]        
 [[1], [2], [3, 4, 5, 6, 7]]

julia&gt; for n in 8:12
         println(&quot;clades below node &quot;, n, &quot;: &quot;, join(below[n], &quot; &quot;))
       end
clades below node 8: [3] [4]
clades below node 9: [6] [7]
clades below node 10: [5] [6, 7]
clades below node 11: [3, 4] [5, 6, 7]
clades below node 12: [1] [2] [3, 4, 5, 6, 7]

julia&gt; above[8:12] # clades sister to and above nodes 8 through 12:
5-element Vector{Vector{Vector{Int64}}}:
 [[5, 6, 7], [1], [2]]
 [[5], [3, 4], [1], [2]]
 [[3, 4], [1], [2]]     
 [[1], [2]]             
 []                     </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/compareNetworks.jl#L353-L425">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.leaststableancestor" href="#PhyloNetworks.leaststableancestor"><code>PhyloNetworks.leaststableancestor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leaststableancestor(net, preorder=true)</code></pre><p>Return <code>(lsa, lsa_index)</code> where <code>lsa</code> is the least stable ancestor node (LSA) in <code>net</code>, and <code>lsa_index</code> is the index of <code>lsa</code> in <code>net.vec_node</code>. The LSA the lowest node <code>n</code> with the following property: <em>any</em> path between <em>any</em> leaf and the root must go through <code>n</code>. All such nodes with this property are ancestral to the LSA (and therefore must have an index that is lower or equal to <code>lsa_index</code>).</p><p>Exception: if the network has a single leaf, the output <code>lsa</code> is the leaf&#39;s parent node, to maintain one external edge between the root and the leaf.</p><p><em>Warning</em>: uses <a href="../public/#PhyloNetworks.biconnectedcomponents"><code>biconnectedcomponents</code></a> and <a href="#PhyloNetworks.biconnectedcomponent_exitnodes"><code>biconnectedcomponent_exitnodes</code></a>, therefore share the same caveats regarding the use of fields <code>.inte1</code> and <code>.intn1</code> (for edges and nodes), <code>.intn2</code> (for nodes) etc. As a positivie side effect, the biconnected components can be recovered via the edges&#39; <code>.inte1</code> field –including the trivial blobs (cut edges).</p><p>See also: <a href="../public/#PhyloNetworks.deleteaboveLSA!"><code>deleteaboveLSA!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/graph_components.jl#L308-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.majoredgelength-Tuple{HybridNetwork}" href="#PhyloNetworks.majoredgelength-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgelength</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">majoredgelength(net::HybridNetwork)</code></pre><p>Generate vector of edge lengths of major <code>net</code> edges organized in the same order as the <code>edge</code> matrix created via <code>majoredgematrix</code>. Considers values of <code>-1.0</code> as missing values, recognized as NA in <code>R</code>. Output: vector allowing for missing values.</p><p>Assume <code>vec_node</code> was updated, to list nodes in pre-order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((A:3.1,(B:0.2)#H1:0.3::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);&quot;);

julia&gt; directedges!(net); preorder!(net);

julia&gt; PhyloNetworks.majoredgelength(net)
8-element Vector{Union{Missing, Float64}}:
  missing
 0.7     
  missing
 1.1     
  missing
 3.1     
 0.3     
 0.2     </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/interop.jl#L60-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}" href="#PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgematrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">majoredgematrix(net::HybridNetwork)</code></pre><p>Matrix of major edges from <code>net</code> where edge[i,1] is the number of the parent node of edge i and edge[i,2] is the number of the child node of edge i. Assume <code>vec_node</code> was updated, to list nodes in pre-order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(A,(B,(C,D)));&quot;);

julia&gt; PhyloNetworks.resetnodenumbers!(net);

julia&gt; PhyloNetworks.majoredgematrix(net)
6×2 Matrix{Int64}:
 5  1
 5  6
 6  2
 6  7
 7  3
 7  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/interop.jl#L19-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.makemissing!-Tuple{AbstractVector}" href="#PhyloNetworks.makemissing!-Tuple{AbstractVector}"><code>PhyloNetworks.makemissing!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makemissing!(x::AbstractVector)</code></pre><p>Turn to <code>missing</code> any element of <code>x</code> exactly equal to -1.0. Used for branch lengths and γs. <code>x</code> needs to accept missing values. If not, this can be done with <code>allowmissing(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/interop.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.mapindividuals-Tuple{HybridNetwork, String}" href="#PhyloNetworks.mapindividuals-Tuple{HybridNetwork, String}"><code>PhyloNetworks.mapindividuals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapindividuals(net::HybridNetwork, mappingFile::String)</code></pre><p>Return a network expanded from <code>net</code>, where species listed in the mapping file are replaced by individuals mapped to that species. If a species has only 1 individual, the name of the leaf for that species is replaced by the name of its one individual representative. If a species has 2 or more individuals, the leaf for that species is expanded into a &quot;star&quot; (polytomy if 3 or more individuals) with a tip for each individual. If a species is in the network but not listed in the mapping file, the tip for that species is left as is. Species listed in the mapping file but not present in the network are ignored.</p><p>The mapping file should be readable by <code>CSV.File</code> and contain two columns: one for the species names and one for the individual (or allele) names. fixit: make this function more flexible by accepting column names</p><p>Output: individual-level network and vector of species constraint(s).</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; species_net = readnewick(&quot;(((S8,S9),((((S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));&quot;);

julia&gt; filename = joinpath(dirname(Base.find_package(&quot;PhyloNetworks&quot;)), &quot;..&quot;, &quot;examples&quot;, &quot;mappingIndividuals.csv&quot;);

julia&gt; filename |&gt; read |&gt; String |&gt; print # to see what the mapping file contains
species,individual
S1,S1A
S1,S1B
S1,S1C

julia&gt; individual_net, species_constraints = PhyloNetworks.mapindividuals(species_net, filename);

julia&gt; writenewick(individual_net, internallabel=true)
&quot;(((S8,S9),(((((S1A,S1B,S1C)S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));&quot;

julia&gt; species_constraints
1-element Vector{PhyloNetworks.TopologyConstraint}:
 Species constraint, on tips: S1A, S1B, S1C
 stem edge number 4
 crown node number 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L769-L812">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.maxParsimonyNet-Tuple{HybridNetwork, DataFrames.DataFrame}" href="#PhyloNetworks.maxParsimonyNet-Tuple{HybridNetwork, DataFrames.DataFrame}"><code>PhyloNetworks.maxParsimonyNet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maxParsimonyNet(T::HybridNetwork, df::DataFrame)</code></pre><div class="admonition is-warning"><header class="admonition-header">feature to be re-implemented</header><div class="admonition-body"><p>This function has been disabled. It will be re-implemented, without the level-1 restriction. Please use version 0.16 of PhyloNetworks to access this older functionality, until a better one is made available.</p></div></div><p>Search for the most parsimonious network (or tree). A level-1 network is assumed. <code>df</code> should be a data frame containing the species names in column 1, or in a column named <code>species</code> or <code>taxon</code>. Trait data are assumed to be in all other columns. The search starts from topology <code>T</code>, which can be a tree or a network with no more than <code>hmax</code> hybrid nodes (see optional arguments below for <code>hmax</code>).</p><p>Output:</p><ul><li>estimated network in file <code>.out</code> (also in <code>.log</code>): best network overall and list of networks from each individual run.</li><li>if any error occurred, file <code>.err</code> provides information (seed) to reproduce the error.</li></ul><p>Optional arguments include</p><ul><li>hmax: maximum number of hybridizations allowed (default 1)</li><li>runs: number of starting points for the search (default 10); each starting point is <code>T</code> with probability <code>probST</code>=0.3 or a modification of <code>T</code> otherwise (using a NNI move, or a hybrid edge direction change)</li><li>Nfail: number of failures (proposed networks with equal or worse score) before the search is aborted. 75 by default: this is quite small, which is okay for a first trial. Larger values are recommended.</li><li>outgroup: outgroup taxon.           It can be a taxon name (String) or Node number (Integer).           If none provided, or if the outgroup conflicts the starting           topology, the function returns an error</li><li>filename: root name for the output files. Default is &quot;mp&quot;. If empty (&quot;&quot;), files are <em>not</em> created, progress log goes to the screen only (standard out).</li><li>seed: seed to replicate a given search</li><li>criterion: parsimony score could be hardwired, softwired (default) or parental. Currently,            only softwired is implemented</li></ul><p><strong>References</strong></p><ol><li><p>Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).</p></li><li><p>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/parsimony.jl#L1167-L1220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}" href="#PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationgamma</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minorreticulationgamma(net::HybridNetwork)</code></pre><p>Vector of minor edge gammas (inheritance probabilities) organized in the same order as in the matrix created via <code>minorreticulationmatrix</code>. Considers values of <code>-1.0</code> as missing values, recognized as NA in <code>R</code>. Output: vector allowing for missing values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;);

julia&gt; PhyloNetworks.minorreticulationgamma(net)
1-element Vector{Union{Float64, Missings.Missing}}:
 0.1</code></pre><pre><code class="nohighlight hljs"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/interop.jl#L167-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}" href="#PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationlength</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minorreticulationlength(net::HybridNetwork)</code></pre><p>Vector of lengths for the minor hybrid edges, organized in the same order as in the matrix created via <code>minorreticulationmatrix</code>. Replace values of <code>-1.0</code> with missing values recognized by <code>R</code>. Output: vector allowing for missing values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((A:3.1,(B:0.2)#H1:0.4::0.9),(C,#H1:0.3::0.1):1.1),D:0.7);&quot;);

julia&gt; PhyloNetworks.minorreticulationlength(net)
1-element Vector{Union{Missing, Float64}}:
 0.3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/interop.jl#L138-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}" href="#PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationmatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minorreticulationmatrix(net::HybridNetwork)</code></pre><p>Matrix of integers, representing the minor hybrid edges in <code>net</code>. edge[i,1] is the number of the parent node of the ith minor hybrid edge, and edge[i,2] is the number of its child node. Node numbers may be negative, unless they were modified by <code>resetnodenumbers!</code>. Assumes correct <code>ischild1</code> fields.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;);
julia&gt; PhyloNetworks.minorreticulationmatrix(net)
1×2 Matrix{Int64}:
 -6  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/interop.jl#L107-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.moveroot!-Tuple{HybridNetwork, Vararg{Any}}" href="#PhyloNetworks.moveroot!-Tuple{HybridNetwork, Vararg{Any}}"><code>PhyloNetworks.moveroot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moveroot!(
    [rng::AbstractRNG,]
    net::HybridNetwork,
    constraints::Vector{TopologyConstraint}=TopologyConstraint[]
)</code></pre><p>Move the root to a randomly chosen non-leaf node that is different from the current root, and not within a constraint clade or species. Output: <code>true</code> if successul, <code>nothing</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L894-L904">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.nj!" href="#PhyloNetworks.nj!"><code>PhyloNetworks.nj!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nj!(D::Matrix{Float64}, names::AbstractVector{&lt;:AbstractString}=String[];
    force_nonnegative_edges::Bool=false)</code></pre><p>Construct a phylogenetic tree from the input distance matrix and vector of names (as strings), using the Neighbour-Joinging algorithm (<a href="https://doi.org/10.1093/oxfordjournals.molbev.a040454">Satou &amp; Nei 1987</a>). The order of the <code>names</code> argument should match that of the row (and column) of the matrix <code>D</code>. With <code>force_nonnegative_edges</code> being <code>true</code>, any negative edge length is changed to 0.0 (with a message).</p><p>Warning: <code>D</code> is modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/nj.jl#L12-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.nnimax-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloNetworks.nnimax-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.nnimax</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nnimax(e::Edge)</code></pre><p>Return the number of NNI moves around edge <code>e</code>, assuming that the network is semi-directed. Return 0 if <code>e</code> is not internal, and more generally if either node attached to <code>e</code> does not have 3 edges.</p><p>Output: UInt8 (e.g. <code>0x02</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L377-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.norootbelow!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloNetworks.norootbelow!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.norootbelow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norootbelow!(e::Edge)</code></pre><p>Set <code>containroot</code> to <code>false</code> for edge <code>e</code> and all edges below, recursively. The traversal stops if <code>e.containroot</code> is already <code>false</code>, assuming that <code>containroot</code> is already false all the way below down that edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L1129-L1135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.pairwisetaxondistance_gradient-Tuple{HybridNetwork}" href="#PhyloNetworks.pairwisetaxondistance_gradient-Tuple{HybridNetwork}"><code>PhyloNetworks.pairwisetaxondistance_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pairwisetaxondistance_gradient(net; checkEdgeNumber=true, nodeAges=[])</code></pre><p>3-dim array: gradient of pairwise distances between all nodes. (internal and leaves); gradient with respect to edge lengths if <code>nodeAges</code> is empty; with respect to node ages otherwise. Assume correct <code>net.vec_node</code> (preorder).   This gradient depends on the network&#39;s topology and γ&#39;s only, not on branch lengths or node ages (distances are linear in either).</p><p>WARNING: edge numbers need to range between 1 and #edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/pairwiseDistanceLS.jl#L161-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.parsenewick_edgedata!-Tuple{IO, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{Int64}}" href="#PhyloNetworks.parsenewick_edgedata!-Tuple{IO, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{Int64}}"><code>PhyloNetworks.parsenewick_edgedata!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parsenewick_edgedata!(s::IO, edge, numberOfLeftParentheses::Array{Int,1})</code></pre><p>Helper function for readnewick_subtree!. Modifies <code>e</code> according to the specified edge length and gamma values in the tree topology. Advances the stream <code>s</code> past any existing edge data. Edges in a topology may optionally be followed by &quot;:edgeLen:bootstrap:gamma&quot; where edgeLen, bootstrap, and gamma are decimal values. Nexus-style comments <code>[&amp;...]</code>, if any, are ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L317-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.parsenewick_getfloat!-Tuple{IO, Int64, Vector{Int64}}" href="#PhyloNetworks.parsenewick_getfloat!-Tuple{IO, Int64, Vector{Int64}}"><code>PhyloNetworks.parsenewick_getfloat!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parsenewick_getfloat!(s::IO, int, numLeft::Array{Int,1})</code></pre><p>Helper function for <code>parsenewick_edgedata!</code>. Read a single floating point edge data value in a tree topology. Ignore (and skip) nexus-style comments before &amp; after the value (see <a href="#PhyloNetworks.readnexus_comment-Tuple{IO, Char}"><code>readnexus_comment</code></a>).</p><p>Return -1.0 if no value exists before the next colon, return the value as a float otherwise. Modifies s by advancing past the next colon character. Only call this function to read a value when you know a numerical value exists!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L278-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.parsenewick_hybridnode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, String, HybridNetwork, Vector{String}}" href="#PhyloNetworks.parsenewick_hybridnode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, String, HybridNetwork, Vector{String}}"><code>PhyloNetworks.parsenewick_hybridnode!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parsenewick_hybridnode!(node, parentNode, hybridName, net, hybrids)</code></pre><p>Helper function for <code>readnewick_subtree!</code>. Create the parent edge for <code>node</code>. Return this edge, and the hybrid node retained (<code>node</code> or its clone in the newick string). Insert new edge and appropriate node into <code>net</code> and <code>hybrids</code> accordingly. Handles any type of given hybrid node. Called after a <code>#</code> has been found in a tree topology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L178-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.parsenewick_remainingsubtree!-Tuple{IO, Vector{Int64}, HybridNetwork, Vector{String}}" href="#PhyloNetworks.parsenewick_remainingsubtree!-Tuple{IO, Vector{Int64}, HybridNetwork, Vector{String}}"><code>PhyloNetworks.parsenewick_remainingsubtree!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parsenewick_remainingsubtree!(s::IO, numLeft, net, hybrids)</code></pre><p>Create internal node. Helper for <a href="#PhyloNetworks.readnewick_subtree!-Tuple{IO, PhyloNetworks.Node, Vector{Int64}, HybridNetwork, Vector{String}}"><code>readnewick_subtree!</code></a>, which creates the parent edge of the node created by <code>parsenewick_remainingsubtree!</code>: <code>readnewick_subtree!</code> calls <code>parsenewick_remainingsubtree!</code>, and vice versa. Called once a <code>(</code> has been read in a tree topology and reads until the corresponding <code>)</code> has been found. This function performs the recursive step for <code>readnewick_subtree!</code>. Advances <code>s</code> past the subtree, adds discovered nodes and edges to <code>net</code>, and <code>hybrids</code>.</p><p>Does <em>not</em> read the node name and the edge information of the subtree root: this is done by <a href="#PhyloNetworks.readnewick_subtree!-Tuple{IO, PhyloNetworks.Node, Vector{Int64}, HybridNetwork, Vector{String}}"><code>readnewick_subtree!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L145-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.parsenewick_treenode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, HybridNetwork}" href="#PhyloNetworks.parsenewick_treenode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, HybridNetwork}"><code>PhyloNetworks.parsenewick_treenode!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parsenewick_treenode!(node, parentNode, net)</code></pre><p>Helper function for <code>readnewick_subtree!</code>. Insert the input tree node and associated edge (created here) into <code>net</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L262-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.parsimonyGF_bottomup!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, Vararg{AbstractArray, 4}}" href="#PhyloNetworks.parsimonyGF_bottomup!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, Vararg{AbstractArray, 4}}"><code>PhyloNetworks.parsimonyGF_bottomup!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parsimonyGF_bottomup!(node, blobroot, nchar, w, scores,
                     costmatrix1, costmatrix2)</code></pre><p>Compute the MP scores (one for each assignment of the blob root state) given the descendants of a blob, conditional on the states at predefined parents of hybrids in the blobs (one parent per hybrid) as described in</p><p>Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).</p><p>Assumes a set of state <em>guesses</em>, ie correct initialization of <code>w</code> for predefined hybrid parents, and correct <code>boole2</code> field for the children edges of these predefined parents. <code>boole2</code> is true for edges that are cut.</p><p>The field <code>booln4</code> is used to know which nodes are at the root of a blob. The field <code>ischild1</code> is used (and assumed correct). Field <code>intn1</code> is assumed to store the # of detached parents (with guessed states)</p><ul><li><code>nchar</code>: number of characters considered at internal lineages. For softwired parsimony, this is # states + 1, because characters at internal nodes are ∅, {1}, {2}, etc. For parental parsimony, this is 2^#states -1, because characters are all sets on {1,2,...} except for the empty set ∅.</li><li><code>costmatrix1</code>[i,j] and <code>costmatrix2</code>[k][i,j]: 2d array and vector of 2d arrays containing the cost of going to character j starting from character i when the end node has a single parent, or the cost of a child node having character j when its parents have characters k and i. These cost matrices are pre-computed depending on the parsimony criterion (softwired, hardwired, parental etc.)</li></ul><p>used by <a href="../public/#PhyloNetworks.parsimonyGF-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}, Tuple{HybridNetwork, Dict{String, T}, Symbol}} where T"><code>parsimonyGF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/parsimony.jl#L855-L889">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.parsimonyfitch-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T" href="#PhyloNetworks.parsimonyfitch-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T"><code>PhyloNetworks.parsimonyfitch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parsimonyfitch(net, tipdata)</code></pre><p>Calculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network. Tip data can be given in a data frame, in which case the taxon names are to appear in column 1 or in a column named &quot;taxon&quot; or &quot;species&quot;, and trait values are to appear in column 2 or in a column named &quot;trait&quot;. Alternatively, tip data can be given as a dictionary taxon =&gt; trait.</p><p>also return the union of all optimized character states at each internal node as obtained by Fitch algorithm, where the union is taken over displayed trees with the MP score.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/parsimony.jl#L82-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.parsimonyfitch_bottomup!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}, Vector{Int64}}} where T" href="#PhyloNetworks.parsimonyfitch_bottomup!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}, Vector{Int64}}} where T"><code>PhyloNetworks.parsimonyfitch_bottomup!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parsimonyfitch_bottomup!(node, states, score)</code></pre><p>Bottom-up phase (from tips to root) of the Fitch algorithm: assign sets of character states to internal nodes based on character states at tips. Polytomies okay. Assumes a <em>tree</em> (no reticulation) and correct ischild1 attribute.</p><p>output: dictionary with state sets and most parsimonious score</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/parsimony.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.parsimonyfitch_summary-Union{Tuple{T}, Tuple{HybridNetwork, Dict{Int64, Set{T}}}} where T" href="#PhyloNetworks.parsimonyfitch_summary-Union{Tuple{T}, Tuple{HybridNetwork, Dict{Int64, Set{T}}}} where T"><code>PhyloNetworks.parsimonyfitch_summary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parsimonyfitch_summary(tree, nodestates)</code></pre><p>summarize character states at nodes, assuming a <em>tree</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/parsimony.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.parsimonyfitch_topdown!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}}} where T" href="#PhyloNetworks.parsimonyfitch_topdown!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}}} where T"><code>PhyloNetworks.parsimonyfitch_topdown!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parsimonyfitch_topdown!(node, states)</code></pre><p>Top-down phase (root to tips) of the Fitch algorithm: constrains character states at internal nodes based on the state of the root. Assumes a <em>tree</em>: no reticulation.</p><p>output: dictionary with state sets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/parsimony.jl#L42-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.parsimonysoftwired_bottomup!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, AbstractArray, AbstractArray}" href="#PhyloNetworks.parsimonysoftwired_bottomup!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, AbstractArray, AbstractArray}"><code>PhyloNetworks.parsimonysoftwired_bottomup!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parsimonysoftwired_bottomup!(node, blobroot, states, w, scores)</code></pre><p>Computing the MP scores (one for each assignment of the root state) of a swicthing as described in Algorithm 1 in the following paper:</p><p>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</p><p>Assumes a <em>switching</em> (ie correct <code>boole2</code> field) and correct ischild1 field. The field <code>booln4</code> is used to know which nodes are at the root of a blob.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/parsimony.jl#L160-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.postorder_nodeupdate!" href="#PhyloNetworks.postorder_nodeupdate!"><code>PhyloNetworks.postorder_nodeupdate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">traversal_postorder(nodes, init_function,
    tip_function, internalnode_function, parameters...)
postorder_nodeupdate!(node_index, nodes, output_array,
    tip_function, internalnode_function, parameters...)</code></pre><p>Generic tool to apply a post-order (or reverse topological ordering) algorithm, acting on a matrix where rows &amp; columns correspond to nodes. Used by <a href="../public/#PhyloNetworks.descendencematrix-Tuple{HybridNetwork}"><code>descendencematrix</code></a>.</p><p>output: matrix <code>output_array</code>.</p><p>arguments:</p><ul><li><code>nodes</code>: array of nodes in the network, pre-ordered, typically the internal <code>net.vec_node</code> after applying <code>preorder!(net)</code>. This array is traversed in reverse order.</li><li><code>output_array</code>: output object, of type <code>Matrix</code>, named <code>V</code> below</li><li><code>init_function</code>: to initialize the output array, taking <code>(nodes, parameters...)</code> as arguments</li><li><code>tip_function</code>: to do whatever needs to be done to <code>V</code> at a leaf node, using <code>(V, tip_index, parameters...)</code> as arguments</li><li><code>internalnode_function</code>: to do whatever needs to be done to <code>V</code> at an internal node, using arguments <code>(V, node_index, childnodes_index_vector, childedges_vector, parameters...)</code></li></ul><p>The last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.</p><p>See also <a href="#PhyloNetworks.traversal_preorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Function, Vararg{Any}}"><code>traversal_preorder</code></a>, and <a href="#PhyloNetworks.traversalupdate_default!-Tuple{AbstractArray, Int64, Vararg{Any}}"><code>traversalupdate_default!</code></a> for a default function that does nothing to <code>V</code> and returns true, with an adequate signature to be used here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/recursion_routines.jl#L112-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.preorder_nodeupdate!" href="#PhyloNetworks.preorder_nodeupdate!"><code>PhyloNetworks.preorder_nodeupdate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">traversal_preorder(nodes, init_function, root_function, tree_node_function,
                  hybrid_node_function, parameters...)
traversal_preorder!(nodes, output_array, root_function, tree_node_function,
                   hybrid_node_function, parameters...)
preorder_nodeupdate!(node_index, nodes, output_array, root_function, tree_node_function,
               hybrid_node_function, parameters...)</code></pre><p>Generic tool to apply a pre-order (or topological ordering) algorithm. Used by <code>sharedpathmatrix</code> and by <code>pairwisetaxondistancematrix</code>, for example. <code>preorder_nodeupdate!</code> is a helper that calls the root / tree node / hybrid node function as appropriate.</p><p>output: array object <code>output_array</code>.</p><p>arguments:</p><ul><li><code>nodes</code>: array of nodes in the network, pre-ordered, typically the internal <code>net.vec_node</code> after applying <code>preorder!(net)</code></li><li><code>output_array</code>: output object, of type <code>AbstractArray</code>, named <code>V</code> below</li><li><code>init_function</code>: to initialize the output array, taking <code>(nodes, parameters...)</code> as arguments</li><li><code>root_function</code>: to do whatever needs to be done to <code>V</code> at the root, using <code>(V, rootnode_index, parameters...)</code> as arguments</li><li><code>tree_node_function</code>: to do whatever needs to be done to <code>V</code> at a tree node, using <code>(V, treenode_index, parentnode_index, parentedge, parameters...)</code> as arguments</li><li><code>hybrid_node_function</code>: to do whatever needs to be done to <code>V</code> at a hybrid node, using arguments <code>(V, hybnode_index, parentnodes_index_vector, parentedges_vector, parameters...)</code></li></ul><p>The last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.</p><p>See also <a href="#PhyloNetworks.traversal_postorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Vararg{Any}}"><code>traversal_postorder</code></a>, and <a href="#PhyloNetworks.traversalupdate_default!-Tuple{AbstractArray, Int64, Vararg{Any}}"><code>traversalupdate_default!</code></a> for a default function that does nothing to <code>V</code> and returns true, with an adequate signature to be used here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/recursion_routines.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.problem4cycle-NTuple{4, PhyloNetworks.Node}" href="#PhyloNetworks.problem4cycle-NTuple{4, PhyloNetworks.Node}"><code>PhyloNetworks.problem4cycle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">problem4cycle(β::Node, δ::Node, α::Node, γ::Node)</code></pre><p>Check if the focus edge uv has a 4 cycle that could lead to a 3 cycle after an chosen NNI. Return true if there is a problem 4 cycle, false if none.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L735-L740">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.readcsvtoarray-Tuple{DataFrames.DataFrame}" href="#PhyloNetworks.readcsvtoarray-Tuple{DataFrames.DataFrame}"><code>PhyloNetworks.readcsvtoarray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readcsvtoarray(dat::DataFrame)
readcsvtoarray(filename::String)</code></pre><p>Read a CSV table containing both species names and data, create two separate arrays: one for the species names, a second for the data, in a format that <a href="../public/#PhyloNetworks.parsimonyGF-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}, Tuple{HybridNetwork, Dict{String, T}, Symbol}} where T"><code>parsimonyGF</code></a> needs.</p><p>Warning:</p><ul><li>it will try to find a column &#39;taxon&#39; or &#39;species&#39; for the taxon names. If none found, it will assume the taxon names are in column 1.</li><li>will use all other columns as characters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/parsimony.jl#L472-L484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.readfastatoarray" href="#PhyloNetworks.readfastatoarray"><code>PhyloNetworks.readfastatoarray</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readfastatoarray(filename::AbstractString, sequencetype=BioSequences.LongDNA{4})</code></pre><p>Read a fasta-formatted file. Return a tuple <code>species, sequences</code> where <code>species</code> is a vector of Strings with identifier names, and <code>sequences</code> is a vector of BioSequences, each of type <code>sequencetype</code> (DNA by default).</p><p><strong>Warnings</strong>:</p><ul><li>assumes a <em>semi-sequential</em> format, <em>not interleaved</em>. More specifically, each taxon name should appear only once. For this one time, the corresponding sequence may be broken across several lines though.</li><li>fails if all sequences aren&#39;t of the same length</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/parsimony.jl#L381-L394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.readnewick_nodename-Tuple{IO, Char, HybridNetwork, Vector{Int64}}" href="#PhyloNetworks.readnewick_nodename-Tuple{IO, Char, HybridNetwork, Vector{Int64}}"><code>PhyloNetworks.readnewick_nodename</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readnewick_nodename(s::IO, c::Char, net, numLeft)</code></pre><p>Auxiliary function to read a taxon name during newick parsing. output: tuple (number, name, pound_boolean)</p><p>Names may have numbers: numbers are treated as strings. Accepts <code>#</code> as part of the name (but excludes it from the name), in which case <code>pound_boolean</code> is true. <code>#</code> is used in extended newick to flag hybrid nodes.</p><p>Nexus-style comments following the node name, if any, are read and ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L71-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.readnewick_subtree!-Tuple{IO, PhyloNetworks.Node, Vector{Int64}, HybridNetwork, Vector{String}}" href="#PhyloNetworks.readnewick_subtree!-Tuple{IO, PhyloNetworks.Node, Vector{Int64}, HybridNetwork, Vector{String}}"><code>PhyloNetworks.readnewick_subtree!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readnewick_subtree!(s::IO, parentNode, numLeft, net, hybrids)</code></pre><p>Recursive helper method for <code>readnewick</code>: read a subtree from an extended Newick topology. input <code>s</code>: IOStream/IOBuffer.</p><p>Reads additional info formatted as: <code>:length:bootstrap:gamma</code>. Allows for name of internal nodes without # after closing parenthesis: (1,2)A. Warning if hybrid edge without γ, or if γ (ignored) without hybrid edge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L422-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.readnexus_assigngammas!-Tuple{HybridNetwork, Dict}" href="#PhyloNetworks.readnexus_assigngammas!-Tuple{HybridNetwork, Dict}"><code>PhyloNetworks.readnexus_assigngammas!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readnexus_assigngammas!(net, d::Dict)</code></pre><p>Assign d[i] as the <code>.gamma</code> value of the minor parent edge of hybrid &quot;Hi&quot;, if this hybrid node name is found, and if its minor parent doesn&#39;t already have a non-missing γ. See <a href="#PhyloNetworks.readnexus_extractgamma-Tuple{Any}"><code>readnexus_extractgamma</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L1110-L1116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.readnexus_comment-Tuple{IO, Char}" href="#PhyloNetworks.readnexus_comment-Tuple{IO, Char}"><code>PhyloNetworks.readnexus_comment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readnexus_comment(s::IO, c::Char)</code></pre><p>Read (and do nothing with) nexus-style comments: <code>[&amp; ... ]</code>   Assumption: &#39;c&#39; is the next character to be read from s.   Output: nothing.</p><p>Comments can appear after (or instead of) a node or leaf name, before or after an edge length, and after another comment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L47-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.readnexus_extractgamma-Tuple{Any}" href="#PhyloNetworks.readnexus_extractgamma-Tuple{Any}"><code>PhyloNetworks.readnexus_extractgamma</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readnexus_extractgamma(nexus_string)</code></pre><p>Extract γ from comments and return a dictionary hybrid number ID =&gt; γ, from one single phylogeny given as a string. The output from BEAST2 uses this format for reticulations at <em>minor</em> edges, as output by bacter (<a href="http://dx.doi.org/10.1534/genetics.116.193425">Vaughan et al. 2017</a>):</p><pre><code class="nohighlight hljs">#11[&amp;conv=0, relSize=0.08, ...</code></pre><p>or as output by SpeciesNetwork (<a href="https://doi.org/10.1093/molbev/msx307">Zhang et al. 2018</a>):</p><pre><code class="nohighlight hljs">#H11[&amp;gamma=0.08]</code></pre><p>The function below assumes that the &quot;H&quot; was already added back if not present already (from bacter), like this:</p><pre><code class="nohighlight hljs">#H11[&amp;conv=0, relSize=0.19, ...</code></pre><p>The bacter format is tried first. If this format doesn&#39;t give any match, then the SpeciesNetwork format is tried next.   See <a href="#PhyloNetworks.readnexus_assigngammas!-Tuple{HybridNetwork, Dict}"><code>readnexus_assigngammas!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L1071-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.readnexus_translatetable-Tuple{Any}" href="#PhyloNetworks.readnexus_translatetable-Tuple{Any}"><code>PhyloNetworks.readnexus_translatetable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readnexus_translatetable(io)</code></pre><p>Read translate table from IO object <code>io</code>, whose first non-empty line should contain &quot;translate&quot;. Then each line should have &quot;number name&quot; and the end of the table is indicated by a ;. Output tuple:</p><ul><li>line that was last read, and is not part of the translate table, taken from <code>io</code></li><li>translate: boolean, whether a table was successfully read</li><li>id2name: dictionary mapping number to name.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L1018-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network, PhyloNetworks.Node}" href="#PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network, PhyloNetworks.Node}"><code>PhyloNetworks.removeHybrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">removeHybrid!(net::Network, n::Node)</code></pre><p>Delete a hybrid node <code>n</code> from <code>net.hybrid</code>, and update <code>net.numHybrid</code>. The actual node <code>n</code> is not deleted. It is kept in the full list <code>net.node</code>. Very internal function, used by <a href="#PhyloNetworks.deletehybridedge!"><code>deletehybridedge!</code></a> and others.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L586-L592">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.remove_edgelengthsgammas!-Tuple{HybridNetwork}" href="#PhyloNetworks.remove_edgelengthsgammas!-Tuple{HybridNetwork}"><code>PhyloNetworks.remove_edgelengthsgammas!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_edgelengthsgammas!(net::HybridNetwork)</code></pre><p>Reset all edge lengths and all hybrid edge γs to be missing (coded as -1.0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L902-L906">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.resetedgenumbers!" href="#PhyloNetworks.resetedgenumbers!"><code>PhyloNetworks.resetedgenumbers!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resetedgenumbers!(net::HybridNetwork, verbose=true)</code></pre><p>Check that edge numbers of <code>net</code> are consecutive numbers from 1 to the total number of edges. If not, reset the edge numbers to be so.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L1107-L1112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.resetnodenumbers!-Tuple{HybridNetwork}" href="#PhyloNetworks.resetnodenumbers!-Tuple{HybridNetwork}"><code>PhyloNetworks.resetnodenumbers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resetnodenumbers!(net::HybridNetwork; checkpreorder=true, type=:ape)</code></pre><p>Change internal node numbers of <code>net</code> to consecutive numbers from 1 to the total number of nodes.</p><p>keyword arguments:</p><ul><li><code>type</code>: default is <code>:ape</code>, to get numbers that satisfy the conditions assumed by the <code>ape</code> R package: leaves are 1 to n, the root is n+1, and internal nodes are higher consecutive integers. If <code>:postorder</code>, nodes are numbered in post-order, with leaves from 1 to n (and the root last). If <code>:internalonly</code>, leaves are unchanged. Only internal nodes are modified, to take consecutive numbers from (max leaf number)+1 and up. With this last option, the post-ordering of nodes is by-passed.</li><li><code>checkpreorder</code>: if false, the <code>ischild1</code> edge field and the <code>net.vec_node</code> network field are supposed to be correct (to get nodes in preorder). This is not needed when <code>type=:internalonly</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(A,(B,(C,D)));&quot;);

julia&gt; PhyloNetworks.resetnodenumbers!(net)

julia&gt; printnodes(net) # first column &quot;node&quot;: root is 5
node leaf  hybrid name i_cycle edges&#39;numbers
1    true  false  A    -1      1   
2    true  false  B    -1      2   
3    true  false  C    -1      3   
4    true  false  D    -1      4   
7    false false       -1      3    4    5   
6    false false       -1      2    5    6   
5    false false       -1      1    6   

julia&gt; net = readnewick(&quot;(A,(B,(C,D)));&quot;);

julia&gt; PhyloNetworks.resetnodenumbers!(net; type=:postorder)

julia&gt; printnodes(net) # first column &quot;node&quot;: root is 7
node leaf  hybrid name i_cycle edges&#39;numbers
1    true  false  A    -1      1   
2    true  false  B    -1      2   
3    true  false  C    -1      3   
4    true  false  D    -1      4   
5    false false       -1      3    4    5   
6    false false       -1      2    5    6   
7    false false       -1      1    6   </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L1021-L1071">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.resolvetreepolytomy!" href="#PhyloNetworks.resolvetreepolytomy!"><code>PhyloNetworks.resolvetreepolytomy!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resolvetreepolytomy!(net::HybridNetwork, n::Node, e1::Edge, e2::Edge)</code></pre><p>Create new node <code>v</code> and new edge <code>n --&gt; v</code>, detach edges <code>e1</code> and <code>e2</code> from <code>n</code> to connect them to <code>v</code> instead. Return the new edge, whose child is <code>v</code>.</p><p>Warning: assumes that <code>n</code> is incident to both <code>e1</code> and <code>e2</code>. It is best if these edges are originally children of <code>n</code> because the new edge is directed from <code>n</code> to the newly created node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L635-L644">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.resolvetreepolytomy!-Tuple{HybridNetwork, PhyloNetworks.Node}" href="#PhyloNetworks.resolvetreepolytomy!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>PhyloNetworks.resolvetreepolytomy!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resolvetreepolytomy!(net::HybridNetwork, n::Node)</code></pre><p>Create new nodes and edges from a tree node <code>n</code>, until it has degree 3. It is best if the network&#39;s tree edges are correctly directed beforehand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L673-L678">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.rezip_canonical!-Tuple{Vector{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}" href="#PhyloNetworks.rezip_canonical!-Tuple{Vector{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}"><code>PhyloNetworks.rezip_canonical!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rezip_canonical!(hybridnodes::Vector{Node}, childedges::Vector{Edge},
                 originallengths::Vector{Float64})</code></pre><p>Undo <a href="#PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}"><code>unzip_canonical!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L1262-L1267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.samplebootstrap_multiloci-Tuple{Vector{Vector{HybridNetwork}}}" href="#PhyloNetworks.samplebootstrap_multiloci-Tuple{Vector{Vector{HybridNetwork}}}"><code>PhyloNetworks.samplebootstrap_multiloci</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">samplebootstrap_multiloci(vector of tree lists; seed=0, generesampling=false, row=0)
samplebootstrap_multiloci!(tree list, vector of tree lists; seed=0, generesampling=false, row=0)</code></pre><p>Sample bootstrap gene trees, 1 tree per gene. Set the seed with keyword argument <code>seed</code>, which is 0 by default. When <code>seed=0</code>, the actual seed is set using the clock. Assumes a vector of vectors of networks (see <code>readmultinewick_files</code>), each one of length 1 or more (error if one vector is empty, tested in <code>bootsnaq</code>).</p><ul><li>site resampling: always, from sampling one bootstrap tree from each given list. This tree is sampled at <strong>random</strong> unless <code>row&gt;0</code> (see below).</li><li>gene resampling: if <code>generesampling=true</code> (default is false), genes (i.e. lists) are sampled with replacement.</li><li><code>row=i</code>: samples the ith bootstrap tree for each gene. <code>row</code> is turned back to 0 if gene resampling is true.</li></ul><p>output: one vector of trees. the modifying function (!) modifies the input tree list and returns it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/bootstrap.jl#L32-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.setmultiplegammas!-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}" href="#PhyloNetworks.setmultiplegammas!-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}"><code>PhyloNetworks.setmultiplegammas!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setmultiplegammas!(edges::Vector{Edge}, γs::Vector{Float64})</code></pre><p>Set the inheritance of the ith edge to the ith γ value, calling <a href="../public/#PhyloNetworks.setgamma!"><code>setgamma!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L890-L895">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.shrink2cycleat!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool}" href="#PhyloNetworks.shrink2cycleat!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool}"><code>PhyloNetworks.shrink2cycleat!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shrink2cycleat!(net::HybridNetwork, minor::Edge, major::Edge, unroot::Bool)</code></pre><p>Remove <code>minor</code> edge then update the branch length of the remaining <code>major</code> edge. Called by <a href="../public/#PhyloNetworks.shrink2cycles!"><code>shrink2cycles!</code></a></p><p>Assumption: <code>minor</code> and <code>major</code> do form a 2-cycle. That is, they start and end at the same node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1728-L1736">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.shrink3cycleat!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.Node, Bool}" href="#PhyloNetworks.shrink3cycleat!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.Node, Bool}"><code>PhyloNetworks.shrink3cycleat!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shrink3cycleat!(net::HybridNetwork, hybrid::Node, edge1::Edge, edge2::Edge,
                node1::Node, node2::Node, unroot::Bool)</code></pre><p>Replace a 3-cycle at a given <code>hybrid</code> node by a single node, if any. Assumption: <code>edge1</code> (<code>node1</code>) and <code>edge2</code> (<code>node2</code>) are the parent edges (nodes) of <code>hybrid</code>. Return true if a 3-cycle is found and removed, false otherwise. There is a 3-cycle if nodes 1 &amp; 2 are connected, by an edge called <code>e3</code> below.</p><p>There are two cases, with differing effects on the γ inheritance values and branch lengths.</p><p><strong>Hybrid case</strong>: the 3-cycle is shrunk to a hybrid node, which occurs if either node 1 or 2 is a hybrid node (that is, e3 is hybrid). If e3 goes from node 1 to node 2, the 3-cycle (left) is shrunk as on the right:</p><pre><code class="nohighlight hljs">\eA      /eB           \eA  /eB
 1--e3-&gt;2       γ1+γ2γ3 \  / γ2(1-γ3)
  \    /               hybrid
 γ1\  /γ2
  hybrid</code></pre><p>with new branch lengths: new tA = tA + (γ1.t1 + γ2γ3.(t2+t3))/(γ1+γ2γ3), new tB = tB + t2, provided that γ1, γ2=1-γ1, and γ3 are not missing. If one of them is missing then γ1 and γ2 remain as is, and e3 is deleted naively, such that new tA = tA + t1 and new tB = tB + t2. If γ&#39;s are not missing but one of t1,t2,t3 is missing, then the γ&#39;s are updated to γ1+γ2γ3 and γ2(1-γ3), but t&#39;s are update naively.</p><p><strong>Tree case</strong>: the 3-cycle is shrunk to a tree node, which occurs if node 1 &amp; 2 are both tree nodes (that is, e3 is a tree edge). If eC is the child edge of <code>hybrid</code>, the 3-cycle (left) is shrunk as on the right:</p><pre><code class="nohighlight hljs">\eA                  \eA
 1--e3--2--eB--       \
  \    /               n--eB--
 γ1\  /γ2              |
  hybrid               |eC
    |
    |eC</code></pre><p>with new branch lengths: new tA = tA + γ2.t3, new tB = tB + γ1.t3, new tC = tC + γ1.t1 + γ2.t2, provided that γ1, γ2=1-γ1, t1, t2 and t3 are not missing. If one is missing, then e1 is deleted naively such that tB is unchanged, new tC = tC + t2 and new tA = tA + t3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1793-L1843">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.shrinkedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloNetworks.shrinkedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.shrinkedge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shrinkedge!(net::HybridNetwork, edge::Edge)</code></pre><p>Delete <code>edge</code> from net, provided that it is a non-external tree edge. Specifically: delete its child node (as determined by <code>ischild1</code>) and connect all edges formerly incident to this child node to the parent node of <code>edge</code>, thus creating a new polytomy, unless the child was of degree 2.</p><p>Warning: it&#39;s best for <code>ischild1</code> to be in sync with the root for this. If not, the shrinking may fail (if <code>edge</code> is a tree edge but its &quot;child&quot; is a hybrid) or the root may change arbitrarily (if the child of <code>edge</code> is the root).</p><p>Output: true if the remaining node (parent of <code>edge</code>) becomes a hybrid node with more than 1 child after the shrinking; false otherwise (e.g. no polytomy was created, or the new polytomy is below a tree node)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1633-L1648">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.startingBL!" href="#PhyloNetworks.startingBL!"><code>PhyloNetworks.startingBL!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">startingBL!(net::HybridNetwork,
            trait::AbstractVector{Vector{Union{Missings.Missing,Int}}},
            siteweight::AbstractVector{Float64}=ones(length(trait[1])))</code></pre><p>Calibrate branch lengths in <code>net</code> by minimizing the mean squared error between the JC-adjusted pairwise distance between taxa, and network-predicted pairwise distances, using <a href="../public/#PhyloNetworks.calibratefrompairwisedistances!-Tuple{HybridNetwork, Matrix{Float64}, Vector{&lt;:AbstractString}}"><code>calibratefrompairwisedistances!</code></a>. The network is <em>not</em> forced to be time-consistent nor ultrametric. To avoid one source of non-identifiability, the network is &quot;zipped&quot; by forcing minor hybrid edges to have length 0.</p><p><code>siteweight[k]</code> gives the weight of site (or site pattern) <code>k</code> (default: all 1s).</p><p>Assumptions:</p><ul><li>all species have the same number of traits (sites): <code>length(trait[i])</code> constant</li><li><code>trait[i]</code> is for leaf with <code>node.number = i</code> in <code>net</code>, and <code>trait[i][j] = k</code> means that leaf number <code>i</code> has state index <code>k</code> for trait <code>j</code>. These indices are those used in a substitution model (see <code>PhyloTraits.jl</code>): kth value of <code>getlabels(model)</code>.</li></ul><p>Other:</p><ul><li>Hamming distances are calculated for each pair, ignoring any site in which one of 2 values is missing. The total number of differences is then divided by the total weight of all sites, ignoring that some of them may have been missing for the pair. This is an inexact rescaling of the hamming distance, assuming a small proportion of missing values for each pair.</li><li>Theoretically, Hamming distances are &lt; 0.75 with four states, or &lt; (n-1)/n for n states. If not, all pairwise hamming distances are scaled by <code>.75/(m*1.01)</code> where <code>m</code> is the maximum observed hamming distance, to make them all &lt; 0.75. The JC correction calculates: d<em>JC = - 0.75 log(1-d</em>hamming/0.75) for n=4 states</li><li>At the end, any edge length smaller than 1.0e-10 is reset to 0.0001, to avoid the 0 boundary.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/pairwiseDistanceLS.jl#L465-L500">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.startree_newick" href="#PhyloNetworks.startree_newick"><code>PhyloNetworks.startree_newick</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">startree_newick(n, l)</code></pre><p>String for the Newick parenthetical description of the star tree with <code>n</code> tips, and all branch lengths equal to <code>l</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/generate_topology.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.symmetricnet_newick" href="#PhyloNetworks.symmetricnet_newick"><code>PhyloNetworks.symmetricnet_newick</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetricnet_newick(n::Int, h::Int, γ::Real)</code></pre><p>Create a string for a symmetric network with 2^n tips, numbered from 1 to 2^n, with a symmetric major tree, whose branch lengths are all equal. 2^(n-h) hybrids are added from level h to h-1 &quot;symmetrically&quot;. The network is time-consistent and ultrametric, with a total height of 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/generate_topology.jl#L68-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.symmetricnet_newick-Tuple{Int64, Int64, Int64, Real, Real}" href="#PhyloNetworks.symmetricnet_newick-Tuple{Int64, Int64, Int64, Real, Real}"><code>PhyloNetworks.symmetricnet_newick</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetricnet_newick(n::Int, i::Int, j::Int, γ::Real, l::Real)</code></pre><p>Newick string for a network with a symmetric major tree with 2^n tips, numbered from 1 to 2^n. All the branch lengths of the major tree are set to <code>l</code>. One hybrid branch, going from level i to level j is added, cutting in half each initial edge in the tree. The new edge has length <code>l</code> and inheritance <code>γ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/generate_topology.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.symmetrictree_newick" href="#PhyloNetworks.symmetrictree_newick"><code>PhyloNetworks.symmetrictree_newick</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetrictree_newick(n::Int, ell::Real, i=1)</code></pre><p>String for the Newick parenthetical description of a symmetric tree with 2^n tips, numbered from i to i+2^n-1. All branch lengths are set equal to <code>ell</code>. The tree can be created later by reading the string with <a href="../public/#PhyloNetworks.readnewick-Tuple{AbstractString}"><code>readnewick</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/generate_topology.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.synchronizepartnersdata!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node}" href="#PhyloNetworks.synchronizepartnersdata!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node}"><code>PhyloNetworks.synchronizepartnersdata!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">synchronizepartnersdata!(e::Edge, n::Node)</code></pre><p>Synchronize γ and ismajor for edges <code>e</code> and its partner, both hybrid edges with the same child <code>n</code>:</p><ul><li>if one γ is missing and the other is not: set the missing γ to 1 - the other</li><li>γ&#39;s should sum up to 1.0</li><li>update <code>ismajor</code> to match the γ information: the major edge is the one with γ &gt; 0.5.</li></ul><p><strong>Warnings</strong>: does not check that <code>e</code> is a hybrid edge, nor that <code>n</code> is the child of <code>e</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/readwrite.jl#L346-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.timeinconsistency_average-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Ref{Bool}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}} where T&lt;:Real" href="#PhyloNetworks.timeinconsistency_average-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Ref{Bool}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}} where T&lt;:Real"><code>PhyloNetworks.timeinconsistency_average</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timeinconsistency_average(
    candidate_nodeheights,
    missingparent_heights,
    isconsistent::Ref{Bool},
    parent_edges,
    nonmissingparent_j;
    atol::Real=1e-8, rtol::Real=√eps(Float64))</code></pre><p>Calculate the γ-weighted average node height of a given hybrid node <code>h</code>, based on the candidate node heights from its parents with non-missing edge lengths.</p><ul><li>If some of these parent edges have a missing γ, then equal weights are used and a warning is issued.</li><li>If the hybrid node&#39;s average height (calculate from non-missing lengths) turns out to be lower than one of the parent&#39;s height with a missing length (such that this parent edge would need to be assigned a negative value) then a warning is issued.</li></ul><p>Outcome:</p><ul><li>update <code>isconsistent</code> to false if the candidate node heights are not all equal or if some missing edge length would have to be assigned a negative value to make the network time-consistent</li><li>returns <code>(true, nodeheight)</code></li></ul><p>Assumption: <code>candidate_nodeheight</code> is not empty, that is, the node has at least one parent edge with a non-missing length.</p><p>See also <a href="#PhyloNetworks._getnodeheights"><code>_getnodeheights</code></a> and <a href="../public/#PhyloNetworks.getnodeheights_average"><code>getnodeheights_average</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1325-L1353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.timeinconsistency_check" href="#PhyloNetworks.timeinconsistency_check"><code>PhyloNetworks.timeinconsistency_check</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timeinconsistency_error(
    candidate_nodeheights,
    missingparent_heights,
    args...;
    atol::Real=1e-8, rtol::Real=√eps(Float64))
timeinconsistency_check</code></pre><p>Check that all candidate node heights are approximately equal to one another, and that this shared value <code>nodeheight</code> is higher (farther from the root) than the height of parents connected by edge of missing length <code>missingparent_heights</code> to ensure that these edge lengths would be assigned non-negative values.</p><p>If any of these conditions is not met, <code>timeinconsistency_error</code> throws an error. Otherwise, it returns <code>(true, nodeheight)</code> where <code>true</code> means that the network is (or could be) time-consistent at the node being considered. <code>timeinconsistency_check</code> returns <code>(is_timeconsistent, nodeheight)</code> but does <em>not</em> throw an error the <code>is_timeconsistent</code> if false (for either reason).</p><p>Assumption: <code>candidate_nodeheight</code> is not empty, that is, the node has at least one parent edge with a non-missing length.</p><p>See also <a href="#PhyloNetworks._getnodeheights"><code>_getnodeheights</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1264-L1287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.timeinconsistency_error-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Vararg{Any}}} where T&lt;:Real" href="#PhyloNetworks.timeinconsistency_error-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Vararg{Any}}} where T&lt;:Real"><code>PhyloNetworks.timeinconsistency_error</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timeinconsistency_error(
    candidate_nodeheights,
    missingparent_heights,
    args...;
    atol::Real=1e-8, rtol::Real=√eps(Float64))
timeinconsistency_check</code></pre><p>Check that all candidate node heights are approximately equal to one another, and that this shared value <code>nodeheight</code> is higher (farther from the root) than the height of parents connected by edge of missing length <code>missingparent_heights</code> to ensure that these edge lengths would be assigned non-negative values.</p><p>If any of these conditions is not met, <code>timeinconsistency_error</code> throws an error. Otherwise, it returns <code>(true, nodeheight)</code> where <code>true</code> means that the network is (or could be) time-consistent at the node being considered. <code>timeinconsistency_check</code> returns <code>(is_timeconsistent, nodeheight)</code> but does <em>not</em> throw an error the <code>is_timeconsistent</code> if false (for either reason).</p><p>Assumption: <code>candidate_nodeheight</code> is not empty, that is, the node has at least one parent edge with a non-missing length.</p><p>See also <a href="#PhyloNetworks._getnodeheights"><code>_getnodeheights</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1264-L1287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.timeinconsistency_majortree-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Ref{Bool}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}} where T&lt;:Real" href="#PhyloNetworks.timeinconsistency_majortree-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Ref{Bool}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}} where T&lt;:Real"><code>PhyloNetworks.timeinconsistency_majortree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timeinconsistency_majortree(
    candidate_nodeheights,
    missingparent_heights,
    isconsistent::Ref{Bool},
    parent_edges,
    nonmissingparent_j;
    atol::Real=1e-8, rtol::Real=√eps(Float64))</code></pre><p>Calculate node height of a given hybrid node <code>h</code>, based on the its major parent node height, if its major parent edge has a non-missing length. If missing, then the non-missing edge length with the largest γ is used and a warning is issued. If all parent edges have missing γ values then an error is thrown.</p><p>Outcome:</p><ul><li>update <code>isconsistent</code> to false if the candidate node heights are not all equal or if some missing edge length would have to be assigned a negative value to make the network time-consistent</li><li>returns <code>(true, nodeheight)</code></li></ul><p>Assumption: <code>candidate_nodeheight</code> is not empty, that is, the node has at least one parent edge with a non-missing length.</p><p>See also <a href="#PhyloNetworks._getnodeheights"><code>_getnodeheights</code></a> and <a href="../public/#PhyloNetworks.getnodeheights_average"><code>getnodeheights_average</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/auxiliary.jl#L1390-L1414">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.traversal_postorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Vararg{Any}}" href="#PhyloNetworks.traversal_postorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Vararg{Any}}"><code>PhyloNetworks.traversal_postorder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">traversal_postorder(nodes, init_function,
    tip_function, internalnode_function, parameters...)
postorder_nodeupdate!(node_index, nodes, output_array,
    tip_function, internalnode_function, parameters...)</code></pre><p>Generic tool to apply a post-order (or reverse topological ordering) algorithm, acting on a matrix where rows &amp; columns correspond to nodes. Used by <a href="../public/#PhyloNetworks.descendencematrix-Tuple{HybridNetwork}"><code>descendencematrix</code></a>.</p><p>output: matrix <code>output_array</code>.</p><p>arguments:</p><ul><li><code>nodes</code>: array of nodes in the network, pre-ordered, typically the internal <code>net.vec_node</code> after applying <code>preorder!(net)</code>. This array is traversed in reverse order.</li><li><code>output_array</code>: output object, of type <code>Matrix</code>, named <code>V</code> below</li><li><code>init_function</code>: to initialize the output array, taking <code>(nodes, parameters...)</code> as arguments</li><li><code>tip_function</code>: to do whatever needs to be done to <code>V</code> at a leaf node, using <code>(V, tip_index, parameters...)</code> as arguments</li><li><code>internalnode_function</code>: to do whatever needs to be done to <code>V</code> at an internal node, using arguments <code>(V, node_index, childnodes_index_vector, childedges_vector, parameters...)</code></li></ul><p>The last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.</p><p>See also <a href="#PhyloNetworks.traversal_preorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Function, Vararg{Any}}"><code>traversal_preorder</code></a>, and <a href="#PhyloNetworks.traversalupdate_default!-Tuple{AbstractArray, Int64, Vararg{Any}}"><code>traversalupdate_default!</code></a> for a default function that does nothing to <code>V</code> and returns true, with an adequate signature to be used here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/recursion_routines.jl#L112-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.traversal_preorder!" href="#PhyloNetworks.traversal_preorder!"><code>PhyloNetworks.traversal_preorder!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">traversal_preorder(nodes, init_function, root_function, tree_node_function,
                  hybrid_node_function, parameters...)
traversal_preorder!(nodes, output_array, root_function, tree_node_function,
                   hybrid_node_function, parameters...)
preorder_nodeupdate!(node_index, nodes, output_array, root_function, tree_node_function,
               hybrid_node_function, parameters...)</code></pre><p>Generic tool to apply a pre-order (or topological ordering) algorithm. Used by <code>sharedpathmatrix</code> and by <code>pairwisetaxondistancematrix</code>, for example. <code>preorder_nodeupdate!</code> is a helper that calls the root / tree node / hybrid node function as appropriate.</p><p>output: array object <code>output_array</code>.</p><p>arguments:</p><ul><li><code>nodes</code>: array of nodes in the network, pre-ordered, typically the internal <code>net.vec_node</code> after applying <code>preorder!(net)</code></li><li><code>output_array</code>: output object, of type <code>AbstractArray</code>, named <code>V</code> below</li><li><code>init_function</code>: to initialize the output array, taking <code>(nodes, parameters...)</code> as arguments</li><li><code>root_function</code>: to do whatever needs to be done to <code>V</code> at the root, using <code>(V, rootnode_index, parameters...)</code> as arguments</li><li><code>tree_node_function</code>: to do whatever needs to be done to <code>V</code> at a tree node, using <code>(V, treenode_index, parentnode_index, parentedge, parameters...)</code> as arguments</li><li><code>hybrid_node_function</code>: to do whatever needs to be done to <code>V</code> at a hybrid node, using arguments <code>(V, hybnode_index, parentnodes_index_vector, parentedges_vector, parameters...)</code></li></ul><p>The last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.</p><p>See also <a href="#PhyloNetworks.traversal_postorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Vararg{Any}}"><code>traversal_postorder</code></a>, and <a href="#PhyloNetworks.traversalupdate_default!-Tuple{AbstractArray, Int64, Vararg{Any}}"><code>traversalupdate_default!</code></a> for a default function that does nothing to <code>V</code> and returns true, with an adequate signature to be used here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/recursion_routines.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.traversal_preorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Function, Vararg{Any}}" href="#PhyloNetworks.traversal_preorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Function, Vararg{Any}}"><code>PhyloNetworks.traversal_preorder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">traversal_preorder(nodes, init_function, root_function, tree_node_function,
                  hybrid_node_function, parameters...)
traversal_preorder!(nodes, output_array, root_function, tree_node_function,
                   hybrid_node_function, parameters...)
preorder_nodeupdate!(node_index, nodes, output_array, root_function, tree_node_function,
               hybrid_node_function, parameters...)</code></pre><p>Generic tool to apply a pre-order (or topological ordering) algorithm. Used by <code>sharedpathmatrix</code> and by <code>pairwisetaxondistancematrix</code>, for example. <code>preorder_nodeupdate!</code> is a helper that calls the root / tree node / hybrid node function as appropriate.</p><p>output: array object <code>output_array</code>.</p><p>arguments:</p><ul><li><code>nodes</code>: array of nodes in the network, pre-ordered, typically the internal <code>net.vec_node</code> after applying <code>preorder!(net)</code></li><li><code>output_array</code>: output object, of type <code>AbstractArray</code>, named <code>V</code> below</li><li><code>init_function</code>: to initialize the output array, taking <code>(nodes, parameters...)</code> as arguments</li><li><code>root_function</code>: to do whatever needs to be done to <code>V</code> at the root, using <code>(V, rootnode_index, parameters...)</code> as arguments</li><li><code>tree_node_function</code>: to do whatever needs to be done to <code>V</code> at a tree node, using <code>(V, treenode_index, parentnode_index, parentedge, parameters...)</code> as arguments</li><li><code>hybrid_node_function</code>: to do whatever needs to be done to <code>V</code> at a hybrid node, using arguments <code>(V, hybnode_index, parentnodes_index_vector, parentedges_vector, parameters...)</code></li></ul><p>The last 3 functions should return a boolean. If true: traversal continues. If false: traversal is stopped, that is, the next node is not processed.</p><p>See also <a href="#PhyloNetworks.traversal_postorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Vararg{Any}}"><code>traversal_postorder</code></a>, and <a href="#PhyloNetworks.traversalupdate_default!-Tuple{AbstractArray, Int64, Vararg{Any}}"><code>traversalupdate_default!</code></a> for a default function that does nothing to <code>V</code> and returns true, with an adequate signature to be used here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/recursion_routines.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.traversalupdate_default!-Tuple{AbstractArray, Int64, Vararg{Any}}" href="#PhyloNetworks.traversalupdate_default!-Tuple{AbstractArray, Int64, Vararg{Any}}"><code>PhyloNetworks.traversalupdate_default!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">traversalupdate_default!(::AbstractArray, ::Int, args...)</code></pre><p>Returns <code>true</code>. With its signature, this function can be used as a default update function at any node (root/tree/hybrid) in <a href="#PhyloNetworks.traversal_preorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Function, Vararg{Any}}"><code>traversal_preorder</code></a> or <a href="#PhyloNetworks.traversal_postorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Vararg{Any}}"><code>traversal_postorder</code></a>, if we need a function that does nothing and keeps the traversal going.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/recursion_routines.jl#L100-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}" href="#PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}"><code>PhyloNetworks.unzip_canonical!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unzip_canonical!(net::HybridNetwork)</code></pre><p>Unzip all reticulations: set the length of child edge to 0, and increase the length of both parent edges by the original child edge&#39;s length, to obtain the canonical version of the network according to Pardi &amp; Scornavacca (2015).</p><p>Output: vector of hybrid node in postorder, vector of child edges whose length is constrained to be 0, and vector of their original branch lengths to re-zip if needed using <a href="#PhyloNetworks.rezip_canonical!-Tuple{Vector{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}"><code>rezip_canonical!</code></a>.</p><p>Assumption: <code>net.hybrid</code> is correct, but a preordering of all nodes is <em>not</em> assumed.</p><p>Note: This unzipping is not as straightforward as it might seem, because of &quot;nested&quot; zippers: when the child of a hybrid node is itself a hybrid node. The unzipping is propagated all the way through.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L1189-L1207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.unzipat_canonical!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloNetworks.unzipat_canonical!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.unzipat_canonical!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unzipat_canonical!(hyb::Node, childedge::Edge)</code></pre><p>Unzip the reticulation a node <code>hyb</code>. See <a href="#PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}"><code>unzip_canonical!</code></a>. Warning: no check that <code>hyb</code> has a single child.</p><p>Output: constrained edge (child of <code>hyb</code>) and its original length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/manipulateNet.jl#L1242-L1249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.updateconstraintfields!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}" href="#PhyloNetworks.updateconstraintfields!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}"><code>PhyloNetworks.updateconstraintfields!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateconstraintfields!(constraints::Vector{TopologyConstraint}, net::HybridNetwork)</code></pre><p>Update fields stem <code>edge</code> and crown <code>node</code> to match the given <code>net</code>.</p><p>Assumes that the constraints are still met in <code>net</code>, and that nodes &amp; edges are numbered identically in <code>net</code> as in the network used to create all <code>constraints</code>.</p><p>fixit: remove the assumption that constraints are still met, since an NNI near the crown of a constrained clade might change the crown node and / or the stem edge (u and v exchange).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L245-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.updateconstraints!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}" href="#PhyloNetworks.updateconstraints!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}"><code>PhyloNetworks.updateconstraints!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateconstraints!(constraints::Vector{TopologyConstraint}, net::HybridNetwork)</code></pre><p>Update the set <code>taxonnum</code> in each constraint, assuming that the stem edge and the crown node are still correct, and that their descendants are still correct. May be needed if the node and edge numbers were modified by <a href="#PhyloNetworks.resetnodenumbers!-Tuple{HybridNetwork}"><code>resetnodenumbers!</code></a> or <a href="#PhyloNetworks.resetedgenumbers!"><code>resetedgenumbers!</code></a>.</p><p>Warning: does <em>not</em> check that the names of leaves with numbers in <code>taxonnum</code> are <code>taxonnames</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((2a,2b),(((((1a,1b,1c),4),(5)#H1),(#H1,(6,7))))#H2),(#H2,10));&quot;);

julia&gt; c_species1 = PhyloNetworks.TopologyConstraint(0x01, [&quot;1a&quot;,&quot;1b&quot;,&quot;1c&quot;], net)
Species constraint, on tips: 1a, 1b, 1c
 stem edge number 7
 crown node number -9

julia&gt; c_species1.taxonnums
Set{Int64} with 3 elements:
  5
  4
  3

julia&gt; c_clade145 = PhyloNetworks.TopologyConstraint(0x02, [&quot;1a&quot;,&quot;1b&quot;,&quot;1c&quot;,&quot;4&quot;,&quot;5&quot;], net)
Clade constraint, on tips: 1a, 1b, 1c, 4, 5
 stem edge number 12
 crown node number -7

julia&gt; PhyloNetworks.resetnodenumbers!(net)

julia&gt; net.node[4].number = 111;

julia&gt; PhyloNetworks.updateconstraints!([c_species1, c_clade145], net)

julia&gt; c_species1
Species constraint, on tips: 1a, 1b, 1c
 stem edge number 7
 crown node number 21

julia&gt; c_species1.taxonnums
Set{Int64} with 3 elements:
  5
  4
  111</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/752f516167203db2298b30b3ab94003769dbd8f1/src/moves_semidirected.jl#L175-L222">source</a></section></article><h2 id="index"><a class="docs-heading-anchor" href="#index">index</a><a id="index-1"></a><a class="docs-heading-anchor-permalink" href="#index" title="Permalink"></a></h2><ul><li><a href="#PhyloNetworks.ANode"><code>PhyloNetworks.ANode</code></a></li><li><a href="#PhyloNetworks.EdgeT"><code>PhyloNetworks.EdgeT</code></a></li><li><a href="#PhyloNetworks.MatrixTopologicalOrder"><code>PhyloNetworks.MatrixTopologicalOrder</code></a></li><li><a href="#PhyloNetworks.Node"><code>PhyloNetworks.Node</code></a></li><li><a href="#PhyloNetworks.Partition"><code>PhyloNetworks.Partition</code></a></li><li><a href="#PhyloNetworks.TopologyConstraint-Tuple{UInt8, Vector{String}, HybridNetwork}"><code>PhyloNetworks.TopologyConstraint</code></a></li><li><a href="#PhyloNetworks.TopologyConstraint"><code>PhyloNetworks.TopologyConstraint</code></a></li><li><a href="#Base.getindex"><code>Base.getindex</code></a></li><li><a href="#PhyloNetworks._getnodeheights"><code>PhyloNetworks._getnodeheights</code></a></li><li><a href="#PhyloNetworks.addAlternativeHybridizations!-Tuple{HybridNetwork, DataFrames.DataFrame}"><code>PhyloNetworks.addAlternativeHybridizations!</code></a></li><li><a href="#PhyloNetworks.addHybridBetweenClades!-Tuple{HybridNetwork, Number, Number}"><code>PhyloNetworks.addHybridBetweenClades!</code></a></li><li><a href="#PhyloNetworks.addhybridedge!-Tuple{HybridNetwork, Bool, Vararg{Any}}"><code>PhyloNetworks.addhybridedge!</code></a></li><li><a href="#PhyloNetworks.addhybridedge!"><code>PhyloNetworks.addhybridedge!</code></a></li><li><a href="#PhyloNetworks.addindividuals!-Tuple{HybridNetwork, AbstractString, Vector{&lt;:AbstractString}}"><code>PhyloNetworks.addindividuals!</code></a></li><li><a href="#PhyloNetworks.addleaf!"><code>PhyloNetworks.addleaf!</code></a></li><li><a href="#PhyloNetworks.adjacentedges-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.adjacentedges</code></a></li><li><a href="#PhyloNetworks.allowrootbelow!-Tuple{HybridNetwork}"><code>PhyloNetworks.allowrootbelow!</code></a></li><li><a href="#PhyloNetworks.allowrootbelow!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.allowrootbelow!</code></a></li><li><a href="#PhyloNetworks.assignhybridnames!-Tuple{HybridNetwork}"><code>PhyloNetworks.assignhybridnames!</code></a></li><li><a href="#PhyloNetworks.biconnectedcomponent_entrynodes"><code>PhyloNetworks.biconnectedcomponent_entrynodes</code></a></li><li><a href="#PhyloNetworks.biconnectedcomponent_exitnodes"><code>PhyloNetworks.biconnectedcomponent_exitnodes</code></a></li><li><a href="#PhyloNetworks.blobinfo"><code>PhyloNetworks.blobinfo</code></a></li><li><a href="#PhyloNetworks.breakedge!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, HybridNetwork}"><code>PhyloNetworks.breakedge!</code></a></li><li><a href="#PhyloNetworks.checkNumHybEdges!-Tuple{HybridNetwork}"><code>PhyloNetworks.checkNumHybEdges!</code></a></li><li><a href="#PhyloNetworks.check_nonmissing_nonnegative_edgelengths"><code>PhyloNetworks.check_nonmissing_nonnegative_edgelengths</code></a></li><li><a href="#PhyloNetworks.checkspeciesnetwork!-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}"><code>PhyloNetworks.checkspeciesnetwork!</code></a></li><li><a href="#PhyloNetworks.cleantaxonname-Tuple{AbstractString}"><code>PhyloNetworks.cleantaxonname</code></a></li><li><a href="#PhyloNetworks.constraintviolated-Tuple{HybridNetwork, Vector{PhyloNetworks.TopologyConstraint}}"><code>PhyloNetworks.constraintviolated</code></a></li><li><a href="#PhyloNetworks.deleteEdge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.deleteEdge!</code></a></li><li><a href="#PhyloNetworks.deleteNode!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>PhyloNetworks.deleteNode!</code></a></li><li><a href="#PhyloNetworks.deletehybridedge!"><code>PhyloNetworks.deletehybridedge!</code></a></li><li><a href="#PhyloNetworks.descendants"><code>PhyloNetworks.descendants</code></a></li><li><a href="#PhyloNetworks.directionalconflict-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool}"><code>PhyloNetworks.directionalconflict</code></a></li><li><a href="#PhyloNetworks.displayednetworks!"><code>PhyloNetworks.displayednetworks!</code></a></li><li><a href="#PhyloNetworks.edgerelation-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.edgerelation</code></a></li><li><a href="#PhyloNetworks.fliphybrid!-Tuple{HybridNetwork, Bool, Vararg{Any}}"><code>PhyloNetworks.fliphybrid!</code></a></li><li><a href="#PhyloNetworks.fliphybrid!"><code>PhyloNetworks.fliphybrid!</code></a></li><li><a href="#PhyloNetworks.fuseedgesat!"><code>PhyloNetworks.fuseedgesat!</code></a></li><li><a href="#PhyloNetworks.getTipSubmatrix-Tuple{Matrix, HybridNetwork}"><code>PhyloNetworks.getTipSubmatrix</code></a></li><li><a href="#PhyloNetworks.getconnectingedge-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}"><code>PhyloNetworks.getconnectingedge</code></a></li><li><a href="#PhyloNetworks.getlengths-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}"><code>PhyloNetworks.getlengths</code></a></li><li><a href="#PhyloNetworks.hardwiredclusterdistance_unrooted-Tuple{HybridNetwork, HybridNetwork}"><code>PhyloNetworks.hardwiredclusterdistance_unrooted</code></a></li><li><a href="#PhyloNetworks.hashybridladder-Tuple{HybridNetwork}"><code>PhyloNetworks.hashybridladder</code></a></li><li><a href="#PhyloNetworks.hybrid3cycle-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.hybrid3cycle</code></a></li><li><a href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.hybridEdges</code></a></li><li><a href="#PhyloNetworks.hybridEdges-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.hybridEdges</code></a></li><li><a href="#PhyloNetworks.inheritanceweight-Tuple{HybridNetwork}"><code>PhyloNetworks.inheritanceweight</code></a></li><li><a href="#PhyloNetworks.initializeweightsfromleaves!-Tuple{AbstractArray, HybridNetwork, Any, Any, Symbol}"><code>PhyloNetworks.initializeweightsfromleaves!</code></a></li><li><a href="#PhyloNetworks.initializeweightsfromleaves_softwired!-Tuple{AbstractArray, HybridNetwork, Any, Any}"><code>PhyloNetworks.initializeweightsfromleaves_softwired!</code></a></li><li><a href="#PhyloNetworks.isconnected-Tuple{Any, Any}"><code>PhyloNetworks.isconnected</code></a></li><li><a href="#PhyloNetworks.isdescendant-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}"><code>PhyloNetworks.isdescendant</code></a></li><li><a href="#PhyloNetworks.isdescendant_undirected-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.isdescendant_undirected</code></a></li><li><a href="#PhyloNetworks.ladderpartition-Tuple{HybridNetwork}"><code>PhyloNetworks.ladderpartition</code></a></li><li><a href="#PhyloNetworks.leaststableancestor"><code>PhyloNetworks.leaststableancestor</code></a></li><li><a href="#PhyloNetworks.majoredgelength-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgelength</code></a></li><li><a href="#PhyloNetworks.majoredgematrix-Tuple{HybridNetwork}"><code>PhyloNetworks.majoredgematrix</code></a></li><li><a href="#PhyloNetworks.makemissing!-Tuple{AbstractVector}"><code>PhyloNetworks.makemissing!</code></a></li><li><a href="#PhyloNetworks.mapindividuals-Tuple{HybridNetwork, String}"><code>PhyloNetworks.mapindividuals</code></a></li><li><a href="#PhyloNetworks.maxParsimonyNet-Tuple{HybridNetwork, DataFrames.DataFrame}"><code>PhyloNetworks.maxParsimonyNet</code></a></li><li><a href="#PhyloNetworks.minorreticulationgamma-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationgamma</code></a></li><li><a href="#PhyloNetworks.minorreticulationlength-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationlength</code></a></li><li><a href="#PhyloNetworks.minorreticulationmatrix-Tuple{HybridNetwork}"><code>PhyloNetworks.minorreticulationmatrix</code></a></li><li><a href="#PhyloNetworks.moveroot!-Tuple{HybridNetwork, Vararg{Any}}"><code>PhyloNetworks.moveroot!</code></a></li><li><a href="#PhyloNetworks.nj!"><code>PhyloNetworks.nj!</code></a></li><li><a href="#PhyloNetworks.nnimax-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.nnimax</code></a></li><li><a href="#PhyloNetworks.norootbelow!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.norootbelow!</code></a></li><li><a href="#PhyloNetworks.pairwisetaxondistance_gradient-Tuple{HybridNetwork}"><code>PhyloNetworks.pairwisetaxondistance_gradient</code></a></li><li><a href="#PhyloNetworks.parsenewick_edgedata!-Tuple{IO, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{Int64}}"><code>PhyloNetworks.parsenewick_edgedata!</code></a></li><li><a href="#PhyloNetworks.parsenewick_getfloat!-Tuple{IO, Int64, Vector{Int64}}"><code>PhyloNetworks.parsenewick_getfloat!</code></a></li><li><a href="#PhyloNetworks.parsenewick_hybridnode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, String, HybridNetwork, Vector{String}}"><code>PhyloNetworks.parsenewick_hybridnode!</code></a></li><li><a href="#PhyloNetworks.parsenewick_remainingsubtree!-Tuple{IO, Vector{Int64}, HybridNetwork, Vector{String}}"><code>PhyloNetworks.parsenewick_remainingsubtree!</code></a></li><li><a href="#PhyloNetworks.parsenewick_treenode!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, HybridNetwork}"><code>PhyloNetworks.parsenewick_treenode!</code></a></li><li><a href="#PhyloNetworks.parsimonyGF_bottomup!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, Vararg{AbstractArray, 4}}"><code>PhyloNetworks.parsimonyGF_bottomup!</code></a></li><li><a href="#PhyloNetworks.parsimonyfitch-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T"><code>PhyloNetworks.parsimonyfitch</code></a></li><li><a href="#PhyloNetworks.parsimonyfitch_bottomup!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}, Vector{Int64}}} where T"><code>PhyloNetworks.parsimonyfitch_bottomup!</code></a></li><li><a href="#PhyloNetworks.parsimonyfitch_summary-Union{Tuple{T}, Tuple{HybridNetwork, Dict{Int64, Set{T}}}} where T"><code>PhyloNetworks.parsimonyfitch_summary</code></a></li><li><a href="#PhyloNetworks.parsimonyfitch_topdown!-Union{Tuple{T}, Tuple{PhyloNetworks.Node, Dict{Int64, Set{T}}}} where T"><code>PhyloNetworks.parsimonyfitch_topdown!</code></a></li><li><a href="#PhyloNetworks.parsimonysoftwired_bottomup!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, AbstractArray, AbstractArray}"><code>PhyloNetworks.parsimonysoftwired_bottomup!</code></a></li><li><a href="#PhyloNetworks.postorder_nodeupdate!"><code>PhyloNetworks.postorder_nodeupdate!</code></a></li><li><a href="#PhyloNetworks.preorder_nodeupdate!"><code>PhyloNetworks.preorder_nodeupdate!</code></a></li><li><a href="#PhyloNetworks.problem4cycle-NTuple{4, PhyloNetworks.Node}"><code>PhyloNetworks.problem4cycle</code></a></li><li><a href="#PhyloNetworks.readcsvtoarray-Tuple{DataFrames.DataFrame}"><code>PhyloNetworks.readcsvtoarray</code></a></li><li><a href="#PhyloNetworks.readfastatoarray"><code>PhyloNetworks.readfastatoarray</code></a></li><li><a href="#PhyloNetworks.readnewick_nodename-Tuple{IO, Char, HybridNetwork, Vector{Int64}}"><code>PhyloNetworks.readnewick_nodename</code></a></li><li><a href="#PhyloNetworks.readnewick_subtree!-Tuple{IO, PhyloNetworks.Node, Vector{Int64}, HybridNetwork, Vector{String}}"><code>PhyloNetworks.readnewick_subtree!</code></a></li><li><a href="#PhyloNetworks.readnexus_assigngammas!-Tuple{HybridNetwork, Dict}"><code>PhyloNetworks.readnexus_assigngammas!</code></a></li><li><a href="#PhyloNetworks.readnexus_comment-Tuple{IO, Char}"><code>PhyloNetworks.readnexus_comment</code></a></li><li><a href="#PhyloNetworks.readnexus_extractgamma-Tuple{Any}"><code>PhyloNetworks.readnexus_extractgamma</code></a></li><li><a href="#PhyloNetworks.readnexus_translatetable-Tuple{Any}"><code>PhyloNetworks.readnexus_translatetable</code></a></li><li><a href="#PhyloNetworks.removeHybrid!-Tuple{PhyloNetworks.Network, PhyloNetworks.Node}"><code>PhyloNetworks.removeHybrid!</code></a></li><li><a href="#PhyloNetworks.remove_edgelengthsgammas!-Tuple{HybridNetwork}"><code>PhyloNetworks.remove_edgelengthsgammas!</code></a></li><li><a href="#PhyloNetworks.resetedgenumbers!"><code>PhyloNetworks.resetedgenumbers!</code></a></li><li><a href="#PhyloNetworks.resetnodenumbers!-Tuple{HybridNetwork}"><code>PhyloNetworks.resetnodenumbers!</code></a></li><li><a href="#PhyloNetworks.resolvetreepolytomy!"><code>PhyloNetworks.resolvetreepolytomy!</code></a></li><li><a href="#PhyloNetworks.resolvetreepolytomy!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>PhyloNetworks.resolvetreepolytomy!</code></a></li><li><a href="#PhyloNetworks.rezip_canonical!-Tuple{Vector{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}"><code>PhyloNetworks.rezip_canonical!</code></a></li><li><a href="#PhyloNetworks.samplebootstrap_multiloci-Tuple{Vector{Vector{HybridNetwork}}}"><code>PhyloNetworks.samplebootstrap_multiloci</code></a></li><li><a href="#PhyloNetworks.setmultiplegammas!-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}"><code>PhyloNetworks.setmultiplegammas!</code></a></li><li><a href="#PhyloNetworks.shrink2cycleat!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool}"><code>PhyloNetworks.shrink2cycleat!</code></a></li><li><a href="#PhyloNetworks.shrink3cycleat!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.Node, Bool}"><code>PhyloNetworks.shrink3cycleat!</code></a></li><li><a href="#PhyloNetworks.shrinkedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.shrinkedge!</code></a></li><li><a href="#PhyloNetworks.startingBL!"><code>PhyloNetworks.startingBL!</code></a></li><li><a href="#PhyloNetworks.startree_newick"><code>PhyloNetworks.startree_newick</code></a></li><li><a href="#PhyloNetworks.symmetricnet_newick-Tuple{Int64, Int64, Int64, Real, Real}"><code>PhyloNetworks.symmetricnet_newick</code></a></li><li><a href="#PhyloNetworks.symmetricnet_newick"><code>PhyloNetworks.symmetricnet_newick</code></a></li><li><a href="#PhyloNetworks.symmetrictree_newick"><code>PhyloNetworks.symmetrictree_newick</code></a></li><li><a href="#PhyloNetworks.synchronizepartnersdata!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node}"><code>PhyloNetworks.synchronizepartnersdata!</code></a></li><li><a href="#PhyloNetworks.timeinconsistency_average-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Ref{Bool}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}} where T&lt;:Real"><code>PhyloNetworks.timeinconsistency_average</code></a></li><li><a href="#PhyloNetworks.timeinconsistency_check"><code>PhyloNetworks.timeinconsistency_check</code></a></li><li><a href="#PhyloNetworks.timeinconsistency_error-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Vararg{Any}}} where T&lt;:Real"><code>PhyloNetworks.timeinconsistency_error</code></a></li><li><a href="#PhyloNetworks.timeinconsistency_majortree-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Ref{Bool}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}} where T&lt;:Real"><code>PhyloNetworks.timeinconsistency_majortree</code></a></li><li><a href="#PhyloNetworks.traversal_postorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Vararg{Any}}"><code>PhyloNetworks.traversal_postorder</code></a></li><li><a href="#PhyloNetworks.traversal_preorder-Tuple{Vector{PhyloNetworks.Node}, Function, Function, Function, Function, Vararg{Any}}"><code>PhyloNetworks.traversal_preorder</code></a></li><li><a href="#PhyloNetworks.traversal_preorder!"><code>PhyloNetworks.traversal_preorder!</code></a></li><li><a href="#PhyloNetworks.traversalupdate_default!-Tuple{AbstractArray, Int64, Vararg{Any}}"><code>PhyloNetworks.traversalupdate_default!</code></a></li><li><a href="#PhyloNetworks.unzip_canonical!-Tuple{HybridNetwork}"><code>PhyloNetworks.unzip_canonical!</code></a></li><li><a href="#PhyloNetworks.unzipat_canonical!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.unzipat_canonical!</code></a></li><li><a href="#PhyloNetworks.updateconstraintfields!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}"><code>PhyloNetworks.updateconstraintfields!</code></a></li><li><a href="#PhyloNetworks.updateconstraints!-Tuple{Vector{PhyloNetworks.TopologyConstraint}, HybridNetwork}"><code>PhyloNetworks.updateconstraints!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public/">« Public</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 20 November 2024 22:03">Wednesday 20 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
