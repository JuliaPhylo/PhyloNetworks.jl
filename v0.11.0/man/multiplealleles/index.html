<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multiple Alleles · PhyloNetworks.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="PhyloNetworks.jl logo"/></a><h1>PhyloNetworks.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../inputdata/">Input Data for SNaQ</a></li><li><a class="toctext" href="../ticr_howtogetQuartetCFs/">TICR pipeline</a></li><li><a class="toctext" href="../snaq_plot/">Network estimation and display</a></li><li><a class="toctext" href="../dist_reroot/">Network comparison and manipulation</a></li><li><a class="toctext" href="../fixednetworkoptim/">Candidate Networks</a></li><li><a class="toctext" href="../expectedCFs/">Extract Expected CFs</a></li><li><a class="toctext" href="../bootstrap/">Bootstrap</a></li><li class="current"><a class="toctext" href>Multiple Alleles</a><ul class="internal"><li><a class="toctext" href="#between-species-4-taxon-sets-1">between-species 4-taxon sets</a></li><li><a class="toctext" href="#within-species-4-taxon-sets-1">within-species 4-taxon sets</a></li></ul></li><li><a class="toctext" href="../trait_tree/">Continuous Trait Evolution</a></li><li><a class="toctext" href="../parsimony/">Parsimony on networks</a></li><li><a class="toctext" href="../fitDiscrete/">Discrete Trait Evolution</a></li><li><a class="toctext" href="../nj/">Neighbour Joining</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../lib/public/">Public</a></li><li><a class="toctext" href="../../lib/internals/">Internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Multiple Alleles</a></li></ul><a class="edit-page" href="https://github.com/crsl4/PhyloNetworks.jl/blob/master/docs/src/man/multiplealleles.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Multiple Alleles</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Multiple-alleles-per-species-1" href="#Multiple-alleles-per-species-1">Multiple alleles per species</a></h1><h2><a class="nav-anchor" id="between-species-4-taxon-sets-1" href="#between-species-4-taxon-sets-1">between-species 4-taxon sets</a></h2><p>The default setting for SNaQ considers that each allele in a gene tree corresponds to a taxon (a tip) in the network. If instead each allele/individual can be mapped confidently to a species, and if only the species-level network needs to be estimated, then the following functions can be used:</p><pre><code class="language-julia">tm = CSV.read(mappingFile) # taxon map as a data frame
taxonmap = Dict(tm[i,:allele] =&gt; tm[i,:species] for i in 1:110) # taxon map as a dictionary</code></pre><p>The mapping file can be a text (or <code>csv</code>) file with two columns (at least): one column named <code>allele</code> and one named <code>species</code>, mapping each allele name to a species name. Next, read in the gene trees and calculate the quartet CFs at the species level:</p><pre><code class="language-julia">genetrees = readMultiTopology(genetreeFile)
df_sp = writeTableCF(countquartetsintrees(genetrees, taxonmap)...)</code></pre><p>Now <code>df_sp</code> is a data frame containing the quartet concordance factors at the species level only, that is, considering sets made of 4 distinct species, even if the gene trees may have multiple alleles from the same species. For 4 distinct species <code>A,B,C,D</code>, all alleles from each species (<code>A</code> etc.) will be used to calculate the quartet CF. If a given gene tree has <code>n_a</code> alleles from <code>a</code>, <code>n_b</code> alleles from <code>b</code> etc., then each set of 4 alleles is given a weight of <code>1/(n_a n_b b_c n_c)</code> to calculated of the CF for <code>A,B,C,D</code> (such that the total weight from this particular gene trees is 1). It is save to save this data frame, then use it for <code>snaq!</code> like this:</p><pre><code class="language-julia">CSV.write(&quot;tableCF_species.csv&quot;, df)      # to save the data frame to a file
d_sp = readTableCF(&quot;tableCF_species.csv&quot;) # to get a &quot;DataCF&quot; object for use in snaq!.</code></pre><h2><a class="nav-anchor" id="within-species-4-taxon-sets-1" href="#within-species-4-taxon-sets-1">within-species 4-taxon sets</a></h2><p>Four-taxon sets involving 2 individuals per species can provide more information about the underlying network, including external branch length in coalescent units. However, <code>snaq!</code> runs more slowly when using this extra information. To get quartet CFs from sets of 4 individuals in which 2 individuals are from the same species, the following functions should be used:</p><pre><code class="language-julia">df_ind = writeTableCF(countquartetsintrees(genetrees)...) # no mapping here: so quartet CFs across individuals
CSV.write(&quot;tableCF_individuals.csv&quot;, df)               # to save to a file
df_sp = mapAllelesCFtable(mappingFile, &quot;tableCF_individuals.csv&quot;);
d_sp = readTableCF!(df_sp);</code></pre><p>where the mapping file can be a text (or <code>csv</code>) file with two columns named <code>allele</code> and <code>species</code>, mapping each allele name to a species name. The data in <code>df_ind</code> is the table of concordance factors at the level of individuals. In other words, it list CFs using one row for each set of 4 alleles/individuals.</p><p><code>mapAllelesCFtable</code> creates a new data frame <code>df_sp</code> of quartet concordance factors at the species level: with the allele names replaced by the appropriate species names.</p><p><strong>Warnings</strong>:</p><ul><li>This procedure requires that all alleles from the same individual are given the same name (the individual&#39;s &#39;name&#39;) across all genes for which that individual was sequenced.</li><li>For a four-taxon set <code>A,B,C,D</code>, all the individuals from <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code> are considered, say <code>a1,b1,c1,d1</code>, <code>a2,b1,c1,d1</code>, <code>a1,b2,c1,d1</code>, <code>a2,b2,c1,d1</code> and so on. The CFs of these 4-taxon sets are averaged together to obtain the CFs at the species level. This procedures gives more weight to genes that have many alleles (because they contribute to more sets of 4 individuals) and less weight to genes that have few alleles.</li></ul><p>The last command modifies this data frame <code>df_sp</code> by deleting rows that are uninformative about between-species relationships, such as rows corresponding to 4 individuals from the same species. The output <code>d_sp</code> of this second command is an object of type <code>DataCF</code> at the species level, which can be used as input for networks estimation with <code>snaq!</code>. But before, it is safe to save the concordance factor of quartets of species, which can be calculated by averaging the CFs of quartets of individuals from the associated species:</p><pre><code class="language-julia">df_sp = writeTableCF(d_sp) # data frame, quartet CFs averaged across individuals of same species
CSV.write(&quot;CFtable_species.csv&quot;, df_sp) # save to file</code></pre><p>Some quartets have the same species repeated twice, representing cases when 2 of the 4 individuals came from the same species. These quartets, with repeated species, are informative about the population size of extant populations, i.e. about the lengths of external branches in coalescent units.</p><p>now we can run snaq:</p><pre><code class="language-julia">net = snaq!(T_sp, d_sp);</code></pre><p>where <code>T_sp</code> should be a starting topology with one tip per species, labelled with the same species names as the names used in the mapping file.</p><p>If <code>snaq!</code> takes too long that way, we can try a less ambitious estimation that does not estimate the external branch lengths, that is, <em>without</em> using quartets that have 2 individuals from the same species. To do so, we can use the quartet concordance factors at the species level, but filter out the quartets with one (or more) species repeated:</p><pre><code class="language-julia">df_sp = writeTableCF(d_sp) # some quartets have the same species twice
function hasrep(row) # see if a row (4-taxon set) has a species name ending with &quot;__2&quot;: repeated species
  occursin(r&quot;__2$&quot;, row[:tx1]) || occursin(r&quot;__2$&quot;, row[:tx2]) ||
    occursin(r&quot;__2$&quot;, row[:tx3]) || occursin(r&quot;__2$&quot;, row[:tx4])
end
df_sp_reduced = filter(!hasrep, df_sp) # removes rows with repeated species
df_sp_reduced # should have fewer rows than df_sp
CSV.write(&quot;CFtable_species_norep.csv&quot;, df_sp_reduced) # to save to file
d_sp_reduced = readTableCF(df_sp_reduced) # DataCF object, for input to snaq!</code></pre><p>and now we can run <code>snaq!</code> on the reduced set of quartets without repeats, which should be faster:</p><pre><code class="language-julia">net = snaq!(T_sp, d_sp_reduced);</code></pre><footer><hr/><a class="previous" href="../bootstrap/"><span class="direction">Previous</span><span class="title">Bootstrap</span></a><a class="next" href="../trait_tree/"><span class="direction">Next</span><span class="title">Continuous Trait Evolution</span></a></footer></article></body></html>
