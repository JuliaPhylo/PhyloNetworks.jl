<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · PhyloNetworks.jl</title><meta name="title" content="Public · PhyloNetworks.jl"/><meta property="og:title" content="Public · PhyloNetworks.jl"/><meta property="twitter:title" content="Public · PhyloNetworks.jl"/><meta name="description" content="Documentation for PhyloNetworks.jl."/><meta property="og:description" content="Documentation for PhyloNetworks.jl."/><meta property="twitter:description" content="Documentation for PhyloNetworks.jl."/><meta property="og:url" content="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/public/"/><meta property="twitter:url" content="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/public/"/><link rel="canonical" href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/public/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="PhyloNetworks.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="PhyloNetworks.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PhyloNetworks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/installation/">Installation</a></li><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/netmanipulation/">Network manipulation</a></li><li><a class="tocitem" href="../../man/net_plot/">Network visualization</a></li><li><a class="tocitem" href="../../man/dist_reroot/">Network comparison and manipulation</a></li><li><a class="tocitem" href="../../man/network_support/">Network support</a></li><li><a class="tocitem" href="../../man/parsimony/">Parsimony on networks</a></li><li><a class="tocitem" href="../../man/nj/">Neighbour Joining</a></li><li><a class="tocitem" href="../../man/expecteddata/">Pairwise and quartet data</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#functions-and-types"><span>functions &amp; types</span></a></li><li><a class="tocitem" href="#index"><span>index</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/PhyloNetworks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/master/docs/src/lib/public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="public-documentation"><a class="docs-heading-anchor" href="#public-documentation">public documentation</a><a id="public-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#public-documentation" title="Permalink"></a></h1><p>Documentation for <code>PhyloNetworks</code>&#39;s public (exported) interface.</p><h2 id="functions-and-types"><a class="docs-heading-anchor" href="#functions-and-types">functions &amp; types</a><a id="functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#functions-and-types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PhyloNetworks.biconnectedcomponents"><a class="docstring-binding" href="#PhyloNetworks.biconnectedcomponents"><code>PhyloNetworks.biconnectedcomponents</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">biconnectedcomponents(network, ignoreTrivial=false)</code></pre><p>Calculate biconnected components (aka &quot;blobs&quot;) using Tarjan&#39;s algorithm.</p><p>Output: array of arrays of edges.</p><ul><li>the length of the array is the number of blobs</li><li>each element is an array of all the edges inside a given blob.</li></ul><p>These blobs are returned in post-order, but within a blob, edges are <em>not</em> necessarily sorted in topological order. If <code>ignoreTrivial</code> is true, trivial components (of a single edge) are not returned. The network is assumed to be connected.</p><p><em>Warnings</em>: for nodes, fields <code>intn2</code> and <code>intn1</code> are modified during the algorithm. They are used to store the node&#39;s &quot;index&quot; (time of visitation), &quot;lowpoint&quot;, and the node&#39;s &quot;parent&quot;, as defined by the order in which nodes are visited. For edges, field <code>boole2</code> is modified, to store whether the edge has been already been visited or not.</p><p>References:</p><ul><li>p. 153 of <a href="http://epubs.siam.org/doi/pdf/10.1137/0201010">Tarjan (1972)</a>. Depth first search and linear graph algorithms, SIAM Journal on Computing, 1(2):146-160</li><li>on <a href="https://www.geeksforgeeks.org/biconnected-components/">geeksforgeeks</a>, there is an error (as of 2018-01-30): <code>elif v != parent[u] and low[u] &gt; disc[v]:</code> (python version) should be replaced by <code>elif v != parent[u] and disc[u] &gt; disc[v]:</code></li><li>nice explanation at this <a href="https://www.cs.cmu.edu/~avrim/451f12/lectures/biconnected.pdf">url</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/graph_components.jl#L1-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.biconnectedcomponents-NTuple{5, Any}"><a class="docstring-binding" href="#PhyloNetworks.biconnectedcomponents-NTuple{5, Any}"><code>PhyloNetworks.biconnectedcomponents</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">biconnectedcomponents(node, index, S, blobs, ignoreTrivial)</code></pre><p>Helper recursive function starting at a node (not a network). <code>index</code> is an array containing a single integer, thus mutable: order in which nodes are visited.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/graph_components.jl#L51-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.blobdecomposition-Tuple{Any}"><a class="docstring-binding" href="#PhyloNetworks.blobdecomposition-Tuple{Any}"><code>PhyloNetworks.blobdecomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">blobdecomposition!(network)
blobdecomposition(network)</code></pre><p>Find blobs using <a href="#PhyloNetworks.biconnectedcomponents"><code>biconnectedcomponents</code></a>; find their roots using <a href="../internals/#PhyloNetworks.blobinfo"><code>blobinfo</code></a>; create a forest in the form of a disconnected network (for efficiency), by deconnecting the root of each non-trivial blob from its parent. The root of each blob corresponds to a new leaf (in another tree of the forest): the number of the blob&#39;s root is given to the newly created leaf.</p><p>The first (bang) version modifies the network and returns the array of blob roots. The second version copies the network then returns a tuple: the forest and the array of blob roots.</p><p>Warnings:</p><ul><li>the forest is represented by a single HybridNetwork object, on which most functions don&#39;t work (like <code>writenewick</code>, plotting etc.) because the network is disconnected (to make the forest). Revert back to low-level functions, e.g. <code>printedges</code> and <code>printnodes</code>.</li><li>see <a href="#PhyloNetworks.biconnectedcomponents"><code>biconnectedcomponents</code></a> for node attributes modified during the algorithm.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/graph_components.jl#L258-L281">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.calibratefrompairwisedistances!-Tuple{HybridNetwork, Matrix{Float64}, Vector{&lt;:AbstractString}}"><a class="docstring-binding" href="#PhyloNetworks.calibratefrompairwisedistances!-Tuple{HybridNetwork, Matrix{Float64}, Vector{&lt;:AbstractString}}"><code>PhyloNetworks.calibratefrompairwisedistances!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calibratefrompairwisedistances!(net, distances::Matrix{Float64},
    taxon_names::Vector{&lt;:AbstractString})</code></pre><p>Calibrate the network to match (as best as possible) input average pairwise distances between taxa, such as observed from sequence data. <code>taxon_names</code> should provide the list of taxa, in the same order in which they they are considered in the <code>distances</code> matrix. The optimization criterion is the sum of squares between the observed distances, and the distances from the network (weighted average of tree distances, weighted by γ&#39;s). The network&#39;s edge lengths are modified.</p><p>Warning: for many networks, mutiple calibrations can fit the average pairwise distance data equally well (lack of identifiability). This function will output <em>one</em> of these equally good calibrations.</p><p>optional arguments (default):</p><ul><li>checkpreorder (true)</li><li>forceMinorLength0 (false) to force minor hybrid edges to have a length of 0</li><li>ultrametric (true) to force the network to be<ul><li>time-consistent: all paths from the root to a given node must have the same length, so the age of this node is well-defined, and</li><li>ultrametric: all tips are at the same distance from the root, so have the same age.</li></ul></li><li>NLoptMethod (<code>:LD_MMA</code>) for the optimization algorithm. Other options include <code>:LN_COBYLA</code> (derivative-free); see NLopt package.</li><li>tolerance values to control when the optimization is stopped: ftolRel (1e-12), ftolAbs (1e-10) on the criterion, and xtolRel (1e-10), xtolAbs (1e-10) on branch lengths / divergence times.</li><li>verbose (false)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/pairwiseDistanceLS.jl#L324-L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.checkroot!-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.checkroot!-Tuple{HybridNetwork}"><code>PhyloNetworks.checkroot!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkroot!(net)
checkroot!(net::HybridNetwork, membership::Dict{Node, Int})</code></pre><p>Set the root of <code>net</code> to an appropriate node and update the edges <code>containroot</code> field appropriately, using the <code>membership</code> output by <a href="#PhyloNetworks.treeedgecomponents-Tuple{HybridNetwork}"><code>treeedgecomponents</code></a>. A node is appropriate to serve as root if it belongs in the root tree-edge component, that is, the root of the tree-edge component graph.</p><ul><li>If the current root is appropriate, it is left as is. The direction of edges (via <code>ischild1</code>) is also left as is, assuming it was in synch with the existing root.</li><li>Otherwise, the root is set to the first appropriate node in <code>net.node</code>, that is not a leaf. Then edges are directed away from this root.</li></ul><p>A <code>RootMismatch</code> error is thrown if <code>net</code> is not a valid semidirected phylogenetic network (i.e. it is not possible to root the network in a way compatible with the given hybrid edges).</p><p>Output: the <code>membership</code> ID of the root component. The full set of nodes in the root component can be obtained as shown below. Warning: only use the output component ID after calling the second version <code>checkroot!(net, membership)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(#H1:::0.1,#H2:::0.2,(((b)#H1)#H2,a));&quot;);

julia&gt; membership = treeedgecomponents(net);

julia&gt; rootcompID = checkroot!(net, membership);

julia&gt; rootcomp = keys(filter(p -&gt; p.second == rootcompID, membership));

julia&gt; sort([n.number for n in rootcomp]) # number of nodes in the root component
3-element Vector{Int64}:
 -3
 -2
  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/graph_components.jl#L709-L748">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.cladewiseorder!-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.cladewiseorder!-Tuple{HybridNetwork}"><code>PhyloNetworks.cladewiseorder!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cladewiseorder!(net::HybridNetwork)</code></pre><p>Update the internal attribute <code>net.vec_int1</code>. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges&#39; direction needs to be correct before calling <a href="#PhyloNetworks.cladewiseorder!-Tuple{HybridNetwork}"><code>cladewiseorder!</code></a>, using <a href="#PhyloNetworks.directedges!-Tuple{HybridNetwork}"><code>directedges!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/manipulateNet.jl#L675-L683">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.countquartetsintrees"><a class="docstring-binding" href="#PhyloNetworks.countquartetsintrees"><code>PhyloNetworks.countquartetsintrees</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">countquartetsintrees(trees [, taxonmap]; which=:all, weight_byallele=true)</code></pre><p>Calculate the quartet concordance factors (CF) observed in the <code>trees</code> vector. If present, <code>taxonmap</code> should be a dictionary that maps each allele name to it&#39;s species name. To save to a file, first convert to a data frame using <a href="#PhyloNetworks.tablequartetCF-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><code>tablequartetCF</code></a>. When <code>which=:all</code>, quartet CFs are calculated for all 4-taxon sets. (Other options are not implemented yet.)</p><p>The algorithm runs in O(mn⁴) where m is the number of trees and n is the number of tips in the trees.</p><p>CFs are calculated at the species level only, that is, considering 4-taxon sets made of 4 distinct species, even if the gene trees may have multiple alleles from the same species. For 4 distinct species <code>a,b,c,d</code>, all alleles from each species (<code>a</code> etc.) will be considered to calculate the quartet CF.</p><p>By default, each gene has a weight of 1. So if there are <code>n_a</code> alleles from <code>a</code>, <code>n_b</code> alleles from <code>b</code> etc. in a given gene, then each set of 4 alleles has a weight of <code>1/(n_a n_b b_c n_c)</code> in the calculation of the CF for <code>a,b,c,d</code>. With option <code>weight_byallele=true</code>, then each set of 4 alleles is given a weight of 1 instead. This inflates the total number of sets used to calculate the quartet CFs (to something larger than the number of genes). This may also affect the CF values if the number of alleles varies across genes: genes with more alleles will be given more weight.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tree1 = readnewick(&quot;(E,(A,B),(C,D),O);&quot;); tree2 = readnewick(&quot;(((A,B),(C,D)),E);&quot;);

julia&gt; q,t = countquartetsintrees([tree1, tree2]);
Reading in trees, looking at 15 quartets in each...
0+--+100%
  **

julia&gt; t # taxon order: t[i] = name of taxon number i
6-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;C&quot;
 &quot;D&quot;
 &quot;E&quot;
 &quot;O&quot;

julia&gt; length(q) # 15 four-taxon sets on 6 taxa
15

julia&gt; q[1] # both trees agree on AB|CD: resolution 1
4-taxon set number 1; taxon numbers: 1,2,3,4
data: [1.0, 0.0, 0.0, 2.0]

julia&gt; q[8] # tree 2 is missing O (taxon 6), tree 1 wants resolution 3: AO|CD
4-taxon set number 8; taxon numbers: 1,3,4,6
data: [0.0, 0.0, 1.0, 1.0]

julia&gt; q[11] # tree 1 has ACEO unresolved, and tree 2 is missing O: no data for this quartet
4-taxon set number 11; taxon numbers: 1,3,5,6
data: [0.0, 0.0, 0.0, 0.0]</code></pre><p>In the next example, each tree has 2 individuals from population A.</p><pre><code class="language-julia-repl hljs">julia&gt; tree1 = readnewick(&quot;(E,(a1,B),(a2,D),O);&quot;); tree2 = readnewick(&quot;(((a1,a2),(B,D)),E);&quot;);

julia&gt; q,t = countquartetsintrees([tree1, tree2], Dict(&quot;a1&quot;=&gt;&quot;A&quot;, &quot;a2&quot;=&gt;&quot;A&quot;); showprogressbar=false);

julia&gt; t
5-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;D&quot;
 &quot;E&quot;
 &quot;O&quot;

julia&gt; q[1] # tree 1 has discordance: a1B|DE and a2D|BE. tree 2 has AE|BD for both alleles of A
4-taxon set number 1; taxon numbers: 1,2,3,4
data: [0.25, 0.25, 0.5, 2.0]

julia&gt; q[3] # tree 2 is missing O (taxon 5), and a2 is unresolved in tree 1. There&#39;s only a1B|EO
4-taxon set number 3; taxon numbers: 1,2,4,5
data: [1.0, 0.0, 0.0, 0.5]</code></pre><p>Next we show how to convert these objects to a table using <a href="#PhyloNetworks.tablequartetCF-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><code>tablequartetCF</code></a>. The output is a <code>NamedTuple</code>. It can be saved later to a <code>DataFrame</code> for example, using option <code>copycols=false</code> to avoid copying the columns (which can be very large if there are many 4-taxon sets). Data frames are easier to visualize, filter etc., but performance can be better on named tuples.</p><pre><code class="language-julia-repl hljs">julia&gt; nt = tablequartetCF(q,t); # named tuple

julia&gt; using DataFrames

julia&gt; df = DataFrame(nt, copycols=false); # convert to data frame, without copying column data

julia&gt; show(df, allcols=true) # data frames displayed more nicely than named tuples
5×9 DataFrame
 Row │ qind   t1      t2      t3      t4      CF12_34  CF13_24  CF14_23  ngenes  
     │ Int64  String  String  String  String  Float64  Float64  Float64  Float64 
─────┼───────────────────────────────────────────────────────────────────────────
   1 │     1  A       B       D       E          0.25     0.25      0.5      2.0
   2 │     2  A       B       D       O          0.5      0.5       0.0      1.0
   3 │     3  A       B       E       O          1.0      0.0       0.0      0.5
   4 │     4  A       D       E       O          1.0      0.0       0.0      0.5
   5 │     5  B       D       E       O          0.0      0.0       0.0      0.0

julia&gt; using CSV; CSV.write(&quot;quartetCFs_fromgenetrees.csv&quot;, nt); # save to file if needed</code></pre><p>Note that <code>CSV.write</code> can take a data frame or a named tuple as input, to write the table to a file.</p><p>Finally, the example below shows the effect of using <code>weight_byallele=true</code> when caculating quartet concordance factors from gene trees with multiple alleles per population, and of filtering out 4-taxon sets with no informative genes with <code>keepQwithoutgenes=false</code> when converting to a table.</p><pre><code class="language-julia-repl hljs">julia&gt; tree2 = readnewick(&quot;((A,(B,D)),E);&quot;);

julia&gt; q,t = countquartetsintrees([tree1, tree2], Dict(&quot;a1&quot;=&gt;&quot;A&quot;, &quot;a2&quot;=&gt;&quot;A&quot;); weight_byallele=true);
Reading in trees, looking at 5 quartets in each...
0+--+100%
  **

julia&gt; nt = tablequartetCF(q,t; keepQwithoutgenes=false); # qind=5 excluded: 0 genes

julia&gt; show(DataFrame(nt, copycols=false), allcols=true)
4×9 DataFrame
 Row │ qind   t1      t2      t3      t4      CF12_34   CF13_24   CF14_23   ngenes  
     │ Int64  String  String  String  String  Float64   Float64   Float64   Float64 
─────┼──────────────────────────────────────────────────────────────────────────────
   1 │     1  A       B       D       E       0.333333  0.333333  0.333333      3.0
   2 │     2  A       B       D       O       0.5       0.5       0.0           2.0
   3 │     3  A       B       E       O       1.0       0.0       0.0           1.0
   4 │     4  A       D       E       O       1.0       0.0       0.0           1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/quartets.jl#L261-L401">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.deleteaboveLSA!"><a class="docstring-binding" href="#PhyloNetworks.deleteaboveLSA!"><code>PhyloNetworks.deleteaboveLSA!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">deleteaboveLSA!(net, preorder=true)</code></pre><p>Delete edges and nodes above (ancestral to) the least stable ancestor (LSA) of the leaves in <code>net</code>. See <a href="#PhyloNetworks.leaststableancestor"><code>leaststableancestor</code></a> for the definition of the LSA. Output: modified network <code>net</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/manipulateNet.jl#L1125-L1132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.deletehybridthreshold!"><a class="docstring-binding" href="#PhyloNetworks.deletehybridthreshold!"><code>PhyloNetworks.deletehybridthreshold!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">deletehybridthreshold!(net::HybridNetwork, threshold::Float64,
                       nofuse=false, unroot=false, multgammas=false,
                       keeporiginalroot=false)</code></pre><p>Deletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.</p><ul><li>if threshold&lt;0.5: delete minor hybrid edges with γ &lt; threshold (or with a missing γ, for any threshold &gt; -1.0)</li><li>if threshold=0.5: delete all minor hybrid edges (i.e normally with γ &lt; 0.5, if γ non-missing)</li><li><code>nofuse</code>: if true, do not fuse edges and keep original nodes.</li><li><code>unroot</code>: if false, the root will not be deleted if it becomes of degree 2.</li><li><code>multgammas</code>: if true, the modified edges have γ values equal to the proportion of genes that the extracted subnetwork represents. For an edge <code>e</code> in the modified network, the inheritance γ for <code>e</code> is the product of γs of all edges in the original network that have been merged into <code>e</code>.</li></ul><p>-<code>keeporiginalroot</code>: if true, the root will be retained even if of degree 1.</p><p>Warnings:</p><ul><li>by default, <code>nofuse</code> is false, partner hybrid edges are fused with their child edge and have their γ changed to 1.0. If <code>nofuse</code> is true: the γ&#39;s of partner hybrid edges are unchanged.</li><li>assumes correct <code>ismajor</code> fields, and correct <code>ischild1</code> fields to update <code>containroot</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/compareNetworks.jl#L480-L505">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.deleteleaf!-Tuple{HybridNetwork, PhyloNetworks.Node}"><a class="docstring-binding" href="#PhyloNetworks.deleteleaf!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>PhyloNetworks.deleteleaf!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">deleteleaf!(HybridNetwork, leafName::AbstractString; ...)
deleteleaf!(HybridNetwork, Node; ...)
deleteleaf!(HybridNetwork, Integer; index=false, ...)</code></pre><p>Delete a node from the network, possibly from its name, number, or index in the network&#39;s array of nodes. The first two versions require that the node is a leaf. The third version does <strong>not</strong> require that the node is a leaf: If it has degree 3 or more, nothing happens. If it has degree 1 or 2, then it is deleted.</p><p><strong>keyword arguments</strong></p><p><code>simplify</code>: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.</p><p><code>unroot</code>: if true, a root of degree 1 or 2 is deleted. If false, the root is deleted if it is of degree 1 (no root edge is left), but is kept if it is of degree 2. Deleting all leaves in an outgroup clade or grade will leave the ingroup rooted (that is, the new root will be of degree 2).</p><p><code>nofuse</code>: if true, keep nodes (and edges) provided that they have at least one descendant leaf, even if they are of degree 2. This will keep two-cycles (forcing <code>simplify</code> to false). Nodes without any descendant leaves are deleted. If <code>nofuse</code> is false, edges adjacent to degree-2 nodes are fused.</p><p><code>multgammas</code>: if true, the fused edge has γ equal to the product of the hybrid edges that have been fused together, which may result in tree edges with γ&lt;1, or with reticulations in which the two parent γ don&#39;t add up to 1.</p><p><code>keeporiginalroot</code>: if true, keep the root even if it is of degree one (forcing <code>unroot</code> to be false).</p><p>Warning: does <strong>not</strong> update edges&#39; <code>containroot</code> nor internal attributes (e.g. those used by SNaQ for level-1 networks). Does not require branch lengths, and designed to work on networks of all levels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/manipulateNet.jl#L779-L821">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.descendencematrix-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.descendencematrix-Tuple{HybridNetwork}"><code>PhyloNetworks.descendencematrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">descendencematrix(net::HybridNetwork; checkpreorder::Bool=true)</code></pre><p>Descendence matrix between all the nodes of a network: object <code>D</code> of type <a href="../internals/#PhyloNetworks.MatrixTopologicalOrder"><code>MatrixTopologicalOrder</code></a> in which <code>D[i,j]</code> is the proportion of genetic material in node <code>i</code> that can be traced back to node <code>j</code>. If <code>D[i,j]&gt;0</code> then <code>i</code> is a descendent of <code>j</code> (and <code>j</code> is an ancestor of <code>i</code>). The network is assumed to be pre-ordered if <code>checkpreorder</code> is false. If <code>checkpreorder</code> is true (default), <code>preorder!</code> is run on the network beforehand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/recursion_matrices.jl#L288-L298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.directedges!-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.directedges!-Tuple{HybridNetwork}"><code>PhyloNetworks.directedges!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">directedges!(net::HybridNetwork; checkMajor::Bool=true)</code></pre><p>Updates the edges&#39; attribute <code>ischild1</code>, according to the root placement. Also updates edges&#39; attribute <code>containroot</code>, for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if <code>checkMajor</code> is true.</p><p>Warnings:</p><ol><li>Assumes that <code>ischild1</code> is correct on hybrid edges (to avoid changing the identity of which nodes are hybrids and which are not).</li><li>Does not check for cycles (to maintain a network&#39;s DAG status)</li></ol><p>Returns the network. Throws a &#39;RootMismatch&#39; Exception if the root was found to conflict with the direction of any hybrid edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/manipulateNet.jl#L547-L563">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.displayednetworkat!"><a class="docstring-binding" href="#PhyloNetworks.displayednetworkat!"><code>PhyloNetworks.displayednetworkat!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">displayednetworkat!(net::HybridNetwork, node::Node, nofuse=false,
                    unroot=false, multgammas=false)</code></pre><p>Delete all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before. If <code>nofuse</code> is true, edges are not fused (degree-2 nodes are kept).</p><p>Warning: assume correct <code>ismajor</code> fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/compareNetworks.jl#L713-L722">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.displayedtrees-Tuple{HybridNetwork, Float64}"><a class="docstring-binding" href="#PhyloNetworks.displayedtrees-Tuple{HybridNetwork, Float64}"><code>PhyloNetworks.displayedtrees</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">displayedtrees(net::HybridNetwork, gamma::Float64; nofuse::Bool=false,
               unroot::Bool=false, multgammas::Bool=false,
               keeporiginalroot::Bool=false)</code></pre><p>Extracts all trees displayed in a network, following hybrid edges with heritability &gt;= γ threshold (or &gt;0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than γ. Returns an array of trees, as HybridNetwork objects.</p><p><code>nofuse</code>: if true, do not fuse edges (keep degree-2 nodes) during hybrid edge removal.   <code>unroot</code>: if false, the root will not be deleted if it becomes of degree 2 unless   keeporiginalroot is true.   <code>multgammas</code>: if true, the edges in the displayed trees have γ values   equal to the proportion of genes that the edge represents, even though all   these edges are tree edges. The product of all the γ values across all edges   is the proportion of genes that the tree represents. More specifically,   edge <code>e</code> in a given displayed tree has γ equal to the product of γs   of all edges in the original network that have been merged into <code>e</code>.   <code>keeporiginalroot</code>: if true, keep root even if of degree 1.</p><p>Warnings:</p><ul><li>if <code>nofuse</code> is true: the retained partner hybrid edges have their γ values unchanged, but their <code>ismajor</code> is changed to true</li><li>assume correct <code>ismajor</code> attributes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/compareNetworks.jl#L563-L589">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.expectedf2matrix-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.expectedf2matrix-Tuple{HybridNetwork}"><code>PhyloNetworks.expectedf2matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expectedf2matrix(net::HybridNetwork; preorder::Bool=true)</code></pre><p>Matrix of f2 statistics expected from <code>net</code>, assuming that branch lengths in <code>net</code> represent &quot;f2 distance&quot;. When data are based on allele frequencies, edge lengths measure drift units scaled by a variance factor p(1-p) depending on the allele frequency p at the root.</p><p>The rows and columns correspond to the taxa in the network, in the same order as listed by <code>tiplabels(net)</code>.</p><p>For background on f-statistics, see for example <a href="https://doi.org/10.1534/genetics.112.145037">Patterson et al. 2012</a> or <a href="https://doi.org/10.1111/1755-0998.13230">Lipson 2020</a>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net2 = readnewick(&quot;(O:5.5,(((E:1.5)#H1:2.5::0.7,((#H1:0,D:1.5):1.5,((C:1,B:1):1)#H2:1::0.6):1.0):1.0,(#H2:0,A:2):3):0.5);&quot;);

julia&gt; f2 = expectedf2matrix(net2)
6×6 Matrix{Float64}:
  0.0   9.95  11.0   9.56  9.56  11.0
  9.95  0.0    5.45  5.95  5.95   8.95
 11.0   5.45   0.0   6.16  6.16  10.0
  9.56  5.95   6.16  0.0   2.0    6.16
  9.56  5.95   6.16  2.0   0.0    6.16
 11.0   8.95  10.0   6.16  6.16   0.0

julia&gt; tiplabels(net2) # order of taxa in rows and columns of f2 matrix above
6-element Vector{String}:
 &quot;O&quot;
 &quot;E&quot;
 &quot;D&quot;
 &quot;C&quot;
 &quot;B&quot;
 &quot;A&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/expectedfstat.jl#L1-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.expectedf4table-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.expectedf4table-Tuple{HybridNetwork}"><code>PhyloNetworks.expectedf4table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expectedf4table(net::HybridNetwork;
                showprogressbar::Bool=true,
                preorder::Bool=true)</code></pre><p>Calculate the f4 statistics expected from <code>net</code>, assuming that branch lengths in <code>net</code> represent &quot;f2 distance&quot;. Output: <code>(q,t)</code> where <code>t</code> is a list of taxa and <code>q</code> is a list of 4-taxon set objects of type <a href="../internals/#PhyloNetworks.QuartetT"><code>PhyloNetworks.QuartetT{datatype}</code></a>. In each element of <code>q</code>, <code>taxonnumber</code> gives the indices in <code>taxa</code> of the 4 taxa of interest; and <code>data</code> contains the 3 primary expected f4-statistics, for the following 3 ordering of the 4 taxa:</p><pre><code class="language-julia hljs">t1,t2|t3,t4   t1,t3|t4,t2   t1,t4|t2,t3.</code></pre><p>This output is similar to that of <a href="#PhyloNetworks.countquartetsintrees"><code>countquartetsintrees</code></a>, with 4-taxon sets listed in the same alphabetical order (same output <code>t</code>, then same order of 4-taxon sets in <code>q</code>).</p><p>For background on f-statistics, see for example <a href="https://doi.org/10.1534/genetics.112.145037">Patterson et al. 2012</a> and <a href="https://doi.org/10.1111/1755-0998.13230">Lipson 2020</a>.</p><p>f4-statistics are linear combination of f2-statistics:</p><p><code>f4[t1,t2|t3,t4] = (f2[t1,t4] + f2[t2,t3] - f2[t1,t3] - f2[t2,t4])/2</code></p><p>Given a set of 4 taxa, there are 12 ways to order them, but there are only 2 &quot;degrees of freedom&quot; in the associated 12 f4-statistics, thanks to symmetries:</p><ul><li>f4[t2,t1|t3,t4] = - f4[t1,t2|t3,t4]</li><li>f4[t3,t4|t1,t2] =   f4[t1,t2|t3,t4]</li><li>f4[t1,t2|t3,t4] + f4[t1,t3|t4,t2] + f4[t1,t4|t2,t3] = 0</li></ul><p><strong>example</strong></p><p>The first example is a tree: on which some f4 values are expected to be 0.</p><pre><code class="language-julia-repl hljs">julia&gt; net0 = readnewick(&quot;((D:0.6,((a1:.1,a2:.1):0.1,B:0.2):0.3),C:0.4);&quot;);

julia&gt; # using PhyloPlots; plot(net0, showedgelength=true);

julia&gt; f4,t = expectedf4table(net0);
Calculation of expected f4 for 5 4-taxon sets...
0+-----+100%
  *****

julia&gt; show(t)
[&quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;a1&quot;, &quot;a2&quot;]
julia&gt; show(f4[1].taxonnumber) # taxa numbered 1-4 are: B,C,D,a1
[1, 2, 3, 4]
julia&gt; for q in f4
         println(join(t[q.taxonnumber],&quot;,&quot;) * &quot;: &quot; * string(round.(q.data, digits=3)))
       end
B,C,D,a1: [-0.3, 0.3, 0.0]
B,C,D,a2: [-0.3, 0.3, 0.0]
B,C,a1,a2: [0.0, -0.1, 0.1]
B,D,a1,a2: [0.0, -0.1, 0.1]
C,D,a1,a2: [0.0, -0.4, 0.4]</code></pre><p>The zeros correspond to splits in the tree: Ba1|CD, Ba2|CD, BC|a1a2, BD|a1a2, CD|a1a2. The other values correspond to the internal path length for each split.</p><p>Next, we use a network with 2 reticulations, each time between sister species (resulting in 3-cycle blobs).</p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(D:1,((C:1,#H25:0):0.1,
        ((((B1:10,B2:1):1.5,#H1:0):10.8,
        ((A1:1,A2:1):0.001)#H1:0::0.5):0.5)#H25:0::0.501):1);&quot;);

julia&gt; # plot(net, showedgelength=true);

julia&gt; f4,t = expectedf4table(net, showprogressbar=false);

julia&gt; using DataFrames

julia&gt; df = tablequartetf4(f4, t) |&gt; DataFrame
15×8 DataFrame
 Row │ qind   t1      t2      t3      t4      f4_12_34  f4_13_42  f4_14_23 
     │ Int64  String  String  String  String  Float64   Float64   Float64  
─────┼─────────────────────────────────────────────────────────────────────
   1 │     1  A1      A2      B1      B2           0.0    -4.201     4.201
   2 │     2  A1      A2      B1      C            0.0     2.699    -2.699
   3 │     3  A1      A2      B2      C            0.0     2.699    -2.699
   4 │     4  A1      B1      B2      C           -6.9     6.9       0.0
   5 │     5  A2      B1      B2      C           -6.9     6.9       0.0
   6 │     6  A1      A2      B1      D            0.0     2.699    -2.699
   7 │     7  A1      A2      B2      D            0.0     2.699    -2.699
   8 │     8  A1      B1      B2      D           -6.9     6.9       0.0
   9 │     9  A2      B1      B2      D           -6.9     6.9       0.0
  10 │    10  A1      A2      C       D            0.0    -3.176     3.176
  11 │    11  A1      B1      C       D            0.0    -5.875     5.875
  12 │    12  A2      B1      C       D            0.0    -5.875     5.875
  13 │    13  A1      B2      C       D            0.0    -5.875     5.875
  14 │    14  A2      B2      C       D            0.0    -5.875     5.875
  15 │    15  B1      B2      C       D            0.0   -12.775    12.775</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/expectedfstat.jl#L71-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><a class="docstring-binding" href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.getchild</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getchild(edge)
getchild(node)
getchildren(node)</code></pre><p>Get child(ren) <strong>node(s)</strong>.</p><ul><li><code>getchild</code>: single child node of <code>edge</code>, or of <code>node</code> after checking that <code>node</code> has a single child.</li><li><code>getchildren</code>: vector of all children <em>nodes</em> of <code>node</code>.</li></ul><pre><code class="language-julia hljs">getchildedge(node)</code></pre><p>Single child <strong>edge</strong> of <code>node</code>. Checks that it&#39;s a single child.</p><p><em>Warning</em>: these functions rely on correct edge direction, via their <code>ischild1</code> field.</p><p>See also: <a href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getparent</code></a>, <a href="#PhyloNetworks.getpartneredge-Tuple{Any}"><code>getpartneredge</code></a>, <a href="#PhyloNetworks.isparentof-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>isparentof</code></a>, <a href="#PhyloNetworks.hassinglechild-Tuple{PhyloNetworks.Node}"><code>hassinglechild</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L195-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getchildedge"><a class="docstring-binding" href="#PhyloNetworks.getchildedge"><code>PhyloNetworks.getchildedge</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getchild(edge)
getchild(node)
getchildren(node)</code></pre><p>Get child(ren) <strong>node(s)</strong>.</p><ul><li><code>getchild</code>: single child node of <code>edge</code>, or of <code>node</code> after checking that <code>node</code> has a single child.</li><li><code>getchildren</code>: vector of all children <em>nodes</em> of <code>node</code>.</li></ul><pre><code class="language-julia hljs">getchildedge(node)</code></pre><p>Single child <strong>edge</strong> of <code>node</code>. Checks that it&#39;s a single child.</p><p><em>Warning</em>: these functions rely on correct edge direction, via their <code>ischild1</code> field.</p><p>See also: <a href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getparent</code></a>, <a href="#PhyloNetworks.getpartneredge-Tuple{Any}"><code>getpartneredge</code></a>, <a href="#PhyloNetworks.isparentof-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>isparentof</code></a>, <a href="#PhyloNetworks.hassinglechild-Tuple{PhyloNetworks.Node}"><code>hassinglechild</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getchildren"><a class="docstring-binding" href="#PhyloNetworks.getchildren"><code>PhyloNetworks.getchildren</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getchild(edge)
getchild(node)
getchildren(node)</code></pre><p>Get child(ren) <strong>node(s)</strong>.</p><ul><li><code>getchild</code>: single child node of <code>edge</code>, or of <code>node</code> after checking that <code>node</code> has a single child.</li><li><code>getchildren</code>: vector of all children <em>nodes</em> of <code>node</code>.</li></ul><pre><code class="language-julia hljs">getchildedge(node)</code></pre><p>Single child <strong>edge</strong> of <code>node</code>. Checks that it&#39;s a single child.</p><p><em>Warning</em>: these functions rely on correct edge direction, via their <code>ischild1</code> field.</p><p>See also: <a href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getparent</code></a>, <a href="#PhyloNetworks.getpartneredge-Tuple{Any}"><code>getpartneredge</code></a>, <a href="#PhyloNetworks.isparentof-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>isparentof</code></a>, <a href="#PhyloNetworks.hassinglechild-Tuple{PhyloNetworks.Node}"><code>hassinglechild</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getlevel"><a class="docstring-binding" href="#PhyloNetworks.getlevel"><code>PhyloNetworks.getlevel</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlevel(net, preorder=true, preprocess=false)</code></pre><p>Level of <code>net</code>: maximum number of edges to delete within a biconnected component to make it a tree. If the network is bicombining (each hybrid has 2 parents), then the level is the maximum number of hybrid nodes within a biconnected component. Arguments:</p><ul><li><code>preorder</code> to direct edges according to the root and store a pre-ordering of nodes in <code>net.vec_node</code>, if not done earlier on the network (e.g. after a topology modification)</li><li><code>preprocess</code> to recalculate &amp; store the biconnected components with <a href="../internals/#PhyloNetworks.process_biconnectedcomponents!"><code>process_biconnectedcomponents!</code></a>, assuming the preordering was done</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/graph_components.jl#L415-L428">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getnodeages-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.getnodeages-Tuple{HybridNetwork}"><code>PhyloNetworks.getnodeages</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getnodeages(net)</code></pre><p>vector of node ages in pre-order, as in <code>vec_node</code>.</p><p><em>Warnings</em>: <code>net</code> is assumed to</p><ul><li>have been preordered before (to calculate <code>vec_node</code>)</li><li>be time-consistent (all paths to the root to a given hybrid have the same length)</li><li>be ultrametric (all leaves have the same age: 0)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/pairwiseDistanceLS.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getnodeheights"><a class="docstring-binding" href="#PhyloNetworks.getnodeheights"><code>PhyloNetworks.getnodeheights</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getnodeheights(net, checkpreorder::Bool=true)
getnodeheights!(net, checkpreorder::Bool=true)</code></pre><p>Vector of node heights, that is: the distance of each node to the root. An error is thrown if the network is not time-consistent. A network is time-consistent if, for any node <code>v</code>, all paths from the root to <code>v</code> have the same length. (It is sufficient to check this condition at hybrid nodes). Ultrametricity is not assumed: tips need not all be at the same distance from the root. If <code>checkpreorder=false</code>, assumes the network has already been preordered with <a href="#PhyloNetworks.preorder!-Tuple{HybridNetwork}"><code>preorder!</code></a>.</p><p>If a tree edge has a missing length (coded as -1), both functions throw an error. In general, there may be an exponential number of ways to assign tree edge lengths that make the network time-consistent.</p><p><code>getnodeheights</code> sends a warning upon finding a missing hybrid edge length, otherwises proceeds as <code>getnodeheights!</code> but without modifying the network. <code>getnodeheights!</code> will attempt to assign values to missing lengths, for hybrid edges only, so as to make the network time-consistent.</p><p>If a hybrid edge <code>e</code> has a missing length, <code>getnodeheights!</code> proceeds as follows at its child hybrid node <code>h</code>:</p><ul><li>If all of <code>h</code>&#39;s parent edges lack a length: the shortest non-negative lengths are assigned to make the network time-consistent at <code>h</code>. In particular, one of the partner edges is assigned length 0, and <code>h</code> is made as old as possible, that is, as close to the root as possible: the reticulation is &quot;zipped-up&quot;.</li><li>Otherwise: the length of <code>e</code> is set to the unique value that makes the network time-consistent at <code>h</code>, based on the partner edge&#39;s length. If this value is negative, then an error is thrown.</li></ul><p>Output: vector of node heights, one per node, in the same order as in <code>net.vec_node</code>.</p><p>See also: <a href="#PhyloNetworks.istimeconsistent"><code>istimeconsistent</code></a> and <a href="#PhyloNetworks.getnodeheights_average"><code>getnodeheights_average</code></a>.</p><p>Examples:</p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((C:1,(A:1)#H1:1.5::0.7):1,(#H1:0.3::0.3,E:2.0):2.2):1.0,O:5.2)root;&quot;);

julia&gt; # using PhyloPlots; plot(net, useedgelength=true, showedgelength=true, shownodenumber=true); # to see

julia&gt; nodeheight = getnodeheights(net)
9-element Vector{Float64}:
 0.0
 5.2
 1.0
 3.2
 5.2
 2.0
 3.5
 4.5
 3.0

julia&gt; [node.number =&gt; (height, node.name) for (height,node) in zip(nodeheight, net.vec_node)]
9-element Vector{Pair{Int64, Tuple{Float64, String}}}:
 -2 =&gt; (0.0, &quot;root&quot;)
  5 =&gt; (5.2, &quot;O&quot;)
 -3 =&gt; (1.0, &quot;&quot;)
 -6 =&gt; (3.2, &quot;&quot;)
  4 =&gt; (5.2, &quot;E&quot;)
 -4 =&gt; (2.0, &quot;&quot;)
  3 =&gt; (3.5, &quot;H1&quot;)
  2 =&gt; (4.5, &quot;A&quot;)
  1 =&gt; (3.0, &quot;C&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L975-L1043">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getnodeheights!"><a class="docstring-binding" href="#PhyloNetworks.getnodeheights!"><code>PhyloNetworks.getnodeheights!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getnodeheights(net, checkpreorder::Bool=true)
getnodeheights!(net, checkpreorder::Bool=true)</code></pre><p>Vector of node heights, that is: the distance of each node to the root. An error is thrown if the network is not time-consistent. A network is time-consistent if, for any node <code>v</code>, all paths from the root to <code>v</code> have the same length. (It is sufficient to check this condition at hybrid nodes). Ultrametricity is not assumed: tips need not all be at the same distance from the root. If <code>checkpreorder=false</code>, assumes the network has already been preordered with <a href="#PhyloNetworks.preorder!-Tuple{HybridNetwork}"><code>preorder!</code></a>.</p><p>If a tree edge has a missing length (coded as -1), both functions throw an error. In general, there may be an exponential number of ways to assign tree edge lengths that make the network time-consistent.</p><p><code>getnodeheights</code> sends a warning upon finding a missing hybrid edge length, otherwises proceeds as <code>getnodeheights!</code> but without modifying the network. <code>getnodeheights!</code> will attempt to assign values to missing lengths, for hybrid edges only, so as to make the network time-consistent.</p><p>If a hybrid edge <code>e</code> has a missing length, <code>getnodeheights!</code> proceeds as follows at its child hybrid node <code>h</code>:</p><ul><li>If all of <code>h</code>&#39;s parent edges lack a length: the shortest non-negative lengths are assigned to make the network time-consistent at <code>h</code>. In particular, one of the partner edges is assigned length 0, and <code>h</code> is made as old as possible, that is, as close to the root as possible: the reticulation is &quot;zipped-up&quot;.</li><li>Otherwise: the length of <code>e</code> is set to the unique value that makes the network time-consistent at <code>h</code>, based on the partner edge&#39;s length. If this value is negative, then an error is thrown.</li></ul><p>Output: vector of node heights, one per node, in the same order as in <code>net.vec_node</code>.</p><p>See also: <a href="#PhyloNetworks.istimeconsistent"><code>istimeconsistent</code></a> and <a href="#PhyloNetworks.getnodeheights_average"><code>getnodeheights_average</code></a>.</p><p>Examples:</p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((C:1,(A:1)#H1:1.5::0.7):1,(#H1:0.3::0.3,E:2.0):2.2):1.0,O:5.2)root;&quot;);

julia&gt; # using PhyloPlots; plot(net, useedgelength=true, showedgelength=true, shownodenumber=true); # to see

julia&gt; nodeheight = getnodeheights(net)
9-element Vector{Float64}:
 0.0
 5.2
 1.0
 3.2
 5.2
 2.0
 3.5
 4.5
 3.0

julia&gt; [node.number =&gt; (height, node.name) for (height,node) in zip(nodeheight, net.vec_node)]
9-element Vector{Pair{Int64, Tuple{Float64, String}}}:
 -2 =&gt; (0.0, &quot;root&quot;)
  5 =&gt; (5.2, &quot;O&quot;)
 -3 =&gt; (1.0, &quot;&quot;)
 -6 =&gt; (3.2, &quot;&quot;)
  4 =&gt; (5.2, &quot;E&quot;)
 -4 =&gt; (2.0, &quot;&quot;)
  3 =&gt; (3.5, &quot;H1&quot;)
  2 =&gt; (4.5, &quot;A&quot;)
  1 =&gt; (3.0, &quot;C&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L1046">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getnodeheights_average"><a class="docstring-binding" href="#PhyloNetworks.getnodeheights_average"><code>PhyloNetworks.getnodeheights_average</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getnodeheights_average(net, checkpreorder::Bool=true; warn=true)</code></pre><p>Vector of average node heights, that is: the average distance from the root to each node. The average is a weighted average with weights taken to be the hybrid edges&#39; inheritance values γ, if available. Equal weights are used at hybrid nodes with some parents lacking a γ inheritance value (with a warning).</p><p>missing edge lengths:</p><ul><li>An error is thrown if a tree edge has a missing edge length.</li><li>If all parent hybrid edges have missing lengths at a given hybrid node, then the hybrid node is assumed to be as close to the root as possible, that is, the reticulation is assumed &quot;zipped-up&quot; with one of its hybrid edges of length 0.</li><li>If some but not all parent hybrid edges have a missing length, then the average node height is calculated based on the non-missing parents only. If the hybrid node height turns out to be lower than one of the parent&#39;s height (such that some missing length would need to be negative) then a warning is issued.</li></ul><p>A warning is issued, unless <code>warn=false</code>, if the network is not time-consistent.</p><p>See also: <a href="#PhyloNetworks.istimeconsistent"><code>istimeconsistent</code></a>, <a href="#PhyloNetworks.getnodeheights"><code>getnodeheights</code></a>, and <code>getnodeheights_majortree</code>](@ref).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L1050-L1072">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getnodeheights_majortree"><a class="docstring-binding" href="#PhyloNetworks.getnodeheights_majortree"><code>PhyloNetworks.getnodeheights_majortree</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getnodeheights_majortree(net, checkpreorder::Bool=true; warn=true)</code></pre><p>Vector of node heights from the major tree, that is: the distance from the root to each node when considering the major tree for node heights. </p><p>missing edge lengths:</p><ul><li>An error is thrown if a tree edge has a missing edge length.</li><li>If all parent hybrid edges have missing lengths at a given hybrid node, then the hybrid node is assumed to be as close to the root as possible, that is, the reticulation is assumed &quot;zipped-up&quot; with one of its hybrid edges of length 0.</li><li>If a major hybrid edge has a missing length, then the hybrid node height will be calculated using the node height and edge length of the minor parent with the largest inheritance γ (with a warning). If the major hybrid edge lacks a length and all non-missing minor edges lack an inheritance γ or have the same value, then an error is thrown.</li></ul><p>A warning is issued, unless <code>warn=false</code>, if the network is not time-consistent.</p><p>See also: <a href="#PhyloNetworks.istimeconsistent"><code>istimeconsistent</code></a>, <a href="#PhyloNetworks.getnodeheights"><code>getnodeheights</code></a> and <a href="#PhyloNetworks.getnodeheights_average"><code>getnodeheights_average</code></a>.</p><pre><code class="language-julia-repl hljs">#node heights of time-consistent networks are the same 
julia&gt; consistent_net = readnewick(&quot;((A:2.5,#H1:1.5::0.4):0.25,(C:1.5,(B:1)#H1:0.5::0.6):1.25);&quot;);

julia&gt; heights = getnodeheights(consistent_net)
7-element Vector{Float64}:
 0.0
 1.25
 2.75
 0.25
 1.75
 2.75
 2.75

julia&gt; heights_average = getnodeheights_average(consistent_net);

julia&gt; heights_major = getnodeheights_majortree(consistent_net);

julia&gt; heights == heights_average == heights_major  
true</code></pre><pre><code class="language-julia-repl hljs">#inconsistent networks give different results
julia&gt; inconsistent_net = readnewick(&quot;((A:2.5,#H1:1.5::0.4):0.25,(C:1.5,(B:1)#H1:2.5::0.6):1.25);&quot;);

julia&gt; getnodeheights_average(inconsistent_net;warn=false)
7-element Vector{Float64}:
 0.0
 1.25
 2.75
 0.25
 2.95
 3.95
 2.75

julia&gt; getnodeheights_majortree(inconsistent_net;warn=false) 
7-element Vector{Float64}:
 0.0
 1.25
 2.75
 0.25
 3.75
 4.75
 2.75
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L1083-L1152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><a class="docstring-binding" href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.getparent</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getparent(edge)
getparent(node)
getparentminor(node)
getparents(node)</code></pre><p>Get parental <strong>node(s)</strong>.</p><ul><li><code>getparent</code>: <strong>major</strong> (or only) parent node of <code>edge</code> or <code>node</code></li><li><code>getparentminor</code>: minor parent node of <code>node</code></li><li><code>getparents</code>: vector of all parent nodes of <code>node</code>.</li></ul><pre><code class="language-julia hljs">getparentedge(node)
getparentedgeminor(node)</code></pre><p>Get one parental <strong>edge</strong> of a <code>node</code>.</p><ul><li><code>getparentedge</code>: major parent edge. For a tree node, it&#39;s its only parent edge.</li><li><code>getparentedgeminor</code>: minor parent edge, if <code>node</code> is hybrid (with an error if <code>node</code> has no minor parent).</li></ul><p>If <code>node</code> has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.</p><p><em>Warning</em>: these functions use the field <code>ischild1</code> of edges.</p><p>See also: <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a>, <a href="#PhyloNetworks.getpartneredge-Tuple{Any}"><code>getpartneredge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L239-L265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getparentedge"><a class="docstring-binding" href="#PhyloNetworks.getparentedge"><code>PhyloNetworks.getparentedge</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getparent(edge)
getparent(node)
getparentminor(node)
getparents(node)</code></pre><p>Get parental <strong>node(s)</strong>.</p><ul><li><code>getparent</code>: <strong>major</strong> (or only) parent node of <code>edge</code> or <code>node</code></li><li><code>getparentminor</code>: minor parent node of <code>node</code></li><li><code>getparents</code>: vector of all parent nodes of <code>node</code>.</li></ul><pre><code class="language-julia hljs">getparentedge(node)
getparentedgeminor(node)</code></pre><p>Get one parental <strong>edge</strong> of a <code>node</code>.</p><ul><li><code>getparentedge</code>: major parent edge. For a tree node, it&#39;s its only parent edge.</li><li><code>getparentedgeminor</code>: minor parent edge, if <code>node</code> is hybrid (with an error if <code>node</code> has no minor parent).</li></ul><p>If <code>node</code> has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.</p><p><em>Warning</em>: these functions use the field <code>ischild1</code> of edges.</p><p>See also: <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a>, <a href="#PhyloNetworks.getpartneredge-Tuple{Any}"><code>getpartneredge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L297">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getparentedgeminor"><a class="docstring-binding" href="#PhyloNetworks.getparentedgeminor"><code>PhyloNetworks.getparentedgeminor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getparent(edge)
getparent(node)
getparentminor(node)
getparents(node)</code></pre><p>Get parental <strong>node(s)</strong>.</p><ul><li><code>getparent</code>: <strong>major</strong> (or only) parent node of <code>edge</code> or <code>node</code></li><li><code>getparentminor</code>: minor parent node of <code>node</code></li><li><code>getparents</code>: vector of all parent nodes of <code>node</code>.</li></ul><pre><code class="language-julia hljs">getparentedge(node)
getparentedgeminor(node)</code></pre><p>Get one parental <strong>edge</strong> of a <code>node</code>.</p><ul><li><code>getparentedge</code>: major parent edge. For a tree node, it&#39;s its only parent edge.</li><li><code>getparentedgeminor</code>: minor parent edge, if <code>node</code> is hybrid (with an error if <code>node</code> has no minor parent).</li></ul><p>If <code>node</code> has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.</p><p><em>Warning</em>: these functions use the field <code>ischild1</code> of edges.</p><p>See also: <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a>, <a href="#PhyloNetworks.getpartneredge-Tuple{Any}"><code>getpartneredge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L306">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getparentminor"><a class="docstring-binding" href="#PhyloNetworks.getparentminor"><code>PhyloNetworks.getparentminor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getparent(edge)
getparent(node)
getparentminor(node)
getparents(node)</code></pre><p>Get parental <strong>node(s)</strong>.</p><ul><li><code>getparent</code>: <strong>major</strong> (or only) parent node of <code>edge</code> or <code>node</code></li><li><code>getparentminor</code>: minor parent node of <code>node</code></li><li><code>getparents</code>: vector of all parent nodes of <code>node</code>.</li></ul><pre><code class="language-julia hljs">getparentedge(node)
getparentedgeminor(node)</code></pre><p>Get one parental <strong>edge</strong> of a <code>node</code>.</p><ul><li><code>getparentedge</code>: major parent edge. For a tree node, it&#39;s its only parent edge.</li><li><code>getparentedgeminor</code>: minor parent edge, if <code>node</code> is hybrid (with an error if <code>node</code> has no minor parent).</li></ul><p>If <code>node</code> has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.</p><p><em>Warning</em>: these functions use the field <code>ischild1</code> of edges.</p><p>See also: <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a>, <a href="#PhyloNetworks.getpartneredge-Tuple{Any}"><code>getpartneredge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L276">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getparents"><a class="docstring-binding" href="#PhyloNetworks.getparents"><code>PhyloNetworks.getparents</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getparent(edge)
getparent(node)
getparentminor(node)
getparents(node)</code></pre><p>Get parental <strong>node(s)</strong>.</p><ul><li><code>getparent</code>: <strong>major</strong> (or only) parent node of <code>edge</code> or <code>node</code></li><li><code>getparentminor</code>: minor parent node of <code>node</code></li><li><code>getparents</code>: vector of all parent nodes of <code>node</code>.</li></ul><pre><code class="language-julia hljs">getparentedge(node)
getparentedgeminor(node)</code></pre><p>Get one parental <strong>edge</strong> of a <code>node</code>.</p><ul><li><code>getparentedge</code>: major parent edge. For a tree node, it&#39;s its only parent edge.</li><li><code>getparentedgeminor</code>: minor parent edge, if <code>node</code> is hybrid (with an error if <code>node</code> has no minor parent).</li></ul><p>If <code>node</code> has multiple major (resp. minor) parent edges, the first one would be returned without any warning or error.</p><p><em>Warning</em>: these functions use the field <code>ischild1</code> of edges.</p><p>See also: <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a>, <a href="#PhyloNetworks.getpartneredge-Tuple{Any}"><code>getpartneredge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getpartneredge-Tuple{Any}"><a class="docstring-binding" href="#PhyloNetworks.getpartneredge-Tuple{Any}"><code>PhyloNetworks.getpartneredge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getpartneredge(edge::Edge)
getpartneredge(edge::Edge, node::Node)</code></pre><p>Edge that is the hybrid partner of <code>edge</code>, meaning that is has the same child <code>node</code> as <code>edge</code>. This child <code>node</code> is given as an argument in the second method. Assumptions, not checked:</p><ul><li>no in-coming polytomy: a node has 0, 1 or 2 parents, no more</li><li>when <code>node</code> is given, it is assumed to be the child of <code>edge</code> (the first method calls the second).</li></ul><p>See also: <a href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getparent</code></a>, <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L316-L329">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.getroot-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.getroot-Tuple{HybridNetwork}"><code>PhyloNetworks.getroot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getroot(net)</code></pre><p>Node used to root <code>net</code>. If <code>net</code> is to be considered as semi-directed or unrooted, this root node is used to write the networks&#39; Newick parenthetical description or for network traversals.</p><p>See also: <a href="#PhyloNetworks.isrootof-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>isrootof</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L138-L146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.hardwiredcluster-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Union{AbstractVector{Int64}, AbstractVector{String}}}"><a class="docstring-binding" href="#PhyloNetworks.hardwiredcluster-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Union{AbstractVector{Int64}, AbstractVector{String}}}"><code>PhyloNetworks.hardwiredcluster</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hardwiredcluster(edge::Edge, taxa::Union{AbstractVector{String},AbstractVector{Int}})
hardwiredcluster!(v::Vector{Bool}, edge::Edge, taxa)
hardwiredcluster!(v::Vector{Bool}, edge::Edge, taxa, visited::Vector{Int})</code></pre><p>Calculate the hardwired cluster of <code>edge</code>, coded as a vector of booleans: true for taxa that are descendent of the edge, false for other taxa (including missing taxa).</p><p>The edge should belong in a rooted network for which <code>ischild1</code> is up-to-date. Run <code>directedges!</code> beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.</p><p>visited: vector of node numbers, of all visited nodes.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net5 = &quot;(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));&quot; |&gt; readnewick |&gt; directedges! ;

julia&gt; taxa = net5 |&gt; tiplabels # ABC EF D
6-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;C&quot;
 &quot;E&quot;
 &quot;F&quot;
 &quot;D&quot;

julia&gt; hardwiredcluster(net5.edge[12], taxa) # descendants of 12th edge = CEF
6-element Vector{Bool}:
 0
 0
 1
 1
 1
 0</code></pre><p>See also <a href="#PhyloNetworks.hardwiredclusterdistance-Tuple{HybridNetwork, HybridNetwork, Bool}"><code>hardwiredclusterdistance</code></a> and <a href="#PhyloNetworks.hardwiredclusters-Tuple{HybridNetwork, Union{AbstractVector{Int64}, AbstractVector{String}}}"><code>hardwiredclusters</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/compareNetworks.jl#L158-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.hardwiredclusterdistance-Tuple{HybridNetwork, HybridNetwork, Bool}"><a class="docstring-binding" href="#PhyloNetworks.hardwiredclusterdistance-Tuple{HybridNetwork, HybridNetwork, Bool}"><code>PhyloNetworks.hardwiredclusterdistance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hardwiredclusterdistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)</code></pre><p>Hardwired cluster distance between the topologies of <code>net1</code> and <code>net2</code>, that is, the number of hardwired clusters found in one network and not in the other (with multiplicity, see below).</p><p>If the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, then both networks are considered as semi-directed.</p><p>Networks are assumed bicombining (each hybrid has exactly 2 parents, no more).</p><p><strong>Dissimilarity vs distance</strong></p><p>This is <em>not</em> a distance per se on the full space of phylogenetic networks: there are pairs of distinct networks for which this dissimilarity is 0. But it is a distance on some classes of networks, such as the class of tree-child networks that are &quot;normal&quot; (without shortcuts), or the class of tree-child networks that can be assigned node ages such that hybrid edges have length 0 and tree edges have non-negative lengths. See <a href="https://doi.org/10.1016/j.mbs.2007.11.003">Cardona, Rossello &amp; Valiente (2008)</a>, <a href="https://doi.org/10.1109/TCBB.2008.70">Cardona, Llabres, Rossello &amp; Valiente (2008)</a>, and <a href="https://doi.org/10.1017/CBO9780511974076">Huson, Rupp, Scornavacca (2010)</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net1 = readnewick(&quot;(t6,(t5,((t4,(t3,((t2,t1))#H1)),#H1)));&quot;);

julia&gt; taxa = sort(tiplabels(net1)); # t1 through t6, sorted alphabetically

julia&gt; # using PhyloPlots; plot(net1, showedgenumber=true);

julia&gt; # in matrix below: column 1: edge number. last column: tree (10) vs hybrid (11) edge
       # middle columns: for &#39;taxa&#39;: t1,...t6. 1=descendant, 0=not descendant
       hardwiredclusters(net1, taxa)
6×8 Matrix{Int64}:
 13  1  1  1  1  1  0  10
 12  1  1  1  1  0  0  10
 10  1  1  1  1  0  0  10
  9  1  1  1  0  0  0  10
  8  1  1  0  0  0  0  11
  7  1  1  0  0  0  0  10

julia&gt; net2 = readnewick(&quot;(t6,(t5,((t4,(t3)#H1),(#H1,(t1,t2)))));&quot;);

julia&gt; hardwiredclusters(net2, taxa)
6×8 Matrix{Int64}:
 13  1  1  1  1  1  0  10
 12  1  1  1  1  0  0  10
  6  0  0  1  1  0  0  10
  5  0  0  1  0  0  0  11
 11  1  1  1  0  0  0  10
 10  1  1  0  0  0  0  10

julia&gt; hardwiredclusterdistance(net1, net2, true) # true: as rooted networks
4</code></pre><p><strong>What is a hardwired cluster?</strong></p><p>Each edge in a network is associated with its <em>hardwired cluster</em>, that is, the set of all its descendant taxa (leaves). The set of hardwired cluster of a network is the set of its edges&#39; hardwired clusters. The dissimilarity <code>d_hard</code> defined in <a href="https://doi.org/10.1017/CBO9780511974076">Huson, Rupp, Scornavacca (2010)</a> is the number of hardwired clusters that are in one network but not in the other.</p><p>This implementation is a slightly more discriminative version of <code>d_hard</code>, where each cluster is counted with multiplicity and annotated with its edge&#39;s hybrid status, as follows:</p><ul><li>External edges are not counted (they are tree edges to a leaf, shared by all phylogenetic networks).</li><li>A cluster is counted for each edge for which it&#39;s the hardwired cluster.</li><li>At a given hybrid node, both hybrid partner edges have the same cluster, so this cluster is only counted once for both partners.</li><li>A given cluster is matched between the two networks only if it&#39;s the cluster from a tree edge in both networks, or from a hybrid edge in both networks.</li></ul><p>In the example above, <code>net1</code> has a shortcut (hybrid edge 11) resulting in 2 tree edges (12 and 10) with the same cluster {t1,t2,t3,t4}. So cluster {t1,t2,t3,t4} has multiplicity 2 in <code>net1</code>. <code>net2</code> also has this cluster, but only associated with 1 tree edge, so this cluster contributes (2-1)=1 towards the hardwired cluster distance between the two networks. The distance of 4 corresponds to these 4 clusters:</p><ul><li>{t1,t2,t3,t4}: twice in net1, once in net2</li><li>{t3,t4}: absent in net1, once in net2</li><li>{t1,t2}: twice in net1 (from a hybrid edge &amp; a tree edge), once in net2</li><li>{t3}: absent in net1 (because external edges are not counted), once in net2 (from a hybrid edge).</li></ul><p>Degree-2 nodes cause multiple edges to have the same cluster, so counting clusters with multiplicity distinguishes a network with extra degree-2 nodes from the &quot;same&quot; network after these nodes have been suppressed (e.g. with <a href="../internals/#PhyloNetworks.fuseedgesat!"><code>PhyloNetworks.fuseedgesat!</code></a> or <a href="../internals/#PhyloNetworks.shrinkedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.shrinkedge!</code></a>).</p><p><strong>Networks as semi-directed</strong></p><p>If <code>rooted</code> is false and one of the phylogenies is not a tree (1+ reticulations), then all degree-2 nodes are removed before comparing the hardwired clusters, and the minimum distance is returned over all possible ways to root the networks at internal nodes.</p><p>See also: <a href="#PhyloNetworks.hardwiredclusters-Tuple{HybridNetwork, Union{AbstractVector{Int64}, AbstractVector{String}}}"><code>hardwiredclusters</code></a>, <a href="#PhyloNetworks.hardwiredcluster-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Union{AbstractVector{Int64}, AbstractVector{String}}}"><code>hardwiredcluster</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/compareNetworks.jl#L740-L842">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.hardwiredclusters-Tuple{HybridNetwork, Union{AbstractVector{Int64}, AbstractVector{String}}}"><a class="docstring-binding" href="#PhyloNetworks.hardwiredclusters-Tuple{HybridNetwork, Union{AbstractVector{Int64}, AbstractVector{String}}}"><code>PhyloNetworks.hardwiredclusters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hardwiredclusters(net::HybridNetwork, taxon_labels)</code></pre><p>Returns a matrix describing all the hardwired clusters in a network, with taxa listed in same order as in <code>taxon_labels</code> to describe their membership in each cluster. Allows for missing taxa, with entries all 0.</p><p>Warnings:</p><ul><li>clusters are rooted, so the root must be correct.</li><li>each hybrid node is assumed to have exactly 2 parents (no more).</li></ul><p>Each row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).</p><ul><li>first column: edge number</li><li>next columns: 0/1. 1=descendant of edge, 0=not a descendant, or missing taxon.</li><li>last column:  10/11 values. 10=tree edge, 11=hybrid edge</li></ul><p>See also <a href="#PhyloNetworks.hardwiredclusterdistance-Tuple{HybridNetwork, HybridNetwork, Bool}"><code>hardwiredclusterdistance</code></a> and <a href="#PhyloNetworks.hardwiredcluster-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Union{AbstractVector{Int64}, AbstractVector{String}}}"><code>hardwiredcluster</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/compareNetworks.jl#L61-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.hashybridladder-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.hashybridladder-Tuple{HybridNetwork}"><code>PhyloNetworks.hashybridladder</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hashybridladder(net::HybridNetwork)</code></pre><p>Return true if <code>net</code> contains a hybrid ladder: where a hybrid node&#39;s child is itself a hybrid node. This makes the network not treechild, assuming it is fully resolved. (One of the nodes does not have any tree-node child).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L1656-L1663">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.hassinglechild-Tuple{PhyloNetworks.Node}"><a class="docstring-binding" href="#PhyloNetworks.hassinglechild-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.hassinglechild</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hassinglechild(node)</code></pre><p><code>true</code> if <code>node</code> has a single child, based on the edges&#39; <code>ischild1</code> field; <code>false</code> otherwise.</p><p>See also: <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a>, <a href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getparent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L185-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.hybridclades_support-Tuple{Vector{HybridNetwork}, HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.hybridclades_support-Tuple{Vector{HybridNetwork}, HybridNetwork}"><code>PhyloNetworks.hybridclades_support</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hybridclades_support(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)</code></pre><p>Match hybrid nodes in a reference network with those in an array of networks, like bootstrap networks or in a posterior sample of networks. All networks must be fully resolved, and on the same taxon set. If <code>rooted=true</code>, all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).</p><p>Two hybrid edges in two networks are said to match if they share the same &quot;hybrid&quot; clade (or recipient) and the same &quot;donor clade&quot;, which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with γ&gt;0.5) and one is its minor sister (following the major hybrid edge with γ&lt;0.5).</p><p>To calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If <code>rooted=false</code>, sister clades are considered as bipartitions.</p><p>Output:</p><ol><li>a &quot;node&quot; data frame (see below)</li><li>an &quot;edge&quot; data frame (see below)</li><li>a &quot;clade&quot; data frame to describe the make up of all clades found as hybrids or sisters, starting with a column <code>taxa</code> that lists all taxa. All other columns correspond to a given clade and contain true/false values. <code>true</code> means that a given taxon belongs in a given clade. For a clade named <code>H1</code>, for instance, and if the data frame was named <code>cla</code>, the list of taxa in this clade can be obtained with <code>cla[:taxa][cla[:H1]]</code>.</li><li>an array of gamma values, with one row for each network in the sample and two columns (major/minor) for each hybrid edge in the reference network. If this hybrid edge was found in the sampled network (i.e. same hybrid and sister clades, after removal of all other hybrid nodes), its inheritcance gamma value is recorded here. Otherwise, the gamma entry is 0.0.</li><li>a vector with the number of each hybrid edge in the reference network, in the same order as for the columns in the array of gamma values above.</li></ol><p>The &quot;node&quot; data frame has one row per clade and 9 columns giving:</p><ul><li><code>:clade</code>: the clade&#39;s name, like the taxon name (if a hybrid is a single taxon) or the hybrid tag (like &#39;H1&#39;) in the reference network</li><li><code>:node</code>: the node number in the reference network. missing if the clade is not in this network.</li><li><code>:hybridnode</code>: typically the same node number as above, except for hybrid clades in the reference network. For those, the hybrid node number is listed here.</li><li><code>:edge</code>: number of the parent edge, parent to the node in column 2, if found in the ref network. missing otherwise.</li><li><code>:BS_hybrid</code>: percentage of sample networks in which the clade is found to be a hybrid clade.</li><li><code>:BS_sister</code>: percentage of sample networks in which the clade is found to be sister to some hybrid clade (sum of the next 2 columns)</li><li><code>:BS_major_sister</code>: percentage of sample networks in which the clade is found to be the major sister to some hybrid clade</li><li><code>:BS_minor_sister</code>: same as previous, but minor</li><li><code>:BS_hybrid_samesisters</code>: percentage of sample networks in which the clade is found to be a hybrid and with the same set of sister clades as in the reference network. Applies to hybrid clades found in the reference network only, missing for all other clades.</li></ul><p>The &quot;edge&quot; data frame has one row for each pair of clades, and 8 columns:</p><ul><li><code>:edge</code>: hybrid edge number, if the edge appears in the reference network. missing otherwise.</li><li><code>:hybrid_clade</code>: name of the clade found to be a hybrid, descendent of &#39;edge&#39;</li><li><code>:hybrid</code>: node number of that clade, if it appears in the reference network. missing otherwise.</li><li><code>:sister_clade</code>: name of the clade that is sister to &#39;edge&#39;, i.e. be sister to a hybrid</li><li><code>:sister</code>: node number of that clade, if in the ref network.</li><li><code>:BS_hybrid_edge</code>: percentage of sample networks in which &#39;edge&#39; is found to be a hybrid  edge, i.e. when the clade in the &#39;hybrid&#39; column is found to be a hybrid and the clade in  the &#39;sister&#39; column is one of its sisters.</li><li><code>:BS_major</code>: percentage of sample networks in which &#39;edge&#39; is found to be a major hybrid  edge, i.e. when &#39;hybrid&#39; is found to be a hybrid clade and &#39;sister&#39; is found to be its  major sister.</li><li><code>:BS_minor</code>: same as previous, but minor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/bootstrap.jl#L154-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.hybridlambdaformat-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.hybridlambdaformat-Tuple{HybridNetwork}"><code>PhyloNetworks.hybridlambdaformat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hybridlambdaformat(net::HybridNetwork; prefix=&quot;I&quot;)</code></pre><p>Output <code>net</code> as a string in the format that the <a href="https://github.com/hybridLambda/hybrid-Lambda">Hybrid-Lambda</a> simulator expects, namely:</p><ul><li>all internal nodes are named, including the root, with names that are unique and start with a letter.</li><li>hybrid nodes are written as <code>H6#γ1:length1</code> and <code>H6#γ1:length2</code> instead of <code>#H6:length1::γ1</code> and <code>#H6:length2::γ2</code> (note the samme γ value expected by Hybrid-Lambda)</li></ul><p>This is a modified version of the <a href="https://doi.org/10.1186/1471-2105-9-532">extended Newick</a> format.</p><p>Optional keyword argument <code>prefix</code>: must start with a letter, other than &quot;H&quot;. Internal nodes are given names like &quot;I1&quot;, &quot;I2&quot;, etc. Existing internal non-hybrid node names are <strong>replaced</strong>, which is crucial if some of them don&#39;t start with a letter (e.g. in case node names are bootstrap values). See <a href="#PhyloNetworks.nameinternalnodes!"><code>nameinternalnodes!</code></a> to add node names.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;((a:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);&quot;);

julia&gt; hybridlambdaformat(net) # net is unchanged here
&quot;((a:1.0,(b:1.0)H1#0.8:1.0)I1:5.0,(H1#0.8:0.0,c:1.0)I2:1.0)I3;&quot;

julia&gt; # using PhyloPlots; plot(net, shownodenumber=true) # shows that node -2 is the root

julia&gt; rotate!(net, -2)

julia&gt; writenewick(net) # now the minor edge with γ=0.2 appears first
&quot;((#H1:0.0::0.2,c:1.0):1.0,(a:1.0,(b:1.0)#H1:1.0::0.8):5.0);&quot;

julia&gt; hybridlambdaformat(net)
&quot;((H1#0.2:0.0,c:1.0)I2:1.0,(a:1.0,(b:1.0)H1#0.2:1.0)I1:5.0)I3;&quot;

julia&gt; net = readnewick(&quot;((((B)#H1:::.6)#H2,((D,C,#H2:::0.8),(#H1,A))));&quot;); # 2 reticulations, no branch lengths

julia&gt; writenewick(net, round=true)
&quot;(#H2:::0.2,((D,C,((B)#H1:::0.6)#H2:::0.8),(#H1:::0.4,A)));&quot;

julia&gt; hybridlambdaformat(net; prefix=&quot;int&quot;)
&quot;(H2#0.2,((D,C,((B)H1#0.6)H2#0.2)int1,(H1#0.6,A)int2)int3)int4;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/readwrite.jl#L1335-L1382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.ischildof"><a class="docstring-binding" href="#PhyloNetworks.ischildof"><code>PhyloNetworks.ischildof</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isparentof(node, edge)
ischildof(node, edge)</code></pre><p><code>true</code> if <code>node</code> is the tail / head, or parent / child, of <code>edge</code>; <code>false</code> otherwise. Assumes that the edge&#39;s direction is correct, meaning its field <code>ischild1</code> is reliable (in sync with the rooting).</p><p>See also: <a href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getparent</code></a>, <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a>, <a href="#PhyloNetworks.isrootof-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>isrootof</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.isexternal"><a class="docstring-binding" href="#PhyloNetworks.isexternal"><code>PhyloNetworks.isexternal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isrootof(node, net)</code></pre><p><code>true</code> if <code>node</code> is the root of <code>net</code> (or used as such for network traversals in case the network is considered as semi-directed); <code>false</code> otherwise.</p><pre><code class="language-julia hljs">isleaf(node)
isexternal(edge)</code></pre><p><code>true</code> if <code>node</code> is a leaf or <code>edge</code> is adjacent to a leaf, <code>false</code> otherwise.</p><p>See also: <a href="#PhyloNetworks.getroot-Tuple{HybridNetwork}"><code>getroot</code></a>, <a href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getparent</code></a>, <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.isgalled"><a class="docstring-binding" href="#PhyloNetworks.isgalled"><code>PhyloNetworks.isgalled</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isgalled(net::HybridNetwork, checkpreorder::Bool=true)</code></pre><p><code>true</code> (resp. <code>false</code>) if <code>net</code> is (resp. is not) a galled network, assuming that <code>net</code> is bicombining (every hybrid has exactly 2 parents). A network is galled if every hybrid node is contained in a cycle that has its 2 hybrid parent edges and otherwise tree edges only. See for example <a href="https://doi.org/10.1017/CBO9780511974076">Huson, Rupp &amp; Scornavacca (2010)</a> and <a href="https://doi.org/10.1016/j.ic.2016.11.001">Gunawan, DasGupta &amp; Zhang (2017)</a>. Equivalently, a bicombining network is galled if, for any hybrid node <code>n</code>, both of its parent edges originate from the same tree component. We get the tree components by deleting all hybrid edges from the network: we are left with a forest of trees.</p><p>The network is traversed in preorder (from the root to the leaves). Turn <code>checkpreorder</code> to <code>false</code> if the pre-ordering was run and is known to be up-to-date. Assumption: tree edges are directly correctly according to the current root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L1740-L1758">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.isleaf"><a class="docstring-binding" href="#PhyloNetworks.isleaf"><code>PhyloNetworks.isleaf</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isrootof(node, net)</code></pre><p><code>true</code> if <code>node</code> is the root of <code>net</code> (or used as such for network traversals in case the network is considered as semi-directed); <code>false</code> otherwise.</p><pre><code class="language-julia hljs">isleaf(node)
isexternal(edge)</code></pre><p><code>true</code> if <code>node</code> is a leaf or <code>edge</code> is adjacent to a leaf, <code>false</code> otherwise.</p><p>See also: <a href="#PhyloNetworks.getroot-Tuple{HybridNetwork}"><code>getroot</code></a>, <a href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getparent</code></a>, <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.isparentof-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><a class="docstring-binding" href="#PhyloNetworks.isparentof-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.isparentof</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isparentof(node, edge)
ischildof(node, edge)</code></pre><p><code>true</code> if <code>node</code> is the tail / head, or parent / child, of <code>edge</code>; <code>false</code> otherwise. Assumes that the edge&#39;s direction is correct, meaning its field <code>ischild1</code> is reliable (in sync with the rooting).</p><p>See also: <a href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getparent</code></a>, <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a>, <a href="#PhyloNetworks.isrootof-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>isrootof</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L171-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.isrootof-Tuple{PhyloNetworks.Node, HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.isrootof-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>PhyloNetworks.isrootof</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isrootof(node, net)</code></pre><p><code>true</code> if <code>node</code> is the root of <code>net</code> (or used as such for network traversals in case the network is considered as semi-directed); <code>false</code> otherwise.</p><pre><code class="language-julia hljs">isleaf(node)
isexternal(edge)</code></pre><p><code>true</code> if <code>node</code> is a leaf or <code>edge</code> is adjacent to a leaf, <code>false</code> otherwise.</p><p>See also: <a href="#PhyloNetworks.getroot-Tuple{HybridNetwork}"><code>getroot</code></a>, <a href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getparent</code></a>, <a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>getchild</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L149-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.istimeconsistent"><a class="docstring-binding" href="#PhyloNetworks.istimeconsistent"><code>PhyloNetworks.istimeconsistent</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">istimeconsistent(net, checkpreorder::Bool=true)</code></pre><p>True (resp. false) if <code>net</code> network is (resp. is not) time-consistent. A network is time-consistent if for any node <code>v</code>, all paths from the root to <code>v</code> have the same length. It is sufficient to check this condition at nodes <code>v</code> that are hybrid nodes.</p><p>See also <a href="#PhyloNetworks.getnodeheights"><code>getnodeheights</code></a> and <a href="#PhyloNetworks.getnodeheights_average"><code>getnodeheights_average</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L1159-L1168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.istreechild-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.istreechild-Tuple{HybridNetwork}"><code>PhyloNetworks.istreechild</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">istreechild(net::HybridNetwork)</code></pre><p>Tuple <code>(rooted, semi_weakly, semi_strongly)</code> in which each element is true or false, to indicate if <code>net</code> is / is not</p><ul><li>tree-child as a rooted network</li><li>weakly tree-child as a semidirected network</li><li>strongly tree-child as a semidirected network</li></ul><p>A rooted network is tree-child if all of its internal nodes have at least one child that is a tree node (or equivalently, one child edge that is a tree edge). A semidirected network is strongly (resp. weakly) tree-child if all (resp. at least one) of its rooted partners are tree-child.</p><p>Note that degree-2 nodes are not suppressed: a degree-2 node with a single hybrid child causes the network to <em>not</em> be tree-child, despite the fact that suppressing this node may render the reduced network tree-child.</p><p>Assumes that tree edges are directly correctly according to the current root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L1673-L1692">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.leaststableancestor"><a class="docstring-binding" href="#PhyloNetworks.leaststableancestor"><code>PhyloNetworks.leaststableancestor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">leaststableancestor(net, preorder=true, preprocess=true)</code></pre><p>Tuple <code>(lsa, lsa_index)</code> where <code>lsa</code> is the least stable ancestor (LSA) node of the full network <code>net</code>, and <code>lsa_index</code> is the index of <code>lsa</code> in <code>net.vec_node</code>. The LSA the lowest node <code>n</code> with the following property: <em>any</em> path between <em>any</em> leaf and the root must go through <code>n</code>. All such nodes with this property are ancestral to the LSA (and therefore must have an index that is lower or equal to <code>lsa_index</code>).</p><p>Exception: if the network has a single leaf, the output <code>lsa</code> is the leaf&#39;s parent node, to maintain one external edge between the root and the leaf.</p><p>Arguments:</p><ul><li><code>preorder</code> to direct edges according to the root and store a pre-ordering of nodes in <code>net.vec_node</code>, if not done earlier on the network (e.g. after a topology modification)</li><li><code>preprocess</code> to recalculate &amp; store the biconnected components with <a href="../internals/#PhyloNetworks.process_biconnectedcomponents!"><code>process_biconnectedcomponents!</code></a>, assuming the preordering was done</li></ul><p><em>Warning</em>: uses <a href="#PhyloNetworks.biconnectedcomponents"><code>biconnectedcomponents</code></a> and <a href="../internals/#PhyloNetworks.biconnectedcomponent_exitnodes"><code>biconnectedcomponent_exitnodes</code></a>, therefore share the same caveats regarding the use of field <code>.intn1</code> and <code>.intn2</code> for nodes; <code>boole2</code> and <code>.inte1</code> for edges. As a positivie side effect, the biconnected components can be recovered via the edges&#39; <code>.inte1</code> field –including the trivial blobs (cut edges).</p><p>See also: <a href="#PhyloNetworks.deleteaboveLSA!"><code>deleteaboveLSA!</code></a>, <a href="#PhyloNetworks.leaststableancestor_matrix"><code>leaststableancestor_matrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/graph_components.jl#L447-L475">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.leaststableancestor_matrix"><a class="docstring-binding" href="#PhyloNetworks.leaststableancestor_matrix"><code>PhyloNetworks.leaststableancestor_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">leaststableancestor_matrix(net, preorder=true)</code></pre><p>Matrix <code>M</code> that contains the least stable ancestor (LSA) of each pair of nodes (tips and internal nodes). If the network is a tree, the least stable ancestor of 2 nodes is just their most recent common ancestor (MRCA). Note that the LSA highly depends on the root placement.</p><p><code>M</code> is of type <a href="../internals/#PhyloNetworks.MatrixTopologicalOrder"><code>MatrixTopologicalOrder</code></a>, which allows to access nodes in various ways in which they are indexed. For example, to get the matrix of LSAs between all pairs tips, with tips ordered as in <code>tiplabels(net)</code>, do <code>M[:tips]</code>. Alternatively, to get the LSA between nodes of topological (pre-order) indices <code>i</code> and <code>j</code>, do <code>M[:all][i,j]</code>.</p><p>Argument <code>preorder</code>: to direct edges according to the root and store a pre-ordering of nodes in <code>net.vec_node</code>. Use <code>preorder=false</code> to skip this, if certain that this step was already done earlier on the network.</p><p>The algorithm traverses the network once, with complexity O(n²) if the network is bicombining (hybrids have 2 parents).</p><p>See also: <a href="#PhyloNetworks.leaststableancestor"><code>leaststableancestor</code></a>, which gets the LSA of the full taxon set, using a different algorithm based on a blob decomposition.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((#H3,(((a1,a2),a3)#H3,(b1,#H1),(b2)#H1))));&quot;);

julia&gt; # using PhyloPlots; plot(net, shownodenumber=true, tipoffset=0.2);

julia&gt; M = leaststableancestor_matrix(net);

julia&gt; tipLSAnode = M[:tips]; # tips listed as in taxa below

julia&gt; taxa = tiplabels(net)
5-element Vector{String}:
 &quot;a1&quot;
 &quot;a2&quot;
 &quot;a3&quot;
 &quot;b1&quot;
 &quot;b2&quot;

julia&gt; tipLSAnum = map(n -&gt; n.number, tipLSAnode) # node number of each LSA
5×5 Matrix{Int64}:
  2  -7   1  -4  -4
 -7   3   1  -4  -4
  1   1   4  -4  -4
 -4  -4  -4   5  -5
 -4  -4  -4  -5   7

julia&gt; using DataFrames

julia&gt; DataFrame(:taxon =&gt; taxa,
                 (Symbol(t) =&gt; tipLSAnum[:,i] for (i,t) in enumerate(taxa))...)
5×6 DataFrame
 Row │ taxon   a1     a2     a3     b1     b2    
     │ String  Int64  Int64  Int64  Int64  Int64 
─────┼───────────────────────────────────────────
   1 │ a1          2     -7      1     -4     -4
   2 │ a2         -7      3      1     -4     -4
   3 │ a3          1      1      4     -4     -4
   4 │ b1         -4     -4     -4      5     -5
   5 │ b2         -4     -4     -4     -5      7
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/graph_components.jl#L505-L571">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.majortree-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.majortree-Tuple{HybridNetwork}"><code>PhyloNetworks.majortree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">majortree(net::HybridNetwork; nofuse::Bool=false, unroot::Bool=false,
          keeporiginalroot::Bool=false)</code></pre><p>Extract the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node.</p><p><code>nofuse</code>: if true, edges and degree-2 nodes are retained during edge removal. Otherwise, at each reticulation the child edge (below the hybrid node) is retained: the major hybrid edge is fused with it.</p><p><code>unroot</code>: is true, the root will be deleted if it becomes of degree 2.</p><p><code>keeporiginalroot</code>: the network&#39;s root is kept even if it becomes of degree 1.</p><p>Warnings:</p><ul><li>if <code>nofuse</code> is true: the hybrid edges that are retained (without fusing) have their γ values unchanged, but their <code>ismajor</code> is changed to true</li><li>assume correct <code>ismajor</code> attributes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/compareNetworks.jl#L640-L660">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.minortreeat"><a class="docstring-binding" href="#PhyloNetworks.minortreeat"><code>PhyloNetworks.minortreeat</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">minortreeat(net::HybridNetwork, hybindex::Integer, nofuse=false, unroot::Bool=false)</code></pre><p>Extract the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i=<code>hybindex</code>), where the minor hybrid edge is kept instead of the major hybrid edge. If <code>nofuse</code> is true, edges are not fused (degree-2 nodes are kept). If <code>unroot</code> is true, the root will be deleted if it becomes of degree 2.</p><p>Warning: assume correct <code>ismajor</code> fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/compareNetworks.jl#L689-L699">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.mudistance_rooted-Tuple{HybridNetwork, HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.mudistance_rooted-Tuple{HybridNetwork, HybridNetwork}"><code>PhyloNetworks.mudistance_rooted</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mudistance_rooted(net1::HybridNetwork, net2::HybridNetwork;
    labels::AbstractVector{&lt;:AbstractString}=sort!(union(tiplabels(net1), tiplabels(net2))),
    preorder::Bool=true)</code></pre><p>Distance or matrix of distances between the networks, considered as rooted, based on their node-based μ-representation: number of nodes in one network whose μ-vector does not match with that of a node in the other network. The μ-vector of a node has n+1 coordinates: one for each tip taxon, and one for hybrids. Each value counts the number of paths starting at the node and ending at a specific leaf, or ending at a hybrid node (any hybrid node).</p><p>See <a href="https://doi.org/10.1109/TCBB.2007.70270">Cardona, Rossello &amp; Valiente (2009)</a> for the original μ-distance, and <a href="https://doi.org/10.1109/TCBB.2024.3361390">Cardona et al. (2024)</a> for the extension using paths ending at hybrids.</p><p>The distance implemented here considers one μ-vector per non-leaf node: without ignoring any non-leaf node (including degree-2 nodes if any), and ignoring leaves whose μ-vectors are trivial.</p><p>Assumption: networks have a single root.</p><p>See also <a href="../internals/#PhyloNetworks.node_murepresentation"><code>node_murepresentation</code></a>.</p><p><strong>keyword arguments</strong></p><ul><li><code>preorder</code> indicates whether to preprocess each network with <a href="#PhyloNetworks.directedges!-Tuple{HybridNetwork}"><code>directedges!</code></a> and <a href="#PhyloNetworks.preorder!-Tuple{HybridNetwork}"><code>preorder!</code></a>.</li><li><code>labels</code>: tip labels that each μ-vector will track, by default the union of taxon labels across both networks. If a taxon is absent from <code>net1</code> (say) but tracked because present in <code>net2</code>, then there are 0 paths from any node in <code>net1</code> to that taxon.</li></ul><p>If the networks have different tip labels, consider pruning leaves that are not shared between them beforehand, using <a href="#PhyloNetworks.deleteleaf!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>deleteleaf!</code></a>, to compare the subnetworks on their shared leaf set.</p><p>If a non-default <code>label</code> set is used, such as the sorted shared taxon set <code>sort!(intersect(tiplabels(net1), tiplabels(net2)))</code>, then the distance may drop, because the number of paths to non-shared taxa will be ignored. But <em>all</em> nodes still count towards the distance, including degree-2 nodes that would be suppressed in subnetworks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/murepresentation.jl#L534-L577">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.mudistance_semidirected-Tuple{HybridNetwork, HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.mudistance_semidirected-Tuple{HybridNetwork, HybridNetwork}"><code>PhyloNetworks.mudistance_semidirected</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mudistance_semidirected(net1::HybridNetwork, net2::HybridNetwork; ...)
mudistance_semidirected(nets::AbstractVector{HybridNetwork}; ...)</code></pre><p>Distance or matrix of distances between the networks, considered as semidirected, based on their edge-based μ-representation: number of edges in one network whose μ-entry does not match with that of an edge in the other network.</p><p>The μ-vector of an edge, assigned some specific direction, has n+1 coordinates: one for each tip taxon, and one for hybrids. Each value counts the number of paths starting with the edge (directed as specified) and ending at a specific leaf, or ending at a (any) hybrid node. For more details, see <a href="https://doi.org/10.1109/TCBBIO.2025.3534780">Maxfield, Xu &amp; Ané 2025</a>. The implementation here departs from Maxfield, Xu &amp; Ané (2025) by considering μ-vectors &quot;extended&quot; with the counts of paths ending at hybrids, as defined on rooted networks by <a href="https://doi.org/10.1109/TCBB.2024.3361390">Cardona et al. (2024)</a>.</p><p>Each μ-entry includes 1 or 2 μ-vector(s) and tag(s) indicating the edge type (e.g. hybrid). The number of μ-vector(s) depends on the direction(s) that an edge may have under different rootings.</p><p>If the networks have different tip labels, the union of all their labels is considered to build μ-vectors, and the resulting distance must be positive. Consider pruning leaves that are not shared between the two networks beforehand, using <a href="#PhyloNetworks.deleteleaf!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>deleteleaf!</code></a>, to compare the subnetworks on their shared leaf set.</p><p>Assumption: networks have a single root.</p><p>See also <a href="../internals/#PhyloNetworks.edge_murepresentation"><code>edge_murepresentation</code></a>.</p><p><strong>keyword arguments</strong></p><ul><li><code>preorder=true</code> indicates whether to preprocess each network with <a href="#PhyloNetworks.directedges!-Tuple{HybridNetwork}"><code>directedges!</code></a> and <a href="#PhyloNetworks.preorder!-Tuple{HybridNetwork}"><code>preorder!</code></a>.</li><li><code>userootμ=false</code> controls whether the root μ-vector in included in the set of μ-entries being compared. It is ignored by default (departing from <a href="https://doi.org/10.1109/TCBBIO.2025.3534780">Maxfield, Xu &amp; Ané 2025</a>) because different root μ-vectors for networks with a single root would cause all μ-entries in their root components to be different.</li><li><code>suppressroot=true</code> to exclude one internal tree edge incident to the root, in case the root is incident to exactly 2 edges which are not both hybrid edges. In that case, re-rooting the network would suppress that internal tree edge, hence its associated μ-entry. This option does <em>not</em> modify the network.</li><li><code>labels</code>: tip labels that each μ-vector will track, by default the union of taxon labels across both networks, sorted alphabetically. If a taxon is absent from <code>net1</code> (say) but tracked because present in <code>net2</code>, then there are 0 paths from any edge in <code>net1</code> to that taxon.</li></ul><p>If the networks have different tip labels, consider pruning leaves that are not shared between them beforehand, using <a href="#PhyloNetworks.deleteleaf!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>deleteleaf!</code></a>, to compare the subnetworks on their shared leaf set.</p><p>If a non-default <code>label</code> set is used, such as the sorted shared taxon set <code>sort!(intersect(tiplabels(net1), tiplabels(net2)))</code>, then the distance may drop, as the number of paths to non-shared taxa will be ignored. But <em>all</em> edges still count towards the distance, whereas edges below degree-2 nodes would be suppressed in subnetworks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/murepresentation.jl#L634-L691">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.nameinternalnodes!"><a class="docstring-binding" href="#PhyloNetworks.nameinternalnodes!"><code>PhyloNetworks.nameinternalnodes!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nameinternalnodes!(net::HybridNetwork, prefix=&quot;i&quot;)</code></pre><p>Add names to nodes in <code>net</code> that don&#39;t already have a name. Leaves already have names; but if not, they will be given names as well. New node names will be of the form &quot;prefixk&quot; where <code>k</code> is an integer. So by default, new node names will be of the form &quot;i1&quot;, &quot;i2&quot;, etc.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;((a:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);&quot;);

julia&gt; nameinternalnodes!(net, &quot;I&quot;) # by default, shown without internal node names
HybridNetwork, Rooted Network
7 edges
7 nodes: 3 tips, 1 hybrid nodes, 3 internal tree nodes.
tip labels: a, b, c
((a:1.0,(b:1.0)#H1:1.0::0.8)I1:5.0,(#H1:0.0::0.2,c:1.0)I2:1.0)I3;

julia&gt; writenewick(net; internallabel=false) # by default, writenewick shows internal names if they exist
&quot;((a:1.0,(b:1.0)#H1:1.0::0.8):5.0,(#H1:0.0::0.2,c:1.0):1.0);&quot;

julia&gt; net = readnewick(&quot;((int5:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);&quot;); # one taxon name starts with &quot;int&quot;

julia&gt; nameinternalnodes!(net, &quot;int&quot;);

julia&gt; writenewick(net)
&quot;((int5:1.0,(b:1.0)#H1:1.0::0.8)int6:5.0,(#H1:0.0::0.2,c:1.0)int7:1.0)int8;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/readwrite.jl#L1421-L1450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.nj-Tuple{DataFrames.DataFrame}"><a class="docstring-binding" href="#PhyloNetworks.nj-Tuple{DataFrames.DataFrame}"><code>PhyloNetworks.nj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nj(D::DataFrame; force_nonnegative_edges::Bool=false)</code></pre><p>Construct a tree from a distance matrix by neighbor joining, where <code>D</code> is a <code>DataFrame</code> of the distance matrix, with taxon names taken from the header of the data frame. The rows are assumed to correspond to tips in the tree in the same order as they do in columns. With <code>force_nonnegative_edges</code> being <code>true</code>, any negative edge length is changed to 0.0 (with a message).</p><p>For the algorithm, see <a href="https://doi.org/10.1093/oxfordjournals.molbev.a040454">Satou &amp; Nei 1987</a>.</p><p>See <a href="../internals/#PhyloNetworks.nj!"><code>nj!</code></a> for using a matrix as input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/nj.jl#L139-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.nni!-Tuple{HybridNetwork, Vararg{Any}}"><a class="docstring-binding" href="#PhyloNetworks.nni!-Tuple{HybridNetwork, Vararg{Any}}"><code>PhyloNetworks.nni!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nni!([rng::AbstractRNG,]
     net::HybridNetwork,
     e::Edge,
     nohybridladder::Bool=true,
     no3cycle::Bool=true,
     constraints::Vector{TopologyConstraint}=TopologyConstraint[]
)</code></pre><p>Attempt to perform a nearest neighbor interchange (NNI) around edge <code>e</code>, randomly chosen among all possible NNIs (e.g 3, sometimes more depending on <code>e</code>) satisfying the constraints, and such that the new network is a DAG. The number of possible NNI moves around an edge depends on whether the edge&#39;s parent/child nodes are tree or hybrid nodes. This is calculated by <a href="../internals/#PhyloNetworks.nnimax-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>nnimax</code></a>.</p><p>The option <code>no3cycle</code> forbids moves that would create a 3-cycle in the network. When <code>no3cycle</code> = false, 2-cycle and 3-cycles may be generated.</p><p>Note that the defaults values are for positional (not keyword) arguments, so two or more arguments can be used, but in a specific order: <code>nni!(net, e)</code> or <code>nni!(net, e, nohybridladder)</code>, <code>nni!(net, e, nohybridladder, no3cycle)</code>, <code>nni!(net, e, nohybridladder, no3cycle, contraints)</code>.</p><p>Assumptions:</p><ul><li>The starting network does not have 3-cycles, if <code>no3cycle=true</code>. No check for the presence of 2- and 3-cycles in the input network.</li><li>The edges&#39; field <code>ischild1</code> is correct in the input network. (This field will be correct in the output network.)</li></ul><p>Output: information indicating how to undo the move or <code>nothing</code> if all NNIs failed.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; str_network = &quot;(((S8,S9),(((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));&quot;;

julia&gt; net = readnewick(str_network);

julia&gt; # using Random; Random.seed!(3); ## commented out for doctest reproducibility across julia versions, but users can use this line to set the seed in their analyses.

julia&gt; undoinfo = nni!(net, net.edge[3], true, true); # true&#39;s to avoid hybrid ladders and 3-cycles</code></pre><p>In the next example, we use a stable RNG to make the example reproducible across julia versions. However, this particular RNG is <em>not</em> recommended. The RNG used by default is better (e.g. much more efficient).</p><pre><code class="language-julia-repl hljs">julia&gt; str_network = &quot;(((S8,S9),(((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));&quot;;

julia&gt; net = readnewick(str_network);

julia&gt; # using Pkg; Pkg.add(&quot;StableRNGs&quot;) # to install StableRNGs if not done earlier

julia&gt; using StableRNGs

julia&gt; rng = StableRNG(791);

julia&gt; undoinfo = nni!(rng, net, net.edge[3], true, true); # true&#39;s to avoid hybrid ladders and 3-cycles

julia&gt; writenewick(net)
&quot;((S9,((((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2,S8)),(#H2,S10));&quot;

julia&gt; nni!(undoinfo...);

julia&gt; writenewick(net) == str_network # net back to original topology: the NNI was &quot;undone&quot;
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/moves_semidirected.jl#L272-L342">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.nni!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><a class="docstring-binding" href="#PhyloNetworks.nni!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.nni!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nni!(αu::Edge, u::Node, uv::Edge, v::Node, vδ::Edge)
nni!(αu,u,uv,v,vδ, flip::Bool, inner::Bool, indices)</code></pre><p>Transform a network locally around the focus edge <code>uv</code> with the following NNI, that detaches u-β and grafts it onto vδ:</p><pre><code class="language-julia hljs">α - u -- v ------ δ
    |    |
    β    γ

α ------ v -- u - δ
         |    |
         γ    β</code></pre><p><code>flip</code> boolean indicates if the uv edge was flipped <code>inner</code> boolean indicates if edges αu and uv both point toward node u, i.e. α-&gt;u&lt;-v&lt;-δ. If this is true, we flip the hybrid status of αu and vδ.</p><p><code>indices</code> give indices for nodes and edges u<em>in</em>αu, αu<em>in</em>u, vδ<em>in</em>v, and v<em>in</em>vδ. These are interpreted as:</p><pre><code class="language-julia hljs">u_in_αu: the index for u in the edge αu
αu_in_u: the index for αu in node u
vδ_in_v: the index for vδ in node v
v_in_vδ: the index for v in edge vδ</code></pre><p><strong>Warnings</strong>:</p><ul><li><em>No</em> check of assumed adjacencies</li><li>Not implemented for cases that are not necessary thanks to symmetry, such as cases covered by <code>nni!(vδ, v, uv, u, αu)</code> or <code>nni!(βu, u, v, vγ)</code>. More specifically, these cases are not implemented (and not checked):<ul><li>u not hybrid &amp; v hybrid</li><li>u hybrid, v not hybrid, α -&gt; u &lt;- v -&gt; δ</li></ul></li><li>Because of this, <code>nni(αu,u,uv,v,vδ, ...)</code> should not be used directly; use instead <code>nni!(uv, move_number)</code>.</li><li>nni!(undoinfo...) restores the topology, but edges below hybrid nodes will have length 0.0 even if they didn&#39;t before.</li></ul><p>Node numbers and edge numbers are not modified. Edge <code>uv</code> keeps its direction unchanged <em>unless</em> the directions were <code>α -&gt; u -&gt; v -&gt; δ</code> or <code>α &lt;- u &lt;- v &lt;- δ</code>, in which case the direction of <code>uv</code> is flipped.</p><p>The second version&#39;s input has the same signature as the output, but will undo the NNI more easily. This means that if <code>output = nni!(input)</code>, then <code>nni!(output...)</code> is valid and undoes the first operation.</p><p>Right now, branch lengths are not modified except when below a hybrid node. Future versions might implement options to modify branch lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/moves_semidirected.jl#L593-L644">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.nni!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, UInt8, Bool, Bool}"><a class="docstring-binding" href="#PhyloNetworks.nni!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, UInt8, Bool, Bool}"><code>PhyloNetworks.nni!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nni!(uv::Edge, nummove::UInt8, nohybridladder::Bool, no3cycle::Bool)</code></pre><p>Modify a network with a nearest neighbor interchange (NNI) around its edge <code>uv</code>. Return the information necessary to undo the NNI, or <code>nothing</code> if the move was not successful (such as if the resulting graph was not acyclic (not a DAG) or if the focus edge is adjacent to a polytomy). If the move fails, the network is not modified. <code>nummove</code> specifies which of the available NNIs is performed.</p><p>rooted-NNI options according to Gambette et al. (2017), fig. 8:</p><ul><li>BB: 2 moves, both to BB, if directed edges. 8 moves if undirected.</li><li>RR: 2 moves, both to RR.</li><li>BR: 3 moves, 1 RB &amp; 2 BRs, if directed. 6 moves if e is undirected.</li><li>RB: 4 moves, all 4 BRs.</li></ul><p>The extra options are due to assuming a semi-directed network, whereas Gambette et al (2017) describe options for rooted networks. On a semi-directed network, there might be a choice of how to direct the edges that may contain the root, e.g. choice of e=uv versus vu, and choice of labelling adjacent nodes as α/β (BB), or as α/γ (BR).</p><p><code>nohybridladder</code> = true prevents moves that would create a hybrid ladder in the network, that is, 2 consecutive hybrid nodes (one parent of the other). <code>no3cycle</code> = true prevents NNI moves that would make a 3-cycle, and assumes that the input network does not have any 2- or 3-cycles. If <code>no3cycle</code> is false, 3-cycles can be generated, but NNIs generating 2-cycles are prevented.</p><p>The edge field <code>ischild1</code> is assumed to be correct in the overall network (that is, in sync with the network&#39;s field <code>.rooti</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/moves_semidirected.jl#L400-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.pairwisetaxondistancematrix-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.pairwisetaxondistancematrix-Tuple{HybridNetwork}"><code>PhyloNetworks.pairwisetaxondistancematrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pairwisetaxondistancematrix(net; type=:average, keepInternal=false,
                            checkpreorder=true, nodeAges=[])</code></pre><p>Return the matrix <code>M</code> of pairwise distances between nodes in the network:</p><ul><li>between all nodes (internal and leaves) if <code>keepInternal=true</code>, in which case the nodes are listed in <code>M</code> in the order in which they appear in <code>net.vec_node</code></li><li>between taxa only otherwise, in which case the nodes are listed in <code>M</code> in the order in which they appear in <code>tiplabels(net)</code> (i.e. same order as in <code>net.leaf</code>)</li></ul><p>Between any two nodes n1 and n2, we consider all up-down paths between n1 and n2: paths starting from n1, going up to a common ancestor then back down to n2. The distance between n1 and n2 associated with an up-down path is the path length, the sum of its edge lengths. Each path also has an inheritance weight γ: the product of γs of all edges on the path, representing the proportion of the genome that took this path.</p><p>By default, the distance <code>type</code> is <code>:average</code> to get a weighted average distance. This is the average of the up-down paths&#39; lengths, weighted by the paths&#39; inheritance γs. It measures the average genetic distance across the genome, if branch lengths are in substitutions/site.</p><p>Other distance types are <code>:maximum</code> or <code>:minimum</code>. They are the maximum (or minimum) length among all up-down paths between two nodes. For either of these distances, the inheritance probabilities γ (or path weights) have no impact.</p><p>Other optional arguments:</p><ul><li><code>checkpreorder</code>: if true, <code>net.vec_node</code> is updated to get a topological ordering of nodes.</li><li><code>nodeAges</code>: if not provided, i.e. empty vector, the network is <em>not</em> modified.   If provided and non-empty, <code>nodeAges</code> should list node ages in the pre-order in which nodes are listed in <code>vec_node</code> (including leaves), and <strong>edge lengths</strong> in <code>net</code> <strong>are modified</strong> accordingly.</li></ul><p>Providing node ages hence makes the network time consistent: such that all paths from the root to a given hybrid node have the same length. If node ages are not provided, the network need not be time consistent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/pairwiseDistanceLS.jl#L62-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.parsimonyGF-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}, Tuple{HybridNetwork, Dict{String, T}, Symbol}} where T"><a class="docstring-binding" href="#PhyloNetworks.parsimonyGF-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}, Tuple{HybridNetwork, Dict{String, T}, Symbol}} where T"><code>PhyloNetworks.parsimonyGF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parsimonyGF(net, tip_dictionary, criterion=:softwired)
parsimonyGF(net, species, sequenceData, criterion=:softwired)</code></pre><p>Calculate the most parsimonious score of a network given discrete characters at the tips using a general framework (Van Iersel et al. 2018) allowing for various parsimony criteria: softwired (default), hardwired, parental etc. Only softwired is implemented at the moment.</p><p>Data can given in one of the following:</p><ul><li><code>tipdata</code>: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named &quot;taxon&quot; or &quot;species&quot;, and  trait values are to appear in column 2 or in a column named &quot;trait&quot;.</li><li><code>tipdata</code>: dictionary taxon =&gt; state, for a single trait.</li><li><code>species</code>: array of strings, and <code>sequences</code>: array of sequences,   in the order corresponding to the order of species names.</li></ul><p><strong>algorithm</strong></p><p>The complexity of the algorithm is exponential in the level of the network, that is, the maximum number of hybridizations in a single blob, or biconnected component (Fischer et al. 2015). The function loops over all the state assignments of the minor parent of each hybrid node within a blob, so its complexity is of the order of <code>n * m * c^2 * c^level</code> where <code>n</code> is the number of tips, <code>m</code> the number of traits and <code>c</code> the number of states.</p><p>See <a href="#PhyloNetworks.parsimonysoftwired-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T"><code>parsimonysoftwired</code></a> for a faster algorithm, but solving the softwired criterion only.</p><p><strong>references</strong></p><ol><li><p>Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).</p></li><li><p>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</p></li></ol><p>Use the recursive helper function <a href="../internals/#PhyloNetworks.parsimonyGF_bottomup!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, Vararg{AbstractArray, 4}}"><code>parsimonyGF_bottomup!</code></a>. Use the fields <code>ischild1</code>, <code>booln4</code> to know which nodes are at the root of a blob, and <code>boole2</code> to know which edges are cut (below the minor parent of each hybrid).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/parsimony.jl#L523-L569">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.parsimonysoftwired-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T"><a class="docstring-binding" href="#PhyloNetworks.parsimonysoftwired-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T"><code>PhyloNetworks.parsimonysoftwired</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parsimonysoftwired(net, tipdata)
parsimonysoftwired(net, species, sequences)</code></pre><p>Calculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network.</p><p>Data can given in one of the following:</p><ul><li><code>tipdata</code>: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named &quot;taxon&quot; or &quot;species&quot;, and  trait values are to appear in column 2 or in a column named &quot;trait&quot;.</li><li><code>tipdata</code>: dictionary taxon =&gt; state, for a single trait.</li><li><code>species</code>: array of strings, and <code>sequences</code>: array of sequences,  in the order corresponding to the order of species names.</li></ul><p><strong>algorithm</strong></p><p>The dynamic programming algorithm by Fischer et al. (2015) is used. The function loops over all the displayed subtrees within a blob (biconnected component), so its complexity is of the order of <code>n * m * c^2 * 2^level</code> where <code>n</code> is the number of tips, <code>m</code> the number of traits, <code>c</code> the number of states, and <code>level</code> is the level of the network: the maximum number of hybridizations within a blob.</p><p>See <a href="#PhyloNetworks.parsimonyGF-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}, Tuple{HybridNetwork, Dict{String, T}, Symbol}} where T"><code>parsimonyGF</code></a> for a different algorithm, slower but extendable to other parsimony criteria.</p><p><strong>references</strong></p><ol><li>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/parsimony.jl#L207-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.preorder!-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.preorder!-Tuple{HybridNetwork}"><code>PhyloNetworks.preorder!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">preorder!(net::HybridNetwork)</code></pre><p>Update attribute <code>net.vec_node</code> in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges&#39; direction needs to be correct before calling <code>preorder!</code>, using <code>directedges!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/manipulateNet.jl#L631-L637">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.printedges-Tuple{Any}"><a class="docstring-binding" href="#PhyloNetworks.printedges-Tuple{Any}"><code>PhyloNetworks.printedges</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">printedges(net)
printedges(io::IO, net)</code></pre><p>Print information on the edges of a <code>HybridNetwork</code> <code>net</code>: edge number, numbers of nodes attached to it, edge length, whether it&#39;s a hybrid edge, its γ inheritance value, whether it&#39;s a major edge, if it could contain the root (this field is not always updated, though) and one more attribute pertaining to level-1 networks used in SNaQ: in which cycle it is contained (-1 if no cycle).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L654-L664">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.printnodes-Tuple{Any}"><a class="docstring-binding" href="#PhyloNetworks.printnodes-Tuple{Any}"><code>PhyloNetworks.printnodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">printnodes(net)
printnodes(io, net)</code></pre><p>Print information on the nodes of a <code>HybridNetwork</code> net: node number, whether it&#39;s a leaf, whether it&#39;s a hybrid node, it&#39;s name (label), its <code>intn1</code> field (for level-1 networks in SNaQ: number given to the cycle in which the node might be, -1 if the node it <em>not</em> in a cycle cycle), and the list of edges attached to it, by their numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L682-L691">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.readfastatodna"><a class="docstring-binding" href="#PhyloNetworks.readfastatodna"><code>PhyloNetworks.readfastatodna</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">readfastatodna(filename::String, countPatterns::Bool=false)</code></pre><p>Read a fasta file to a dataframe containing a column for each site. If <code>countPatterns</code> is true, calculate weights and remove identical site patterns to reduce matrix dimension.</p><p>Return a tuple containing:</p><ol><li>data frame of BioSequence DNA sequences, with taxon names in column 1 followed by a column for each site pattern, in columns 2-npatterns;</li><li>array of weights, one weight for each of the site columns. The length of the weight vector is equal to npatterns.</li></ol><p><strong>Warning</strong>: assumes a <em>semi-sequential</em> format, <em>not interleaved</em>, where each taxon name appears only once. For this one time, the corresponding sequence may be broken across several lines though.</p><p>See also: <a href="../internals/#PhyloNetworks.readfastatoarray"><code>PhyloNetworks.readfastatoarray</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/parsimony.jl#L411-L429">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.readmultinewick"><a class="docstring-binding" href="#PhyloNetworks.readmultinewick"><code>PhyloNetworks.readmultinewick</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">readmultinewick(filename::AbstractString, fast=true)
readmultinewick(newicktrees_list::Vector{&lt;:AbstractString})</code></pre><p>Read a list of networks in parenthetical format, either from a file (one network per line) if the input is a string giving the path to the file, or from a vector of strings with each string corresponding to a newick-formatted topology. By default (<code>fast=true</code>), <code>Functors.fmap</code> is used for repeatedly reading the newick trees into of HybridNetwork-type objects. The option <code>fast=false</code> corresponds to the behavior up until v0.14.3: with a file name as input, it prints a message (without failing) when a phylogeny cannot be parsed, and allows for empty lines. Each network is read with <a href="#PhyloNetworks.readnewick-Tuple{IO}"><code>readnewick</code></a>.</p><p>Return an array of HybridNetwork objects.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; multitreepath = joinpath(dirname(Base.find_package(&quot;PhyloNetworks&quot;)), &quot;..&quot;, &quot;examples&quot;, &quot;multitrees.newick&quot;);
julia&gt; multitree = readmultinewick(multitreepath) # vector of 25 HybridNetworks
julia&gt; multitree = readmultinewick(multitreepath, false) # same but slower &amp; safer
julia&gt; treestrings = readlines(multitreepath) # vector of 25 strings
julia&gt; multitree = readmultinewick(treestrings)
julia&gt; readmultinewick(treestrings, false) # same, but slower</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/readwrite.jl#L919-L948">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.readmultinewick_files-Tuple{AbstractString}"><a class="docstring-binding" href="#PhyloNetworks.readmultinewick_files-Tuple{AbstractString}"><code>PhyloNetworks.readmultinewick_files</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">readmultinewick_files(listfile; relative2listfile=true)</code></pre><p>Read the list of file names in <code>listfile</code>, then read all the trees in each of these files. Output: vector of vectors of trees (networks with h&gt;0 allowed).</p><p><code>listfile</code> should be the name of a file containing the path/name to multiple bootstrap files, one on each line (no header). Each named bootstrap file should contain multiple trees, one per line (such as bootstrap trees from a single gene).</p><p>The path/name to each bootstrap file should be relative to <code>listfile</code>. Otherwise, use option <code>relative2listfile=false</code>, in which case the file names are interpreted as usual: relative to the user&#39;s current directory if not given as absolute paths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/bootstrap.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.readnewick-Tuple{IO}"><a class="docstring-binding" href="#PhyloNetworks.readnewick-Tuple{IO}"><code>PhyloNetworks.readnewick</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">readnewick(file name)
readnewick(parenthetical description)
readnewick(IO)</code></pre><p>Read a tree or network topology from parenthetical format (extended Newick).</p><p>Input: text file or parenthetical format directly. Leading white spaces are ignored. The input string may start with white spaces followed by the file name. The file name may <em>not</em> start with spaces. Also, it may <em>not</em> start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description. Nexus-style comments (<code>[&amp;...]</code>) are ignored, and may be placed after (or instead) of a node name, and before/after an edge length.</p><p>A root edge, not enclosed within a pair a parentheses, is ignored. If the root node ρ0 has a single child edge ρ0 → ρ1, then this initial root ρ0 and its child edge are deleted from the topology. Its initial child ρ1 becomes the new root.</p><p>See also: <a href="#PhyloNetworks.readnexus_treeblock"><code>readnexus_treeblock</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/readwrite.jl#L496-L516">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.readnexus_treeblock"><a class="docstring-binding" href="#PhyloNetworks.readnexus_treeblock"><code>PhyloNetworks.readnexus_treeblock</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">readnexus_treeblock(filename, treereader=readnewick, args...;
                    reticulate=true, stringmodifier=[r&quot;#(\d+)&quot; =&gt; s&quot;#H\1&quot;])</code></pre><p>Read the <em>first</em> &quot;trees&quot; block of a nexus-formatted file, using the translate table if present, and return a vector of <code>HybridNetwork</code>s. Information inside <code>[&amp;...]</code> are interpreted as comments and are discarded by the default tree reader. Optional arguments <code>args</code> are passed to the tree reader.</p><p>For the nexus format, see <a href="https://doi.org/10.1093/sysbio/46.4.590">Maddison, Swofford &amp; Maddison (1997)</a>.</p><p>Unless <code>reticulate</code> is false, the following is done to read networks with reticulations.</p><p>Prior to reading each phylogeny, each instance of <code>#number</code> is replaced by <code>#Hnumber</code> to fit the standard extended Newick format at hybrid nodes. This behavior can be changed with option <code>stringmodifier</code>, which should be a vector of pairs accepted by <code>replace</code>.</p><p>Inheritance γ values are assumed to be given within &quot;comment&quot; blocks at <em>minor</em> hybrid edges (cut as tips to form the extended Newick) like this for example, as output by bacter (<a href="http://dx.doi.org/10.1534/genetics.116.193425">Vaughan et al. 2017</a>):</p><pre><code class="language-julia hljs">#11[&amp;conv=0, relSize=0.08, ...</code></pre><p>or like this, as output by SpeciesNetwork (<a href="https://doi.org/10.1093/molbev/msx307">Zhang et al. 2018</a>):</p><pre><code class="language-julia hljs">#H11[&amp;gamma=0.08]</code></pre><p>In this example, the corresponding edge to hybrid H11 has γ=0.08.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/readwrite.jl#L977-L1008">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.readphylip"><a class="docstring-binding" href="#PhyloNetworks.readphylip"><code>PhyloNetworks.readphylip</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">readphylip(file::AbstractString)</code></pre><p>Read a PHYLIP-formatted DNA sequence alignment (see for example <a href="https://en.wikipedia.org/wiki/PHYLIP#File_format">wikipedia</a>). Currently, only sequential PHYLIP alignments are supported, i.e., each sequence appears on one line. The reader makes no assumption about the length of the sequence identifier so IDs (or taxon names) may be longer than 10 characters. However:</p><ul><li>at least one space is required between the sequence ID and the sequence itself</li><li>spaces are not allowed inside the sequence.</li></ul><p>Output: tuple <code>(species, sequences)</code> where <code>species</code> is a vector of Strings with identifier names, and <code>sequences</code> is a vector of BioSequences, each of type <code>sequencetype</code> (DNA by default)</p><p>See also: <a href="../internals/#PhyloNetworks.readfastatoarray"><code>PhyloNetworks.readfastatoarray</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/readwrite.jl#L1471-L1489">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.removedegree2nodes!"><a class="docstring-binding" href="#PhyloNetworks.removedegree2nodes!"><code>PhyloNetworks.removedegree2nodes!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">removedegree2nodes!(net::HybridNetwork, keeproot::Bool=false)</code></pre><p>Delete <em>all</em> nodes of degree two in <code>net</code>, fusing the two adjacent edges together each time, and return the network. If the network has a degree-2 root and <code>keeproot</code> is false, then the root is eliminated as well, leaving the network unrooted. The only exception to this rule is if the root is incident to 2 (outgoing) hybrid edges. Removing the root should leave a loop-edge (equal end point), which we don&#39;t want to do, to preserve the paths in the original network. In this case, the root is maintained even if <code>keeproot</code> is false. If <code>keeproot</code> is true, then the root is kept even if it&#39;s of degree 2.</p><p>See <a href="../internals/#PhyloNetworks.fuseedgesat!"><code>fuseedgesat!</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((((S1,(S2)#H1),(#H1,S3)))#H2),(#H2,S4));&quot;);

julia&gt; PhyloNetworks.breakedge!(net.edge[3], net); # create a degree-2 node along hybrid edge

julia&gt; PhyloNetworks.breakedge!(net.edge[3], net); # another one: 2 in a row

julia&gt; PhyloNetworks.breakedge!(net.edge[10], net); # another one, elsewhere

julia&gt; writenewick(net) # extra pairs of parentheses
&quot;((#H2,S4),(((((S1,(((S2)#H1))),(#H1,S3)))#H2)));&quot;

julia&gt; removedegree2nodes!(net);

julia&gt; writenewick(net) # even the root is gone
&quot;(#H2,S4,(((S1,(S2)#H1),(#H1,S3)))#H2);&quot;

julia&gt; net = readnewick(&quot;((((C:0.9)I1:0.1)I3:0.1,((A:1.0)I2:0.4)I3:0.6):1.4,(((B:0.2)H1:0.6)I2:0.5)I3:2.1);&quot;);

julia&gt; removedegree2nodes!(net, true);

julia&gt; writenewick(net, round=true) # the root was kept
&quot;((C:1.1,A:2.0):1.4,B:3.4);&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/manipulateNet.jl#L354-L394">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.rootatnode!-Tuple{HybridNetwork, PhyloNetworks.Node}"><a class="docstring-binding" href="#PhyloNetworks.rootatnode!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>PhyloNetworks.rootatnode!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rootatnode!(HybridNetwork, nodeNumber::Integer; index::Bool=false)
rootatnode!(HybridNetwork, Node)
rootatnode!(HybridNetwork, nodeName::AbstractString)</code></pre><p>Root the network/tree object at the node with name &#39;nodeName&#39; or number &#39;nodeNumber&#39; (by default) or with index &#39;nodeNumber&#39; if index=true. Attributes ischild1 and containroot are updated along the way. Use <code>plot(net, shownodenumber=true, showedgelength=false)</code> to visualize and identify a node of interest. (see package <a href="https://github.com/juliaphylo/PhyloPlots.jl">PhyloPlots</a>)</p><p>Return the network.</p><p>Warnings:</p><ul><li><p>If the node is a leaf, the root will be placed along the edge adjacent to the leaf. This might add a new node.</p></li><li><p>If the desired root placement is incompatible with one or more hybrids, then</p><ul><li>the original network is restored with its old root and edges&#39; direction.</li><li>a RootMismatch error is thrown.</li></ul></li></ul><p>See also: <a href="#PhyloNetworks.rootonedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>rootonedge!</code></a>, and <a href="#PhyloNetworks.suppressroot!-Tuple{HybridNetwork}"><code>suppressroot!</code></a> to undo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/manipulateNet.jl#L4-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.rootonedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><a class="docstring-binding" href="#PhyloNetworks.rootonedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.rootonedge!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rootonedge!(HybridNetwork, edgeNumber::Integer; index::Bool=false)
rootonedge!(HybridNetwork, Edge)</code></pre><p>Root the network/tree along an edge with number <code>edgeNumber</code> (by default) or with index <code>edgeNumber</code> if <code>index=true</code>. Attributes <code>ischild1</code> and <code>containroot</code> are updated along the way.</p><p>This adds a new node and a new edge to the network. Use <code>plot(net, showedgenumber=true, showedgelength=false)</code> to visualize and identify an edge of interest. (see package <a href="https://github.com/juliaphylo/PhyloPlots.jl">PhyloPlots</a>)</p><p>See also: <a href="#PhyloNetworks.rootatnode!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>rootatnode!</code></a>, and <a href="#PhyloNetworks.suppressroot!-Tuple{HybridNetwork}"><code>suppressroot!</code></a> to undo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/manipulateNet.jl#L84-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.rotate!-Tuple{HybridNetwork, Integer}"><a class="docstring-binding" href="#PhyloNetworks.rotate!-Tuple{HybridNetwork, Integer}"><code>PhyloNetworks.rotate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rotate!(net::HybridNetwork, nodeNumber::Integer; orderedEdgeNum::Array{Int,1})</code></pre><p>Rotates the order of the node&#39;s children edges. Useful for plotting, to remove crossing edges. If <code>node</code> is a tree node with no polytomy, the 2 children edges are switched and the optional argument <code>orderedEdgeNum</code> is ignored.</p><p>Use <code>plot(net, shownodenumber=true, showedgenumber=false)</code> to map node and edge numbers on the network, as shown in the examples below. (see package <a href="https://github.com/juliaphylo/PhyloPlots.jl">PhyloPlots</a>)</p><p>Warning: assumes that edges are correctly directed (ischild1 updated). This is done by <code>plot(net)</code>. Otherwise run <code>directedges!(net)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; net = readnewick(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
julia&gt; using PhyloPlots
julia&gt; plot(net, shownodenumber=true)
julia&gt; rotate!(net, -4)
julia&gt; plot(net)
julia&gt; net=readnewick(&quot;(4,((1,(2)#H7:::0.864):2.069,(6,5):3.423):0.265,(3,#H7:::0.136):10.0);&quot;);
julia&gt; plot(net, shownodenumber=true, showedgenumber=true)
julia&gt; rotate!(net, -1, orderedEdgeNum=[1,12,9])
julia&gt; plot(net, shownodenumber=true, showedgenumber=true)
julia&gt; rotate!(net, -3)
julia&gt; plot(net)</code></pre><p>Note that <code>LinearAlgebra</code> also exports a function named <code>rotate!</code> in Julia v1.5. If both packages need to be used in Julia v1.5 or higher, usage of <code>rotate!</code> needs to be qualified, such as with <code>PhyloNetworks.rotate!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/manipulateNet.jl#L704-L738">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.setgamma!"><a class="docstring-binding" href="#PhyloNetworks.setgamma!"><code>PhyloNetworks.setgamma!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setgamma!(Edge, new γ, change_other=true)</code></pre><p>Set inheritance probability γ for an edge, which must be a hybrid edge. The new γ needs to be in [0,1]. The γ of the &quot;partner&quot; hybrid edge is changed accordingly, to 1-γ. The field <code>ismajor</code> is also changed accordingly. If the new γ is approximately 0.5, <code>Edge</code> is set to the major parent, its partner is set to the minor parent.</p><p>If <code>net</code> is a HybridNetwork object, <code>printedges(net)</code> will show the list of edges and their γ&#39;s. The γ of the third hybrid edge (say) can be changed to 0.2 with <code>setgamma!(net.edge[3],0.2)</code>. This will automatically set γ of the partner hybrid edge to 0.8.</p><p>The last argument is true by default. If false: the partner edge is not updated. This is useful if the new γ is 0.5, and the partner&#39;s γ is already 0.5, in which case the <code>ismajor</code> attributes can remain unchanged.</p><p>See also <a href="../internals/#PhyloNetworks.setmultiplegammas!-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Float64}}"><code>PhyloNetworks.setmultiplegammas!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L836-L855">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.setlength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Any}"><a class="docstring-binding" href="#PhyloNetworks.setlength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Any}"><code>PhyloNetworks.setlength!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setlength!(edge::Edge, new_length)</code></pre><p>Assign new length to <code>edge</code>. <code>new_length</code> should be non-negative, or <code>missing</code> (or -1, interpreted as missing).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L1620-L1625">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.setlengths!-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}"><a class="docstring-binding" href="#PhyloNetworks.setlengths!-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}"><code>PhyloNetworks.setlengths!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setlengths!(edges::Vector{Edge}, lengths::AbstractVector)</code></pre><p>Assign new lengths to a vector of <code>edges</code>. Checks that the new edge lengths are non-negative or <code>missing</code> (or -1 to be interpreted as missing).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L1636-L1642">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.sharedpathmatrix-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.sharedpathmatrix-Tuple{HybridNetwork}"><code>PhyloNetworks.sharedpathmatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sharedpathmatrix(net::HybridNetwork; checkpreorder::Bool=true)</code></pre><p>Matrix Ω of shared path lengths from the root to a pair of nodes, for all pairs of nodes in network <code>net</code>. This is the covariance under a Brownian motion model, returned as a data frame by <a href="#PhyloNetworks.vcv-Tuple{HybridNetwork}"><code>vcv</code></a>. The network is assumed to be pre-ordered if <code>checkpreorder</code> is false. If <code>checkpreorder</code> is true (default), <code>preorder!</code> is run on the network beforehand.</p><p>Returns an object of type <a href="../internals/#PhyloNetworks.MatrixTopologicalOrder"><code>MatrixTopologicalOrder</code></a>.</p><p>See also <a href="../internals/#PhyloNetworks.descendenceweight-Tuple{HybridNetwork}"><code>descendenceweight</code></a>, which returns a matrix P independent of edge lengths. P only depends on the network topology and γ. Then Ω = PDP&#39; where D is a diagonal matrix with the network&#39;s edge lengths on its diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/recursion_matrices.jl#L213-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.shrink2cycles!"><a class="docstring-binding" href="#PhyloNetworks.shrink2cycles!"><code>PhyloNetworks.shrink2cycles!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">shrink2cycles!(net::HybridNetwork, unroot::Bool=false)</code></pre><p>If <code>net</code> contains a 2-cycle, collapse the cycle into one edge of length tA + γt1+(1-γ)t2 + tB (see below), and return true. Return false otherwise. A 2-cycle is a set of 2 parallel hybrid edges, from the same parent node to the same hybrid child node.</p><pre><code class="language-julia hljs">       A                A
       | tA             |
     parent             |
       | \              |
t2,1-γ |  | t1,γ        | tA + γ*t1 + (1-γ)*t2 + tB
       | /              |
     hybrid             |
       | tB             |
       B                B</code></pre><p>If any of the lengths or gammas associated with a 2-cycle are missing, the combined length is missing. If γ is missing, branch lengths are calculated using γ=0.5.</p><p>If <code>unroot</code> is false and the root is up for deletion, it will be kept only if it is has degree 2 or more. If <code>unroot</code> is true and the root is up for deletion, it will be kept only if it has degree 3 or more. A root node with degree 1 will be deleted in both cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L1844-L1871">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.shrink3cycles!"><a class="docstring-binding" href="#PhyloNetworks.shrink3cycles!"><code>PhyloNetworks.shrink3cycles!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">shrink3cycles!(net::HybridNetwork, unroot::Bool=false)</code></pre><p>Remove all 2- and 3-cycles from a network.</p><p>Return true if <code>net</code> contains a 2-cycle or a 3-cycle; false otherwise. A 3-cycle (2-cycle) is a set of 3 (2) nodes that are all connected. One of them must be a hybrid node, since <code>net</code> is a DAG.</p><p>If <code>unroot</code> is false and the root is up for deletion, it will be kept only if it is has degree 2 or more. If <code>unroot</code> is true and the root is up for deletion, it will be kept only if it has degree 3 or more. A root node with degree 1 will be deleted in both cases.</p><p>See <a href="../internals/#PhyloNetworks.shrink3cycleat!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.Node, Bool}"><code>shrink3cycleat!</code></a> for details on branch lengths and inheritance values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/auxiliary.jl#L1915-L1931">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.suppressroot!-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.suppressroot!-Tuple{HybridNetwork}"><code>PhyloNetworks.suppressroot!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">suppressroot!(net::HybridNetwork)</code></pre><p>Suppress the root of <code>net</code>, in an attempt to convey the interpretation that its root is in fact unknown, as in unrooted trees and semidirected networks. Namely:</p><ol><li>delete the root if has only 1 edge, unless its child is a leaf, and do so recursively until the new root has 2 or more edges (or a single child leaf)</li><li>stop if the root is of degree 3 or more or has 2 outgoing hybrid edges,</li><li>otherwise fuse its 2 edges, unless its 2 children are leaves (in which case a warning is printed).</li></ol><p>An error is thrown if the root is a leaf.</p><p>See also <a href="#PhyloNetworks.rootonedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>rootonedge!</code></a> and <a href="#PhyloNetworks.rootatnode!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>rootatnode!</code></a>, which do the opposite.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((((a,b))#H2,(#H2,c))));&quot;); # extra root edge

julia&gt; suppressroot!(net); writenewick(net) # root with 3 edges
&quot;(#H2,c,((a,b))#H2);&quot;

julia&gt; deleteleaf!(net, &quot;c&quot;); writenewick(net) # root with 2 hybrid edges
&quot;(#H2,((a,b))#H2);&quot;

julia&gt; suppressroot!(net); writenewick(net) # root cannot be suppressed more
&quot;(#H2,((a,b))#H2);&quot;</code></pre><p>Below, the resulting network still has a root with only 2 children:</p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((a,(b)i1)));&quot;);

julia&gt; # plot(net, shownodelabel=true); # extra: root above LSA, and degree-2 node i1 above b

julia&gt; suppressroot!(net); writenewick(net) # root now at i1: still of degree 2
&quot;(b,a)i1;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/manipulateNet.jl#L412-L453">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.tablequartetCF-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><a class="docstring-binding" href="#PhyloNetworks.tablequartetCF-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><code>PhyloNetworks.tablequartetCF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tablequartetCF(quartetlist::Vector{QuartetT} [, taxonnames];
               keepQwithoutgenes=true, colnames=nothing)</code></pre><p>Convert a vector of <a href="../internals/#PhyloNetworks.QuartetT"><code>QuartetT</code></a> objects to a table with 1 row for each four-taxon set in the list. Each four-taxon set contains quartet data of some type (vector of length 3 or 4, or 3×n matrix), which determines the number of columns in the table (3, 4, or 3n). The first 3 columns are named &quot;CF12<em>34&quot;, &quot;CF13</em>24&quot;, &quot;CF14_23&quot;, unless the full list of column names is provided in <code>colnames</code>. See <a href="../internals/#PhyloNetworks.tablequartetdata-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><code>tablequartetdata</code></a> for details.</p><p>The output is a <code>NamedTuple</code>, to which we can apply common table operations as a <a href="https://github.com/JuliaData/Tables.jl"><code>Table.jl</code></a>-compatible source. It can easily be converted to other table formats such as a <code>DataFrame</code>.</p><p>See <a href="#PhyloNetworks.countquartetsintrees"><code>countquartetsintrees</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/quartets.jl#L65-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.tablequartetf4-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><a class="docstring-binding" href="#PhyloNetworks.tablequartetf4-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><code>PhyloNetworks.tablequartetf4</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tablequartetf4(quartetlist::Vector{QuartetT} [, taxonnames];
               keepQwithoutgenes=true, colnames=nothing)</code></pre><p>Convert a vector of <a href="../internals/#PhyloNetworks.QuartetT"><code>QuartetT</code></a> objects to a table with 1 row for each four-taxon set in the list. Each four-taxon set contains quartet data of some type (vector of length 3 or 4, or 3×n matrix), which determines the number of columns in the table (3, 4, or 3n). The first 3 columns are named &quot;f4<em>12</em>34&quot;, &quot;f4<em>13</em>42&quot; and &quot;f4<em>14</em>23&quot;, unless the full list of column names is provided in <code>colnames</code>. See <a href="../internals/#PhyloNetworks.tablequartetdata-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><code>tablequartetdata</code></a> for details.</p><p>The output is a <code>NamedTuple</code>, to which we can apply common table operations as a <a href="https://github.com/JuliaData/Tables.jl"><code>Table.jl</code></a>-compatible source. It can easily be converted to other table formats such as a <code>DataFrame</code>.</p><p>See <a href="#PhyloNetworks.countquartetsintrees"><code>countquartetsintrees</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/quartets.jl#L93-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.tiplabels-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.tiplabels-Tuple{HybridNetwork}"><code>PhyloNetworks.tiplabels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tiplabels(x)</code></pre><p>Vector of taxon names at the leaves, defined for objects of various types: <code>HybridNetwork</code>, <code>MatrixTopologicalOrder</code>.</p><p>For a network, the taxon names are coerced to strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/descriptive.jl#L4-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.treeedgecomponents-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.treeedgecomponents-Tuple{HybridNetwork}"><code>PhyloNetworks.treeedgecomponents</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">treeedgecomponents(net::HybridNetwork)</code></pre><p>Return the tree-edge components of the semidirected network as a <code>membership</code> dictionary <code>Node =&gt; Int</code>. Nodes with the same membership integer value are in the same tree-edge component. The tree-edge components of a network are the connected components of the network when all hybrid edges are removed.</p><p>A <code>RootMismatch</code> error is thrown if there exists a cycle in any of the tree-edge components, or if a tree-edge component has more than one &quot;entry&quot; hybrid node.</p><p>Warnings:</p><ul><li>since <code>Node</code>s are mutable, the network should not be modified until usage of the output <code>membership</code> dictionary is over.</li><li>the component IDs are not predicable, but will be consecutive integers from 1 to the number of components.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/graph_components.jl#L633-L650">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.treeedges_support-Tuple{Vector{HybridNetwork}, HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.treeedges_support-Tuple{Vector{HybridNetwork}, HybridNetwork}"><code>PhyloNetworks.treeedges_support</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">treeedges_support(sample_net::Vector{HybridNetwork}, ref_net::HybridNetwork)`</code></pre><p>Read a sample of networks <code>sample_net</code> (such as a bootstrap sample or a posterior sample) and a reference network (<code>ref_net</code>), and calculate the support for the tree edges in the reference network. All minor hybrid edges (γ&lt;0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.</p><p>output:</p><ul><li>a data frame with one row per tree edge and two columns: edge number, bootstrap support (as a percentage)</li><li>the major tree from the reference network, where minor hybrid edges (with γ&lt;0.5) have been removed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/bootstrap.jl#L98-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.treeofblobs-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.treeofblobs-Tuple{HybridNetwork}"><code>PhyloNetworks.treeofblobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">treeofblobs(net::HybridNetwork; preorder::Bool=true, preprocess::Bool=true)</code></pre><p>Tree of blobs for <code>net</code>. This tree is obtained from the network by shrinking any blob (2-edge connected component) that is not trivial (more than 1 edge) into a single node. The remaining edges are cut-edges (or bridges): they disconnect the network if removed. After shrinking blobs, only these cut-edges remain (with their edge length if any) and the graph forms a tree: the tree-of-blobs. It typically has polytomies, and may have degree-2 nodes. See <a href="https://doi.org/10.1007/s00285-022-01838-9">Allman et al. (2022)</a> (on binary networks) and <a href="https://doi.org/10.1007/s00285-022-01847-8">Xu &amp; Ané (2023)</a>.</p><p>If the network is binary, each blob is a block (biconnected component). If the network is not binary, then multiple blocks forming a single blob are shrunk into the same node.</p><p>The network is not modified. <code>PhyloNetworks.treeofblobs!(net)</code> modifies <code>net</code>, but is unsafe to use, in the sense that it assumes that the network is already preordered and preprocessed to get its biconnected component.</p><p>In the output tree, the biconnected component information is stored.</p><p>Arguments:</p><ul><li><code>preorder</code> to direct edges according to the root and store a pre-ordering of nodes in <code>net.vec_node</code>, if not done earlier on the network (e.g. after a topology modification)</li><li><code>preprocess</code> to recalculate &amp; store the biconnected components with <a href="../internals/#PhyloNetworks.process_biconnectedcomponents!"><code>process_biconnectedcomponents!</code></a>, assuming the preordering was done.</li></ul><p><strong>examples</strong></p><p>In this first example, the network is binary (no polytomies of any kind) and has 2 blobs.</p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;((S1:0.1,(((S2,(S3)#H1),(#H1,S4:0.4)):0.2)#H2:0.2),(#H2,S5));&quot;);

julia&gt; tob = treeofblobs(net);

julia&gt; writenewick(tob) # 2 polytomies: at root, and to S2,S3,S4
&quot;(S5,S1:0.1,(S4:0.4,S2,S3):0.2);&quot;</code></pre><p>Now we use the same network but without the edge connecting the 2 blobs: there are now 2 blocks sharing one node, so 1 blob only.</p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;((S1:0.1,((S2,(S3)#H1),(#H1,S4:0.4))#H2:0.2),(#H2,S5));&quot;);

julia&gt; # using PhyloPlots; plot(net, style=:majortree, arrowlen=0.1);

julia&gt; tob = treeofblobs(net);

julia&gt; writenewick(tob) # star tree: 1 big polytomy
&quot;(S5,S1:0.1,S4:0.4,S2,S3);&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/graph_components.jl#L824-L881">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.vcv-Tuple{HybridNetwork}"><a class="docstring-binding" href="#PhyloNetworks.vcv-Tuple{HybridNetwork}"><code>PhyloNetworks.vcv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vcv(net::HybridNetwork; model::AbstractString=&quot;BM&quot;,
                        corr::Bool=false,
                        checkpreorder::Bool=true)</code></pre><p>This function computes the variance covariance matrix between the tips of the network, assuming a Brownian model of trait evolution (with unit variance). If optional argument <code>corr</code> is set to <code>true</code>, then the correlation matrix is returned instead.</p><p>The function returns a <code>DataFrame</code> object, with columns named by the tips of the network.</p><p>The calculation of the covariance matrix requires a pre-ordering of nodes to be fast. If <code>checkpreorder</code> is true (default), then <a href="#PhyloNetworks.preorder!-Tuple{HybridNetwork}"><code>preorder!</code></a> is run on the network beforehand. Otherwise, the network is assumed to be already in pre-order.</p><p>This function internally calls <a href="#PhyloNetworks.sharedpathmatrix-Tuple{HybridNetwork}"><code>sharedpathmatrix</code></a>, which computes the variance matrix between all the nodes of the network.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tree_str = &quot;(((t2:0.14,t4:0.33):0.59,t3:0.96):0.14,(t5:0.70,t1:0.18):0.90);&quot;;

julia&gt; tree = readnewick(tree_str);

julia&gt; C = vcv(tree)
5×5 DataFrame
 Row │ t2       t4       t3       t5       t1      
     │ Float64  Float64  Float64  Float64  Float64 
─────┼─────────────────────────────────────────────
   1 │    0.87     0.73     0.14      0.0     0.0
   2 │    0.73     1.06     0.14      0.0     0.0
   3 │    0.14     0.14     1.1       0.0     0.0
   4 │    0.0      0.0      0.0       1.6     0.9
   5 │    0.0      0.0      0.0       0.9     1.08
</code></pre><p>The following block needs <code>ape</code> to be installed (not run):</p><pre><code class="language-julia hljs">julia&gt; using RCall # Comparison with ape vcv function

julia&gt; R&quot;ape::vcv(ape::read.tree(text = $tree_str))&quot;
RCall.RObject{RCall.RealSxp}
     t2   t4   t3  t5   t1
t2 0.87 0.73 0.14 0.0 0.00
t4 0.73 1.06 0.14 0.0 0.00
t3 0.14 0.14 1.10 0.0 0.00
t5 0.00 0.00 0.00 1.6 0.90
t1 0.00 0.00 0.00 0.9 1.08
</code></pre><p>The covariance can also be calculated on a network (for the model, see Bastide et al. 2018)</p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;((t1:1.0,#H1:0.1::0.30):0.5,((t2:0.9)#H1:0.2::0.70,t3:1.1):0.4);&quot;);

julia&gt; C = vcv(net)
3×3 DataFrame
 Row │ t1       t2       t3      
     │ Float64  Float64  Float64 
─────┼───────────────────────────
   1 │    1.5     0.15      0.0
   2 │    0.15    1.248     0.28
   3 │    0.0     0.28      1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/recursion_matrices.jl#L129-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.writemultinewick-Tuple{Vector{HybridNetwork}, AbstractString}"><a class="docstring-binding" href="#PhyloNetworks.writemultinewick-Tuple{Vector{HybridNetwork}, AbstractString}"><code>PhyloNetworks.writemultinewick</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">writemultinewick(nets, file_name; append=false)
writemultinewick(nets, IO)</code></pre><p>Write an array of networks in parenthetical extended Newick format, one network per line. Use the option append=true to append to the file. Otherwise, the default is to create a new file or overwrite it, if it already existed. Each network is written with <code>writenewick</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; net = [readnewick(&quot;(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10);&quot;),
              readnewick(&quot;(A,(B,C));&quot;),readnewick(&quot;(E,F);&quot;),readnewick(&quot;(G,H,F);&quot;)];

julia&gt; writemultinewick(net, &quot;fournets.net&quot;) # to (over)write to file &quot;fournets.net&quot;
julia&gt; writemultinewick(net, &quot;fournets.net&quot;, append=true) # to append to this file
julia&gt; writemultinewick(net, stdout)         # to write to the screen (standard out)
(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10.0);
(A,(B,C));
(E,F);
(G,H,F);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/readwrite.jl#L1182-L1204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.writenewick-Tuple{HybridNetwork, AbstractString}"><a class="docstring-binding" href="#PhyloNetworks.writenewick-Tuple{HybridNetwork, AbstractString}"><code>PhyloNetworks.writenewick</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">writenewick(net; kwargs...)
writenewick(net, filename; kwargs...)
writenewick(net, IO, args...)</code></pre><p>Write the parenthetical extended Newick format of a network, as a string, to a file or to an IO buffer / stream. Optional arguments (default values):</p><ul><li>append (false): if true, appends to the file</li><li>round (false): rounds branch lengths and heritabilities γ</li><li>digits (3): digits after the decimal place for rounding</li><li>di (false): write in format for Dendroscope</li><li>internallabel (true): if true, writes internal node labels</li><li>support (nothing): if something, such as <code>true</code>, write values in the &quot;support&quot; slot for edges in the newick format (after second colon). Currently, support values are taken from the <code>.y</code> internal field of each edge, consistent with <a href="#PhyloNetworks.readnewick-Tuple{IO}"><code>readnewick</code></a>.</li></ul><p>If the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.</p><p>Uses lower-level function <a href="#PhyloNetworks.writesubtree!"><code>writesubtree!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/readwrite.jl#L1227-L1250">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.writesubtree!"><a class="docstring-binding" href="#PhyloNetworks.writesubtree!"><code>PhyloNetworks.writesubtree!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">writesubtree!(IO, network, dendroscope::Bool, namelabel::Bool,
              round_branch_lengths::Bool, digits::Integer,
              internallabel::Bool, support=nothing)</code></pre><p>Write to IO the extended newick format (parenthetical description) of a network. If written for dendroscope, inheritance γ&#39;s are not written. If <code>namelabel</code> is true, taxa are labelled by their names; otherwise taxa are labelled by their number IDs. If unspecified, branch lengths and γ&#39;s are rounded to 3 digits. Use <code>internallabel=false</code> to suppress the labels of internal nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/readwrite.jl#L767-L779">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.writesubtree!-Tuple{IO, PhyloNetworks.Node, Any, Any, Any}"><a class="docstring-binding" href="#PhyloNetworks.writesubtree!-Tuple{IO, PhyloNetworks.Node, Any, Any, Any}"><code>PhyloNetworks.writesubtree!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">writesubtree!(IO, node, edge, dendroscope::Bool, namelabel::Bool,
              round_branch_lengths::Bool, digits::Integer,
              internallabel::Bool, support)</code></pre><p>Write the extended newick format of the sub-network rooted at <code>node</code> and assuming that <code>edge</code> is a parent of <code>node</code>.</p><p>If the parent <code>edge</code> is <code>nothing</code>, the edge attribute <code>ischild1</code> is used and assumed to be correct to write the subtree rooted at <code>node</code>. This is useful to write a subtree starting at a non-root node.</p><p>In the example below, we run <code>directedges!</code> just to be safe (edges are directed correctly right after <code>readnewick</code>), as a reminder that <code>writesubtree!</code> assumes tree edges to be correctly directed away from the current root (while <code>writenewick</code> checks).</p><pre><code class="language-julia-repl hljs">julia&gt; net = readnewick(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;) |&gt; directedges!;

julia&gt; getroot(net).number
-2

julia&gt; crownABC = net.node[7]; crownABC.number # not the root: crown of ABC clade
-3

julia&gt; s = IOBuffer(); writesubtree!(s, crownABC, nothing, false,true);

julia&gt; String(take!(s))
&quot;((A,(B)#H1:::0.9),(C,#H1:::0.1));&quot;

julia&gt; ancestorBC = net.node[6]; # ancestor of B and C, but not stable

julia&gt; writesubtree!(s, ancestorBC, nothing, false,true);

julia&gt; String(take!(s)) # includes only 1 of the 2 partner hybrid edges
&quot;(C,#H1:::0.1);&quot;</code></pre><p>Used by <a href="#PhyloNetworks.writenewick-Tuple{HybridNetwork, AbstractString}"><code>writenewick</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/readwrite.jl#L809-L849">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhyloNetworks.HybridNetwork"><a class="docstring-binding" href="#PhyloNetworks.HybridNetwork"><code>PhyloNetworks.HybridNetwork</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HybridNetwork</code></pre><p>Subtype of abstract <code>Network</code> type. Explicit network (which may be a tree) with the following attributes:</p><ul><li><code>numtaxa</code>: number of taxa, that is, number of are leaves (or tips). Leaves are required to be attached to a single edge.</li><li><code>numnodes</code>: total number of nodes: tips and internal nodes</li><li><code>numedges</code>: total number of edges</li><li><code>numhybrids</code>: total number of hybrid nodes</li><li><code>edge</code>: vector of Edges</li><li><code>node</code>: vector of Nodes</li><li><code>rooti</code>: index of the root in vector &#39;node&#39;. May be artificial in a semidirected network, but is necessary for printing and traversal purposes.</li><li><code>hybrid</code>: vector of Nodes: those are are hybrid nodes</li><li><code>leaf</code>: vector of Nodes: those that are leaves</li><li><code>fscore</code>: score after fitting network to data, i.e. parsimony score, or  multipe of the negative log pseudodeviance for SNaQ</li><li><code>isrooted</code>: true or false</li><li><code>partition</code>: vector of <code>Partition</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloNetworks.jl/blob/49cf533661220388f97bd17c940f06e9c0b10f17/src/types.jl#L240-L261">source</a></section></details></article><h2 id="index"><a class="docs-heading-anchor" href="#index">index</a><a id="index-1"></a><a class="docs-heading-anchor-permalink" href="#index" title="Permalink"></a></h2><ul><li><a href="#PhyloNetworks.HybridNetwork"><code>PhyloNetworks.HybridNetwork</code></a></li><li><a href="#PhyloNetworks.biconnectedcomponents"><code>PhyloNetworks.biconnectedcomponents</code></a></li><li><a href="#PhyloNetworks.biconnectedcomponents-NTuple{5, Any}"><code>PhyloNetworks.biconnectedcomponents</code></a></li><li><a href="#PhyloNetworks.blobdecomposition-Tuple{Any}"><code>PhyloNetworks.blobdecomposition</code></a></li><li><a href="#PhyloNetworks.calibratefrompairwisedistances!-Tuple{HybridNetwork, Matrix{Float64}, Vector{&lt;:AbstractString}}"><code>PhyloNetworks.calibratefrompairwisedistances!</code></a></li><li><a href="#PhyloNetworks.checkroot!-Tuple{HybridNetwork}"><code>PhyloNetworks.checkroot!</code></a></li><li><a href="#PhyloNetworks.cladewiseorder!-Tuple{HybridNetwork}"><code>PhyloNetworks.cladewiseorder!</code></a></li><li><a href="#PhyloNetworks.countquartetsintrees"><code>PhyloNetworks.countquartetsintrees</code></a></li><li><a href="#PhyloNetworks.deleteaboveLSA!"><code>PhyloNetworks.deleteaboveLSA!</code></a></li><li><a href="#PhyloNetworks.deletehybridthreshold!"><code>PhyloNetworks.deletehybridthreshold!</code></a></li><li><a href="#PhyloNetworks.deleteleaf!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>PhyloNetworks.deleteleaf!</code></a></li><li><a href="#PhyloNetworks.descendencematrix-Tuple{HybridNetwork}"><code>PhyloNetworks.descendencematrix</code></a></li><li><a href="#PhyloNetworks.directedges!-Tuple{HybridNetwork}"><code>PhyloNetworks.directedges!</code></a></li><li><a href="#PhyloNetworks.displayednetworkat!"><code>PhyloNetworks.displayednetworkat!</code></a></li><li><a href="#PhyloNetworks.displayedtrees-Tuple{HybridNetwork, Float64}"><code>PhyloNetworks.displayedtrees</code></a></li><li><a href="#PhyloNetworks.expectedf2matrix-Tuple{HybridNetwork}"><code>PhyloNetworks.expectedf2matrix</code></a></li><li><a href="#PhyloNetworks.expectedf4table-Tuple{HybridNetwork}"><code>PhyloNetworks.expectedf4table</code></a></li><li><a href="#PhyloNetworks.getchild-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.getchild</code></a></li><li><a href="#PhyloNetworks.getchildedge"><code>PhyloNetworks.getchildedge</code></a></li><li><a href="#PhyloNetworks.getchildren"><code>PhyloNetworks.getchildren</code></a></li><li><a href="#PhyloNetworks.getlevel"><code>PhyloNetworks.getlevel</code></a></li><li><a href="#PhyloNetworks.getnodeages-Tuple{HybridNetwork}"><code>PhyloNetworks.getnodeages</code></a></li><li><a href="#PhyloNetworks.getnodeheights"><code>PhyloNetworks.getnodeheights</code></a></li><li><a href="#PhyloNetworks.getnodeheights!"><code>PhyloNetworks.getnodeheights!</code></a></li><li><a href="#PhyloNetworks.getnodeheights_average"><code>PhyloNetworks.getnodeheights_average</code></a></li><li><a href="#PhyloNetworks.getnodeheights_majortree"><code>PhyloNetworks.getnodeheights_majortree</code></a></li><li><a href="#PhyloNetworks.getparent-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.getparent</code></a></li><li><a href="#PhyloNetworks.getparentedge"><code>PhyloNetworks.getparentedge</code></a></li><li><a href="#PhyloNetworks.getparentedgeminor"><code>PhyloNetworks.getparentedgeminor</code></a></li><li><a href="#PhyloNetworks.getparentminor"><code>PhyloNetworks.getparentminor</code></a></li><li><a href="#PhyloNetworks.getparents"><code>PhyloNetworks.getparents</code></a></li><li><a href="#PhyloNetworks.getpartneredge-Tuple{Any}"><code>PhyloNetworks.getpartneredge</code></a></li><li><a href="#PhyloNetworks.getroot-Tuple{HybridNetwork}"><code>PhyloNetworks.getroot</code></a></li><li><a href="#PhyloNetworks.hardwiredcluster-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Union{AbstractVector{Int64}, AbstractVector{String}}}"><code>PhyloNetworks.hardwiredcluster</code></a></li><li><a href="#PhyloNetworks.hardwiredclusterdistance-Tuple{HybridNetwork, HybridNetwork, Bool}"><code>PhyloNetworks.hardwiredclusterdistance</code></a></li><li><a href="#PhyloNetworks.hardwiredclusters-Tuple{HybridNetwork, Union{AbstractVector{Int64}, AbstractVector{String}}}"><code>PhyloNetworks.hardwiredclusters</code></a></li><li><a href="#PhyloNetworks.hashybridladder-Tuple{HybridNetwork}"><code>PhyloNetworks.hashybridladder</code></a></li><li><a href="#PhyloNetworks.hassinglechild-Tuple{PhyloNetworks.Node}"><code>PhyloNetworks.hassinglechild</code></a></li><li><a href="#PhyloNetworks.hybridclades_support-Tuple{Vector{HybridNetwork}, HybridNetwork}"><code>PhyloNetworks.hybridclades_support</code></a></li><li><a href="#PhyloNetworks.hybridlambdaformat-Tuple{HybridNetwork}"><code>PhyloNetworks.hybridlambdaformat</code></a></li><li><a href="#PhyloNetworks.ischildof"><code>PhyloNetworks.ischildof</code></a></li><li><a href="#PhyloNetworks.isexternal"><code>PhyloNetworks.isexternal</code></a></li><li><a href="#PhyloNetworks.isgalled"><code>PhyloNetworks.isgalled</code></a></li><li><a href="#PhyloNetworks.isleaf"><code>PhyloNetworks.isleaf</code></a></li><li><a href="#PhyloNetworks.isparentof-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.isparentof</code></a></li><li><a href="#PhyloNetworks.isrootof-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>PhyloNetworks.isrootof</code></a></li><li><a href="#PhyloNetworks.istimeconsistent"><code>PhyloNetworks.istimeconsistent</code></a></li><li><a href="#PhyloNetworks.istreechild-Tuple{HybridNetwork}"><code>PhyloNetworks.istreechild</code></a></li><li><a href="#PhyloNetworks.leaststableancestor"><code>PhyloNetworks.leaststableancestor</code></a></li><li><a href="#PhyloNetworks.leaststableancestor_matrix"><code>PhyloNetworks.leaststableancestor_matrix</code></a></li><li><a href="#PhyloNetworks.majortree-Tuple{HybridNetwork}"><code>PhyloNetworks.majortree</code></a></li><li><a href="#PhyloNetworks.minortreeat"><code>PhyloNetworks.minortreeat</code></a></li><li><a href="#PhyloNetworks.mudistance_rooted-Tuple{HybridNetwork, HybridNetwork}"><code>PhyloNetworks.mudistance_rooted</code></a></li><li><a href="#PhyloNetworks.mudistance_semidirected-Tuple{HybridNetwork, HybridNetwork}"><code>PhyloNetworks.mudistance_semidirected</code></a></li><li><a href="#PhyloNetworks.nameinternalnodes!"><code>PhyloNetworks.nameinternalnodes!</code></a></li><li><a href="#PhyloNetworks.nj-Tuple{DataFrames.DataFrame}"><code>PhyloNetworks.nj</code></a></li><li><a href="#PhyloNetworks.nni!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.nni!</code></a></li><li><a href="#PhyloNetworks.nni!-Tuple{HybridNetwork, Vararg{Any}}"><code>PhyloNetworks.nni!</code></a></li><li><a href="#PhyloNetworks.nni!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, UInt8, Bool, Bool}"><code>PhyloNetworks.nni!</code></a></li><li><a href="#PhyloNetworks.pairwisetaxondistancematrix-Tuple{HybridNetwork}"><code>PhyloNetworks.pairwisetaxondistancematrix</code></a></li><li><a href="#PhyloNetworks.parsimonyGF-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}, Tuple{HybridNetwork, Dict{String, T}, Symbol}} where T"><code>PhyloNetworks.parsimonyGF</code></a></li><li><a href="#PhyloNetworks.parsimonysoftwired-Union{Tuple{T}, Tuple{HybridNetwork, Dict{String, T}}} where T"><code>PhyloNetworks.parsimonysoftwired</code></a></li><li><a href="#PhyloNetworks.preorder!-Tuple{HybridNetwork}"><code>PhyloNetworks.preorder!</code></a></li><li><a href="#PhyloNetworks.printedges-Tuple{Any}"><code>PhyloNetworks.printedges</code></a></li><li><a href="#PhyloNetworks.printnodes-Tuple{Any}"><code>PhyloNetworks.printnodes</code></a></li><li><a href="#PhyloNetworks.readfastatodna"><code>PhyloNetworks.readfastatodna</code></a></li><li><a href="#PhyloNetworks.readmultinewick"><code>PhyloNetworks.readmultinewick</code></a></li><li><a href="#PhyloNetworks.readmultinewick_files-Tuple{AbstractString}"><code>PhyloNetworks.readmultinewick_files</code></a></li><li><a href="#PhyloNetworks.readnewick-Tuple{IO}"><code>PhyloNetworks.readnewick</code></a></li><li><a href="#PhyloNetworks.readnexus_treeblock"><code>PhyloNetworks.readnexus_treeblock</code></a></li><li><a href="#PhyloNetworks.readphylip"><code>PhyloNetworks.readphylip</code></a></li><li><a href="#PhyloNetworks.removedegree2nodes!"><code>PhyloNetworks.removedegree2nodes!</code></a></li><li><a href="#PhyloNetworks.rootatnode!-Tuple{HybridNetwork, PhyloNetworks.Node}"><code>PhyloNetworks.rootatnode!</code></a></li><li><a href="#PhyloNetworks.rootonedge!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloNetworks.rootonedge!</code></a></li><li><a href="#PhyloNetworks.rotate!-Tuple{HybridNetwork, Integer}"><code>PhyloNetworks.rotate!</code></a></li><li><a href="#PhyloNetworks.setgamma!"><code>PhyloNetworks.setgamma!</code></a></li><li><a href="#PhyloNetworks.setlength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Any}"><code>PhyloNetworks.setlength!</code></a></li><li><a href="#PhyloNetworks.setlengths!-Tuple{Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, AbstractVector}"><code>PhyloNetworks.setlengths!</code></a></li><li><a href="#PhyloNetworks.sharedpathmatrix-Tuple{HybridNetwork}"><code>PhyloNetworks.sharedpathmatrix</code></a></li><li><a href="#PhyloNetworks.shrink2cycles!"><code>PhyloNetworks.shrink2cycles!</code></a></li><li><a href="#PhyloNetworks.shrink3cycles!"><code>PhyloNetworks.shrink3cycles!</code></a></li><li><a href="#PhyloNetworks.suppressroot!-Tuple{HybridNetwork}"><code>PhyloNetworks.suppressroot!</code></a></li><li><a href="#PhyloNetworks.tablequartetCF-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><code>PhyloNetworks.tablequartetCF</code></a></li><li><a href="#PhyloNetworks.tablequartetf4-Union{Tuple{Array{PhyloNetworks.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{PhyloNetworks.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><code>PhyloNetworks.tablequartetf4</code></a></li><li><a href="#PhyloNetworks.tiplabels-Tuple{HybridNetwork}"><code>PhyloNetworks.tiplabels</code></a></li><li><a href="#PhyloNetworks.treeedgecomponents-Tuple{HybridNetwork}"><code>PhyloNetworks.treeedgecomponents</code></a></li><li><a href="#PhyloNetworks.treeedges_support-Tuple{Vector{HybridNetwork}, HybridNetwork}"><code>PhyloNetworks.treeedges_support</code></a></li><li><a href="#PhyloNetworks.treeofblobs-Tuple{HybridNetwork}"><code>PhyloNetworks.treeofblobs</code></a></li><li><a href="#PhyloNetworks.vcv-Tuple{HybridNetwork}"><code>PhyloNetworks.vcv</code></a></li><li><a href="#PhyloNetworks.writemultinewick-Tuple{Vector{HybridNetwork}, AbstractString}"><code>PhyloNetworks.writemultinewick</code></a></li><li><a href="#PhyloNetworks.writenewick-Tuple{HybridNetwork, AbstractString}"><code>PhyloNetworks.writenewick</code></a></li><li><a href="#PhyloNetworks.writesubtree!-Tuple{IO, PhyloNetworks.Node, Any, Any, Any}"><code>PhyloNetworks.writesubtree!</code></a></li><li><a href="#PhyloNetworks.writesubtree!"><code>PhyloNetworks.writesubtree!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/expecteddata/">« Pairwise and quartet data</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 26 November 2025 22:32">Wednesday 26 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
