<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · PhyloNetworks.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PhyloNetworks.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PhyloNetworks.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/installation/">Installation</a></li><li><a class="tocitem" href="../../man/inputdata/">Input Data for SNaQ</a></li><li><a class="tocitem" href="../../man/ticr_howtogetQuartetCFs/">TICR pipeline</a></li><li><a class="tocitem" href="../../man/snaq_plot/">Network estimation and display</a></li><li><a class="tocitem" href="../../man/dist_reroot/">Network comparison and manipulation</a></li><li><a class="tocitem" href="../../man/fixednetworkoptim/">Candidate Networks</a></li><li><a class="tocitem" href="../../man/expectedCFs/">Extract Expected CFs</a></li><li><a class="tocitem" href="../../man/bootstrap/">Bootstrap</a></li><li><a class="tocitem" href="../../man/multiplealleles/">Multiple Alleles</a></li><li><a class="tocitem" href="../../man/trait_tree/">Continuous Trait Evolution</a></li><li><a class="tocitem" href="../../man/parsimony/">Parsimony on networks</a></li><li><a class="tocitem" href="../../man/fitDiscrete/">Discrete Trait Evolution</a></li><li><a class="tocitem" href="../../man/nj/">Neighbour Joining</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#types"><span>types</span></a></li><li><a class="tocitem" href="#utilities"><span>utilities</span></a></li><li><a class="tocitem" href="#data-and-topology-read/write"><span>data and topology read/write</span></a></li><li><a class="tocitem" href="#network-inference"><span>network inference</span></a></li><li><a class="tocitem" href="#network-Comparisons"><span>network Comparisons</span></a></li><li><a class="tocitem" href="#continuous-trait-evolution"><span>continuous trait evolution</span></a></li><li><a class="tocitem" href="#discrete-trait-evolution"><span>discrete trait evolution</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/crsl4/PhyloNetworks.jl/blob/master/docs/src/lib/public.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation"><a class="docs-heading-anchor" href="#Public-Documentation">Public Documentation</a><a id="Public-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Documentation" title="Permalink"></a></h1><p>Documentation for <code>PhyloNetworks</code>&#39;s public (exported) interface.</p><p>See <a href="../internals/#Internal-Documentation">Internal Documentation</a> for documentation on internal functions.</p><ul><li><a href="#Public-Documentation">Public Documentation</a></li><ul><li><a href="#Index">Index</a></li><li><a href="#types">types</a></li><li><a href="#utilities">utilities</a></li><li><a href="#data-and-topology-read/write">data and topology read/write</a></li><li><a href="#network-inference">network inference</a></li><li><a href="#network-Comparisons">network Comparisons</a></li><li><a href="#continuous-trait-evolution">continuous trait evolution</a></li><li><a href="#discrete-trait-evolution">discrete trait evolution</a></li></ul></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PhyloNetworks.BinaryTraitSubstitutionModel"><code>PhyloNetworks.BinaryTraitSubstitutionModel</code></a></li><li><a href="#PhyloNetworks.DataCF"><code>PhyloNetworks.DataCF</code></a></li><li><a href="#PhyloNetworks.EqualRatesSubstitutionModel"><code>PhyloNetworks.EqualRatesSubstitutionModel</code></a></li><li><a href="#PhyloNetworks.HKY85"><code>PhyloNetworks.HKY85</code></a></li><li><a href="#PhyloNetworks.HybridNetwork"><code>PhyloNetworks.HybridNetwork</code></a></li><li><a href="#PhyloNetworks.JC69"><code>PhyloNetworks.JC69</code></a></li><li><a href="#PhyloNetworks.ParamsBM"><code>PhyloNetworks.ParamsBM</code></a></li><li><a href="#PhyloNetworks.ParamsMultiBM"><code>PhyloNetworks.ParamsMultiBM</code></a></li><li><a href="#PhyloNetworks.PhyloNetworkLinearModel"><code>PhyloNetworks.PhyloNetworkLinearModel</code></a></li><li><a href="#PhyloNetworks.Quartet"><code>PhyloNetworks.Quartet</code></a></li><li><a href="#PhyloNetworks.RateVariationAcrossSites-Tuple{}"><code>PhyloNetworks.RateVariationAcrossSites</code></a></li><li><a href="#PhyloNetworks.RateVariationAcrossSites"><code>PhyloNetworks.RateVariationAcrossSites</code></a></li><li><a href="#PhyloNetworks.ReconstructedStates"><code>PhyloNetworks.ReconstructedStates</code></a></li><li><a href="#PhyloNetworks.ShiftNet"><code>PhyloNetworks.ShiftNet</code></a></li><li><a href="#PhyloNetworks.TraitSimulation"><code>PhyloNetworks.TraitSimulation</code></a></li><li><a href="#PhyloNetworks.TraitSubstitutionModel"><code>PhyloNetworks.TraitSubstitutionModel</code></a></li><li><a href="#PhyloNetworks.TwoBinaryTraitSubstitutionModel"><code>PhyloNetworks.TwoBinaryTraitSubstitutionModel</code></a></li><li><a href="#Base.getindex-Tuple{TraitSimulation, Symbol}"><code>Base.getindex</code></a></li><li><a href="#PhyloNetworks.Q"><code>PhyloNetworks.Q</code></a></li><li><a href="#PhyloNetworks.ancestralStateReconstruction"><code>PhyloNetworks.ancestralStateReconstruction</code></a></li><li><a href="#PhyloNetworks.biconnectedComponents"><code>PhyloNetworks.biconnectedComponents</code></a></li><li><a href="#PhyloNetworks.blobDecomposition"><code>PhyloNetworks.blobDecomposition</code></a></li><li><a href="#PhyloNetworks.bootsnaq"><code>PhyloNetworks.bootsnaq</code></a></li><li><a href="#PhyloNetworks.calibrateFromPairwiseDistances!"><code>PhyloNetworks.calibrateFromPairwiseDistances!</code></a></li><li><a href="#PhyloNetworks.checkroot!"><code>PhyloNetworks.checkroot!</code></a></li><li><a href="#PhyloNetworks.cladewiseorder!"><code>PhyloNetworks.cladewiseorder!</code></a></li><li><a href="#PhyloNetworks.countquartetsintrees"><code>PhyloNetworks.countquartetsintrees</code></a></li><li><a href="#PhyloNetworks.deleteHybridThreshold!"><code>PhyloNetworks.deleteHybridThreshold!</code></a></li><li><a href="#PhyloNetworks.deleteleaf!"><code>PhyloNetworks.deleteleaf!</code></a></li><li><a href="#PhyloNetworks.descendenceMatrix"><code>PhyloNetworks.descendenceMatrix</code></a></li><li><a href="#PhyloNetworks.directEdges!"><code>PhyloNetworks.directEdges!</code></a></li><li><a href="#PhyloNetworks.displayedNetworkAt!"><code>PhyloNetworks.displayedNetworkAt!</code></a></li><li><a href="#PhyloNetworks.displayedTrees"><code>PhyloNetworks.displayedTrees</code></a></li><li><a href="#PhyloNetworks.empiricalDNAfrequencies"><code>PhyloNetworks.empiricalDNAfrequencies</code></a></li><li><a href="#PhyloNetworks.expectations"><code>PhyloNetworks.expectations</code></a></li><li><a href="#PhyloNetworks.expectationsPlot"><code>PhyloNetworks.expectationsPlot</code></a></li><li><a href="#PhyloNetworks.fitdiscrete"><code>PhyloNetworks.fitdiscrete</code></a></li><li><a href="#PhyloNetworks.fittedQuartetCF"><code>PhyloNetworks.fittedQuartetCF</code></a></li><li><a href="#PhyloNetworks.getNodeAges"><code>PhyloNetworks.getNodeAges</code></a></li><li><a href="#PhyloNetworks.getShiftEdgeNumber"><code>PhyloNetworks.getShiftEdgeNumber</code></a></li><li><a href="#PhyloNetworks.getShiftValue"><code>PhyloNetworks.getShiftValue</code></a></li><li><a href="#PhyloNetworks.getlabels"><code>PhyloNetworks.getlabels</code></a></li><li><a href="#PhyloNetworks.hardwiredCluster"><code>PhyloNetworks.hardwiredCluster</code></a></li><li><a href="#PhyloNetworks.hardwiredClusterDistance"><code>PhyloNetworks.hardwiredClusterDistance</code></a></li><li><a href="#PhyloNetworks.hardwiredClusters"><code>PhyloNetworks.hardwiredClusters</code></a></li><li><a href="#PhyloNetworks.hybridBootstrapSupport"><code>PhyloNetworks.hybridBootstrapSupport</code></a></li><li><a href="#PhyloNetworks.hybridDetection"><code>PhyloNetworks.hybridDetection</code></a></li><li><a href="#PhyloNetworks.hybridatnode!"><code>PhyloNetworks.hybridatnode!</code></a></li><li><a href="#PhyloNetworks.hybridlambdaformat"><code>PhyloNetworks.hybridlambdaformat</code></a></li><li><a href="#PhyloNetworks.lambda_estim"><code>PhyloNetworks.lambda_estim</code></a></li><li><a href="#PhyloNetworks.majorTree"><code>PhyloNetworks.majorTree</code></a></li><li><a href="#PhyloNetworks.mapAllelesCFtable"><code>PhyloNetworks.mapAllelesCFtable</code></a></li><li><a href="#PhyloNetworks.mapindividuals"><code>PhyloNetworks.mapindividuals</code></a></li><li><a href="#PhyloNetworks.maxParsimonyNet"><code>PhyloNetworks.maxParsimonyNet</code></a></li><li><a href="#PhyloNetworks.minorTreeAt"><code>PhyloNetworks.minorTreeAt</code></a></li><li><a href="#PhyloNetworks.mu_phylo"><code>PhyloNetworks.mu_phylo</code></a></li><li><a href="#PhyloNetworks.nj"><code>PhyloNetworks.nj</code></a></li><li><a href="#PhyloNetworks.nni!"><code>PhyloNetworks.nni!</code></a></li><li><a href="#PhyloNetworks.nparams"><code>PhyloNetworks.nparams</code></a></li><li><a href="#PhyloNetworks.nstates"><code>PhyloNetworks.nstates</code></a></li><li><a href="#PhyloNetworks.pairwiseTaxonDistanceMatrix"><code>PhyloNetworks.pairwiseTaxonDistanceMatrix</code></a></li><li><a href="#PhyloNetworks.parsimonyGF"><code>PhyloNetworks.parsimonyGF</code></a></li><li><a href="#PhyloNetworks.parsimonySoftwired"><code>PhyloNetworks.parsimonySoftwired</code></a></li><li><a href="#PhyloNetworks.phylolm"><code>PhyloNetworks.phylolm</code></a></li><li><a href="#PhyloNetworks.predint"><code>PhyloNetworks.predint</code></a></li><li><a href="#PhyloNetworks.predintPlot"><code>PhyloNetworks.predintPlot</code></a></li><li><a href="#PhyloNetworks.preorder!"><code>PhyloNetworks.preorder!</code></a></li><li><a href="#PhyloNetworks.printEdges"><code>PhyloNetworks.printEdges</code></a></li><li><a href="#PhyloNetworks.printNodes"><code>PhyloNetworks.printNodes</code></a></li><li><a href="#PhyloNetworks.randomTrait"><code>PhyloNetworks.randomTrait</code></a></li><li><a href="#PhyloNetworks.randomTrait!"><code>PhyloNetworks.randomTrait!</code></a></li><li><a href="#PhyloNetworks.readBootstrapTrees"><code>PhyloNetworks.readBootstrapTrees</code></a></li><li><a href="#PhyloNetworks.readInputTrees"><code>PhyloNetworks.readInputTrees</code></a></li><li><a href="#PhyloNetworks.readMultiTopology"><code>PhyloNetworks.readMultiTopology</code></a></li><li><a href="#PhyloNetworks.readNexusTrees"><code>PhyloNetworks.readNexusTrees</code></a></li><li><a href="#PhyloNetworks.readSnaqNetwork"><code>PhyloNetworks.readSnaqNetwork</code></a></li><li><a href="#PhyloNetworks.readTableCF"><code>PhyloNetworks.readTableCF</code></a></li><li><a href="#PhyloNetworks.readTableCF!"><code>PhyloNetworks.readTableCF!</code></a></li><li><a href="#PhyloNetworks.readTopology"><code>PhyloNetworks.readTopology</code></a></li><li><a href="#PhyloNetworks.readTopologyLevel1"><code>PhyloNetworks.readTopologyLevel1</code></a></li><li><a href="#PhyloNetworks.readTrees2CF"><code>PhyloNetworks.readTrees2CF</code></a></li><li><a href="#PhyloNetworks.readfastatodna"><code>PhyloNetworks.readfastatodna</code></a></li><li><a href="#PhyloNetworks.regressorHybrid"><code>PhyloNetworks.regressorHybrid</code></a></li><li><a href="#PhyloNetworks.regressorShift"><code>PhyloNetworks.regressorShift</code></a></li><li><a href="#PhyloNetworks.rootatnode!"><code>PhyloNetworks.rootatnode!</code></a></li><li><a href="#PhyloNetworks.rootonedge!"><code>PhyloNetworks.rootonedge!</code></a></li><li><a href="#PhyloNetworks.rotate!"><code>PhyloNetworks.rotate!</code></a></li><li><a href="#PhyloNetworks.setGamma!"><code>PhyloNetworks.setGamma!</code></a></li><li><a href="#PhyloNetworks.setLength!"><code>PhyloNetworks.setLength!</code></a></li><li><a href="#PhyloNetworks.sharedPathMatrix"><code>PhyloNetworks.sharedPathMatrix</code></a></li><li><a href="#PhyloNetworks.shiftHybrid"><code>PhyloNetworks.shiftHybrid</code></a></li><li><a href="#PhyloNetworks.sigma2_phylo"><code>PhyloNetworks.sigma2_phylo</code></a></li><li><a href="#PhyloNetworks.sigma2_within"><code>PhyloNetworks.sigma2_within</code></a></li><li><a href="#PhyloNetworks.simulate"><code>PhyloNetworks.simulate</code></a></li><li><a href="#PhyloNetworks.snaq!"><code>PhyloNetworks.snaq!</code></a></li><li><a href="#PhyloNetworks.sorttaxa!"><code>PhyloNetworks.sorttaxa!</code></a></li><li><a href="#PhyloNetworks.stationary"><code>PhyloNetworks.stationary</code></a></li><li><a href="#PhyloNetworks.summarizeDataCF"><code>PhyloNetworks.summarizeDataCF</code></a></li><li><a href="#PhyloNetworks.summarizeHFdf"><code>PhyloNetworks.summarizeHFdf</code></a></li><li><a href="#PhyloNetworks.tipLabels"><code>PhyloNetworks.tipLabels</code></a></li><li><a href="#PhyloNetworks.topologyMaxQPseudolik!"><code>PhyloNetworks.topologyMaxQPseudolik!</code></a></li><li><a href="#PhyloNetworks.topologyQPseudolik!"><code>PhyloNetworks.topologyQPseudolik!</code></a></li><li><a href="#PhyloNetworks.treeEdgesBootstrap"><code>PhyloNetworks.treeEdgesBootstrap</code></a></li><li><a href="#PhyloNetworks.treeedgecomponents"><code>PhyloNetworks.treeedgecomponents</code></a></li><li><a href="#PhyloNetworks.undirectedOtherNetworks"><code>PhyloNetworks.undirectedOtherNetworks</code></a></li><li><a href="#PhyloNetworks.vcv"><code>PhyloNetworks.vcv</code></a></li><li><a href="#PhyloNetworks.writeMultiTopology"><code>PhyloNetworks.writeMultiTopology</code></a></li><li><a href="#PhyloNetworks.writeSubTree!"><code>PhyloNetworks.writeSubTree!</code></a></li><li><a href="#PhyloNetworks.writeTableCF"><code>PhyloNetworks.writeTableCF</code></a></li><li><a href="#PhyloNetworks.writeTopology"><code>PhyloNetworks.writeTopology</code></a></li></ul><h2 id="types"><a class="docs-heading-anchor" href="#types">types</a><a id="types-1"></a><a class="docs-heading-anchor-permalink" href="#types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.BinaryTraitSubstitutionModel" href="#PhyloNetworks.BinaryTraitSubstitutionModel"><code>PhyloNetworks.BinaryTraitSubstitutionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BinaryTraitSubstitutionModel(α, β [, label])</code></pre><p>Model for binary traits, that is, with 2 states. Default labels are &quot;0&quot; and &quot;1&quot;. α is the rate of transition from &quot;0&quot; to &quot;1&quot;, and β from &quot;1&quot; to &quot;0&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L262-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.DataCF" href="#PhyloNetworks.DataCF"><code>PhyloNetworks.DataCF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DataCF</code></pre><p>type that contains the following attributes:</p><ul><li>quartet (vector of Quartets)</li><li>numQuartets</li><li>tree (vector of trees: empty if a table of CF was input instead of list of trees)</li><li>numTrees (-1 if a table CF was input instead of list of trees)</li><li>repSpecies (taxon names that were repeated in table of CF or input gene trees: used inside snaq for multiple alleles case)</li></ul><p>The list of Quartet may be accessed with the attribute .quartet. If the input was a list of trees, the HybridNetwork&#39;s can be accessed with the attribute .tree. For example, if the DataCF object is named d, d.quartet[1] will show the first quartet and d.tree[1] will print the first input tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/types.jl#L512-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.EqualRatesSubstitutionModel" href="#PhyloNetworks.EqualRatesSubstitutionModel"><code>PhyloNetworks.EqualRatesSubstitutionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EqualRatesSubstitutionModel(numberStates, α, labels)</code></pre><p><a href="#PhyloNetworks.TraitSubstitutionModel"><code>TraitSubstitutionModel</code></a> for traits with any number of states and equal substitution rates α between all states. Default labels are &quot;1&quot;,&quot;2&quot;,...</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = EqualRatesSubstitutionModel(2, [1.0], [&quot;low&quot;,&quot;high&quot;])
Equal Rates Substitution Model with k=2,
all rates equal to α=1.0.
rate matrix Q:
             low    high
     low       *  1.0000
    high  1.0000       *</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L415-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.HKY85" href="#PhyloNetworks.HKY85"><code>PhyloNetworks.HKY85</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HKY85(rate, pi, relative)</code></pre><p>A nucleic acid substitution model based on Hasegawa et al. 1985 substitution model. <code>rate</code> should be a vector of 1 or 2 rates, and <code>pi</code> a vector of 4 probabilities summing to 1.</p><p>If <code>relative</code> is false, the 2 rates represent the transition rate and the transversion rate, α and β. If <code>relative</code> is true (default), only the first rate is used and represents the transition/transversion ratio: κ=α/β. The rate transition matrix Q is normalized to have 1 change / unit of time on average, i.e. the absolute version of Q is divided by <code>2(piT*piC + piA*piG)α + 2(piY*piR)β</code>.</p><p><code>nparams</code> returns 1 or 2. In other words: the stationary distribution is not counted in the number of parameters (and <code>fitdiscrete</code> does not optimize the pi values at the moment).</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = HKY85([.5], [0.20, 0.30, 0.30, 0.20])
HKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]
relative rate version with transition/tranversion ratio kappa = 0.5,
 scaled so that there is one substitution per unit time
rate matrix Q:
               A       C       G       T
       A       *  0.4839  0.2419  0.3226
       C  0.3226       *  0.4839  0.1613
       G  0.1613  0.4839       *  0.3226
       T  0.3226  0.2419  0.4839       *

julia&gt; nstates(m1)
4

julia&gt; m2 = HKY85([0.5, 0.5], [0.20, 0.30, 0.30, 0.20], false)
HKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]
absolute rate version with transition/transversion ratio kappa = a/b = 1.0
 with rates a = 0.5 and b = 0.5
rate matrix Q:
               A       C       G       T
       A       *  0.1500  0.1500  0.1000
       C  0.1000       *  0.1500  0.1000
       G  0.1000  0.1500       *  0.1000
       T  0.1000  0.1500  0.1500       *
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L721-L766">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.HybridNetwork" href="#PhyloNetworks.HybridNetwork"><code>PhyloNetworks.HybridNetwork</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HybridNetwork</code></pre><p>Subtype of abstract <code>Network</code> type. Explicit network or tree with the following attributes:</p><ul><li>numTaxa (taxa are tips, i.e. nodes attached to a single edge)</li><li>numNodes (total number of nodes: tips and internal nodes)</li><li>numEdges</li><li>numHybrids (number of hybrid nodes)</li><li>edge (array of Edges)</li><li>node (array of Nodes)</li><li>root (index of root in vector &#39;node&#39;. May be artificial, for printing and traversal purposes only.)</li><li>hybrid (array of Nodes: those are are hybrid nodes)</li><li>leaf (array of Nodes: those that are leaves)</li><li>loglik (score after fitting network to data, i.e. negative log pseudolik for SNaQ)</li><li>isRooted (true or false)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/types.jl#L171-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.JC69" href="#PhyloNetworks.JC69"><code>PhyloNetworks.JC69</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JC69(rate, relative)</code></pre><p>Jukes Cantor (1969) nucleic acid substitution model, which has a single rate parameter. <code>rate</code> corresponds to the absolute diagonal elements, that is, the rate of change (to any of the other 2 states). Individual rates are <code>rate</code>/3. If <code>relative</code> is true (default), the transition matrix <a href="#PhyloNetworks.Q"><code>Q</code></a> is normalized to an average of 1 transition per unit of time: in which case <code>rate</code> is set to 1.0.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = JC69([0.25], false)
Jukes and Cantor 69 Substitution Model,
absolute rate version
off-diagonal rates equal to 0.25/3.
rate matrix Q:
               A       C       G       T
       A       *  0.0833  0.0833  0.0833
       C  0.0833       *  0.0833  0.0833
       G  0.0833  0.0833       *  0.0833
       T  0.0833  0.0833  0.0833       *

julia&gt; nstates(m1)
4

julia&gt; nparams(m1)
1

julia&gt; m2 = JC69([0.5])
Jukes and Cantor 69 Substitution Model,
relative rate version
off-diagonal rates equal to 1/3
rate matrix Q:
               A       C       G       T
       A       *  0.3333  0.3333  0.3333
       C  0.3333       *  0.3333  0.3333
       G  0.3333  0.3333       *  0.3333
       T  0.3333  0.3333  0.3333       *

julia&gt; nparams(m2)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L631-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.ParamsBM" href="#PhyloNetworks.ParamsBM"><code>PhyloNetworks.ParamsBM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParamsBM &lt;: ParamsProcess</code></pre><p>Type for a BM process on a network. Fields are <code>mu</code> (expectation), <code>sigma2</code> (variance), <code>randomRoot</code> (whether the root is random, default to <code>false</code>), and <code>varRoot</code> (if the root is random, the variance of the root, default to <code>NaN</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L853-L860">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.ParamsMultiBM" href="#PhyloNetworks.ParamsMultiBM"><code>PhyloNetworks.ParamsMultiBM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParamsMultiBM &lt;: ParamsProcess</code></pre><p>Type for a multivariate Brownian diffusion (MBD) process on a network. Fields are <code>mu</code> (expectation), <code>sigma</code> (covariance matrix), <code>randomRoot</code> (whether the root is random, default to <code>false</code>), <code>varRoot</code> (if the root is random, the covariance matrix of the root, default to <code>[NaN]</code>), <code>shift</code> (a ShiftNet type, default to <code>missing</code>), and <code>L</code> (the lower triangular of the cholesky decomposition of <code>sigma</code>, computed automatically)</p><p><strong>Constructors</strong></p><pre><code class="language-julia-repl">julia&gt; ParamsMultiBM([1.0, -0.5], [2.0 0.3; 0.3 1.0]) # no shifts
ParamsMultiBM:
Parameters of a MBD with fixed root:
mu: [1.0, -0.5]
Sigma: [2.0 0.3; 0.3 1.0]

julia&gt; net = readTopology(&quot;((A:1,B:1):1,C:2);&quot;);

julia&gt; shifts = ShiftNet(net.node[2], [-1.0, 2.0], net);

julia&gt; ParamsMultiBM([1.0, -0.5], [2.0 0.3; 0.3 1.0], shifts) # with shifts
ParamsMultiBM:
Parameters of a MBD with fixed root:
mu: [1.0, -0.5]
Sigma: [2.0 0.3; 0.3 1.0]

There are 2 shifts on the network:
───────────────────────────────────────────
  Edge Number  Shift Value 1  Shift Value 2
───────────────────────────────────────────
          2.0           -1.0            2.0
───────────────────────────────────────────

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L920-L957">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.PhyloNetworkLinearModel" href="#PhyloNetworks.PhyloNetworkLinearModel"><code>PhyloNetworks.PhyloNetworkLinearModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PhyloNetworkLinearModel &lt;: GLM.LinPredModel</code></pre><p>Phylogenetic linear model representation.</p><p><strong>Fields</strong></p><p><code>lm</code>, <code>V</code>, <code>Vy</code>, <code>RL</code>, <code>Y</code>, <code>X</code>, <code>logdetVy</code>, <code>reml</code>, <code>ind</code>, <code>nonmissing</code>, <code>model</code>, <code>model_within</code>. The following syntax pattern can be used to get more information on a specific field: e.g. to find out about the <code>lm</code> field, do <code>?PhyloNetworkLinearModel.lm</code>.</p><p><strong>Methods applied to fitted models</strong></p><p>The following StatsBase functions can be applied: <code>coef</code>, <code>nobs</code>, <code>vcov</code>, <code>stderror</code>, <code>confint</code>, <code>coeftable</code>, <code>dof_residual</code>, <code>dof</code>, <code>deviance</code>, <code>residuals</code>, <code>response</code>, <code>predict</code>, <code>loglikelihood</code>, <code>nulldeviance</code>, <code>nullloglikelihood</code>, <code>r2</code>, <code>adjr2</code>, <code>aic</code>, <code>aicc</code>, <code>bic</code>, <code>ftest</code>, <code>lrtest</code> etc.</p><p>The estimated variance-rate and estimated mean of the species-level trait model (see <a href="../internals/#PhyloNetworks.ContinuousTraitEM"><code>ContinuousTraitEM</code></a>) can be retrieved using <a href="#PhyloNetworks.sigma2_phylo"><code>sigma2_phylo</code></a> and <a href="#PhyloNetworks.mu_phylo"><code>mu_phylo</code></a> respectively.</p><p>If relevant, the estimated individual-level/within-species variance can be retrieved using <a href="#PhyloNetworks.sigma2_within"><code>sigma2_within</code></a>.</p><p>The optimized λ parameter for Pagel&#39;s λ model (see <a href="../internals/#PhyloNetworks.PagelLambda"><code>PagelLambda</code></a>) can be retrieved using <a href="#PhyloNetworks.lambda_estim"><code>lambda_estim</code></a>.</p><p>An ancestral state reconstruction can be performed using <a href="#PhyloNetworks.ancestralStateReconstruction"><code>ancestralStateReconstruction</code></a>.</p><p><strong>Within-species variation</strong></p><p>The true species/population means for the response trait/variable (or the residuals: conditional on the predictors) are jointly modeled as 𝒩(·, σ²ₛV) where V depends on the trait model (see <a href="../internals/#PhyloNetworks.ContinuousTraitEM"><code>ContinuousTraitEM</code></a>) and on the species network. σ²ₛ is the between-species variance-rate.</p><p>Within-species variation is modeled by assuming that the individual-level responses are iid 𝒩(0, σ²ₑ) about the true species means, so that the species-level sample means (conditional on the predictors) are jointly modeled as 𝒩(·, σ²ₛV + σ²ₑD⁻¹), where σ²ₑ is the within-species variance and D⁻¹ is a diagonal matrix whose entries are the inverse sample-sizes (see <a href="../internals/#PhyloNetworks.WithinSpeciesCTM"><code>WithinSpeciesCTM</code></a>).</p><p>Although the above two models can be expressed in terms of a joint distribution for the species-level sample means (or residuals conditional on the predictors), more data are required to fit a model accounting for within-species variation, that is, a model recognizing that the sample means are estimates of the true population means. To fit a model <em>without</em> within-species variation, data on the species means are sufficient. To fit a model <em>with</em> within-species variation, we need to have the species means and the standard deviations of the response variable for each species.</p><p><code>phylolm</code> can fit a model with within-species variation either from species-level statistics (&quot;mean response&quot; and &quot;standard deviation in response&quot;) or from individual-level data (in which case the species-level statistics are computed internally). See <a href="#PhyloNetworks.phylolm"><code>phylolm</code></a> for more details on these two input choices.</p><p>In the object, <code>obj.Y</code> and <code>obj.X</code> are the observed species means. <code>predict</code>, <code>residuals</code> and <code>response</code> return the values at the species level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L1590-L1650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.Quartet" href="#PhyloNetworks.Quartet"><code>PhyloNetworks.Quartet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Quartet</code></pre><p>type that saves the information on a given 4-taxon subset. It contains the following attributes:</p><ul><li>number: integer</li><li>taxon: vector of taxon names, like t1 t2 t3 t4</li><li>obsCF: vector of observed CF, in order 12|34, 13|24, 14|23</li><li>logPseudoLik</li><li>ngenes: number of gene trees used to compute the observed CF; -1.0 if unknown</li><li>qnet: <a href="../internals/#PhyloNetworks.QuartetNetwork"><code>QuartetNetwork</code></a>, which saves the expCF after snaq estimation to emphasize that the expCF depend on a specific network, not the data</li></ul><p>see also: <a href="../internals/#PhyloNetworks.QuartetT"><code>QuartetT</code></a> for quartet with data of user-defined type <code>T</code>, using a mapping between quartet indices and quartet taxa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/types.jl#L359-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.RateVariationAcrossSites" href="#PhyloNetworks.RateVariationAcrossSites"><code>PhyloNetworks.RateVariationAcrossSites</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RateVariationAcrossSites(rvsymbol::Symbol, ncategories=4::Int)</code></pre><p>Default model for rate variation across site, specified by a symbol:</p><ul><li><code>:noRV</code> for no rate variation</li><li><code>:G</code> or <code>:Gamma</code> for gamma-distributed rates</li><li><code>:I</code> or <code>:Inv</code> for two categories: invariable and variable</li><li><code>:GI</code> or <code>:GI</code> for both.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L1082-L1090">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.RateVariationAcrossSites-Tuple{}" href="#PhyloNetworks.RateVariationAcrossSites-Tuple{}"><code>PhyloNetworks.RateVariationAcrossSites</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RateVariationAcrossSites(; pinv=0.0, alpha=Inf, ncat=4)</code></pre><p>Model for variable substitution rates across sites (or across traits) using the discrete Gamma model (+G, Yang 1994, Journal of Molecular Evolution) or the invariable-sites model (+I, Hasegawa, Kishino &amp; Yano 1985 J Mol Evol). Both types of rate variation can be combined (+G+I, Gu, Fu &amp; Li 1995, Mol Biol Evol) but this is discouraged (Jia, Lo &amp; Ho 2014 PLOS One). Using rate variation increases the number of parameters by one (+G or +I) or by two (+G+I).</p><p>Because the mean of the desired distribution or rates is 1, we use a Gamma distribution with shape α and scale θ=1/α (rate β=α) if no invariable sites, or scale θ=1/(α(1-pinv)), that is rate β=α(1-pinv) with a proportion pinv of invariable sites. The shape parameter is referred to as alpha here. The Gamma distribution is discretized into <code>ncat</code> categories. In each category, the category&#39;s rate multiplier is a normalized quantile of the gamma distribution.</p><pre><code class="language-julia-repl">julia&gt; rv = RateVariationAcrossSites()
Rate variation across sites: discretized Gamma
categories for Gamma discretization: 1
rates: [1.0]

julia&gt; nparams(rv)
0

julia&gt; typeof(rv)
PhyloNetworks.RVASGamma{1}

julia&gt; rv = RateVariationAcrossSites(alpha=1.0, ncat=4)
Rate variation across sites: discretized Gamma
alpha: 1.0
categories for Gamma discretization: 4
rates: [0.146, 0.513, 1.071, 2.27]

julia&gt; typeof(rv)
PhyloNetworks.RVASGamma{4}

julia&gt; PhyloNetworks.setalpha!(rv, 2.0)
Rate variation across sites: discretized Gamma
alpha: 2.0
categories for Gamma discretization: 4
rates: [0.319, 0.683, 1.109, 1.889]

julia&gt; nparams(rv)
1

julia&gt; rv = RateVariationAcrossSites(pinv=0.3)
Rate variation across sites: +I (invariable sites)
pinv: 0.3
rates: [0.0, 1.429]

julia&gt; nparams(rv)
1

julia&gt; typeof(rv)
PhyloNetworks.RVASInv

julia&gt; PhyloNetworks.setpinv!(rv, 0.05)
Rate variation across sites: +I (invariable sites)
pinv: 0.05
rates: [0.0, 1.053]

julia&gt; rv = RateVariationAcrossSites(pinv=0.3, alpha=2.0, ncat=4)
Rate variation across sites: discretized Gamma+I
pinv: 0.3
alpha: 2.0
categories for Gamma discretization: 4
rates: [0.0, 0.456, 0.976, 1.584, 2.698]
probabilities: [0.3, 0.175, 0.175, 0.175, 0.175]

julia&gt; nparams(rv)
2

julia&gt; typeof(rv)
PhyloNetworks.RVASGammaInv{5}

julia&gt; PhyloNetworks.setalpha!(rv, 3.0)
Rate variation across sites: discretized Gamma+I
pinv: 0.3
alpha: 3.0
categories for Gamma discretization: 4
rates: [0.0, 0.6, 1.077, 1.584, 2.454]
probabilities: [0.3, 0.175, 0.175, 0.175, 0.175]

julia&gt; PhyloNetworks.setpinv!(rv, 0.05)
Rate variation across sites: discretized Gamma+I
pinv: 0.05
alpha: 3.0
categories for Gamma discretization: 4
rates: [0.0, 0.442, 0.793, 1.167, 1.808]
probabilities: [0.05, 0.238, 0.238, 0.238, 0.238]

julia&gt; PhyloNetworks.setpinvalpha!(rv, 0.1, 5.0)
Rate variation across sites: discretized Gamma+I
pinv: 0.1
alpha: 5.0
categories for Gamma discretization: 4
rates: [0.0, 0.593, 0.91, 1.221, 1.721]
probabilities: [0.1, 0.225, 0.225, 0.225, 0.225]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L965-L1068">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.ReconstructedStates" href="#PhyloNetworks.ReconstructedStates"><code>PhyloNetworks.ReconstructedStates</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReconstructedStates</code></pre><p>Type containing the inferred information about the law of the ancestral states given the observed tips values. The missing tips are considered as ancestral states.</p><p>The following functions can be applied to it: <a href="#PhyloNetworks.expectations"><code>expectations</code></a> (vector of expectations at all nodes), <code>stderror</code> (the standard error), <code>predint</code> (the prediction interval).</p><p>The <code>ReconstructedStates</code> object has fields: <code>traits_nodes</code>, <code>variances_nodes</code>, <code>NodeNumbers</code>, <code>traits_tips</code>, <code>tipNumbers</code>, <code>model</code>. Type in &quot;?ReconstructedStates.field&quot; to get help on a specific field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L3088-L3100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.ShiftNet" href="#PhyloNetworks.ShiftNet"><code>PhyloNetworks.ShiftNet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ShiftNet</code></pre><p>Shifts associated to a <a href="#PhyloNetworks.HybridNetwork"><code>HybridNetwork</code></a> sorted in topological order. Its <code>shift</code> field is a vector of shift values, one for each node, corresponding to the shift on the parent edge of the node (which makes sense for tree nodes only: they have a single parent edge).</p><p>Two <code>ShiftNet</code> objects on the same network can be concatened with <code>*</code>.</p><p><code>ShiftNet(node::Vector{Node}, value::AbstractVector, net::HybridNetwork; checkPreorder=true::Bool)</code></p><p>Constructor from a vector of nodes and associated values. The shifts are located on the edges above the nodes provided. Warning, shifts on hybrid edges are not allowed.</p><p><code>ShiftNet(edge::Vector{Edge}, value::AbstractVector, net::HybridNetwork; checkPreorder=true::Bool)</code></p><p>Constructor from a vector of edges and associated values. Warning, shifts on hybrid edges are not allowed.</p><p>Extractors: <a href="#PhyloNetworks.getShiftEdgeNumber"><code>getShiftEdgeNumber</code></a>, <a href="#PhyloNetworks.getShiftValue"><code>getShiftValue</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L662-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.TraitSimulation" href="#PhyloNetworks.TraitSimulation"><code>PhyloNetworks.TraitSimulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TraitSimulation</code></pre><p>Result of a trait simulation on an <a href="#PhyloNetworks.HybridNetwork"><code>HybridNetwork</code></a> with function <a href="#PhyloNetworks.simulate"><code>simulate</code></a>.</p><p>The following functions and extractors can be applied to it: <a href="#PhyloNetworks.tipLabels"><code>tipLabels</code></a>, <code>obj[:Tips]</code>, <code>obj[:InternalNodes]</code> (see documentation for function <a href="#Base.getindex-Tuple{TraitSimulation, Symbol}"><code>getindex(::TraitSimulation, ::Symbol)</code></a>).</p><p>The <code>TraitSimulation</code> object has fields: <code>M</code>, <code>params</code>, <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L1044-L1052">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.TraitSubstitutionModel" href="#PhyloNetworks.TraitSubstitutionModel"><code>PhyloNetworks.TraitSubstitutionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TraitSubstitutionModel</code></pre><p>For subtypes, see <a href="#PhyloNetworks.BinaryTraitSubstitutionModel"><code>BinaryTraitSubstitutionModel</code></a>, <a href="#PhyloNetworks.EqualRatesSubstitutionModel"><code>EqualRatesSubstitutionModel</code></a>, <a href="#PhyloNetworks.TwoBinaryTraitSubstitutionModel"><code>TwoBinaryTraitSubstitutionModel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.TwoBinaryTraitSubstitutionModel" href="#PhyloNetworks.TwoBinaryTraitSubstitutionModel"><code>PhyloNetworks.TwoBinaryTraitSubstitutionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TwoBinaryTraitSubstitutionModel(rate [, label])</code></pre><p><a href="#PhyloNetworks.TraitSubstitutionModel"><code>TraitSubstitutionModel</code></a> for two binary traits, possibly correlated. Default labels are &quot;x0&quot;, &quot;x1&quot; for trait 1, and &quot;y0&quot;, &quot;y1&quot; for trait 2. If provided, <code>label</code> should be a vector of size 4, listing labels for trait 1 first then labels for trait 2. <code>rate</code> should be a vector of substitution rates of size 8. rate[1],...,rate[4] describe rates of changes in trait 1. rate[5],...,rate[8] describe rates of changes in trait 2. In the transition matrix, trait combinations are listed in the following order: x0-y0, x0-y1, x1-y0, x1-y1.</p><p><strong>example</strong></p><pre><code class="language-julia">model = TwoBinaryTraitSubstitutionModel([2.0,1.2,1.1,2.2,1.0,3.1,2.0,1.1],
        [&quot;carnivory&quot;, &quot;noncarnivory&quot;, &quot;wet&quot;, &quot;dry&quot;]);
model
using PhyloPlots
plot(model) # to visualize states and rates</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L350-L372">source</a></section></article><h2 id="utilities"><a class="docs-heading-anchor" href="#utilities">utilities</a><a id="utilities-1"></a><a class="docs-heading-anchor-permalink" href="#utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.tipLabels" href="#PhyloNetworks.tipLabels"><code>PhyloNetworks.tipLabels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tipLabels(x)</code></pre><p>Return a vector of taxon names at the leaves, for objects of various types: <code>HybridNetwork</code>, Vector of <code>HybridNetwork</code>s (in which case the union is taken then sorted), Vector of <code>Quartet</code>s, <code>DataCF</code>, <code>TraitSimulation</code>, <code>MatrixTopologicalOrder</code>.</p><p>For a network, the taxon names are coerced to strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/descriptive.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.sorttaxa!" href="#PhyloNetworks.sorttaxa!"><code>PhyloNetworks.sorttaxa!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sorttaxa!(DataFrame, columns)</code></pre><p>Reorder the 4 taxa and reorders the observed concordance factors accordingly, on each row of the data frame. If <code>columns</code> is ommitted, taxon names are assumed to be in columns 1-4 and CFs are assumed to be in columns 5-6 with quartets in this order: <code>12_34</code>, <code>13_24</code>, <code>14_23</code>. Does <strong>not</strong> reorder credibility interval values, if present.</p><pre><code class="language-none">sorttaxa!(DataCF)
sorttaxa!(Quartet, permutation_tax, permutation_cf)</code></pre><p>Reorder the 4 taxa in each element of the DataCF <code>quartet</code>. For a given Quartet, reorder the 4 taxa in its fields <code>taxon</code> and <code>qnet.quartetTaxon</code> (if non-empty) and reorder the 3 concordance values accordingly, in <code>obsCF</code> and <code>qnet.expCF</code>.</p><p><code>permutation_tax</code> and <code>permutation_cf</code> should be vectors of short integers (Int8) of length 4 and 3 respectively, whose memory allocation gets reused. Their length is <em>not checked</em>.</p><p><code>qnet.names</code> is unchanged: the order of taxon names here relates to the order of nodes in the network (???)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/auxiliary.jl#L1262-L1282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.printEdges" href="#PhyloNetworks.printEdges"><code>PhyloNetworks.printEdges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">printEdges(net)
printEdges(io::IO, net)</code></pre><p>Print information on the edges of a <code>HybridNetwork</code> or <code>QuartetNetwork</code> object <code>net</code>: edge number, numbers of nodes attached to it, edge length, whether it&#39;s a hybrid edge, its γ inheritance value, whether it&#39;s a major edge, if it could contain the root (this field is not always updated, though) and attributes pertaining to level-1 networks used in SNaQ: in which cycle it is contained (-1 if no cycle), and if the edge length is identifiable (based on quartet concordance factors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/auxiliary.jl#L626-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.printNodes" href="#PhyloNetworks.printNodes"><code>PhyloNetworks.printNodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">printNodes(net)
printNodes(io, net)</code></pre><p>Print information on the nodes of a <code>HybridNetwork</code> net: node number, whether it&#39;s a leaf, whether it&#39;s a hybrid node, whether it&#39;s connected to one or more hybrid edges, it&#39;s name (label), the cycle in which it is belong (-1 if no cycle; makes sense for level-1 networks), and the list of edges attached to it, by their numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/auxiliary.jl#L664-L673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.summarizeDataCF" href="#PhyloNetworks.summarizeDataCF"><code>PhyloNetworks.summarizeDataCF</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>summarizeDataCF(d::DataCF)</code></p><p>function to summarize the information contained in a DataCF object. It has the following optional arguments:</p><ul><li>filename: if provided, the summary will be saved in the filename, not to screen</li><li>pc (number between (0,1)): threshold of percentage of missing genes to identify 4-taxon subsets with fewer genes than the threshold</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readData.jl#L1062-L1068">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.directEdges!" href="#PhyloNetworks.directEdges!"><code>PhyloNetworks.directEdges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">directEdges!(net::HybridNetwork; checkMajor=true::Bool)</code></pre><p>Updates the edges&#39; attribute <code>isChild1</code>, according to the root placement. Also updates edges&#39; attribute <code>containRoot</code>, for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if checkMajor=true.</p><p>Warnings:</p><ol><li>Assumes that isChild1 is correct on hybrid edges</li></ol><p>(to avoid changing the identity of which nodes are hybrids and which are not).</p><ol><li>Does not check for cycles (to maintain a network&#39;s DAG status)</li></ol><p>Returns the network. Throws a &#39;RootMismatch&#39; Exception if the root was found to conflict with the direction of any hybrid edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/manipulateNet.jl#L609-L625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.checkroot!" href="#PhyloNetworks.checkroot!"><code>PhyloNetworks.checkroot!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">checkroot!(net)
checkroot!(net::HybridNetwork, membership::Dict{Node, Int})</code></pre><p>Set the root of <code>net</code> to an appropriate node and update the edges <code>containRoot</code> field appropriately, using the <code>membership</code> output by <a href="#PhyloNetworks.treeedgecomponents"><code>treeedgecomponents</code></a>. A node is appropriate to serve as root if it belongs in the root tree-edge component, that is, the root of the tree-edge component graph.</p><ul><li>If the current root is appropriate, it is left as is. The direction of edges (via <code>isChild1</code>) is also left as is, assuming it was in synch with the existing root.</li><li>Otherwise, the root is set to the first appropriate node in <code>net.node</code>, that is not a leaf. Then edges are directed away from this root.</li></ul><p>A <code>RootMismatch</code> error is thrown if <code>net</code> is not a valid semidirected phylogenetic network (i.e. it is not possible to root the network in a way compatible with the given hybrid edges).</p><p>Output: the <code>membership</code> ID of the root component. The full set of nodes in the root component can be obtained as shown below. Warning: only use the output component ID after calling the second version <code>checkroot!(net, membership)</code>.</p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(#H1:::0.1,#H2:::0.2,(((b)#H1)#H2,a));&quot;);

julia&gt; membership = treeedgecomponents(net);

julia&gt; rootcompID = checkroot!(net, membership);

julia&gt; rootcomp = keys(filter(p -&gt; p.second == rootcompID, membership));

julia&gt; sort([n.number for n in rootcomp]) # number of nodes in the root component
3-element Vector{Int64}:
 -3
 -2
  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/graph_components.jl#L304-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.preorder!" href="#PhyloNetworks.preorder!"><code>PhyloNetworks.preorder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">preorder!(net::HybridNetwork)</code></pre><p>Updates attribute net.nodes_changed in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges&#39; direction needs to be correct before calling preorder!, using directEdges!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/manipulateNet.jl#L758-L764">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.cladewiseorder!" href="#PhyloNetworks.cladewiseorder!"><code>PhyloNetworks.cladewiseorder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cladewiseorder!(net::HybridNetwork)</code></pre><p>Updates attribute net.cladewiseorder_nodeIndex. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges&#39; direction needs to be correct before calling <a href="#PhyloNetworks.cladewiseorder!"><code>cladewiseorder!</code></a>, using <a href="#PhyloNetworks.directEdges!"><code>directEdges!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/manipulateNet.jl#L801-L809">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.rootatnode!" href="#PhyloNetworks.rootatnode!"><code>PhyloNetworks.rootatnode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rootatnode!(HybridNetwork, nodeNumber::Integer; index=false::Bool, verbose=true::Bool)
rootatnode!(HybridNetwork, Node; verbose=true)
rootatnode!(HybridNetwork, nodeName::AbstractString; verbose=true)</code></pre><p>Root the network/tree object at the node with name &#39;nodeName&#39; or number &#39;nodeNumber&#39; (by default) or with index &#39;nodeNumber&#39; if index=true. Attributes isChild1 and containRoot are updated along the way. Use <code>plot(net, showNodeNumber=true, showEdgeLength=false)</code> to visualize and identify a node of interest. (see package <a href="https://github.com/cecileane/PhyloPlots.jl">PhyloPlots</a>)</p><p>Return the network.</p><p>Warnings:</p><ul><li><p>If the node is a leaf, the root will be placed along the edge adjacent to the leaf. This might add a new node.</p></li><li><p>If the desired root placement is incompatible with one or more hybrids, then</p><ul><li>a RootMismatch error is thrown; use <code>verbose=false</code> to silence the root mismatch info printed before the error is thrown.</li><li>the input network will still have some attributes modified.</li></ul></li></ul><p>See also: <a href="#PhyloNetworks.rootonedge!"><code>rootonedge!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/manipulateNet.jl#L226-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.rootonedge!" href="#PhyloNetworks.rootonedge!"><code>PhyloNetworks.rootonedge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rootonedge!(HybridNetwork, edgeNumber::Integer; index=false::Bool, verbose=true::Bool)
rootonedge!(HybridNetwork, Edge; verbose=true::Bool)</code></pre><p>Root the network/tree along an edge with number <code>edgeNumber</code> (by default) or with index <code>edgeNumber</code> if <code>index=true</code>. Attributes <code>isChild1</code> and <code>containRoot</code> are updated along the way.</p><p>This adds a new node and a new edge to the network. Use <code>plot(net, showEdgeNumber=true, showEdgeLength=false)</code> to visualize and identify an edge of interest. (see package <a href="https://github.com/cecileane/PhyloPlots.jl">PhyloPlots</a>)</p><p>See also: <a href="#PhyloNetworks.rootatnode!"><code>rootatnode!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/manipulateNet.jl#L306-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hybridatnode!" href="#PhyloNetworks.hybridatnode!"><code>PhyloNetworks.hybridatnode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hybridatnode!(net::HybridNetwork, nodeNumber::Integer)</code></pre><p>Change the status of edges in network <code>net</code>, to move the hybrid node in a cycle to the node with number <code>nodeNumber</code>. This node must be in one (and only one) cycle, otherwise an error will be thrown.</p><p><code>net</code> is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. Check and update the nodes&#39; field <code>inCycle</code>.</p><p><strong>example</strong></p><pre><code class="language-julia">net = readTopology(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
using PhyloPlots
plot(net, :R, showNodeNumber=true); # to locate nodes and their numbers. D of hybrid origin
hybridatnode!(net, -4)
plot(net, :R, showNodeNumber=true); # hybrid direction reversed: now 2B of hybrid origin</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/manipulateNet.jl#L96-L117">source</a></section><section><div><pre><code class="language-none">hybridatnode!(net::HybridNetwork, hybrid::Node, newNode::Node)</code></pre><p>Move the reticulation from <code>hybrid</code> to <code>newNode</code>, which must in the same cycle. <code>net</code> is assumed to be of level 1, but <strong>no checks</strong> are made and fields are supposed up-to-date.</p><p>Called by <code>hybridatnode!(net, node number)</code>, which is itself called by <a href="public/#PhyloNetworks.undirectedOtherNetworks"><code>undirectedOtherNetworks</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/manipulateNet.jl#L143-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setLength!" href="#PhyloNetworks.setLength!"><code>PhyloNetworks.setLength!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setLength!(edge, newlength)`</code></pre><p>Set the length of <code>edge</code>, and set <code>edge.y</code> and <code>edge.z</code> accordingly. Warning: specific to SNaQ. Use <a href="../internals/#PhyloNetworks.setlengths!-Tuple{Vector{PhyloNetworks.Edge}, Vector{Float64}}"><code>setlengths!</code></a> or <a href="../internals/#PhyloNetworks.setBranchLength!-Tuple{PhyloNetworks.Edge, Number}"><code>setBranchLength!</code></a> for more general tools.</p><ul><li>The new length is censored to 10: if the new length is above 10, the edge&#39;s length will be set to 10. Lengths are interpreted in coalescent units, and 10 is close to infinity: near perfect gene tree concordance. 10 is used as an upper limit to coalescent units that can be reliably estimated.</li><li>The new length is allowed to be negative, but must be greater than -log(1.5), to ensure that the major quartet concordance factor (1 - 2/3 exp(-length)) is &gt;= 0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/auxiliary.jl#L832-L845">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.setGamma!" href="#PhyloNetworks.setGamma!"><code>PhyloNetworks.setGamma!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setGamma!(Edge, new γ)
setGamma!(Edge, new γ, change_other=true::Bool)</code></pre><p>Set inheritance probability γ for an edge, which must be a hybrid edge. The new γ needs to be in [0,1]. The γ of the &quot;partner&quot; hybrid edge is changed accordingly, to 1-γ. The field <code>isMajor</code> is also changed accordingly. If the new γ is approximately 0.5, <code>Edge</code> is set to the major parent, its partner is set to the minor parent.</p><p>If <code>net</code> is a HybridNetwork object, <code>printEdges(net)</code> will show the list of edges and their γ&#39;s. The γ of the third hybrid edge (say) can be changed to 0.2 with <code>setGamma!(net.edge[3],0.2)</code>. This will automatically set γ of the partner hybrid edge to 0.8.</p><p>The last argument is true by default. If false: the partner edge is not updated. This is useful if the new γ is 0.5, and the partner&#39;s γ is already 0.5, in which case the <code>isMajor</code> attributes can remain unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/auxiliary.jl#L864-L882">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.deleteleaf!" href="#PhyloNetworks.deleteleaf!"><code>PhyloNetworks.deleteleaf!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deleteleaf!(HybridNetwork, leafName::AbstractString; ...)
deleteleaf!(HybridNetwork, Node; ...)
deleteleaf!(HybridNetwork, Integer; index=false, ...)</code></pre><p>Delete a node from the network, possibly from its name, number, or index in the network&#39;s array of nodes. The first two versions require that the node is a leaf. The third version does <strong>not</strong> require that the node is a leaf: If it has degree 3 or more, nothing happens. If it has degree 1 or 2, then it is deleted.</p><p><strong>keyword arguments</strong></p><p><code>simplify</code>: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.</p><p><code>unroot</code>: if true, a root of degree 1 or 2 is deleted. If false, the root is deleted if it is of degree 1 (no root edge is left), but is kept if it is of degree 2. Deleting all leaves in an outgroup clade or grade will leave the ingroup rooted (that is, the new root will be of degree 2).</p><p><code>nofuse</code>: if true, keep nodes (and edges) provided that they have at least one descendant leaf, even if they are of degree 2. This will keep two-cycles (forcing <code>simplify</code> to false). Nodes without any descendant leaves are deleted. If <code>nofuse</code> is false, edges adjacent to degree-2 nodes are fused.</p><p><code>multgammas</code>: if true, the fused edge has γ equal to the product of the hybrid edges that have been fused together, which may result in tree edges with γ&lt;1, or with reticulations in which the two parent γ don&#39;t add up to 1.</p><p><code>keeporiginalroot</code>: if true, keep the root even if it is of degree one.</p><p>Warning: does <strong>not</strong> update attributes related to level-1 networks, such as inCycle, partition, gammaz, etc. Does not require branch lengths, and designed to work on networks of all levels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/manipulateNet.jl#L905-L946">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.deleteHybridThreshold!" href="#PhyloNetworks.deleteHybridThreshold!"><code>PhyloNetworks.deleteHybridThreshold!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deleteHybridThreshold!(net::HybridNetwork, threshold::Float64,
                       nofuse=false, unroot=false, multgammas=false,
                       keeporiginalroot=false)</code></pre><p>Deletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.</p><ul><li>if threshold&lt;0.5: delete minor hybrid edges with γ &lt; threshold (or with a missing γ, for any threshold &gt; -1.0)</li><li>if threshold=0.5: delete all minor hybrid edges (i.e normally with γ &lt; 0.5, if γ non-missing)</li><li><code>nofuse</code>: if true, do not fuse edges and keep original nodes.</li><li><code>unroot</code>: if false, the root will not be deleted if it becomes of degree 2.</li><li><code>multgammas</code>: if true, the modified edges have γ values equal to the proportion of genes that the extracted subnetwork represents. For an edge <code>e</code> in the modified network, the inheritance γ for <code>e</code> is the product of γs of all edges in the original network that have been merged into <code>e</code>.</li></ul><p>-<code>keeporiginalroot</code>: if true, the root will be retained even if of degree 1.</p><p>Warnings:</p><ul><li>by default, <code>nofuse</code> is false, partner hybrid edges are fused with their child edge and have their γ changed to 1.0. If <code>nofuse</code> is true: the γ&#39;s of partner hybrid edges are unchanged.</li><li>assumes correct <code>isMajor</code> fields, and correct <code>isChild1</code> fields to update <code>containRoot</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/compareNetworks.jl#L447-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.rotate!" href="#PhyloNetworks.rotate!"><code>PhyloNetworks.rotate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotate!(net::HybridNetwork, nodeNumber::Integer; orderedEdgeNum::Array{Int,1})</code></pre><p>Rotates the order of the node&#39;s children edges. Useful for plotting, to remove crossing edges. If <code>node</code> is a tree node with no polytomy, the 2 children edges are switched and the optional argument <code>orderedEdgeNum</code> is ignored.</p><p>Use <code>plot(net, showNodeNumber=true, showEdgeNumber=false)</code> to map node and edge numbers on the network, as shown in the examples below. (see package <a href="https://github.com/cecileane/PhyloPlots.jl">PhyloPlots</a>)</p><p>Warning: assumes that edges are correctly directed (isChild1 updated). This is done by <code>plot(net)</code>. Otherwise run <code>directEdges!(net)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; net = readTopology(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
julia&gt; using PhyloPlots
julia&gt; plot(net, showNodeNumber=true)
julia&gt; rotate!(net, -4)
julia&gt; plot(net)
julia&gt; net=readTopology(&quot;(4,((1,(2)#H7:::0.864):2.069,(6,5):3.423):0.265,(3,#H7:::0.136):10.0);&quot;);
julia&gt; plot(net, showNodeNumber=true, showEdgeNumber=true)
julia&gt; rotate!(net, -1, orderedEdgeNum=[1,12,9])
julia&gt; plot(net, showNodeNumber=true, showEdgeNumber=true)
julia&gt; rotate!(net, -3)
julia&gt; plot(net)</code></pre><p>Note that <code>LinearAlgebra</code> also exports a function named <code>rotate!</code> in Julia v1.5. If both packages need to be used in Julia v1.5 or higher, usage of <code>rotate!</code> needs to be qualified, such as with <code>PhyloNetworks.rotate!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/manipulateNet.jl#L830-L864">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{TraitSimulation, Symbol}" href="#Base.getindex-Tuple{TraitSimulation, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(obj, d)</code></pre><p>Getting submatrices of an object of type <a href="public/#PhyloNetworks.TraitSimulation"><code>TraitSimulation</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>obj::TraitSimulation</code>: the matrix from which to extract.</li><li><code>d::Symbol</code>: a symbol precising which sub-matrix to extract. Can be:<ul><li><code>:Tips</code> columns and/or rows corresponding to the tips</li><li><code>:InternalNodes</code> columns and/or rows corresponding to the internal nodes</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L1429-L1439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getNodeAges" href="#PhyloNetworks.getNodeAges"><code>PhyloNetworks.getNodeAges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getNodeAges(net)</code></pre><p>vector of node ages in pre-order, as in <code>nodes_changed</code>, which is assumed to have been calculated before.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/pairwiseDistanceLS.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.pairwiseTaxonDistanceMatrix" href="#PhyloNetworks.pairwiseTaxonDistanceMatrix"><code>PhyloNetworks.pairwiseTaxonDistanceMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pairwiseTaxonDistanceMatrix(net; keepInternal=false,
                            checkPreorder=true, nodeAges=[])
pairwiseTaxonDistanceMatrix!(M, net, nodeAges)</code></pre><p>Return the matrix <code>M</code> of pairwise distances between nodes in the network:</p><ul><li>between all nodes (internal and leaves) if <code>keepInternal=true</code>, in which case the nodes are listed in <code>M</code> in the order in which they appear in <code>net.nodes_changed</code></li><li>between taxa only otherwise, in which case the nodes are listed in <code>M</code> in the order in which they appear in <code>tipLabels(net)</code> (i.e. same order as in <code>net.leaf</code>)</li></ul><p>The second form modifies <code>M</code> in place, assuming all nodes.</p><p>The distance between the root and a given hybrid node (to take an example) is the weighted average of path lengths from the root to that node, where each path is weighted by the product of γs of all edges on that path. This distance measures the average genetic distance across the genome, if branch lengths are in substitutions/site.</p><p>optional arguments:</p><ul><li><code>checkPreorder</code>: if true, <code>net.nodes_changed</code> is updated to get a topological ordering of nodes.</li><li><code>nodeAges</code>: if not provided, i.e. empty vector, the network is <em>not</em> modified.   If provided and non-empty, <code>nodeAges</code> should list node ages in the pre-order in which nodes are listed in <code>nodes_changed</code> (including leaves), and <strong>edge lengths</strong> in <code>net</code> <strong>are modified</strong> accordingly.</li></ul><p>Providing node ages hence makes the network time consistent: such that all paths from the root to a given hybrid node have the same length. If node ages are not provided, the network need not be time consistent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/pairwiseDistanceLS.jl#L27-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.biconnectedComponents" href="#PhyloNetworks.biconnectedComponents"><code>PhyloNetworks.biconnectedComponents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">biconnectedComponents(network, ignoreTrivial=false)</code></pre><p>Calculate biconnected components (aka &quot;blobs&quot;) using Tarjan&#39;s algorithm: the output is an array of arrays of edges. These blobs are returned in post-order, but within a blob, edges are <em>not</em> necessarily sorted in topological order. If <code>ignoreTrivial</code> is true, trivial components (of a single edge) are not returned. The network is assumed to be connected.</p><p><strong>Warnings</strong>: for nodes, fields <code>k</code>, <code>inCycle</code>, and <code>prev</code> are modified during the algorithm. They are used to store the node&#39;s &quot;index&quot; (time of visitation), &quot;lowpoint&quot;, and the node&#39;s &quot;parent&quot;, as defined by the order in which nodes are visited.</p><p>References:</p><ul><li>p. 153 of <a href="http://epubs.siam.org/doi/pdf/10.1137/0201010">Tarjan (1972)</a>. Depth first search and linear graph algorithms, SIAM Journal on Computing, 1(2):146-160</li><li>on <a href="https://www.geeksforgeeks.org/biconnected-components/">geeksforgeeks</a>, there is an error (as of 2018-01-30): <code>elif v != parent[u] and low[u] &gt; disc[v]:</code> (python version) should be replaced by <code>elif v != parent[u] and disc[u] &gt; disc[v]:</code></li><li>nice explanation at this <a href="https://www.cs.cmu.edu/~avrim/451f12/lectures/biconnected.pdf">url</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/graph_components.jl#L1-L28">source</a></section><section><div><pre><code class="language-none">biconnectedComponents(node, index, S, blobs, ignoreTrivial)</code></pre><p>Helper recursive function starting at a node (not a network). <code>index</code> is an array containing a single integer, thus mutable: order in which nodes are visited.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/graph_components.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.blobDecomposition" href="#PhyloNetworks.blobDecomposition"><code>PhyloNetworks.blobDecomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">blobDecomposition!(network)
blobDecomposition(network)</code></pre><p>Find blobs using <a href="#PhyloNetworks.biconnectedComponents"><code>biconnectedComponents</code></a>; find their roots using <a href="../internals/#PhyloNetworks.blobInfo"><code>blobInfo</code></a>; create a forest in the form of a disconnected network (for efficiency), by deconnecting the root of each non-trivial blob from its parent. The root of each blob corresponds to a new leaf (in another tree of the forest): the number of the blob&#39;s root is given to the newly created leaf.</p><p>The first (bang) version modifies the network and returns the array of blob roots. The second version copies the network then returns a tuple: the forest and the blob roots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/graph_components.jl#L186-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.treeedgecomponents" href="#PhyloNetworks.treeedgecomponents"><code>PhyloNetworks.treeedgecomponents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">treeedgecomponents(net::HybridNetwork)</code></pre><p>Return the tree-edge components of the semidirected network as a <code>membership</code> dictionary <code>Node =&gt; Int</code>. Nodes with the same membership integer value are in the same tree-edge component. The tree-edge components of a network are the connected components of the network when all hybrid edges are removed.</p><p>A <code>RootMismatch</code> error is thrown if there exists a cycle in any of the tree-edge components, or if a tree-edge component has more than one &quot;entry&quot; hybrid node.</p><p>Warnings:</p><ul><li>since <code>Node</code>s are mutable, the network should not be modified until usage of the output <code>membership</code> dictionary is over.</li><li>the component IDs are not predicable, but will be consecutive integers from 1 to the number of components.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/graph_components.jl#L228-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getlabels" href="#PhyloNetworks.getlabels"><code>PhyloNetworks.getlabels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getlabels(model)</code></pre><p>State labels of a substitution model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L74-L78">source</a></section><section><div><p>for a given <a href="../internals/#PhyloNetworks.NucleicAcidSubstitutionModel"><code>NucleicAcidSubstitutionModel</code></a>, labels are symbols from <a href="https://github.com/BioJulia/BioSymbols.jl">BioSymbols</a>. For now, only ACGTs are allowed. (When fitting data, any ambiguity code in the data would be treated as missing value).</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; getlabels(JC69([0.03], false))
4-element Vector{BioSymbols.DNA}:
 DNA_A
 DNA_C
 DNA_G
 DNA_T

julia&gt; getlabels(HKY85([.5], repeat([0.25], 4)))
4-element Vector{BioSymbols.DNA}:
 DNA_A
 DNA_C
 DNA_G
 DNA_T
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L109-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.nparams" href="#PhyloNetworks.nparams"><code>PhyloNetworks.nparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nparams(model)</code></pre><p>Number of parameters for a given trait evolution model (length of field <code>model.rate</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L43-L48">source</a></section><section><div><p>for <code>JC69</code> model: 0 if relative, 1 if absolute</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L832-L834">source</a></section><section><div><p>for <code>HKY85</code> model: 1 if relative, 2 if absolute</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L839-L841">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.mapindividuals" href="#PhyloNetworks.mapindividuals"><code>PhyloNetworks.mapindividuals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapindividuals(net::HybridNetwork, mappingFile::String)</code></pre><p>Return a network expanded from <code>net</code>, where species listed in the mapping file are replaced by individuals mapped to that species. If a species has only 1 individual, the name of the leaf for that species is replaced by the name of its one individual representative. If a species has 2 or more individuals, the leaf for that species is expanded into a &quot;star&quot; (polytomy if 3 or more individuals) with a tip for each individual. If a species is in the network but not listed in the mapping file, the tip for that species is left as is. Species listed in the mapping file but not present in the network are ignored.</p><p>The mapping file should be readable by <code>CSV.File</code> and contain two columns: one for the species names and one for the individual (or allele) names. fixit: make this function more flexible by accepting column names</p><p>Output: individual-level network and vector of species constraint(s).</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; species_net = readTopology(&quot;(((S8,S9),((((S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));&quot;);

julia&gt; filename = joinpath(dirname(Base.find_package(&quot;PhyloNetworks&quot;)), &quot;..&quot;, &quot;examples&quot;, &quot;mappingIndividuals.csv&quot;);

julia&gt; filename |&gt; read |&gt; String |&gt; print # to see what the mapping file contains
species,individual
S1,S1A
S1,S1B
S1,S1C

julia&gt; individual_net, species_constraints = mapindividuals(species_net, filename);

julia&gt; writeTopology(individual_net, internallabel=true)
&quot;(((S8,S9),(((((S1A,S1B,S1C)S1,S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));&quot;

julia&gt; species_constraints
1-element Vector{PhyloNetworks.TopologyConstraint}:
 Species constraint, on tips: S1A, S1B, S1C
 stem edge number 4
 crown node number 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/moves_semidirected.jl#L734-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.nni!" href="#PhyloNetworks.nni!"><code>PhyloNetworks.nni!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nni!(net::HybridNetwork, e::Edge, nohybridladder::Bool=true, no3cycle::Bool=true,
     constraints=TopologyConstraint[]::Vector{TopologyConstraint})</code></pre><p>Attempt to perform a nearest neighbor interchange (NNI) around edge <code>e</code>, randomly chosen among all possible NNIs (e.g 3, sometimes more depending on <code>e</code>) satisfying the constraints, and such that the new network is a DAG. The number of possible NNI moves around an edge depends on whether the edge&#39;s parent/child nodes are tree or hybrid nodes. This is calculated by <a href="../internals/#PhyloNetworks.nnimax-Tuple{PhyloNetworks.Edge}"><code>nnimax</code></a>.</p><p>The option <code>no3cycle</code> forbids moves that would create a 3-cycle in the network. When <code>no3cycle</code> = false, 2-cycle and 3-cycles may be generated.</p><p>Note that the defaults values are for positional (not keyword) arguments, so two or more arguments can be used, but in a specific order: nni!(net, e) or nni!(net, e, nohybridladder), nni!(net, e, nohybridladder, no3cycle), nni!(net, e, nohybridladder, no3cycle, contraints).</p><p>Assumptions:</p><ul><li>The starting network does not have 3-cycles, if <code>no3cycle=true</code>. No check for the presence of 2- and 3-cycles in the input network.</li><li>The edges&#39; field <code>isChild1</code> is correct in the input network. (This field will be correct in the output network.)</li></ul><p>Output: information indicating how to undo the move or <code>nothing</code> if all NNIs failed.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; str_network = &quot;(((S8,S9),(((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2),(#H2,S10));&quot;;

julia&gt; net = readTopology(str_network);

julia&gt; using Random; Random.seed!(321);

julia&gt; undoinfo = nni!(net, net.edge[3], true, true); # true&#39;s to avoid hybrid ladders and 3-cycles

julia&gt; writeTopology(net)
&quot;(((S8,(((((S1,S2,S3),S4),(S5)#H1),(#H1,(S6,S7))))#H2),S9),(#H2,S10));&quot;

julia&gt; nni!(undoinfo...);

julia&gt; writeTopology(net) == str_network # net back to original topology: the NNI was &quot;undone&quot;
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/moves_semidirected.jl#L271-L318">source</a></section><section><div><pre><code class="language-none">nni!(net::HybridNetwork, uv::Edge, nummove::UInt8,
     nohybridladder::Bool, no3cycle::Bool)</code></pre><p>Modify <code>net</code> with a nearest neighbor interchange (NNI) around edge <code>uv</code>. Return the information necessary to undo the NNI, or <code>nothing</code> if the move was not successful (such as if the resulting graph was not acyclic (not a DAG) or if the focus edge is adjacent to a polytomy). If the move fails, the network is not modified. <code>nummove</code> specifies which of the available NNIs is performed.</p><p>rooted-NNI options according to Gambette et al. (2017), fig. 8:</p><ul><li>BB: 2 moves, both to BB, if directed edges. 8 moves if undirected.</li><li>RR: 2 moves, both to RR.</li><li>BR: 3 moves, 1 RB &amp; 2 BRs, if directed. 6 moves if e is undirected.</li><li>RB: 4 moves, all 4 BRs.</li></ul><p>The extra options are due to assuming a semi-directed network, whereas Gambette et al (2017) describe options for rooted networks. On a semi-directed network, there might be a choice of how to direct the edges that may contain the root, e.g. choice of e=uv versus vu, and choice of labelling adjacent nodes as α/β (BB), or as α/γ (BR).</p><p><code>nohybridladder</code> = true prevents moves that would create a hybrid ladder in the network, that is, 2 consecutive hybrid nodes (one parent of the other). <code>no3cycle</code> = true prevents NNI moves that would make a 3-cycle, and assumes that the input network does not have any 2- or 3-cycles. If <code>no3cycle</code> is false, 3-cycles can be generated, but NNIs generating 2-cycles are prevented.</p><p>The edge field <code>isChild1</code> is assumed to be correct according to the <code>net.root</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/moves_semidirected.jl#L369-L399">source</a></section><section><div><pre><code class="language-none">nni!(αu, u, uv::Edge, v, vδ)
nni!(αu,u,uv,v,vδ, flip::Bool, inner::Bool, indices)</code></pre><p>Transform a network locally around the focus edge <code>uv</code> with the following NNI, that detaches u-β and grafts it onto vδ:</p><pre><code class="language-none">α - u -- v ------ δ
    |    |
    β    γ

α ------ v -- u - δ
         |    |
         γ    β</code></pre><p><code>flip</code> boolean indicates if the uv edge was flipped <code>inner</code> boolean indicates if edges αu and uv both point toward node u, i.e. α-&gt;u&lt;-v&lt;-δ. If this is true, we flip the hybrid status of αu and vδ.</p><p><code>indices</code> give indices for nodes and edges u<em>in</em>αu, αu<em>in</em>u, vδ<em>in</em>v, and v<em>in</em>vδ. These are interpreted as:</p><pre><code class="language-none">u_in_αu: the index for u in the edge αu
αu_in_u: the index for αu in node u
vδ_in_v: the index for vδ in node v
v_in_vδ: the index for v in edge vδ</code></pre><p><strong>Warnings</strong>:</p><ul><li><em>No</em> check of assumed adjacencies</li><li>Not implemented for cases that are not necessary thanks to symmetry, such as cases covered by <code>nni!(vδ, v, uv, u, αu)</code> or <code>nni!(βu, u, v, vγ)</code>. More specifically, these cases are not implemented (and not checked):<ul><li>u not hybrid &amp; v hybrid</li><li>u hybrid, v not hybrid, α -&gt; u &lt;- v -&gt; δ</li></ul></li><li>Because of this, <code>nni(αu,u,uv,v,vδ, ...)</code> should not be used directly; use instead <code>nni!(net, uv, move_number)</code>.</li><li>nni!(undoinfo...) restores the topology, but edges below hybrid nodes will have length 0.0 even if they didn&#39;t before.</li></ul><p>Node numbers and edge numbers are not modified. Edge <code>uv</code> keeps its direction unchanged <em>unless</em> the directions were <code>α -&gt; u -&gt; v -&gt; δ</code> or <code>α &lt;- u &lt;- v &lt;- δ</code>, in which case the direction of <code>uv</code> is flipped.</p><p>The second version&#39;s input has the same signature as the output, but will undo the NNI more easily. This means that if <code>output = nni!(input)</code>, then <code>nni!(output...)</code> is valid and undoes the first operation.</p><p>Right now, branch lengths are not modified except when below a hybrid node. Future versions might implement options to modify branch lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/moves_semidirected.jl#L558-L609">source</a></section></article><h2 id="data-and-topology-read/write"><a class="docs-heading-anchor" href="#data-and-topology-read/write">data and topology read/write</a><a id="data-and-topology-read/write-1"></a><a class="docs-heading-anchor-permalink" href="#data-and-topology-read/write" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readfastatodna" href="#PhyloNetworks.readfastatodna"><code>PhyloNetworks.readfastatodna</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readfastatodna(filename::String, countPatterns=false::Bool)</code></pre><p>Read a fasta file to a dataframe containing a column for each site. If <code>countPatterns</code> is true, calculate weights and remove identical site patterns to reduce matrix dimension.</p><p>Return a tuple containing:</p><ol><li>data frame of BioSequence DNA sequences, with taxon names in column 1 followed by a column for each site pattern, in columns 2-npatterns;</li><li>array of weights, one weight for each of the site columns. The length of the weight vector is equal to npatterns.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/parsimony.jl#L397-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readTopology" href="#PhyloNetworks.readTopology"><code>PhyloNetworks.readTopology</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readTopology(file name)
readTopology(parenthetical description)</code></pre><p>Read tree or network topology from parenthetical format (extended Newick). If the root node has a single child: ignore (i.e. delete from the topology) the root node and its child edge.</p><p>Input: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description.</p><p>A root edge, not enclosed within a pair a parentheses, is ignored. If the root node has a single edge, this one edge is removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readwrite.jl#L453-L467">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readTopologyLevel1" href="#PhyloNetworks.readTopologyLevel1"><code>PhyloNetworks.readTopologyLevel1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readTopologyLevel1(filename)
readTopologyLevel1(parenthetical format)</code></pre><p>same as readTopology, reads a tree or network from parenthetical format, but this function enforces the necessary conditions for any starting topology in SNaQ: non-intersecting cycles, no polytomies, unrooted. It sets any missing branch length to 1.0.</p><p>If the network has a bad diamond II (in which edge lengths are γ&#39;s are not identifiable) and if the edge below this diamond has a length <code>t</code> different from 0, then this length is set back to 0 and the major parent hybrid edge is lengthened by <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readwrite.jl#L872-L884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readInputTrees" href="#PhyloNetworks.readInputTrees"><code>PhyloNetworks.readInputTrees</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readInputTrees(file)</code></pre><p>Read a text file with a list of trees/networks in parenthetical format (one tree per line) and transform them like <a href="#PhyloNetworks.readTopologyLevel1"><code>readTopologyLevel1</code></a> does: to be unrooted, with resolved polytomies, missing branch lengths set to 1.0, etc. See <a href="#PhyloNetworks.readMultiTopology"><code>readMultiTopology</code></a> to read multiple trees or networks with no modification.</p><p>Output: array of HybridNetwork objects.</p><p>Each line starting with &quot;(&quot; will be considered as describing one topology. The file can have extra lines that are ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readData.jl#L208-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readMultiTopology" href="#PhyloNetworks.readMultiTopology"><code>PhyloNetworks.readMultiTopology</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>readMultiTopology(file)</code></p><p>Read a text file with a list of networks in parenthetical format (one per line). Each network is read with <a href="#PhyloNetworks.readTopology"><code>readTopology</code></a>. Return an array of HybridNetwork object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readwrite.jl#L1266-L1272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readNexusTrees" href="#PhyloNetworks.readNexusTrees"><code>PhyloNetworks.readNexusTrees</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readNexusTrees(filename::AbstractString, treereader=readTopology::Function [, args...])</code></pre><p>Read trees in nexus-formatted file and return a vector of <code>HybridNetwork</code>s. For the nexus format, see Maddison, Swofford &amp; Maddison (1997) https://doi.org/10.1093/sysbio/46.4.590. The optional arguments are passed onto the individual tree reader.</p><p>Warnings:</p><ul><li>&quot;translate&quot; tables are not supported yet</li><li>only the first tree block is read</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readData.jl#L1273-L1284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readSnaqNetwork" href="#PhyloNetworks.readSnaqNetwork"><code>PhyloNetworks.readSnaqNetwork</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readSnaqNetwork(output file)</code></pre><p>Read the estimated network from a <code>.out</code> file generated by <code>snaq!</code>. The network score is read also, and stored in the network&#39;s field <code>.loglik</code>.</p><p>Warning: despite the name &quot;loglik&quot;, this score is only proportional to the network&#39;s pseudo-deviance: the lower, the better. Do NOT use this score to calculate an AIC or BIC (etc.) value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readwrite.jl#L1209-L1218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readTrees2CF" href="#PhyloNetworks.readTrees2CF"><code>PhyloNetworks.readTrees2CF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readTrees2CF(treefile)
readTrees2CF(vector of trees)</code></pre><p>Read trees in parenthetical format from a file, or take a vector of trees already read, and calculate the proportion of these trees having a given quartet (concordance factor: CF), for all quartets or for a sample of quartets. Optional arguments include:</p><ul><li>quartetfile: name of text file with list of 4-taxon subsets to be analyzed. If none is specified, the function will list all possible 4-taxon subsets.</li><li>whichQ=&quot;rand&quot;: to choose a random sample of 4-taxon subsets</li><li>numQ: size of random sample (ignored if whichQ is not set to &quot;rand&quot;)</li><li>writeTab=false: does not write the observedCF to a table (default true)</li><li>CFfile: name of file to save the observedCF (default tableCF.txt)</li><li>writeQ=true: save intermediate files with the list of all 4-taxon subsets and chosen random sample (default false).</li><li>writeSummary: write descriptive stats of input data (default: true)</li><li>nexus: if true, it assumes the gene trees are written in nexus file (default: false)</li></ul><p>See also: <a href="#PhyloNetworks.countquartetsintrees"><code>countquartetsintrees</code></a>, which uses a much faster algorithm; <a href="#PhyloNetworks.readTableCF"><code>readTableCF</code></a> to read a table of quartet CFs directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readData.jl#L937-L958">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.countquartetsintrees" href="#PhyloNetworks.countquartetsintrees"><code>PhyloNetworks.countquartetsintrees</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">countquartetsintrees(trees [, taxonmap=Dict{String,String}]; which=:all, weight_byallele=true)</code></pre><p>Calculate the quartet concordance factors (CF) observed in the <code>trees</code> vector. If present, <code>taxonmap</code> should map each allele name to it&#39;s species name. To save to a file, first convert to a data frame using <a href="#PhyloNetworks.writeTableCF"><code>writeTableCF</code></a>. When <code>which=:all</code>, quartet CFs are calculated for all 4-taxon sets. (Other options are not implemented yet.)</p><p>The algorithm runs in O(mn⁴) where m is the number of trees and n is the number of tips in the trees.</p><p>CFs are calculated at the species level only, that is, considering 4-taxon sets made of 4 distinct species, even if the gene trees may have multiple alleles from the same species. For 4 distinct species <code>a,b,c,d</code>, all alleles from each species (<code>a</code> etc.) will be considered to calculate the quartet CF.</p><p>By default, each gene has a weight of 1. So if there are <code>n_a</code> alleles from <code>a</code>, <code>n_b</code> alleles from <code>b</code> etc. in a given gene, then each set of 4 alleles has a weight of <code>1/(n_a n_b b_c n_c)</code> in the calculation of the CF for <code>a,b,c,d</code>. With option <code>weight_byallele=true</code>, then each set of 4 alleles is given a weight of 1 instead. This inflates the total number of sets used to calculate the quartet CFs (to something larger than the number of genes). This may also affect the CF values if the number of alleles varies across genes: genes with more alleles will be given more weight.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; tree1 = readTopology(&quot;(E,(A,B),(C,D),O);&quot;); tree2 = readTopology(&quot;(((A,B),(C,D)),E);&quot;);

julia&gt; q,t = countquartetsintrees([tree1, tree2]);
Reading in trees, looking at 15 quartets in each...
0+--+100%
  **

julia&gt; t # taxon order: t[i] = name of taxon number i
6-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;C&quot;
 &quot;D&quot;
 &quot;E&quot;
 &quot;O&quot;

julia&gt; length(q) # 15 four-taxon sets on 6 taxa
15

julia&gt; q[1] # both trees agree on AB|CD: resolution 1
4-taxon set number 1; taxon numbers: 1,2,3,4
data: [1.0, 0.0, 0.0, 2.0]

julia&gt; q[8] # tree 2 is missing O (taxon 6), tree 1 wants resolution 3: AO|CD
4-taxon set number 8; taxon numbers: 1,3,4,6
data: [0.0, 0.0, 1.0, 1.0]

julia&gt; q[11] # tree 1 has ACEO unresolved, and tree 2 is missing O: no data for this quartet
4-taxon set number 11; taxon numbers: 1,3,5,6
data: [0.0, 0.0, 0.0, 0.0]

julia&gt; tree1 = readTopology(&quot;(E,(a1,B),(a2,D),O);&quot;); tree2 = readTopology(&quot;(((a1,a2),(B,D)),E);&quot;);

julia&gt; q,t = countquartetsintrees([tree1, tree2], Dict(&quot;a1&quot;=&gt;&quot;A&quot;, &quot;a2&quot;=&gt;&quot;A&quot;); showprogressbar=false);

julia&gt; t
5-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;D&quot;
 &quot;E&quot;
 &quot;O&quot;

julia&gt; q[1] # tree 1 has discordance: a1B|DE and a2D|BE. tree 2 has AE|BD for both alleles of A
4-taxon set number 1; taxon numbers: 1,2,3,4
data: [0.25, 0.25, 0.5, 2.0]

julia&gt; q[3] # tree 2 is missing O (taxon 5), and a2 is unresolved in tree 1. There&#39;s only a1B|EO
4-taxon set number 3; taxon numbers: 1,2,4,5
data: [1.0, 0.0, 0.0, 0.5]

julia&gt; df = writeTableCF(q,t); # to get a DataFrame that can be saved to a file later

julia&gt; show(df, allcols=true)
5×8 DataFrame
 Row │ t1      t2      t3      t4      CF12_34  CF13_24  CF14_23  ngenes  
     │ String  String  String  String  Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────────────────────────────────────
   1 │ A       B       D       E          0.25     0.25      0.5      2.0
   2 │ A       B       D       O          0.5      0.5       0.0      1.0
   3 │ A       B       E       O          1.0      0.0       0.0      0.5
   4 │ A       D       E       O          1.0      0.0       0.0      0.5
   5 │ B       D       E       O          0.0      0.0       0.0      0.0
julia&gt; # using CSV; CSV.write(df, &quot;filename.csv&quot;);

julia&gt; tree2 = readTopology(&quot;((A,(B,D)),E);&quot;);

julia&gt; q,t = countquartetsintrees([tree1, tree2], Dict(&quot;a1&quot;=&gt;&quot;A&quot;, &quot;a2&quot;=&gt;&quot;A&quot;); weight_byallele=true);
Reading in trees, looking at 5 quartets in each...
0+--+100%
  **

julia&gt; show(writeTableCF(q,t), allcols=true)
5×8 DataFrame
 Row │ t1      t2      t3      t4      CF12_34   CF13_24   CF14_23   ngenes  
     │ String  String  String  String  Float64   Float64   Float64   Float64 
─────┼───────────────────────────────────────────────────────────────────────
   1 │ A       B       D       E       0.333333  0.333333  0.333333      3.0
   2 │ A       B       D       O       0.5       0.5       0.0           2.0
   3 │ A       B       E       O       1.0       0.0       0.0           1.0
   4 │ A       D       E       O       1.0       0.0       0.0           1.0
   5 │ B       D       E       O       0.0       0.0       0.0           0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readData.jl#L518-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readTableCF" href="#PhyloNetworks.readTableCF"><code>PhyloNetworks.readTableCF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readTableCF(file)
readTableCF(data frame)
readTableCF!(data frame)</code></pre><p>Read a file or DataFrame object containing a table of concordance factors (CF), with one row per 4-taxon set. The first 4 columns are assumed to give the labels of the 4 taxa in each set (tx1, tx2, tx3, tx4). Columns containing the CFs are assumed to be named <code>CF12_34</code>, <code>CF13_24</code> and <code>CF14_23</code>; or <code>CF12.34</code>, <code>CF13.24</code> and <code>CF14.23</code>; or else are assumed to be columns 5,6,7. If present, a column named &#39;ngenes&#39; will be used to get the number of loci used to estimate the CFs for each 4-taxon set.</p><p>Output: <a href="#PhyloNetworks.DataCF"><code>DataCF</code></a> object</p><p>Optional arguments:</p><ul><li>summaryfile: if specified, a summary file will be created with that name.</li><li>delim (for the first form only): to specify how columns are delimited, with single quotes: delim=&#39;;&#39;. Default is a <code>csv</code> file, i.e. <code>delim=&#39;,&#39;</code>.</li></ul><p>The last version modifies the input data frame, if species are represented by multiple alleles for instance (see <a href="#PhyloNetworks.readTableCF!"><code>readTableCF!</code></a>(data frame, columns)).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readData.jl#L65-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readTableCF!" href="#PhyloNetworks.readTableCF!"><code>PhyloNetworks.readTableCF!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readTableCF!(data frame, columns)</code></pre><p>Read in quartet CFs from data frame, assuming information is in columns numbered <code>columns</code>, of length <strong>7 or 8</strong>: 4 taxon labels then 3 CFs then ngenes possibly.</p><p>If some species appears more than once in the same 4-taxon set (e.g. t1,t1,t2,t3), then the data frame is modified to remove rows (4-taxon sets) that are uninformative about between-species relationships. This situation may occur if multiple individuals are sampled from the same species. A 4-taxon set is uninformative (and its row is removed) if one taxon is repeated 3 or 4 times (like t1,t1,t1,t1 or t1,t2,t2,t2). The list of species appearing twice in some 4-taxon sets is stored in the output DataCF object. For these species, the length of their external edge is identifiable (in coalescent units). If multiple rows correspond to the same 4-taxon set, these rows are merged and their CF values (and number of genes) are averaged.</p><pre><code class="language-none">readTableCF!(DataCF, data frame, columns)</code></pre><p>Modify the <code>.quartet.obsCF</code> values in the <code>DataCF</code> object with those read from the data frame in columns numbered <code>columns</code>. <code>columns</code> should have <strong>3</strong> columns numbers for the 3 CFs in this order: <code>12_34</code>, <code>13_24</code> and <code>14_23</code>.</p><p>Assumptions:</p><ul><li>same 4-taxon sets in <code>DataCF</code> and in the data frame, and in the same order, but this assumption is <em>not checked</em> (for speed, e.g. during bootstrapping).</li><li>one single row per 4-taxon set (multiple individuals representatives of the same 4-taxon set should have been already merged); basically: the DataCF should have been created from the data frame by <code>readTableCF!(df, colums)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readData.jl#L167-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.writeTableCF" href="#PhyloNetworks.writeTableCF"><code>PhyloNetworks.writeTableCF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">writeTableCF(vector of Quartet objects)
writeTableCF(DataCF)
writeTableCF(vector of QuartetT objects [, taxonames])</code></pre><p>Build a DataFrame containing observed quartet concordance factors, with columns named:</p><ul><li><code>:tx1</code>, <code>:tx2</code>, <code>:tx3</code>, <code>:tx4</code> for the four taxon names in each quartet</li><li><code>:CF12_34</code>, <code>:CF13_24</code>, <code>:CF14_23</code> for the 3 quartets of a given four-taxon set</li><li><code>:ngenes</code> if this information is available for some quartets</li></ul><p>If the input are <a href="../internals/#PhyloNetworks.QuartetT"><code>QuartetT</code></a> objects, their <code>data</code> field needs to contain vectors of 4 values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readData.jl#L17-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.readBootstrapTrees" href="#PhyloNetworks.readBootstrapTrees"><code>PhyloNetworks.readBootstrapTrees</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readBootstrapTrees(listfile; relative2listfile=true)</code></pre><p>Read the list of file names in <code>listfile</code>, then read all the trees in each of these files. Output: vector of vectors of trees (networks with h&gt;0 allowed).</p><p><code>listfile</code> should be the name of a file containing the path/name to multiple bootstrap files, one on each line (no header). Each named bootstrap file should contain multiple trees, one per line (such as bootstrap trees from a single gene).</p><p>The path/name to each bootstrap file should be relative to <code>listfile</code>. Otherwise, use option <code>relative2listfile=false</code>, in which case the file names are interpreted as usual: relative to the user&#39;s current directory if not given as absolute paths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/bootstrap.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.writeSubTree!" href="#PhyloNetworks.writeSubTree!"><code>PhyloNetworks.writeSubTree!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">writeSubTree!(IO, network, dendroscope::Bool, namelabel::Bool,
              round_branch_lengths::Bool, digits::Integer,
              internallabel::Bool)</code></pre><p>Write to IO the extended newick format (parenthetical description) of a network. If written for dendroscope, inheritance γ&#39;s are not written. If <code>namelabel</code> is true, taxa are labelled by their names; otherwise taxa are labelled by their number IDs. If unspecified, branch lengths and γ&#39;s are rounded to 3 digits. Use <code>internallabel=false</code> to suppress the labels of internal nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readwrite.jl#L921-L933">source</a></section><section><div><pre><code class="language-none">writeSubTree!(IO, node, edge, dendroscope::Bool, namelabel::Bool,
              round_branch_lengths::Bool, digits::Integer, internallabel::Bool)</code></pre><p>Write the extended newick format of the sub-network rooted at <code>node</code> and assuming that <code>edge</code> is a parent of <code>node</code>.</p><p>If the parent <code>edge</code> is <code>nothing</code>, the edge attribute <code>isChild1</code> is used and assumed to be correct to write the subtree rooted at <code>node</code>. This is useful to write a subtree starting at a non-root node. Example:</p><pre><code class="language-julia">net = readTopology(&quot;(((A,(B)#H1:::0.9),(C,#H1:::0.1)),D);&quot;)
directEdges!(net)
s = IOBuffer()
writeSubTree!(s, net.node[7], nothing, false, true)
String(take!(s))</code></pre><p>Used by <a href="#PhyloNetworks.writeTopology"><code>writeTopology</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readwrite.jl#L955-L976">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.writeTopology" href="#PhyloNetworks.writeTopology"><code>PhyloNetworks.writeTopology</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">writeTopology(net)
writeTopology(net, filename)
writeTopology(net, IO)</code></pre><p>Write the parenthetical extended Newick format of a network, as a string, to a file or to an IO buffer / stream. Optional arguments (default values):</p><ul><li>di (false): write in format for Dendroscope</li><li>round (false): rounds branch lengths and heritabilities γ</li><li>digits (3): digits after the decimal place for rounding</li><li>append (false): if true, appends to the file</li><li>internallabel (true): if true, writes internal node labels</li></ul><p>If the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.</p><p>Uses lower-level function <a href="#PhyloNetworks.writeSubTree!"><code>writeSubTree!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readwrite.jl#L1339-L1358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.writeMultiTopology" href="#PhyloNetworks.writeMultiTopology"><code>PhyloNetworks.writeMultiTopology</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">writeMultiTopology(nets, file_name; append=false)
writeMultiTopology(nets, IO)</code></pre><p>Write an array of networks in parenthetical extended Newick format, one network per line. Use the option append=true to append to the file. Otherwise, the default is to create a new file or overwrite it, if it already existed. Each network is written with <code>writeTopology</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; net = [readTopology(&quot;(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10);&quot;),
              readTopology(&quot;(A,(B,C));&quot;),readTopology(&quot;(E,F);&quot;),readTopology(&quot;(G,H,F);&quot;)];

julia&gt; writeMultiTopology(net, &quot;fournets.net&quot;) # to (over)write to file &quot;fournets.net&quot;
julia&gt; writeMultiTopology(net, &quot;fournets.net&quot;, append=true) # to append to this file
julia&gt; writeMultiTopology(net, stdout)         # to write to the screen (standard out)
(D,((A,(B)#H7:::0.864):2.069,(F,E):3.423):0.265,(C,#H7:::0.1361111):10.0);
(A,(B,C));
(E,F);
(G,H,F);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readwrite.jl#L1294-L1316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hybridlambdaformat" href="#PhyloNetworks.hybridlambdaformat"><code>PhyloNetworks.hybridlambdaformat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hybridlambdaformat(net::HybridNetwork; prefix=&quot;I&quot;)</code></pre><p>Output <code>net</code> as a string in the format that the <a href="https://github.com/hybridLambda/hybrid-Lambda">Hybrid-Lambda</a> simulator expects, namely:</p><ul><li>all internal nodes are named, including the root</li><li>hybrid nodes are written as <code>H6#γ1:length1</code> and <code>H6#γ1:length2</code> instead of <code>#H6:length1::γ1</code> and <code>#H6:length2::γ2</code> (note the samme γ value expected by Hybrid-Lambda)</li></ul><p>This is a modified version of the <a href="https://doi.org/10.1186/1471-2105-9-532">extended Newick</a> format.</p><p>Optional keyword argument: <code>prefix</code>, &quot;I&quot; by default. Internal nodes without a name will be given names like &quot;I1&quot;, &quot;I2&quot;, etc. See <a href="../internals/#PhyloNetworks.nameinternalnodes!-Tuple{HybridNetwork, Any}"><code>nameinternalnodes!</code></a> to add node names (modifies the input network).</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;((a:1,(b:1)#H1:1::0.8):5,(#H1:0::0.2,c:1):1);&quot;);

julia&gt; hybridlambdaformat(net) # net is unchanged here
&quot;((a:1.0,(b:1.0)H1#0.8:1.0)I1:5.0,(H1#0.8:0.0,c:1.0)I2:1.0)I3;&quot;

julia&gt; # using PhyloPlots; plot(net, :R, showNodeNumber=true) # shows that node -2 is the root

julia&gt; rotate!(net, -2)

julia&gt; writeTopology(net) # now the minor edge with γ=0.2 appears first
&quot;((#H1:0.0::0.2,c:1.0):1.0,(a:1.0,(b:1.0)#H1:1.0::0.8):5.0);&quot;

julia&gt; hybridlambdaformat(net)
&quot;((H1#0.2:0.0,c:1.0)I2:1.0,(a:1.0,(b:1.0)H1#0.2:1.0)I1:5.0)I3;&quot;

julia&gt; net = readTopology(&quot;((((B)#H1:::.6)#H2,((D,C,#H2:::0.8),(#H1,A))));&quot;); # 2 reticulations, no branch lengths

julia&gt; writeTopology(net, round=true)
&quot;(#H2:::0.2,((D,C,((B)#H1:::0.6)#H2:::0.8),(#H1:::0.4,A)));&quot;

julia&gt; hybridlambdaformat(net; prefix=&quot;int&quot;)
&quot;(H2#0.2,((D,C,((B)H1#0.6)H2#0.2)int1,(H1#0.6,A)int2)int3)int4;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/readwrite.jl#L1425-L1469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.mapAllelesCFtable" href="#PhyloNetworks.mapAllelesCFtable"><code>PhyloNetworks.mapAllelesCFtable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapAllelesCFtable(mapping file, CF file; filename, columns, delim)</code></pre><p>Create a new DataFrame containing the same concordance factors as in the input CF file, but with modified taxon names. Each allele name in the input CF table is replaced by the species name that the allele maps onto, based on the mapping file. The mapping file should have column names: allele and species.</p><p>Optional arguments:</p><ul><li>file name to write/save resulting CF table. If not specified, then the output data frame is not saved to a file.</li><li>column numbers for the taxon names. 1-4 by default.</li><li>any keyword arguments that <code>CSV.File</code> would accept. For example, delim=&#39;,&#39; by default: columns are delimited by commas. Unless specified otherwise by the user, <code>pool</code>=false (to read taxon names as Strings, not levels of a categorical factor, for combining the 4 columns with taxon names more easily). The same CSV arguments are used to read both input file (mapping file and quartet file)</li></ul><p>See also <a href="../internals/#PhyloNetworks.mapAllelesCFtable!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, Vector{Int64}, Bool, AbstractString}"><code>mapAllelesCFtable!</code></a> to input DataFrames instead of file names.</p><p>If a <code>filename</code> is specified, such as &quot;quartetCF_speciesNames.csv&quot; in the example below, this file is best read later with the option <code>pool=false</code>. example:</p><pre><code class="language-julia">mapAllelesCFtable(&quot;allele-species-map.csv&quot;, &quot;allele-quartet-CF.csv&quot;;
                  filename = &quot;quartetCF_speciesNames.csv&quot;)
df_sp = DataFrame(CSV.File(&quot;quartetCF_speciesNames.csv&quot;); copycols=false); # DataFrame object
dataCF_specieslevel = readTableCF!(df_sp); # DataCF object</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/multipleAlleles.jl#L8-L39">source</a></section></article><h2 id="network-inference"><a class="docs-heading-anchor" href="#network-inference">network inference</a><a id="network-inference-1"></a><a class="docs-heading-anchor-permalink" href="#network-inference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.snaq!" href="#PhyloNetworks.snaq!"><code>PhyloNetworks.snaq!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">snaq!(T::HybridNetwork, d::DataCF)</code></pre><p>Estimate the network (or tree) to fit observed quartet concordance factors (CFs) stored in a DataCF object, using maximum pseudo-likelihood. A level-1 network is assumed. The search starts from topology <code>T</code>, which can be a tree or a network with no more than <code>hmax</code> hybrid nodes. The function name ends with ! because it modifies the CF data <code>d</code> by updating its attributes <code>expCF</code>: CFs expected under the network model. It does <em>not</em> modify <code>T</code>. The quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.</p><p>Output:</p><ul><li>estimated network in file <code>.out</code> (also in <code>.log</code>): best network overall and list of networks from each individual run.</li><li>the best network and modifications of it, in file <code>.networks</code>. All networks in this file have the same undirected topology as the best network, but have different hybrid/gene flow directions. These other networks are reported with their pseudo-likelihood scores, because  non-identifiability issues can cause them to have very similar scores, and because  SNaQ was shown to estimate the undirected topology accurately but not the direction of  hybridization in cases of near non-identifiability.</li><li>if any error occurred, file <code>.err</code> provides information (seed) to reproduce the error.</li></ul><p>There are many optional arguments, including</p><ul><li><code>hmax</code> (default 1): maximum number of hybridizations allowed</li><li><code>verbose</code> (default false): if true, print information about the numerical optimization</li><li><code>runs</code> (default 10): number of independent starting points for the search</li><li><code>outgroup</code> (default none): outgroup taxon to root the estimated topology at the very end</li><li><code>filename</code> (default &quot;snaq&quot;): root name for the output files (<code>.out</code>, <code>.err</code>). If empty (&quot;&quot;), files are <em>not</em> created, progress log goes to the screen only (standard out).</li><li><code>seed</code> (default 0 to get it from the clock): seed to replicate a given search</li><li><code>probST</code> (default 0.3): probability to start from <code>T</code> at each given run. With problability 1-probST, the search is started from an NNI modification of <code>T</code> along a tree edge with no hybrid neighbor, with a possible modification of one reticulation if <code>T</code> has one.</li><li><code>updateBL</code> (default true): If true and if <code>T</code> is a tree, the branch lengths in <code>T</code> are first optimized roughly with <a href="../internals/#PhyloNetworks.updateBL!-Tuple{HybridNetwork, DataCF}"><code>updateBL!</code></a> by using the average CF of all quartets defining each branch and back-calculating the coalescent units.</li></ul><p>The following optional arguments control when to stop the optimization of branch lengths and γ&#39;s on each individual candidate network. Defaults are in parentheses:</p><ul><li><code>ftolRel</code> (1e-6) and <code>ftolAbs</code> (1e-6): relative and absolute differences of the network score between the current and proposed parameters,</li><li><code>xtolRel</code> (1e-2) and <code>xtolAbs</code> (1e-3): relative and absolute differences between the current and proposed parameters.</li></ul><p>Greater values will result in a less thorough but faster search. These parameters are used when evaluating candidate networks only. The following optional arguments control when to stop proposing new network topologies:</p><ul><li><code>Nfail</code> (75): maximum number of times that new topologies are proposed and rejected (in a row).</li><li><code>liktolAbs</code> (1e-6): the proposed network is accepted if its score is better than the current score by at least liktolAbs.</li></ul><p>Lower values of <code>Nfail</code> and greater values of <code>liktolAbs</code> and <code>ftolAbs</code> would result in a less thorough but faster search.</p><p>At the end, branch lengths and γ&#39;s are optimized on the last &quot;best&quot; network with different and very thorough tolerance parameters: 1e-12 for ftolRel, 1e-10 for ftolAbs, xtolRel, xtolAbs.</p><p>See also: <a href="#PhyloNetworks.topologyMaxQPseudolik!"><code>topologyMaxQPseudolik!</code></a> to optimize parameters on a fixed topology, and <a href="#PhyloNetworks.topologyQPseudolik!"><code>topologyQPseudolik!</code></a> to get the deviance (pseudo log-likelihood up to a constant) of a fixed topology with fixed parameters.</p><p>Reference:   Claudia Solís-Lemus and Cécile Ané (2016). Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting. <a href="http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1005896">PLoS Genetics</a> 12(3):e1005896</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/snaq_optimization.jl#L1793-L1867">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.topologyMaxQPseudolik!" href="#PhyloNetworks.topologyMaxQPseudolik!"><code>PhyloNetworks.topologyMaxQPseudolik!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>topologyMaxQPseudolik!(net::HybridNetwork, d::DataCF)</code></p><p>Estimate the branch lengths and inheritance probabilities (γ&#39;s) for a given network topology. The network is <em>not</em> modified, only the object <code>d</code> is, with updated expected concordance factors.</p><p>Ouput: new network, with optimized parameters (branch lengths and gammas). The maximized quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0. This is also an attribute of the network, which can be accessed with <code>net.loglik</code>.</p><p>Optional arguments (default value):</p><ul><li>verbose (false): if true, information on the numerical optimization is printed to screen</li><li>ftolRel (1e-5), ftolAbs (1e-6), xtolRel (1e-3), xtolAbs (1e-4): absolute and relative tolerance values for the pseudo-deviance function and the parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/snaq_optimization.jl#L409-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.topologyQPseudolik!" href="#PhyloNetworks.topologyQPseudolik!"><code>PhyloNetworks.topologyQPseudolik!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>topologyQPseudolik!(net::HybridNetwork, d::DataCF)</code></p><p>Calculate the quartet pseudo-deviance of a given network/tree for DataCF <code>d</code>. This is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.</p><p>Be careful if the net object does not have all internal branch lengths specified because then the pseudolikelihood will be meaningless.</p><p>The loglik attribute of the network is undated, and <code>d</code> is updated with the expected concordance factors under the input network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/pseudolik.jl#L1296-L1309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.fittedQuartetCF" href="#PhyloNetworks.fittedQuartetCF"><code>PhyloNetworks.fittedQuartetCF</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fittedQuartetCF(d::DataCF, format::Symbol)</code></p><p>return a data frame with the observed and expected quartet concordance factors after estimation of a network with snaq(T,d). The format can be :wide (default) or :long.</p><ul><li>if wide, the output has one row per 4-taxon set, and each row has 10 columns: 4 columns for the taxon names, 3 columns for the observed CFs and 3 columns for the expected CF.</li><li>if long, the output has one row per quartet, i.e. 3 rows per 4-taxon sets, and 7 columns: 4 columns for the taxon names, one column to give the quartet resolution, one column for the observed CF and the last column for the expected CF.</li></ul><p>see also: <code>topologyQPseudolik!</code> and <code>topologyMaxQPseudolik!</code> to update the fitted CF expected under a specific network, inside the DataCF object <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/descriptive.jl#L22-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.bootsnaq" href="#PhyloNetworks.bootsnaq"><code>PhyloNetworks.bootsnaq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bootsnaq(T::HybridNetwork, df::DataFrame)
bootsnaq(T::HybridNetwork, vector of tree lists)</code></pre><p>Bootstrap analysis for SNaQ. Bootstrap data can be quartet concordance factors (CF), drawn from sampling uniformly in their credibility intervals, as given in the data frame <code>df</code>. Alternatively, bootstrap data can be gene trees sampled from a vector of tree lists: one list of bootstrap trees per locus (see <code>readBootstrapTrees</code> to generate this, from a file containing a list of bootstrap files: one per locus).</p><p>From each bootstrap replicate, a network is estimated with snaq!, with a search starting from topology <code>T</code>. Optional arguments include the following, with default values in parentheses:</p><ul><li><code>hmax</code> (1): max number of reticulations in the estimated networks</li><li><code>nrep</code> (10): number of bootstrap replicates.</li><li><code>runs</code> (10): number of independent optimization runs for each replicate</li><li><code>filename</code> (&quot;bootsnaq&quot;): root name for output files. No output files if &quot;&quot;.</li><li><code>seed</code> (0 to get a random seed from the clock): seed for random number generator</li><li><code>otherNet</code> (empty): another starting topology so that each replicate will start prcnet% runs on otherNet and (1-prcnet)% runs on <code>T</code></li><li><code>prcnet</code> (0): percentage of runs starting on <code>otherNet</code>; error if different than 0.0, and otherNet not specified.</li><li><code>ftolRel</code>, <code>ftolAbs</code>, <code>xtolRel</code>, <code>xtolAbs</code>, <code>liktolAbs</code>, <code>Nfail</code>, <code>probST</code>, <code>verbose</code>, <code>outgroup</code>: see <code>snaq!</code>, same defaults.</li></ul><p>If <code>T</code> is a tree, its branch lengths are first optimized roughly with <a href="../internals/#PhyloNetworks.updateBL!-Tuple{HybridNetwork, DataCF}"><code>updateBL!</code></a> (by using the average CF of all quartets defining each branch and calculating the coalescent units corresponding to this quartet CF). If <code>T</code> has one or more reticulations, its branch lengths are taken as is to start the search. The branch lengths of <code>otherNet</code> are always taken as is to start the search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/bootstrap.jl#L304-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.calibrateFromPairwiseDistances!" href="#PhyloNetworks.calibrateFromPairwiseDistances!"><code>PhyloNetworks.calibrateFromPairwiseDistances!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calibrateFromPairwiseDistances!(net, distances::Matrix{Float64},
    taxon_names::Vector{String})</code></pre><p>Calibrate the network to match (as best as possible) input pairwise distances between taxa, such as observed from sequence data. <code>taxon_names</code> should provide the list of taxa, in the same order in which they they are considered in the <code>distances</code> matrix. The optimization criterion is the sum of squares between the observed distances, and the distances from the network (weighted average of tree distances, weighted by γ&#39;s). The network&#39;s edge lengths are modified.</p><p>Warning: for many networks, mutiple calibrations can fit the pairwise distance data equally well (lack of identifiability). This function will output <em>one</em> of these equally good calibrations.</p><p>optional arguments (default):</p><ul><li>checkPreorder (true)</li><li>forceMinorLength0 (false) to force minor hybrid edges to have a length of 0</li><li>NLoptMethod (<code>:LD_MMA</code>) for the optimization algorithm. Other options include <code>:LN_COBYLA</code> (derivative-free); see NLopt package.</li><li>tolerance values to control when the optimization is stopped: ftolRel (1e-12), ftolAbs (1e-10) on the criterion, and xtolRel (1e-10), xtolAbs (1e-10) on branch lengths / divergence times.</li><li>verbose (false)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/pairwiseDistanceLS.jl#L211-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.undirectedOtherNetworks" href="#PhyloNetworks.undirectedOtherNetworks"><code>PhyloNetworks.undirectedOtherNetworks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">undirectedOtherNetworks(net::HybridNetwork)</code></pre><p>Return a vector of HybridNetwork objects, obtained by switching the placement of each hybrid node to other nodes inside its cycle. This amounts to changing the direction of a gene flow event (recursively to move around the whole cycle of each reticulation).</p><p>Optional argument: <code>outgroup</code>, as a String. If an outgroup is specified, then networks conflicting with the placement of the root are avoided.</p><p>Assumptions: <code>net</code> is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. All level-1 fields of <code>net</code> are assumed up-to-date.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; net = readTopology(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
julia&gt; vnet = undirectedOtherNetworks(net)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/manipulateNet.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.nj" href="#PhyloNetworks.nj"><code>PhyloNetworks.nj</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nj(D::DataFrame; force_nonnegative_edges::Bool=false)</code></pre><p>Construct a tree from a distance matrix by neighbor joining, where <code>D</code> is a <code>DataFrame</code> of the distance matrix, with taxon names taken from the header of the data frame. The rows are assumed to correspond to tips in the tree in the same order as they do in columns. With <code>force_nonnegative_edges</code> being <code>true</code>, any negative edge length is changed to 0.0 (with a message).</p><p>For the algorithm, see <a href="https://doi.org/10.1093/oxfordjournals.molbev.a040454">Satou &amp; Nei 1987</a>.</p><p>See <a href="../internals/#PhyloNetworks.nj!"><code>nj!</code></a> for using a matrix as input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/nj.jl#L146-L161">source</a></section></article><h2 id="network-Comparisons"><a class="docs-heading-anchor" href="#network-Comparisons">network Comparisons</a><a id="network-Comparisons-1"></a><a class="docs-heading-anchor-permalink" href="#network-Comparisons" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.majorTree" href="#PhyloNetworks.majorTree"><code>PhyloNetworks.majorTree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">majorTree(net::HybridNetwork; nofuse=false::Bool, unroot=false::Bool,
          keeporiginalroot=false::Bool)</code></pre><p>Extract the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node.</p><p><code>nofuse</code>: if true, edges and degree-2 nodes are retained during edge removal. Otherwise, at each reticulation the child edge (below the hybrid node) is retained: the major hybrid edge is fused with it.</p><p><code>unroot</code>: is true, the root will be deleted if it becomes of degree 2.</p><p><code>keeporiginalroot</code>: the network&#39;s root is kept even if it becomes of degree 1.</p><p>Warnings:</p><ul><li>if <code>nofuse</code> is true: the hybrid edges that are retained (without fusing) have their γ values unchanged, but their <code>isMajor</code> is changed to true</li><li>assume correct <code>isMajor</code> attributes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/compareNetworks.jl#L591-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.minorTreeAt" href="#PhyloNetworks.minorTreeAt"><code>PhyloNetworks.minorTreeAt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minorTreeAt(net::HybridNetwork, hybindex::Integer, nofuse=false, unroot=false::Bool)</code></pre><p>Extract the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i=<code>hybindex</code>), where the minor hybrid edge is kept instead of the major hybrid edge. If <code>nofuse</code> is true, edges are not fused (degree-2 nodes are kept). If <code>unroot</code> is true, the root will be deleted if it becomes of degree 2.</p><p>Warning: assume correct <code>isMajor</code> fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/compareNetworks.jl#L632-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.displayedTrees" href="#PhyloNetworks.displayedTrees"><code>PhyloNetworks.displayedTrees</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">displayedTrees(net::HybridNetwork, gamma::Float64; nofuse=false::Bool,
               unroot=false::Bool, multgammas=false::Bool,
               keeporiginalroot=false::Bool)</code></pre><p>Extracts all trees displayed in a network, following hybrid edges with heritability &gt;= γ threshold (or &gt;0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than γ. Returns an array of trees, as HybridNetwork objects.</p><p><code>nofuse</code>: if true, do not fuse edges (keep degree-2 nodes) during hybrid edge removal.   <code>unroot</code>: if false, the root will not be deleted if it becomes of degree 2 unless   keeporiginalroot is true.   <code>multgammas</code>: if true, the edges in the displayed trees have γ values   equal to the proportion of genes that the edge represents, even though all   these edges are tree edges. The product of all the γ values across all edges   is the proportion of genes that the tree represents. More specifically,   edge <code>e</code> in a given displayed tree has γ equal to the product of γs   of all edges in the original network that have been merged into <code>e</code>.   <code>keeporiginalroot</code>: if true, keep root even if of degree 1.</p><p>Warnings:</p><ul><li>if <code>nofuse</code> is true: the retained partner hybrid edges have their γ values unchanged, but their <code>isMajor</code> is changed to true</li><li>assume correct <code>isMajor</code> attributes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/compareNetworks.jl#L519-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.displayedNetworkAt!" href="#PhyloNetworks.displayedNetworkAt!"><code>PhyloNetworks.displayedNetworkAt!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">displayedNetworkAt!(net::HybridNetwork, node::Node, nofuse=false,
                    unroot=false, multgammas=false)</code></pre><p>Delete all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before. If <code>nofuse</code> is true, edges are not fused (degree-2 nodes are kept).</p><p>Warning: assume correct <code>isMajor</code> fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/compareNetworks.jl#L652-L661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hardwiredClusters" href="#PhyloNetworks.hardwiredClusters"><code>PhyloNetworks.hardwiredClusters</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hardwiredClusters(net::HybridNetwork, S::Union{Vector{String},Vector{Int}})</code></p><p>Returns a matrix describing all the hardwired clusters in a network. Warnings: Clusters are rooted, so the root must be correct.           Allows for missing taxa, with entries all 0.</p><p>Each row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).</p><ul><li>first column: edge number</li><li>next columns: 0/1. 1=descendant of edge, 0=not a descendant, or missing taxon.</li><li>last column:  10/11 values. 10=tree edge, 11=hybrid edge</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/compareNetworks.jl#L57-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hardwiredCluster" href="#PhyloNetworks.hardwiredCluster"><code>PhyloNetworks.hardwiredCluster</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hardwiredCluster(edge::Edge,taxa::Union{Vector{String},Vector{Int}})
hardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}})
hardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{String},Vector{Int}},
                  visited::Vector{Int})</code></pre><p>Calculate the hardwired cluster of <code>node</code>, coded a vector of booleans: true for taxa that are descendent of nodes, false for other taxa (including missing taxa).</p><p>The node should belong in a rooted network for which <code>isChild1</code> is up-to-date. Run <code>directEdges!</code> beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.</p><p>visited: vector of node numbers, of all visited nodes.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; net5 = &quot;(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));&quot; |&gt; readTopology |&gt; directEdges! ;

julia&gt; taxa = net5 |&gt; tipLabels # ABC EF D
6-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;C&quot;
 &quot;E&quot;
 &quot;F&quot;
 &quot;D&quot;

julia&gt; hardwiredCluster(net5.edge[12], taxa) # descendants of 12th edge = CEF
6-element Vector{Bool}:
 0
 0
 1
 1
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/compareNetworks.jl#L135-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hardwiredClusterDistance" href="#PhyloNetworks.hardwiredClusterDistance"><code>PhyloNetworks.hardwiredClusterDistance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hardwiredClusterDistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)</code></pre><p>Takes 2 networks and returns their hardwired cluster distance, that is, the number of hardwired clusters found in one network and not in the other. Note that this is not a distance per se on the full space of hybrid networks: there are pairs of different networks for which this measure is 0. But it is a distance on some network subspaces.</p><p>If the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, the trees are considered unrooted.</p><p>If rooted is false and one of the phylogenies is not a tree (1+ reticulations), then all degree-2 nodes are removed before comparing the hardwired clusters, and the minimum distance is returned over all possible ways to root the networks at internal nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/compareNetworks.jl#L675-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.treeEdgesBootstrap" href="#PhyloNetworks.treeEdgesBootstrap"><code>PhyloNetworks.treeEdgesBootstrap</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>treeEdgesBootstrap(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork)</code></p><p>Read a list of bootstrap networks (<code>boot_net</code>) and a reference network (<code>ref_net</code>), and calculate the bootstrap support of the tree edges in the reference network. All minor hybrid edges (γ&lt;0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.</p><p>output:</p><ul><li>a data frame with one row per tree edge and two columns: edge number, bootstrap support (as a percentage)</li><li>the major tree from the reference network, where minor hybrid edges (with γ&lt;0.5) have been removed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/bootstrap.jl#L406-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hybridDetection" href="#PhyloNetworks.hybridDetection"><code>PhyloNetworks.hybridDetection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hybridDetection(net::Vector{HybridNetwork}, net1::HybridNetwork, outgroup::AbstractString)</code></pre><p>function can only compare hybrid nodes in networks that have the same underlying major tree also, need to root all networks in the same place, and the root has to be compatible with the direction of the hybrid edges</p><p>it computes the rooted hardwired distance between networks, the root matters. input: vector of bootstrap networks (net), estimated network (net1), outgroup</p><p>returns</p><ul><li>a matrix with one row per bootstrap network, and 2*number of hybrids in net1, column i corresponds to whether hybrid i (<code>net1.hybrid[i]</code>) is found in the bootstrap network, column 2i+1 corresponds to the estimated gamma on the bootstrap network (0.0 if hybrid not found). To know the order of hybrids, print <code>net1.hybrid</code> or <code>h.name for h in net1.hybrid</code></li><li>list of discrepant trees (trees not matching the main tree in net1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/bootstrap.jl#L461-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.summarizeHFdf" href="#PhyloNetworks.summarizeHFdf"><code>PhyloNetworks.summarizeHFdf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">summarizeHFdf(HFmat::Matrix)</code></pre><p>Summarize data frame output from <a href="#PhyloNetworks.hybridDetection"><code>hybridDetection</code></a>. Output: dataframe with one row per hybrid, and 5 columns:</p><ul><li>hybrid index (order from estimated network, see <a href="#PhyloNetworks.hybridDetection"><code>hybridDetection</code></a>,</li><li>number of bootstrap trees that match the underlying tree of estimated network</li><li>number of bootstrap networks that have the hybrid</li><li>mean estimated gamma in the bootstrap networks that have the hybrid</li><li>sd estimated gamma in the bootstrap networks that have the hybrid also</li></ul><p>last row has index -1, and the third column has the number of networks that have all hybrids (hybrid index, mean gamma, sd gamma are meaningless in this last row)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/bootstrap.jl#L984-L1000">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.hybridBootstrapSupport" href="#PhyloNetworks.hybridBootstrapSupport"><code>PhyloNetworks.hybridBootstrapSupport</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hybridBootstrapSupport(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)</code></p><p>Match hybrid nodes in a reference network with those in an array of networks, like bootstrap networks. All networks must be fully resolved, and on the same taxon set. If <code>rooted=true</code>, all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).</p><p>Two hybrid edges in two networks are said to match if they share the same &quot;hybrid&quot; clade (or recipient) and the same &quot;donor clade&quot;, which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with γ&gt;0.5) and one is its minor sister (following the major hybrid edge with γ&lt;0.5).</p><p>To calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If <code>rooted=false</code>, sister clades are considered as bipartitions.</p><p>Output:</p><ol><li>a &quot;node&quot; data frame (see below)</li><li>an &quot;edge&quot; data frame (see below)</li><li>a &quot;clade&quot; data frame to describe the make up of all clades found as hybrids or sisters, starting with a column <code>taxa</code> that lists all taxa. All other columns correspond to a given clade and contain true/false values. <code>true</code> means that a given taxon belongs in a given clade. For a clade named <code>H1</code>, for instance, and if the data frame was named <code>cla</code>, the list of taxa in this clade can be obtained with <code>cla[:taxa][cla[:H1]]</code>.</li><li>an array of gamma values, with one row for each bootstrap network and two columns (major/minor) for each hybrid edge in the reference network. If this hybrid edge was found in the bootstrap network (i.e. same hybrid and sister clades, after removal of all other hybrid nodes), its bootstrap gamma value is recorded here. Otherwise, the gamma entry is 0.0.</li><li>a vector with the number of each hybrid edge in the reference network, in the same order as for the columns in the array of gamma values above.</li></ol><p>The &quot;node&quot; data frame has one row per clade and 9 columns giving:</p><ul><li><code>:clade</code>: the clade&#39;s name, like the taxon name (if a hybrid is a single taxon) or the hybrid tag (like &#39;H1&#39;) in the reference network</li><li><code>:node</code>: the node number in the reference network. missing if the clade is not in this network.</li><li><code>:hybridnode</code>: typically the same node number as above, except for hybrid clades in the reference network. For those, the hybrid node number is listed here.</li><li><code>:edge</code>: number of the parent edge, parent to the node in column 2, if found in the ref network. missing otherwise.</li><li><code>:BS_hybrid</code>: percentage of bootstrap networks in which the clade is found to be a hybrid clade.</li><li><code>:BS_sister</code>: percentage of bootstrap networks in which the clade is found to be sister to some hybrid clade (sum of the next 2 columns)</li><li><code>:BS_major_sister</code>: percentage of bootstrap networks in which the clade is found to be the major sister to some hybrid clade</li><li><code>:BS_minor_sister</code>: same as previous, but minor</li><li><code>:BS_hybrid_samesisters</code>: percentage of bootstrap networks in which the clade is found to be a hybrid and with the same set of sister clades as in the reference network. Applies to hybrid clades found in the reference network only, missing for all other clades.</li></ul><p>The &quot;edge&quot; data frame has one row for each pair of clades, and 8 columns:</p><ul><li><code>:edge</code>: hybrid edge number, if the edge appears in the reference network. missing otherwise.</li><li><code>:hybrid_clade</code>: name of the clade found to be a hybrid, descendent of &#39;edge&#39;</li><li><code>:hybrid</code>: node number of that clade, if it appears in the reference network. missing otherwise.</li><li><code>:sister_clade</code>: name of the clade that is sister to &#39;edge&#39;, i.e. be sister to a hybrid</li><li><code>:sister</code>: node number of that clade, if in the ref network.</li><li><code>:BS_hybrid_edge</code>: percentage of bootstrap networks in which &#39;edge&#39; is found to be a hybrid  edge, i.e. when the clade in the &#39;hybrid&#39; column is found to be a hybrid and the clade in  the &#39;sister&#39; column is one of its sisters.</li><li><code>:BS_major</code>: percentage of bootstrap networks in which &#39;edge&#39; is found to be a major hybrid  edge, i.e. when &#39;hybrid&#39; is found to be a hybrid clade and &#39;sister&#39; is found to be its  major sister.</li><li><code>:BS_minor</code>: same as previous, but minor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/bootstrap.jl#L555-L625">source</a></section></article><h2 id="continuous-trait-evolution"><a class="docs-heading-anchor" href="#continuous-trait-evolution">continuous trait evolution</a><a id="continuous-trait-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#continuous-trait-evolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.phylolm" href="#PhyloNetworks.phylolm"><code>PhyloNetworks.phylolm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">phylolm(X::Matrix, Y::Vector, net::HybridNetwork, model::ContinuousTraitEM=BM(); kwargs...)</code></pre><p>Return a <a href="#PhyloNetworks.PhyloNetworkLinearModel"><code>PhyloNetworkLinearModel</code></a> object. This method is called by <code>phylolm(formula, data, network; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L1711-L1716">source</a></section><section><div><pre><code class="language-none">phylolm(f::StatsModels.FormulaTerm, fr::AbstractDataFrame, net::HybridNetwork; kwargs...)</code></pre><p>Fit a phylogenetic linear regression model to data.</p><p>Return a <a href="https://juliastats.org/StatsModels.jl/stable/api/#StatsModels.TableRegressionModel"><code>StatsModels.TableRegressionModel</code></a> object. This object has three fields: <code>model</code>, <code>mf</code>, <code>mm</code> (see <a href="https://juliastats.github.io/StatsModels.jl/stable/">StatsModels</a>). To access the fitted <a href="#PhyloNetworks.PhyloNetworkLinearModel"><code>PhyloNetworkLinearModel</code></a>, do <code>object.model</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: formula to use for the regression.</li><li><code>fr</code>: DataFrame containing the response values, predictor values, species/tip labels for each observation/row.</li><li><code>net</code>: phylogenetic network to use. Should have labelled tips.</li></ul><p>Keyword arguments</p><ul><li><code>model=&quot;BM&quot;</code>: model for trait evolution (as a string) &quot;lambda&quot; (Pagel&#39;s lambda), &quot;scalingHybrid&quot; are other possible values (see <a href="../internals/#PhyloNetworks.ContinuousTraitEM"><code>ContinuousTraitEM</code></a>)</li><li><code>tipnames=:tipNames</code>: column name for species/tip-labels, represented as a symbol. For example, if the column containing the species/tip labels in <code>fr</code> is named &quot;Species&quot;, then do <code>tipnames=:Species</code>.</li><li><code>no_names=false</code>: If <code>true</code>, force the function to ignore the tips names. The data is then assumed to be in the same order as the tips of the network. Default is false, setting it to true is dangerous, and strongly discouraged.</li><li><code>reml=true</code>: if <code>true</code>, use REML criterion (&quot;restricted maximum likelihood&quot;) for estimating variance components, else use ML criterion.</li></ul><p>The following tolerance parameters control the optimization of lambda if <code>model=&quot;lambda&quot;</code> or <code>model=&quot;scalingHybrid&quot;</code>, and control the optimization of the variance components if <code>model=&quot;BM&quot;</code> and <code>withinspecies_var=true</code>.</p><ul><li><p><code>fTolRel=1e-10</code>: relative tolerance on the likelihood value</p></li><li><p><code>fTolAbs=1e-10</code>: absolute tolerance on the likelihood value</p></li><li><p><code>xTolRel=1e-10</code>: relative tolerance on the parameter value</p></li><li><p><code>xTolAbs=1e-10</code>: absolute tolerance on the parameter value</p></li><li><p><code>startingValue=0.5</code>: If <code>model</code>=&quot;lambda&quot; or &quot;scalingHybrid&quot;, this provides the starting value for the optimization in lambda.</p></li><li><p><code>fixedValue=missing</code>: If <code>model</code>=&quot;lambda&quot; or &quot;scalingHybrid&quot;, and <code>fixedValue</code> is a number, then lambda is set to this number and is not optimized.</p></li><li><p><code>withinspecies_var=false</code>: If <code>true</code>, fits a within-species variation model. Currently only implemented for <code>model</code>=&quot;BM&quot;.</p></li><li><p><code>y_mean_std::Bool=false</code>: If <code>true</code>, and <code>withinspecies_var=true</code>, then accounts for within-species variation, using species-level statistics provided in <code>fr</code>.</p></li></ul><p><strong>Methods applied to fitted models</strong></p><p>To access the response values, do <code>response(object)</code>. To access the model matrix, do <code>object.mm.m</code>. To access the model formula, do <code>show(object.mf.f)</code>.</p><p>All of the StatsBase methods that can be applied to a <code>PhyloNetworkLinearModel</code> can also be applied to a <code>StatsModels.TableRegressionModel</code>.</p><p><strong>Within-species variation</strong></p><p>For a high-level description, see <a href="#PhyloNetworks.PhyloNetworkLinearModel"><code>PhyloNetworkLinearModel</code></a>. To fit a model with within-species variation in the response variable, either of the following must be provided in the data frame <code>fr</code>:</p><p>(1) Individual-level data: There should be columns for response, predictors, and species/tip-labels. Every row should correspond to an individual observation. At least one species must be represented by two or more individuals.</p><p>(2) Species-level statistics: There should be columns for mean response, predictors, species/tip-labels, species sample-sizes (number of individuals for each species), and species standard deviations (standard deviations of the response values by species). Every row should correspond to a species: each species should be represented by a unique row. The column names for species sample-sizes and species standard deviations are expected to be &quot;[response column name]_n&quot; and &quot;[response column name]_sd&quot;. For example, if the response column name is &quot;y&quot;, then the column names should be &quot;y_n&quot; and &quot;y_sd&quot; for the sample-sizes and standard deviations.</p><p>Regardless of whether the data provided follows (1) or (2), <code>withinspecies_var</code> should be set to true. If the data provided follows (2), then <code>y_mean_std</code> should be set to false.</p><p><strong>Within-species variation in predictors</strong></p><p>The model assumes <em>no</em> within-species variation in predictors, because it aims to capture the evolutionary (historical, phylogenetic) relationship between the predictors and the response, not the within-species (present-day, or phenotypic) relationship.</p><p>If a within-species variation model is fitted on individual-level data, and if there are individuals within the same species with different values for the same predictor, these values are all replaced by the mean predictor value for all the individuals in that species. For example, suppose there are 3 individuals in a given species, and that their predictor values are (x₁=3, x₂=6), (x₁=4, x₂=8) and (x₁=2, x₂=1). Then the predictor values for these 3 individuals are each replaced by (x₁=(3+4+2)/3, x₂=(6+8+1)/3) before model fitting. If a fourth individual had data (x₁=10, x₂=missing), then that individual would be ignored for any model using x₂, and would not contribute any information to its species data for these models.</p><p><strong>Missing data</strong></p><p>Rows with missing data for either the response or the predictors are omitted from the model-fitting. There should minimally be columns for response, predictors, species/tip-labels. As detailed above, additional columns may be required for fitting within-species variation. Missing data in the columns for species names, species standard deviation / sample sizes (if used) will throw an error.</p><p><strong>See also</strong></p><p><a href="#PhyloNetworks.PhyloNetworkLinearModel"><code>PhyloNetworkLinearModel</code></a>, <a href="#PhyloNetworks.ancestralStateReconstruction"><code>ancestralStateReconstruction</code></a></p><p><strong>Examples: Without within-species variation</strong></p><pre><code class="language-julia-repl">julia&gt; phy = readTopology(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;, &quot;examples&quot;, &quot;caudata_tree.txt&quot;));

julia&gt; using DataFrames, CSV # to read data file, next

julia&gt; dat = CSV.File(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;, &quot;examples&quot;, &quot;caudata_trait.txt&quot;)) |&gt; DataFrame;

julia&gt; using StatsModels # for stat model formulas

julia&gt; fitBM = phylolm(@formula(trait ~ 1), dat, phy; reml=false);

julia&gt; fitBM # Shows a summary
StatsModels.TableRegressionModel{PhyloNetworkLinearModel, Matrix{Float64}}

Formula: trait ~ 1

Model: Brownian motion

Parameter Estimates, using ML:
phylogenetic variance rate: 0.00294521

Coefficients:
─────────────────────────────────────────────────────────────────────
             Coef.  Std. Error      t  Pr(&gt;|t|)  Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────
(Intercept)  4.679    0.330627  14.15    &lt;1e-31    4.02696    5.33104
─────────────────────────────────────────────────────────────────────
Log Likelihood: -78.9611507833
AIC: 161.9223015666

julia&gt; round(sigma2_phylo(fitBM), digits=6) # rounding for jldoctest convenience
0.002945

julia&gt; round(mu_phylo(fitBM), digits=4)
4.679

julia&gt; using StatsBase # for aic() stderror() loglikelihood() etc.

julia&gt; round(loglikelihood(fitBM), digits=10)
-78.9611507833

julia&gt; round(aic(fitBM), digits=10)
161.9223015666

julia&gt; round(aicc(fitBM), digits=10)
161.9841572367

julia&gt; round(bic(fitBM), digits=10)
168.4887090241

julia&gt; round.(coef(fitBM), digits=4)
1-element Vector{Float64}:
 4.679

julia&gt; confint(fitBM)
1×2 Matrix{Float64}:
 4.02696  5.33104

julia&gt; abs(round(r2(fitBM), digits=10)) # absolute value for jldoctest convenience
0.0

julia&gt; abs(round(adjr2(fitBM), digits=10))
0.0

julia&gt; round.(vcov(fitBM), digits=6)
1×1 Matrix{Float64}:
 0.109314

julia&gt; round.(residuals(fitBM), digits=6)
197-element Vector{Float64}:
 -0.237648
 -0.357937
 -0.159387
 -0.691868
 -0.323977
 -0.270452
 -0.673486
 -0.584654
 -0.279882
 -0.302175
  ⋮
 -0.777026
 -0.385121
 -0.443444
 -0.327303
 -0.525953
 -0.673486
 -0.603158
 -0.211712
 -0.439833

julia&gt; round.(response(fitBM), digits=5)
197-element Vector{Float64}:
 4.44135
 4.32106
 4.51961
 3.98713
 4.35502
 4.40855
 4.00551
 4.09434
 4.39912
 4.37682
 ⋮
 3.90197
 4.29388
 4.23555
 4.3517
 4.15305
 4.00551
 4.07584
 4.46729
 4.23917

julia&gt; round.(predict(fitBM), digits=5)
197-element Vector{Float64}:
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 ⋮
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679
 4.679</code></pre><p><strong>Examples: With within-species variation (two different input formats shown)</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames, StatsModels # for statistical model formulas

julia&gt; net = readTopology(&quot;((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);&quot;);

julia&gt; df = DataFrame( # individual-level observations
           species = repeat([&quot;D&quot;,&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;E&quot;,&quot;O&quot;],inner=3),
           trait1 = [4.08298,4.08298,4.08298,3.10782,3.10782,3.10782,2.17078,2.17078,2.17078,1.87333,1.87333,
              1.87333,2.8445,2.8445,2.8445,5.88204,5.88204,5.88204],
           trait2 = [-7.34186,-7.34186,-7.34186,-7.45085,-7.45085,-7.45085,-3.32538,-3.32538,-3.32538,-4.26472,
              -4.26472,-4.26472,-5.96857,-5.96857,-5.96857,-1.99388,-1.99388,-1.99388],
           trait3 = [18.8101,18.934,18.9438,17.0687,17.0639,17.0732,14.4818,14.1112,14.2817,13.0842,12.9562,
              12.9019,15.4373,15.4075,15.4317,24.2249,24.1449,24.1302]);

julia&gt; m1 = phylolm(@formula(trait3 ~ trait1), df, net;
                    tipnames=:species, withinspecies_var=true)
StatsModels.TableRegressionModel{PhyloNetworkLinearModel, Matrix{Float64}}

Formula: trait3 ~ 1 + trait1

Model: Brownian motion

Parameter Estimates, using REML:
phylogenetic variance rate: 0.156188
within-species variance: 0.0086343

Coefficients:
──────────────────────────────────────────────────────────────────────
               Coef.  Std. Error     t  Pr(&gt;|t|)  Lower 95%  Upper 95%
──────────────────────────────────────────────────────────────────────
(Intercept)  9.65347    1.3066    7.39    0.0018    6.02577   13.2812
trait1       2.30358    0.276163  8.34    0.0011    1.53683    3.07033
──────────────────────────────────────────────────────────────────────
Log Likelihood: 1.9446255188
AIC: 4.1107489623

julia&gt; df_r = DataFrame( # species-level statistics (sample means, standard deviations)
           species = [&quot;D&quot;,&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;E&quot;,&quot;O&quot;],
           trait1 = [4.08298,3.10782,2.17078,1.87333,2.8445,5.88204],
           trait2 = [-7.34186,-7.45085,-3.32538,-4.26472,-5.96857,-1.99388],
           trait3 = [18.896,17.0686,14.2916,12.9808,15.4255,24.1667],
           trait3_sd = [0.074524,0.00465081,0.185497,0.0936,0.0158379,0.0509643],
           trait3_n = [3, 3, 3, 3, 3, 3]);

julia&gt; m2 = phylolm(@formula(trait3 ~ trait1), df_r, net;
                tipnames=:species, withinspecies_var=true, y_mean_std=true)
StatsModels.TableRegressionModel{PhyloNetworkLinearModel, Matrix{Float64}}

Formula: trait3 ~ 1 + trait1

Model: Brownian motion

Parameter Estimates, using REML:
phylogenetic variance rate: 0.15618
within-species variance: 0.0086343

Coefficients:
──────────────────────────────────────────────────────────────────────
               Coef.  Std. Error     t  Pr(&gt;|t|)  Lower 95%  Upper 95%
──────────────────────────────────────────────────────────────────────
(Intercept)  9.65342    1.30657   7.39    0.0018    6.02582   13.281
trait1       2.30359    0.276156  8.34    0.0011    1.53686    3.07032
──────────────────────────────────────────────────────────────────────
Log Likelihood: 1.9447243714
AIC: 4.1105512573</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L2030-L2347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.sigma2_phylo" href="#PhyloNetworks.sigma2_phylo"><code>PhyloNetworks.sigma2_phylo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sigma2_phylo(m::PhyloNetworkLinearModel)</code></pre><p>Estimated between-species variance-rate for a fitted object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L2697-L2701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.sigma2_within" href="#PhyloNetworks.sigma2_within"><code>PhyloNetworks.sigma2_within</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sigma2_within(m::PhyloNetworkLinearModel)</code></pre><p>Estimated within-species variance for a fitted object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L2717-L2721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.mu_phylo" href="#PhyloNetworks.mu_phylo"><code>PhyloNetworks.mu_phylo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mu_phylo(m::PhyloNetworkLinearModel)</code></pre><p>Estimated root value for a fitted object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L2725-L2729">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.lambda_estim" href="#PhyloNetworks.lambda_estim"><code>PhyloNetworks.lambda_estim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lambda_estim(m::PhyloNetworkLinearModel)</code></pre><p>Estimated lambda parameter for a fitted object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L2767-L2771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.ancestralStateReconstruction" href="#PhyloNetworks.ancestralStateReconstruction"><code>PhyloNetworks.ancestralStateReconstruction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ancestralStateReconstruction(net::HybridNetwork, Y::Vector, params::ParamsBM)</code></pre><p>Compute the conditional expectations and variances of the ancestral (un-observed) traits values at the internal nodes of the phylogenetic network (<code>net</code>), given the values of the traits at the tips of the network (<code>Y</code>) and some known parameters of the process used for trait evolution (<code>params</code>, only BM with fixed root works for now).</p><p>This function assumes that the parameters of the process are known. For a more general function, see <code>ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L3248-L3260">source</a></section><section><div><pre><code class="language-none">ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])</code></pre><p>Function to find the ancestral traits reconstruction on a network, given an object fitted by function <a href="#PhyloNetworks.phylolm"><code>phylolm</code></a>. By default, the function assumes that the regressor is just an intercept. If the value of the regressor for all the ancestral states is known, it can be entered in X_n, a matrix with as many columns as the number of predictors used, and as many lines as the number of unknown nodes or tips.</p><p>Returns an object of type <a href="#PhyloNetworks.ReconstructedStates"><code>ReconstructedStates</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames, CSV # to read data file

julia&gt; phy = readTopology(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;, &quot;examples&quot;, &quot;carnivores_tree.txt&quot;));

julia&gt; dat = CSV.File(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;, &quot;examples&quot;, &quot;carnivores_trait.txt&quot;)) |&gt; DataFrame;

julia&gt; using StatsModels # for statistical model formulas

julia&gt; fitBM = phylolm(@formula(trait ~ 1), dat, phy);

julia&gt; ancStates = ancestralStateReconstruction(fitBM) # Should produce a warning, as variance is unknown.
┌ Warning: These prediction intervals show uncertainty in ancestral values,
│ assuming that the estimated variance rate of evolution is correct.
│ Additional uncertainty in the estimation of this variance rate is
│ ignored, so prediction intervals should be larger.
└ @ PhyloNetworks ~/build/crsl4/PhyloNetworks.jl/src/traits.jl:3359
ReconstructedStates:
───────────────────────────────────────────────
  Node index      Pred.        Min.  Max. (95%)
───────────────────────────────────────────────
        -5.0   1.32139   -0.33824      2.98102
        -8.0   1.03258   -0.589695     2.65485
        -7.0   1.41575   -0.140705     2.97221
        -6.0   1.39417   -0.107433     2.89577
        -4.0   1.39961   -0.102501     2.90171
        -3.0   1.51341   -0.220523     3.24733
       -13.0   5.3192     3.92279      6.71561
       -12.0   4.51176    2.89222      6.13131
       -16.0   1.50947   -0.0186118    3.03755
       -15.0   1.67425    0.196069     3.15242
       -14.0   1.80309    0.309992     3.29618
       -11.0   2.7351     1.17608      4.29412
       -10.0   2.73217    1.12361      4.34073
        -9.0   2.41132    0.603932     4.21871
        -2.0   2.04138   -0.0340955    4.11686
        14.0   1.64289    1.64289      1.64289
         8.0   1.67724    1.67724      1.67724
         5.0   0.331568   0.331568     0.331568
         2.0   2.27395    2.27395      2.27395
         4.0   0.275237   0.275237     0.275237
         6.0   3.39094    3.39094      3.39094
        13.0   0.355799   0.355799     0.355799
        15.0   0.542565   0.542565     0.542565
         7.0   0.773436   0.773436     0.773436
        10.0   6.94985    6.94985      6.94985
        11.0   4.78323    4.78323      4.78323
        12.0   5.33016    5.33016      5.33016
         1.0  -0.122604  -0.122604    -0.122604
        16.0   0.73989    0.73989      0.73989
         9.0   4.84236    4.84236      4.84236
         3.0   1.0695     1.0695       1.0695
───────────────────────────────────────────────

julia&gt; expectations(ancStates)
31×2 DataFrame
 Row │ nodeNumber  condExpectation
     │ Int64       Float64
─────┼─────────────────────────────
   1 │         -5         1.32139
   2 │         -8         1.03258
   3 │         -7         1.41575
   4 │         -6         1.39417
   5 │         -4         1.39961
   6 │         -3         1.51341
   7 │        -13         5.3192
   8 │        -12         4.51176
  ⋮  │     ⋮              ⋮
  25 │         10         6.94985
  26 │         11         4.78323
  27 │         12         5.33016
  28 │          1        -0.122604
  29 │         16         0.73989
  30 │          9         4.84236
  31 │          3         1.0695
                    16 rows omitted

julia&gt; predint(ancStates)
31×2 Matrix{Float64}:
 -0.33824     2.98102
 -0.589695    2.65485
 -0.140705    2.97221
 -0.107433    2.89577
 -0.102501    2.90171
 -0.220523    3.24733
  3.92279     6.71561
  2.89222     6.13131
 -0.0186118   3.03755
  0.196069    3.15242
  ⋮
  0.542565    0.542565
  0.773436    0.773436
  6.94985     6.94985
  4.78323     4.78323
  5.33016     5.33016
 -0.122604   -0.122604
  0.73989     0.73989
  4.84236     4.84236
  1.0695      1.0695

julia&gt; expectationsPlot(ancStates) # format the ancestral states
31×2 DataFrame
 Row │ nodeNumber  PredInt
     │ Int64       Abstract… 
─────┼───────────────────────
   1 │         -5  1.32
   2 │         -8  1.03
   3 │         -7  1.42
   4 │         -6  1.39
   5 │         -4  1.4
   6 │         -3  1.51
   7 │        -13  5.32
   8 │        -12  4.51
  ⋮  │     ⋮           ⋮
  25 │         10  6.95
  26 │         11  4.78
  27 │         12  5.33
  28 │          1  -0.12
  29 │         16  0.74
  30 │          9  4.84
  31 │          3  1.07
              16 rows omitted

julia&gt; using PhyloPlots # next: plot ancestral states on the tree

julia&gt; plot(phy, :RCall, nodeLabel = expectationsPlot(ancStates));

julia&gt; predintPlot(ancStates) # prediction intervals, in data frame, useful to plot
31×2 DataFrame
 Row │ nodeNumber  PredInt
     │ Int64       Abstract…
─────┼───────────────────────────
   1 │         -5  [-0.34, 2.98]
   2 │         -8  [-0.59, 2.65]
   3 │         -7  [-0.14, 2.97]
   4 │         -6  [-0.11, 2.9]
   5 │         -4  [-0.1, 2.9]
   6 │         -3  [-0.22, 3.25]
   7 │        -13  [3.92, 6.72]
   8 │        -12  [2.89, 6.13]
  ⋮  │     ⋮             ⋮
  25 │         10  6.95
  26 │         11  4.78
  27 │         12  5.33
  28 │          1  -0.12
  29 │         16  0.74
  30 │          9  4.84
  31 │          3  1.07
                  16 rows omitted

julia&gt; plot(phy, :RCall, nodeLabel = predintPlot(ancStates));

julia&gt; allowmissing!(dat, :trait);

julia&gt; dat[[2, 5], :trait] .= missing; # missing values allowed to fit model

julia&gt; fitBM = phylolm(@formula(trait ~ 1), dat, phy);

julia&gt; ancStates = ancestralStateReconstruction(fitBM);
┌ Warning: These prediction intervals show uncertainty in ancestral values,
│ assuming that the estimated variance rate of evolution is correct.
│ Additional uncertainty in the estimation of this variance rate is
│ ignored, so prediction intervals should be larger.
└ @ PhyloNetworks ~/build/crsl4/PhyloNetworks.jl/src/traits.jl:3166

julia&gt; first(expectations(ancStates), 3) # looking at first 3 nodes only
3×2 DataFrame
 Row │ nodeNumber  condExpectation 
     │ Int64       Float64         
─────┼─────────────────────────────
   1 │         -5          1.42724
   2 │         -8          1.35185
   3 │         -7          1.61993

julia&gt; predint(ancStates)[1:3,:] # just first 3 nodes again
3×2 Matrix{Float64}:
 -0.373749  3.22824
 -0.698432  3.40214
 -0.17179   3.41165

   
julia&gt; first(expectationsPlot(ancStates),3) # format node &lt;-&gt; ancestral state
3×2 DataFrame
 Row │ nodeNumber  PredInt   
     │ Int64       Abstract… 
─────┼───────────────────────
   1 │         -5  1.43
   2 │         -8  1.35
   3 │         -7  1.62

julia&gt; plot(phy, :RCall, nodeLabel = expectationsPlot(ancStates));

julia&gt; first(predintPlot(ancStates),3) # prediction intervals, useful to plot
3×2 DataFrame
 Row │ nodeNumber  PredInt       
     │ Int64       Abstract…     
─────┼───────────────────────────
   1 │         -5  [-0.37, 3.23]
   2 │         -8  [-0.7, 3.4]
   3 │         -7  [-0.17, 3.41]

julia&gt; plot(phy, :RCall, nodeLabel = predintPlot(ancStates));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L3377-L3594">source</a></section><section><div><pre><code class="language-none">ancestralStateReconstruction(fr::AbstractDataFrame, net::HybridNetwork; kwargs...)</code></pre><p>Estimate the ancestral traits on a network, given some data at the tips. Uses function <a href="#PhyloNetworks.phylolm"><code>phylolm</code></a> to perform a phylogenetic regression of the data against an intercept (amounts to fitting an evolutionary model on the network).</p><p>See documentation on <a href="#PhyloNetworks.phylolm"><code>phylolm</code></a> and <code>ancestralStateReconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])</code> for further details.</p><p>Returns an object of type <a href="#PhyloNetworks.ReconstructedStates"><code>ReconstructedStates</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L3615-L3626">source</a></section><section><div><pre><code class="language-none">ancestralStateReconstruction(obj::SSM, trait::Integer = 1)</code></pre><p>Estimate the marginal probability of ancestral states for discrete character number <code>trait</code> (first trait by default). The parameters of the <a href="../internals/#PhyloNetworks.StatisticalSubstitutionModel"><code>StatisticalSubstitutionModel</code></a> object <code>obj</code> must first be fitted using <a href="#PhyloNetworks.fitdiscrete"><code>fitdiscrete</code></a>, and ancestral state reconstruction is conditional on the estimated parameters. If these parameters were estimated using all traits, they are used as is, to do ancestral state reconstruction of the particular <code>trait</code> of interest.</p><p><strong>output</strong>: data frame with a first column for the node numbers, a second column for the node labels, and a column for each possible state: the entries in these columns give the marginal probability that a given node has a given state.</p><p>warnings:</p><ul><li>node numbers and node labels refer to those in <code>obj.net</code>, which might have a different internal representation of nodes than the original network used to build <code>obj</code>.</li><li><code>obj</code> is modified: its likelihood fields (forward, directional &amp; backward) are updated to make sure that they correspond to the current parameter values in <code>obj.model</code>, and to the <code>trait</code> of interest.</li></ul><p>limitations: the following are not checked.</p><ul><li>Assumes that every node in the large network is also present (with descendant leaves) in each displayed tree. This is not true if the network is not tree-child...</li><li>Assumes that the root is also in each displayed tree, which may not be the case if the root had a hybrid child edge.</li></ul><p>See also <a href="../internals/#PhyloNetworks.posterior_logtreeweight"><code>posterior_logtreeweight</code></a> and <a href="../internals/#PhyloNetworks.discrete_backwardlikelihood_trait!-Tuple{PhyloNetworks.StatisticalSubstitutionModel, Integer, Integer}"><code>discrete_backwardlikelihood_trait!</code></a> to update <code>obj.backwardlik</code>.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);&quot;);

julia&gt; m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [&quot;lo&quot;, &quot;hi&quot;]);

julia&gt; using DataFrames

julia&gt; dat = DataFrame(species=[&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;D&quot;], trait=[&quot;hi&quot;,&quot;lo&quot;,&quot;lo&quot;,&quot;hi&quot;]);

julia&gt; fit1 = fitdiscrete(net, m1, dat);

julia&gt; asr = ancestralStateReconstruction(fit1)
9×4 DataFrame
 Row │ nodenumber  nodelabel  lo        hi
     │ Int64       String     Float64   Float64
─────┼───────────────────────────────────────────
   1 │          1  A          1.0       0.0
   2 │          2  B          1.0       0.0
   3 │          3  C          0.0       1.0
   4 │          4  D          0.0       1.0
   5 │          5  5          0.286021  0.713979
   6 │          6  6          0.319456  0.680544
   7 │          7  7          0.16855   0.83145
   8 │          8  8          0.767359  0.232641
   9 │          9  H1         0.782776  0.217224

julia&gt; using PhyloPlots

julia&gt; plot(fit1.net, :R, nodeLabel = asr[!,[:nodenumber, :lo]], tipOffset=0.2); # pp for &quot;lo&quot; state</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traitsLikDiscrete.jl#L951-L1016">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.expectations" href="#PhyloNetworks.expectations"><code>PhyloNetworks.expectations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expectations(obj::ReconstructedStates)</code></pre><p>Estimated reconstructed states at the nodes and tips.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L3116-L3120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.predint" href="#PhyloNetworks.predint"><code>PhyloNetworks.predint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">predint(obj::ReconstructedStates; level=0.95::Real)</code></pre><p>Prediction intervals with level <code>level</code> for internal nodes and missing tips.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L3158-L3162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.expectationsPlot" href="#PhyloNetworks.expectationsPlot"><code>PhyloNetworks.expectationsPlot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expectationsPlot(obj::ReconstructedStates)</code></pre><p>Compute and format the expected reconstructed states for the plotting function. The resulting dataframe can be readily used as a <code>nodeLabel</code> argument to <code>plot</code> from package <a href="https://github.com/cecileane/PhyloPlots.jl"><code>PhyloPlots</code></a>. Keyword argument <code>markMissing</code> is a string that is appended to predicted tip values, so that they can be distinguished from the actual datapoints. Default to &quot;*&quot;. Set to &quot;&quot; to remove any visual cue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L3125-L3134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.predintPlot" href="#PhyloNetworks.predintPlot"><code>PhyloNetworks.predintPlot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">predintPlot(obj::ReconstructedStates; level=0.95::Real, withExp=false::Bool)</code></pre><p>Compute and format the prediction intervals for the plotting function. The resulting dataframe can be readily used as a <code>nodeLabel</code> argument to <code>plot</code> from package <a href="https://github.com/cecileane/PhyloPlots.jl"><code>PhyloPlots</code></a>. Keyworks argument <code>level</code> control the confidence level of the prediction interval. If <code>withExp</code> is set to true, then the best predicted value is also shown along with the interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L3181-L3190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.simulate" href="#PhyloNetworks.simulate"><code>PhyloNetworks.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simulate(net::HybridNetwork, params::ParamsProcess, checkPreorder=true::Bool)</code></pre><p>Simulate traits on <code>net</code> using the parameters <code>params</code>. For now, only parameters of type <a href="#PhyloNetworks.ParamsBM"><code>ParamsBM</code></a> (univariate Brownian Motion) and <a href="#PhyloNetworks.ParamsMultiBM"><code>ParamsMultiBM</code></a> (multivariate Brownian motion) are accepted.</p><p>The simulation using a recursion from the root to the tips of the network, therefore, a pre-ordering of nodes is needed. If <code>checkPreorder=true</code> (default), <a href="#PhyloNetworks.preorder!"><code>preorder!</code></a> is called on the network beforehand. Otherwise, it is assumed that the preordering has already been calculated.</p><p>Returns an object of type <a href="#PhyloNetworks.TraitSimulation"><code>TraitSimulation</code></a>, which has a matrix with the trait expecations and simulated trait values at all the nodes.</p><p>See examples below for accessing expectations and simulated trait values.</p><p><strong>Examples</strong></p><p><strong>Univariate</strong></p><pre><code class="language-julia-repl">julia&gt; phy = readTopology(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;, &quot;examples&quot;, &quot;carnivores_tree.txt&quot;));

julia&gt; par = ParamsBM(1, 0.1) # BM with expectation 1 and variance 0.1.
ParamsBM:
Parameters of a BM with fixed root:
mu: 1
Sigma2: 0.1


julia&gt; using Random; Random.seed!(17920921); # for reproducibility

julia&gt; sim = simulate(phy, par) # Simulate on the tree.
TraitSimulation:
Trait simulation results on a network with 16 tips, using a BM model, with parameters:
mu: 1
Sigma2: 0.1


julia&gt; traits = sim[:Tips] # Extract simulated values at the tips.
16-element Vector{Float64}:
  2.17618427971927
  1.0330846124205684
  3.048979175536912
  3.0379560744947876
  2.189704751299587
  4.031588898597555
  4.647725850651446
 -0.8772851731182523
  4.625121065244063
 -0.5111667949991542
  1.3560351170535228
 -0.10311152349323893
 -2.088472913751017
  2.6399137689702723
  2.8051193818084057
  3.1910928691142915

julia&gt; sim.M.tipNames # name of tips, in the same order as values above
16-element Vector{String}:
 &quot;Prionodontidae&quot;
 &quot;Felidae&quot;
 &quot;Viverridae&quot;
 &quot;Herpestidae&quot;
 &quot;Eupleridae&quot;
 &quot;Hyaenidae&quot;
 &quot;Nandiniidae&quot;
 &quot;Canidae&quot;
 &quot;Ursidae&quot;
 &quot;Odobenidae&quot;
 &quot;Otariidae&quot;
 &quot;Phocidae&quot;
 &quot;Mephitidae&quot;
 &quot;Ailuridae&quot;
 &quot;Mustelidae&quot;
 &quot;Procyonidae&quot;

julia&gt; traits = sim[:InternalNodes] # Extract simulated values at internal nodes. Order: as in sim.M.internalNodeNumbers
15-element Vector{Float64}:
 1.1754592873593104
 2.0953234045227083
 2.4026760531649423
 1.8143470622283222
 1.5958834784477616
 2.5535578380290103
 0.14811474751515852
 1.2168428692963675
 3.169431736805764
 2.906447201806521
 2.8191520015241545
 2.280632978157822
 2.5212485416800425
 2.4579867601968663
 1.0

julia&gt; traits = sim[:All] # simulated values at all nodes, ordered as in sim.M.nodeNumbersTopOrder
31-element Vector{Float64}:
 1.0
 2.4579867601968663
 2.5212485416800425
 2.280632978157822
 2.8191520015241545
 2.906447201806521
 3.169431736805764
 3.1910928691142915
 2.8051193818084057
 2.6399137689702723
 ⋮
 2.4026760531649423
 4.031588898597555
 2.0953234045227083
 2.189704751299587
 3.0379560744947876
 3.048979175536912
 1.1754592873593104
 1.0330846124205684
 2.17618427971927

julia&gt; traits = sim[:Tips, :Exp] # Extract expected values at the tips (also works for sim[:All, :Exp] and sim[:InternalNodes, :Exp]).
16-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0</code></pre><p><strong>Multivariate</strong></p><pre><code class="language-julia-repl">julia&gt; phy = readTopology(joinpath(dirname(pathof(PhyloNetworks)), &quot;..&quot;, &quot;examples&quot;, &quot;carnivores_tree.txt&quot;));

julia&gt; par = ParamsMultiBM([1.0, 2.0], [1.0 0.5; 0.5 1.0]) # BM with expectation [1.0, 2.0] and variance [1.0 0.5; 0.5 1.0].
ParamsMultiBM:
Parameters of a MBD with fixed root:
mu: [1.0, 2.0]
Sigma: [1.0 0.5; 0.5 1.0]

julia&gt; using Random; Random.seed!(17920921); # for reproducibility

julia&gt; sim = simulate(phy, par) # Simulate on the tree.
TraitSimulation:
Trait simulation results on a network with 16 tips, using a MBD model, with parameters:
mu: [1.0, 2.0]
Sigma: [1.0 0.5; 0.5 1.0]


julia&gt; traits = sim[:Tips] # Extract simulated values at the tips (each column contains the simulated traits for one node).
2×16 Matrix{Float64}:
 5.39465  7.223     1.88036  -5.10491   …  -3.86504  0.133704  -2.44564
 7.29184  7.59947  -1.89206  -0.960013      3.86822  3.23285    1.93376

julia&gt; traits = sim[:InternalNodes] # simulated values at internal nodes. order: same as in sim.M.internalNodeNumbers
2×15 Matrix{Float64}:
 4.42499  -0.364198  0.71666   3.76669  …  4.57552  4.29265  5.61056  1.0
 6.24238   2.97237   0.698006  2.40122     5.92623  5.13753  4.5268   2.0

julia&gt; traits = sim[:All] # simulated values at all nodes, ordered as in sim.M.nodeNumbersTopOrder
2×31 Matrix{Float64}:
 1.0  5.61056  4.29265  4.57552  …   1.88036  4.42499  7.223    5.39465
 2.0  4.5268   5.13753  5.92623     -1.89206  6.24238  7.59947  7.29184

julia&gt; sim[:Tips, :Exp] # Extract expected values (also works for sim[:All, :Exp] and sim[:InternalNodes, :Exp])
2×16 Matrix{Float64}:
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0     2.0  2.0  2.0  2.0  2.0  2.0  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L1072-L1249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.shiftHybrid" href="#PhyloNetworks.shiftHybrid"><code>PhyloNetworks.shiftHybrid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shiftHybrid(value::Vector{T} where T&lt;:Real, net::HybridNetwork; checkPreorder=true::Bool)</code></pre><p>Construct an object <a href="#PhyloNetworks.ShiftNet"><code>ShiftNet</code></a> with shifts on all the edges below hybrid nodes, with values provided. The vector of values must have the same length as the number of hybrids in the network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L743-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getShiftEdgeNumber" href="#PhyloNetworks.getShiftEdgeNumber"><code>PhyloNetworks.getShiftEdgeNumber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getShiftEdgeNumber(shift::ShiftNet)</code></pre><p>Get the edge numbers where the shifts are located, for an object <a href="#PhyloNetworks.ShiftNet"><code>ShiftNet</code></a>. If a shift is placed at the root node with no parent edge, the edge number of a shift is set to -1 (as if missing).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L761-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.getShiftValue" href="#PhyloNetworks.getShiftValue"><code>PhyloNetworks.getShiftValue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getShiftValue(shift::ShiftNet)</code></pre><p>Get the values of the shifts, for an object <a href="#PhyloNetworks.ShiftNet"><code>ShiftNet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L795-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.descendenceMatrix" href="#PhyloNetworks.descendenceMatrix"><code>PhyloNetworks.descendenceMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">descendenceMatrix(net::HybridNetwork; checkPreorder=true::Bool)</code></pre><p>Descendence matrix between all the nodes of a network: object <code>D</code> of type <a href="../internals/#PhyloNetworks.MatrixTopologicalOrder"><code>MatrixTopologicalOrder</code></a> in which <code>D[i,j]</code> is the proportion of genetic material in node <code>i</code> that can be traced back to node <code>j</code>. If <code>D[i,j]&gt;0</code> then <code>j</code> is a descendent of <code>i</code> (and <code>j</code> is an ancestor of <code>i</code>). The network is assumed to be pre-ordered if <code>checkPreorder</code> is false. If <code>checkPreorder</code> is true (default), <code>preorder!</code> is run on the network beforehand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L386-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.regressorShift" href="#PhyloNetworks.regressorShift"><code>PhyloNetworks.regressorShift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">regressorShift(node::Vector{Node}, net::HybridNetwork; checkPreorder=true)
regressorShift(edge::Vector{Edge}, net::HybridNetwork; checkPreorder=true)</code></pre><p>Compute the regressor vectors associated with shifts on edges that are above nodes <code>node</code>, or on edges <code>edge</code>, on a network <code>net</code>. It uses function <a href="#PhyloNetworks.descendenceMatrix"><code>descendenceMatrix</code></a>, so <code>net</code> might be modified to sort it in a pre-order. Return a <code>DataFrame</code> with as many rows as there are tips in net, and a column for each shift, each labelled according to the pattern shift<em>{number</em>of_edge}. It has an aditional column labelled <code>tipNames</code> to allow easy fitting afterward (see example).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5);&quot;);

julia&gt; preorder!(net)

julia&gt; using PhyloPlots

julia&gt; plot(net, :RCall, showNodeNumber=true); # to locate nodes

julia&gt; nodes_shifts = indexin([1,-5], [n.number for n in net.node]) # Put a shift on edges ending at nodes 1 and -5
2-element Vector{Union{Nothing, Int64}}:
 1
 7

julia&gt; params = ParamsBM(10, 0.1, ShiftNet(net.node[nodes_shifts], [3.0, -3.0],  net))
ParamsBM:
Parameters of a BM with fixed root:
mu: 10
Sigma2: 0.1

There are 2 shifts on the network:
──────────────────────────
  Edge Number  Shift Value
──────────────────────────
          8.0         -3.0
          1.0          3.0
──────────────────────────

julia&gt; using Random; Random.seed!(2468); # sets the seed for reproducibility

julia&gt; sim = simulate(net, params); # simulate a dataset with shifts

julia&gt; using DataFrames # to handle data frames

julia&gt; dat = DataFrame(trait = sim[:Tips], tipNames = sim.M.tipNames)
4×2 DataFrame
 Row │ trait     tipNames 
     │ Float64   String   
─────┼────────────────────
   1 │ 13.392    A
   2 │  9.55741  B
   3 │  7.17704  C
   4 │  7.88906  D

julia&gt; dfr_shift = regressorShift(net.node[nodes_shifts], net) # the regressors matching the shifts.
4×3 DataFrame
 Row │ shift_1  shift_8  tipNames 
     │ Float64  Float64  String   
─────┼────────────────────────────
   1 │     1.0      0.0  A
   2 │     0.0      0.0  B
   3 │     0.0      1.0  C
   4 │     0.0      0.6  D

julia&gt; dfr = innerjoin(dat, dfr_shift, on=:tipNames); # join data and regressors in a single dataframe

julia&gt; using StatsModels # for statistical model formulas

julia&gt; fitBM = phylolm(@formula(trait ~ shift_1 + shift_8), dfr, net; reml=false) # actual fit
StatsModels.TableRegressionModel{PhyloNetworkLinearModel, Matrix{Float64}}

Formula: trait ~ 1 + shift_1 + shift_8

Model: Brownian motion

Parameter Estimates, using ML:
phylogenetic variance rate: 0.0112618

Coefficients:
────────────────────────────────────────────────────────────────────────
                Coef.  Std. Error      t  Pr(&gt;|t|)  Lower 95%  Upper 95%
────────────────────────────────────────────────────────────────────────
(Intercept)   9.48238    0.327089  28.99    0.0220    5.32632   13.6384
shift_1       3.9096     0.46862    8.34    0.0759   -2.04479    9.86399
shift_8      -2.4179     0.422825  -5.72    0.1102   -7.7904     2.95461
────────────────────────────────────────────────────────────────────────
Log Likelihood: 1.8937302027
AIC: 4.2125395947
</code></pre><p><strong>See also</strong></p><p><a href="#PhyloNetworks.phylolm"><code>phylolm</code></a>, <a href="#PhyloNetworks.descendenceMatrix"><code>descendenceMatrix</code></a>, <a href="#PhyloNetworks.regressorHybrid"><code>regressorHybrid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L427-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.regressorHybrid" href="#PhyloNetworks.regressorHybrid"><code>PhyloNetworks.regressorHybrid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">regressorHybrid(net::HybridNetwork; checkPreorder=true::Bool)</code></pre><p>Compute the regressor vectors associated with shifts on edges that imediatly below all hybrid nodes of <code>net</code>. It uses function <a href="#PhyloNetworks.descendenceMatrix"><code>descendenceMatrix</code></a> through a call to <a href="#PhyloNetworks.regressorShift"><code>regressorShift</code></a>, so <code>net</code> might be modified to sort it in a pre-order. Return a <code>DataFrame</code> with as many rows as there are tips in net, and a column for each hybrid, each labelled according to the pattern shift<em>{number</em>of_edge}. It has an aditional column labelled <code>tipNames</code> to allow easy fitting afterward (see example).</p><p>This function can be used to test for heterosis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames # Needed to handle data frames.

julia&gt; net = readTopology(&quot;(A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5);&quot;);

julia&gt; preorder!(net)

julia&gt; using PhyloPlots

julia&gt; plot(net, :RCall, showNodeNumber=true); # to locate nodes: node 5 is child of hybrid node

julia&gt; nodes_hybrids = indexin([5], [n.number for n in net.node]) # Put a shift on edges below hybrids
1-element Vector{Union{Nothing, Int64}}:
 5

julia&gt; params = ParamsBM(10, 0.1, ShiftNet(net.node[nodes_hybrids], [3.0],  net))
ParamsBM:
Parameters of a BM with fixed root:
mu: 10
Sigma2: 0.1

There are 1 shifts on the network:
──────────────────────────
  Edge Number  Shift Value
──────────────────────────
          6.0          3.0
──────────────────────────


julia&gt; using Random; Random.seed!(2468); # sets the seed for reproducibility

julia&gt; sim = simulate(net, params); # simulate a dataset with shifts

julia&gt; dat = DataFrame(trait = sim[:Tips], tipNames = sim.M.tipNames)
4×2 DataFrame
 Row │ trait     tipNames 
     │ Float64   String   
─────┼────────────────────
   1 │ 10.392    A
   2 │  9.55741  B
   3 │ 10.177    C
   4 │ 12.6891   D

julia&gt; dfr_hybrid = regressorHybrid(net) # the regressors matching the hybrids.
4×3 DataFrame
 Row │ shift_6  tipNames  sum     
     │ Float64  String    Float64 
─────┼────────────────────────────
   1 │     0.0  A             0.0
   2 │     0.0  B             0.0
   3 │     0.0  C             0.0
   4 │     1.0  D             1.0

julia&gt; dfr = innerjoin(dat, dfr_hybrid, on=:tipNames); # join data and regressors in a single dataframe

julia&gt; using StatsModels

julia&gt; fitBM = phylolm(@formula(trait ~ shift_6), dfr, net; reml=false) # actual fit
StatsModels.TableRegressionModel{PhyloNetworkLinearModel, Matrix{Float64}}

Formula: trait ~ 1 + shift_6

Model: Brownian motion

Parameter Estimates, using ML:
phylogenetic variance rate: 0.041206

Coefficients:
────────────────────────────────────────────────────────────────────────
                Coef.  Std. Error      t  Pr(&gt;|t|)  Lower 95%  Upper 95%
────────────────────────────────────────────────────────────────────────
(Intercept)  10.064      0.277959  36.21    0.0008    8.86805   11.26
shift_6       2.72526    0.315456   8.64    0.0131    1.36796    4.08256
────────────────────────────────────────────────────────────────────────
Log Likelihood: -0.7006021946
AIC: 7.4012043891
</code></pre><p><strong>See also</strong></p><p><a href="#PhyloNetworks.phylolm"><code>phylolm</code></a>, <a href="#PhyloNetworks.descendenceMatrix"><code>descendenceMatrix</code></a>, <a href="#PhyloNetworks.regressorShift"><code>regressorShift</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L559-L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.sharedPathMatrix" href="#PhyloNetworks.sharedPathMatrix"><code>PhyloNetworks.sharedPathMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sharedPathMatrix(net::HybridNetwork; checkPreorder=true::Bool)</code></pre><p>This function computes the shared path matrix between all the nodes of a network. It assumes that the network is in the pre-order. If checkPreorder is true (default), then it runs function <code>preorder!</code> on the network beforehand.</p><p>Returns an object of type <a href="../internals/#PhyloNetworks.MatrixTopologicalOrder"><code>MatrixTopologicalOrder</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L328-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.vcv" href="#PhyloNetworks.vcv"><code>PhyloNetworks.vcv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vcv(net::HybridNetwork; model=&quot;BM&quot;::AbstractString,
                        corr=false::Bool,
                        checkPreorder=true::Bool)</code></pre><p>This function computes the variance covariance matrix between the tips of the network, assuming a Brownian model of trait evolution (with unit variance). If optional argument <code>corr</code> is set to <code>true</code>, then the correlation matrix is returned instead.</p><p>The function returns a <code>DataFrame</code> object, with columns named by the tips of the network.</p><p>The calculation of the covariance matrix requires a pre-ordering of nodes to be fast. If <code>checkPreorder</code> is true (default), then <a href="#PhyloNetworks.preorder!"><code>preorder!</code></a> is run on the network beforehand. Otherwise, the network is assumed to be already in pre-order.</p><p>This function internally calls <a href="#PhyloNetworks.sharedPathMatrix"><code>sharedPathMatrix</code></a>, which computes the variance matrix between all the nodes of the network.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tree_str = &quot;(((t2:0.14,t4:0.33):0.59,t3:0.96):0.14,(t5:0.70,t1:0.18):0.90);&quot;;

julia&gt; tree = readTopology(tree_str);

julia&gt; C = vcv(tree)
5×5 DataFrame
 Row │ t2       t4       t3       t5       t1      
     │ Float64  Float64  Float64  Float64  Float64 
─────┼─────────────────────────────────────────────
   1 │    0.87     0.73     0.14      0.0     0.0
   2 │    0.73     1.06     0.14      0.0     0.0
   3 │    0.14     0.14     1.1       0.0     0.0
   4 │    0.0      0.0      0.0       1.6     0.9
   5 │    0.0      0.0      0.0       0.9     1.08
</code></pre><p>The following block needs <code>ape</code> to be installed (not run):</p><pre><code class="language-julia">julia&gt; using RCall # Comparison with ape vcv function

julia&gt; R&quot;ape::vcv(ape::read.tree(text = $tree_str))&quot;
RCall.RObject{RCall.RealSxp}
     t2   t4   t3  t5   t1
t2 0.87 0.73 0.14 0.0 0.00
t4 0.73 1.06 0.14 0.0 0.00
t3 0.14 0.14 1.10 0.0 0.00
t5 0.00 0.00 0.00 1.6 0.90
t1 0.00 0.00 0.00 0.9 1.08
</code></pre><p>The covariance can also be calculated on a network (for the model, see Bastide et al. 2018)</p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;((t1:1.0,#H1:0.1::0.30):0.5,((t2:0.9)#H1:0.2::0.70,t3:1.1):0.4);&quot;);

julia&gt; C = vcv(net)
3×3 DataFrame
 Row │ t1       t2       t3      
     │ Float64  Float64  Float64 
─────┼───────────────────────────
   1 │    1.5     0.15      0.0
   2 │    0.15    1.248     0.28
   3 │    0.0     0.28      1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traits.jl#L249-L314">source</a></section></article><h2 id="discrete-trait-evolution"><a class="docs-heading-anchor" href="#discrete-trait-evolution">discrete trait evolution</a><a id="discrete-trait-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#discrete-trait-evolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parsimonySoftwired" href="#PhyloNetworks.parsimonySoftwired"><code>PhyloNetworks.parsimonySoftwired</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parsimonySoftwired(net, tipdata)
parsimonySoftwired(net, species, sequences)</code></pre><p>Calculate the most parsimonious (MP) score of a network given a discrete character at the tips. The softwired parsimony concept is used: where the number of state transitions is minimized over all trees displayed in the network.</p><p>Data can given in one of the following:</p><ul><li><code>tipdata</code>: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named &quot;taxon&quot; or &quot;species&quot;, and  trait values are to appear in column 2 or in a column named &quot;trait&quot;.</li><li><code>tipdata</code>: dictionary taxon =&gt; state, for a single trait.</li><li><code>species</code>: array of strings, and <code>sequences</code>: array of sequences,  in the order corresponding to the order of species names.</li></ul><p><strong>algorithm</strong></p><p>The dynamic programming algorithm by Fischer et al. (2015) is used. The function loops over all the displayed subtrees within a blob (biconnected component), so its complexity is of the order of <code>n * m * c^2 * 2^level</code> where <code>n</code> is the number of tips, <code>m</code> the number of traits, <code>c</code> the number of states, and <code>level</code> is the level of the network: the maximum number of hybridizations within a blob.</p><p>See <a href="#PhyloNetworks.parsimonyGF"><code>parsimonyGF</code></a> for a different algorithm, slower but extendable to other parsimony criteria.</p><p><strong>references</strong></p><ol><li>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/parsimony.jl#L207-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.parsimonyGF" href="#PhyloNetworks.parsimonyGF"><code>PhyloNetworks.parsimonyGF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parsimonyGF(net, tip_dictionary, criterion=:softwired)
parsimonyGF(net, species, sequenceData, criterion=:softwired)</code></pre><p>Calculate the most parsimonious score of a network given discrete characters at the tips using a general framework (Van Iersel et al. 2018) allowing for various parsimony criteria: softwired (default), hardwired, parental etc. Only softwired is implemented at the moment.</p><p>Data can given in one of the following:</p><ul><li><code>tipdata</code>: data frame for a single trait, in which case the taxon names  are to appear in column 1 or in a column named &quot;taxon&quot; or &quot;species&quot;, and  trait values are to appear in column 2 or in a column named &quot;trait&quot;.</li><li><code>tipdata</code>: dictionary taxon =&gt; state, for a single trait.</li><li><code>species</code>: array of strings, and <code>sequences</code>: array of sequences,   in the order corresponding to the order of species names.</li></ul><p><strong>algorithm</strong></p><p>The complexity of the algorithm is exponential in the level of the network, that is, the maximum number of hybridizations in a single blob, or biconnected component (Fischer et al. 2015). The function loops over all the state assignments of the minor parent of each hybrid node within a blob, so its complexity is of the order of <code>n * m * c^2 * c^level</code> where <code>n</code> is the number of tips, <code>m</code> the number of traits and <code>c</code> the number of states.</p><p>See <a href="#PhyloNetworks.parsimonySoftwired"><code>parsimonySoftwired</code></a> for a faster algorithm, but solving the softwired criterion only.</p><p><strong>references</strong></p><ol><li><p>Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).</p></li><li><p>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</p></li></ol><p>Use the recursive helper function <a href="../internals/#PhyloNetworks.parsimonyBottomUpGF!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, Integer, AbstractArray, AbstractArray, AbstractArray, AbstractArray}"><code>parsimonyBottomUpGF!</code></a>. Use the fields <code>isChild1</code>, <code>isExtBadTriangle</code> to know which nodes are at the root of a blob, and <code>fromBadDiamondI</code> to know which edges are cut (below the minor parent of each hybrid).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/parsimony.jl#L501-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.Q" href="#PhyloNetworks.Q"><code>PhyloNetworks.Q</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Q(model)</code></pre><p>Substitution rate matrix for a given substitution model: Q[i,j] is the rate of transitioning from state i to state j.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L138-L143">source</a></section><section><div><p>For a BinaryTraitSubstitutionModel, the rate matrix Q is of the form:</p><pre><code class="language-none">-α  α
 β -β</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L322-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.randomTrait" href="#PhyloNetworks.randomTrait"><code>PhyloNetworks.randomTrait</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randomTrait(model, t, start)
randomTrait!(end, model, t, start)</code></pre><p>Simulate traits along one edge of length t. <code>start</code> must be a vector of integers, each representing the starting value of one trait. The bang version (ending with !) uses the vector <code>end</code> to store the simulated values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = BinaryTraitSubstitutionModel(1.0, 2.0)
Binary Trait Substitution Model:
rate 0→1 α=1.0
rate 1→0 β=2.0

julia&gt; using Random; Random.seed!(12345);

julia&gt; randomTrait(m1, 0.2, [1,2,1,2,2])
5-element Vector{Int64}:
 1
 2
 1
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L489-L514">source</a></section><section><div><pre><code class="language-none">randomTrait(model, net; ntraits=1, keepInternal=true, checkPreorder=true)</code></pre><p>Simulate evolution of discrete traits on a rooted evolutionary network based on the supplied evolutionary model. Trait sampling is uniform at the root.</p><p>optional arguments:</p><ul><li><code>ntraits</code>: number of traits to be simulated (default: 1 trait).</li><li><code>keepInternal</code>: if true, export character states at all nodes, including internal nodes. if false, export character states at tips only.</li></ul><p>output:</p><ul><li>matrix of character states with one row per trait, one column per node; these states are <em>indices</em> in <code>model.label</code>, not the trait labels themselves.</li><li>vector of node labels (for tips) or node numbers (for internal nodes) in the same order as columns in the character state matrix</li></ul><p><strong>examples</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = BinaryTraitSubstitutionModel(1.0, 2.0, [&quot;low&quot;,&quot;high&quot;]);

julia&gt; net = readTopology(&quot;(((A:4.0,(B:1.0)#H1:1.1::0.9):0.5,(C:0.6,#H1:1.0::0.1):1.0):3.0,D:5.0);&quot;);

julia&gt; using Random; Random.seed!(235);

julia&gt; trait, lab = randomTrait(m1, net)
([1 2 … 1 1], [&quot;-2&quot;, &quot;D&quot;, &quot;-3&quot;, &quot;-6&quot;, &quot;C&quot;, &quot;-4&quot;, &quot;H1&quot;, &quot;B&quot;, &quot;A&quot;])

julia&gt; trait
1×9 Matrix{Int64}:
 1  2  1  1  2  2  1  1  1

julia&gt; lab
9-element Vector{String}:
 &quot;-2&quot; 
 &quot;D&quot;  
 &quot;-3&quot; 
 &quot;-6&quot; 
 &quot;C&quot;  
 &quot;-4&quot; 
 &quot;H1&quot;
 &quot;B&quot;  
 &quot;A&quot;  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L531-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.randomTrait!" href="#PhyloNetworks.randomTrait!"><code>PhyloNetworks.randomTrait!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randomTrait(model, t, start)
randomTrait!(end, model, t, start)</code></pre><p>Simulate traits along one edge of length t. <code>start</code> must be a vector of integers, each representing the starting value of one trait. The bang version (ending with !) uses the vector <code>end</code> to store the simulated values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; m1 = BinaryTraitSubstitutionModel(1.0, 2.0)
Binary Trait Substitution Model:
rate 0→1 α=1.0
rate 1→0 β=2.0

julia&gt; using Random; Random.seed!(12345);

julia&gt; randomTrait(m1, 0.2, [1,2,1,2,2])
5-element Vector{Int64}:
 1
 2
 1
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.fitdiscrete" href="#PhyloNetworks.fitdiscrete"><code>PhyloNetworks.fitdiscrete</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fitdiscrete(net, model, tipdata)
fitdiscrete(net, model, RateVariationAcrossSites, tipdata)
fitdiscrete(net, model, species, traits)
fitdiscrete(net, model, RateVariationAcrossSites, species, traits)
fitdiscrete(net, model, dnadata, dnapatternweights)
fitdiscrete(net, model, RateVariationAcrossSites, dnadata, dnapatternweights)
fitdiscrete(net, modSymbol, species, traits)
fitdiscrete(net, modSymbol, dnadata, dnapatternweights)</code></pre><p>Calculate the maximum likelihood (ML) score of a network or tree given one or more discrete characters at the tips. Along each edge, transitions are modelled with a continous time Markov <code>model</code>, whose parameters are estimated (by maximizing the likelihood). At each hybrid node, the trait is assumed to be inherited from either of the two immediate parents according to the parents&#39; average genetic contributions (inheritance γ). The model ignores incomplete lineage sorting. The algorithm extracts all trees displayed in the network.</p><p>Data can given in one of the following:</p><ul><li><code>tipdata</code>: dictionary taxon =&gt; state label, for a single trait.</li><li><code>tipdata</code>: data frame for a single trait, in which case the taxon names are to appear in column 1 or in a column named &quot;taxon&quot; or &quot;species&quot;, and trait <em>labels</em> are to appear in column 2 or in a column named &quot;trait&quot;. Here, trait labels should be as they appear in <code>getlabels(model)</code>.</li><li><code>species</code>: vector of strings, and <code>traits</code>: DataFrame of traits, with rows in the order corresponding to the order of species names. Again, trait labels should be as they appear in <code>getlabels(model)</code>. All traits are assumed to follow the same model, with same parameters.</li><li><code>dnadata</code>: the first part of the output of readfastatodna, a dataframe of BioSequence DNA sequences, with taxon in column 1 and a column for each site.</li><li><code>dnapatternweights</code>: the second part of the output of readfastatodna, an array of weights, one weights for each of the site columns. The length of the weight is equal to nsites. If using dnapatternweights, must provide dnadata.</li><li>RateVariationAcrossSites: model for rate variation (optional)</li></ul><p>Optional arguments (default):</p><ul><li><code>optimizeQ</code> (true): should model rate parameters be fixed, or should they be optimized?</li><li><code>optimizeRVAS</code> (true): should the model optimize the parameters for the variability of rates across sites (α and/or p_invariable)?</li><li><code>NLoptMethod</code> (<code>:LN_COBYLA</code>, derivative-free) for the optimization algorithm. For other options, see the <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/">NLopt</a>.</li><li>tolerance values to control when the optimization is stopped: <code>ftolRel</code> (1e-12), <code>ftolAbs</code> (1e-10) on the likelihood, and <code>xtolRel</code> (1e-10), <code>xtolAbs</code> (1e-10) on the model parameters.</li><li>bounds for the alpha parameter of the Gamma distribution of rates across sites: <code>alphamin=0.05</code>, <code>alphamax=50</code>.</li><li><code>verbose</code> (false): if true, more information is output.</li></ul><p><strong>examples:</strong></p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);&quot;);

julia&gt; m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [&quot;lo&quot;, &quot;hi&quot;]);

julia&gt; using DataFrames

julia&gt; dat = DataFrame(species=[&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;D&quot;], trait=[&quot;hi&quot;,&quot;lo&quot;,&quot;lo&quot;,&quot;hi&quot;]);

julia&gt; fit1 = fitdiscrete(net, m1, dat)
PhyloNetworks.StatisticalSubstitutionModel:
Binary Trait Substitution Model:
  rate lo→hi α=0.27222
  rate hi→lo β=0.34981
on a network with 1 reticulations
data:
  4 species
  1 trait
log-likelihood: -2.7277

julia&gt; tips = Dict(&quot;A&quot; =&gt; &quot;lo&quot;, &quot;B&quot; =&gt; &quot;lo&quot;, &quot;C&quot; =&gt; &quot;hi&quot;, &quot;D&quot; =&gt; &quot;hi&quot;);

julia&gt; fit2 = fitdiscrete(net, m1, tips; xtolRel=1e-16, xtolAbs=1e-16, ftolRel=1e-16)
PhyloNetworks.StatisticalSubstitutionModel:
Binary Trait Substitution Model:
  rate lo→hi α=0.27222
  rate hi→lo β=0.34981
on a network with 1 reticulations
data:
  4 species
  1 trait
log-likelihood: -2.7277</code></pre><p>Note that a copy of the network is stored in the fitted object, but the internal representation of the network may be different in <code>fit1.net</code> and in the original network <code>net</code>:</p><pre><code class="language-julia-repl">julia&gt; net = readTopology(&quot;(sp1:3.0,(sp2:2.0,(sp3:1.0,sp4:1.0):1.0):1.0);&quot;);

julia&gt; using BioSymbols

julia&gt; tips = Dict(&quot;sp1&quot; =&gt; BioSymbols.DNA_A, &quot;sp2&quot; =&gt; BioSymbols.DNA_A, &quot;sp3&quot; =&gt; BioSymbols.DNA_G, &quot;sp4&quot; =&gt; BioSymbols.DNA_G);

julia&gt; mJC69 = JC69([0.25], false);

julia&gt; fitJC69 = fitdiscrete(net, mJC69, tips)
PhyloNetworks.StatisticalSubstitutionModel:
Jukes and Cantor 69 Substitution Model,
  absolute rate version
  off-diagonal rates equal to 0.29233/3.
  rate matrix Q:
                 A       C       G       T
         A       *  0.0974  0.0974  0.0974
         C  0.0974       *  0.0974  0.0974
         G  0.0974  0.0974       *  0.0974
         T  0.0974  0.0974  0.0974       *
on a network with 0 reticulations
data:
  4 species
  1 trait
log-likelihood: -4.99274

julia&gt; rv = RateVariationAcrossSites(alpha=1.0, ncat=4)
Rate variation across sites: discretized Gamma
alpha: 1.0
categories for Gamma discretization: 4
rates: [0.146, 0.513, 1.071, 2.27]

julia&gt; fitdiscrete(net, mJC69, rv, tips; optimizeQ=false, optimizeRVAS=false)
PhyloNetworks.StatisticalSubstitutionModel:
Jukes and Cantor 69 Substitution Model,
  absolute rate version
  off-diagonal rates equal to 0.25/3.
  rate matrix Q:
                 A       C       G       T
         A       *  0.0833  0.0833  0.0833
         C  0.0833       *  0.0833  0.0833
         G  0.0833  0.0833       *  0.0833
         T  0.0833  0.0833  0.0833       *
Rate variation across sites: discretized Gamma
  alpha: 1.0
  categories for Gamma discretization: 4
  rates: [0.146, 0.513, 1.071, 2.27]
on a network with 0 reticulations
data:
  4 species
  1 trait
log-likelihood: -5.2568
</code></pre><p>fixit: add option to allow users to specify root prior, using either equal frequencies or stationary frequencies for trait models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/traitsLikDiscrete.jl#L253-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.maxParsimonyNet" href="#PhyloNetworks.maxParsimonyNet"><code>PhyloNetworks.maxParsimonyNet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maxParsimonyNet(T::HybridNetwork, df::DataFrame)</code></pre><p>Search for the most parsimonious network (or tree). A level-1 network is assumed. <code>df</code> should be a data frame containing the species names in column 1, or in a column named <code>species</code> or <code>taxon</code>. Trait data are assumed to be in all other columns. The search starts from topology <code>T</code>, which can be a tree or a network with no more than <code>hmax</code> hybrid nodes (see optional arguments below for <code>hmax</code>).</p><p>Output:</p><ul><li>estimated network in file <code>.out</code> (also in <code>.log</code>): best network overall and list of networks from each individual run.</li><li>if any error occurred, file <code>.err</code> provides information (seed) to reproduce the error.</li></ul><p>Optional arguments include</p><ul><li>hmax: maximum number of hybridizations allowed (default 1)</li><li>runs: number of starting points for the search (default 10); each starting point is <code>T</code> with probability <code>probST</code>=0.3 or a modification of <code>T</code> otherwise (using a NNI move, or a hybrid edge direction change)</li><li>Nfail: number of failures (proposed networks with equal or worse score) before the search is aborted. 75 by default: this is quite small, which is okay for a first trial. Larger values are recommended.</li><li>outgroup: outgroup taxon.           It can be a taxon name (String) or Node number (Integer).           If none provided, or if the outgroup conflicts the starting           topology, the function returns an error</li><li>filename: root name for the output files. Default is &quot;mp&quot;. If empty (&quot;&quot;), files are <em>not</em> created, progress log goes to the screen only (standard out).</li><li>seed: seed to replicate a given search</li><li>criterion: parsimony score could be hardwired, softwired (default) or parental. Currently,            only softwired is implemented</li></ul><p><strong>References</strong></p><ol><li><p>Leo Van Iersel, Mark Jones, Celine Scornavacca (2017). Improved Maximum Parsimony Models for Phylogenetic Networks, Systematic Biology, (https://doi.org/10.1093/sysbio/syx094).</p></li><li><p>Fischer, M., van Iersel, L., Kelk, S., Scornavacca, C. (2015). On computing the Maximum Parsimony score of a phylogenetic network. SIAM J. Discrete Math., 29(1):559-585.</p></li></ol><p>For a roadmap of the functions inside maxParsimonyNet, see <a href="../internals/#PhyloNetworks.maxParsimonyNetRun1!"><code>maxParsimonyNetRun1!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/parsimony.jl#L1112-L1161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.nstates" href="#PhyloNetworks.nstates"><code>PhyloNetworks.nstates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nstates(model)</code></pre><p>Number of character states for a given evolution model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L83-L87">source</a></section><section><div><p>For example, this is 4 for a <code>NucleicAcidSubstitutionModel</code>.</p><pre><code class="language-julia-repl">julia&gt; nstates(JC69([0.03], false))
4

julia&gt; nstates(HKY85([.5], [0.25, 0.25, 0.25, 0.25]))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L90-L100">source</a></section><section><div><p>for a <code>BinaryTraitSubstitutionModel</code>, this is 2:</p><pre><code class="language-julia-repl">julia&gt; m1 = BinaryTraitSubstitutionModel([1.0,2.0], [&quot;low&quot;,&quot;high&quot;])
Binary Trait Substitution Model:
rate low→high α=1.0
rate high→low β=2.0

julia&gt; nstates(m1)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L303-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.stationary" href="#PhyloNetworks.stationary"><code>PhyloNetworks.stationary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stationary(substitutionmodel)</code></pre><p>Stationary distribution of a Markov model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L1409-L1413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhyloNetworks.empiricalDNAfrequencies" href="#PhyloNetworks.empiricalDNAfrequencies"><code>PhyloNetworks.empiricalDNAfrequencies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">empiricalDNAfrequencies(DNAdata::AbstractDataFrame, DNAweights,
                        correction=true, useambiguous=true)</code></pre><p>Estimate base frequencies in DNA data <code>DNAdata</code>, ordered ACGT.</p><ul><li><code>DNAdata</code>: data frame. All columns are used. If the first column gives species names, find a way to ignore it before calculating empirical frequencies, e.g. <code>empiricalDNAfrequencies(view(DNAdata, :, 2:size(DNAdata, 2)))</code>. Data type must be <code>BioSymbols.DNA</code> or <code>Char</code> or <code>String</code>. WARNING: this is checked on the first column only.</li><li><code>DNAweights</code>: vector of weights, to weigh each column in <code>DNAdata</code>.</li><li><code>correction</code>: if <code>true</code>, add 1 to each count and 4 to the denominator for a more stable estimator, similar to Bayes prior of 1/4 and the Agresti-Coull interval in binomial estimation.</li><li><code>useambiguous</code>: if <code>true</code>, ambiguous bases are used (except gaps and Ns). For example, <code>Y</code> adds 0.5 weight to <code>C</code> and 0.5 weight to <code>T</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/crsl4/PhyloNetworks.jl/blob/3ffc509d304293993342077f2a75a7be788c5a9b/src/substitutionModels.jl#L1322-L1339">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/nj/">« Neighbour Joining</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 29 April 2021 22:28">Thursday 29 April 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
